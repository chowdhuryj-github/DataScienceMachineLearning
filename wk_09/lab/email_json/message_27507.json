{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "psomogyi@gamax.hu", "subject": "Rev 94: ctdb/ib: added statistics + some cleanup in\n http://samba.org/~tridge/psomogyi/", "body": "------------------------------------------------------------\nrevno: 94\nrevision-id: psomogyi@gamax.hu-20070511112450-wjf21qva3pjifxy9\nparent: psomogyi@gamax.hu-20070502152756-cgv2olqgrryuhpvq\ncommitter: Peter Somogyi \nbranch nick: ctdb\ntimestamp: Fri 2007-05-11 13:24:50 +0200\nmessage:\n  ctdb/ib: added statistics + some cleanup\nmodified:\n  ib/ibwrapper.c                 ibwrapper.c-20061204130028-0125b4f5a72f4b11\n  ib/ibwrapper_internal.h        ibwrapper_internal.h-20061204130028-47f0a7e658b16ca2\n=== modified file 'ib/ibwrapper.c'\n--- a/ib/ibwrapper.c\t2007-05-02 15:27:56 +0000\n+++ b/ib/ibwrapper.c\t2007-05-11 11:24:50 +0000\n@@ -48,11 +48,6 @@\n #define IBW_LASTERR_BUFSIZE 512\n static char ibw_lasterr[IBW_LASTERR_BUFSIZE];\n \n-#define IBW_MAX_SEND_WR 256\n-#define IBW_MAX_RECV_WR 1024\n-#define IBW_RECV_BUFSIZE 256\n-#define IBW_RECV_THRESHOLD (1 * 1024 * 1024)\n-\n static void ibw_event_handler_verbs(struct event_context *ev,\n \tstruct fd_event *fde, uint16_t flags, void *private_data);\n static int ibw_fill_cq(struct ibw_conn *conn);\n@@ -79,6 +74,13 @@\n \t\treturn NULL;\n \t}\n \n+\t#ifdef IBW_ENABLE_STATS\n+\t\t/* increment statistics */\n+\t\tpctx->stats.n_alloc_mr++;\n+\t\tif (n>pctx->stats.n_max_largebuf_size)\n+\t\t\tpctx->stats.n_max_largebuf_size = n;\n+\t#endif\n+\n \treturn buf;\n }\n \n@@ -340,15 +342,18 @@\n \n \tDEBUG(10, (\"ibw_refill_cq_recv(cmid: %p)\\n\", pconn->cm_id));\n \n-\tlist.addr = (uintptr_t) pconn->buf_recv + pctx->opts.recv_bufsize * pconn->recv_index;\n-\twr.wr_id = pconn->recv_index;\n-\tpconn->recv_index = (pconn->recv_index + 1) % pctx->opts.max_recv_wr;\n-\n-\trc = ibv_post_recv(pconn->cm_id->qp, &wr, &bad_wr);\n-\tif (rc) {\n-\t\tsprintf(ibw_lasterr, \"refill/ibv_post_recv failed with %d\\n\", rc);\n-\t\tDEBUG(0, (ibw_lasterr));\n-\t\treturn -2;\n+\twhile(pconn->nrecv)  {\n+\t\tlist.addr = (uintptr_t) pconn->buf_recv + pctx->opts.recv_bufsize * pconn->recv_index;\n+\t\twr.wr_id = pconn->recv_index;\n+\t\tpconn->recv_index = (pconn->recv_index + 1) % pctx->opts.max_recv_wr;\n+\t\n+\t\trc = ibv_post_recv(pconn->cm_id->qp, &wr, &bad_wr);\n+\t\tif (rc) {\n+\t\t\tsprintf(ibw_lasterr, \"refill/ibv_post_recv failed with %d\\n\", rc);\n+\t\t\tDEBUG(0, (ibw_lasterr));\n+\t\t\treturn -2;\n+\t\t}\n+\t\tpconn->nrecv--;\n \t}\n \n \treturn 0;\n@@ -585,6 +590,39 @@\n \treturn;\n }\n \n+static int ibw_wc_handler(struct ibw_conn *conn, struct ibv_wc *wc)\n+{\n+\tif (wc->status) {\n+\t\tsprintf(ibw_lasterr, \"cq completion failed status=%d, opcode=%d\\n\",\n+\t\t\twc->status, wc->opcode);\n+\t\treturn -1;\n+\t}\n+\n+\tswitch(wc->opcode) {\n+\tcase IBV_WC_SEND:\n+\t\tDEBUG(10, (\"send completion\\n\"));\n+\t\treturn ibw_wc_send(conn, wc);\n+\n+\tcase IBV_WC_RDMA_WRITE:\n+\t\tDEBUG(10, (\"rdma write completion\\n\"));\n+\t\tbreak;\n+\n+\tcase IBV_WC_RDMA_READ:\n+\t\tDEBUG(10, (\"rdma read completion\\n\"));\n+\t\tbreak;\n+\n+\tcase IBV_WC_RECV:\n+\t\tDEBUG(10, (\"recv completion\\n\"));\n+\t\treturn ibw_wc_recv(conn, wc);\n+\n+\tdefault:\n+\t\tbreak; /* see below */\n+\t}\n+\n+\tsprintf(ibw_lasterr, \"unknown completion %d\\n\", wc->opcode);\n+\treturn -1;\n+}\n+\n static void ibw_event_handler_verbs(struct event_context *ev,\n \tstruct fd_event *fde, uint16_t flags, void *private_data)\n {\n@@ -592,12 +630,15 @@\n \tstruct ibw_conn_priv *pconn = talloc_get_type(conn->internal, struct ibw_conn_priv);\n \tstruct ibw_ctx_priv *pctx = talloc_get_type(conn->ctx->internal, struct ibw_ctx_priv);\n \n-\tstruct ibv_wc wc;\n-\tint rc;\n+\tstruct ibv_wc wc[IBW_MAX_WC_POLL];\n+\tint rc, i;\n \tstruct ibv_cq *ev_cq;\n \tvoid          *ev_ctx;\n \n \tDEBUG(10, (\"ibw_event_handler_verbs(%u)\\n\", (uint32_t)flags));\n+\t#ifdef IBW_ENABLE_STATS\n+\t\tpctx->stats.n_events++;\n+\t#endif\n \n \t/* TODO: check whether if it's good to have more channels here... */\n \trc = ibv_get_cq_event(pconn->verbs_channel, &ev_cq, &ev_ctx);\n@@ -615,44 +656,21 @@\n \t\tgoto error;\n \t}\n \n-\twhile((rc=ibv_poll_cq(pconn->cq, 1, &wc))==1) {\n-\t\tif (wc.status) {\n-\t\t\tsprintf(ibw_lasterr, \"cq completion failed status=%d, opcode=%d, rc=%d\\n\",\n-\t\t\t\twc.status, wc.opcode, rc);\n-\t\t\tgoto error;\n-\t\t}\n-\n-\t\tswitch(wc.opcode) {\n-\t\tcase IBV_WC_SEND:\n-\t\t\tDEBUG(10, (\"send completion\\n\"));\n-\t\t\tif (ibw_wc_send(conn, &wc))\n-\t\t\t\tgoto error;\n-\t\t\tbreak;\n-\n-\t\tcase IBV_WC_RDMA_WRITE:\n-\t\t\tDEBUG(10, (\"rdma write completion\\n\"));\n-\t\t\tbreak;\n-\t\n-\t\tcase IBV_WC_RDMA_READ:\n-\t\t\tDEBUG(10, (\"rdma read completion\\n\"));\n-\t\t\tbreak;\n-\n-\t\tcase IBV_WC_RECV:\n-\t\t\tDEBUG(10, (\"recv completion\\n\"));\n-\t\t\tif (ibw_wc_recv(conn, &wc))\n-\t\t\t\tgoto error;\n-\t\t\tbreak;\n-\n-\t\tdefault:\n-\t\t\tsprintf(ibw_lasterr, \"unknown completion %d\\n\", wc.opcode);\n-\t\t\tgoto error;\n-\t\t}\n+\t/* we _have_ to use 'while' here not to loose the event */\n+\twhile((rc=ibv_poll_cq(pconn->cq, IBW_MAX_WC_POLL, wc))>0) {\n+\t\tfor(i=0; inrecv) {\n+\t\tibw_refill_cq_recv(conn);\n+\t}\n+\n \tibv_ack_cq_events(pconn->cq, 1);\n \n \treturn;\n@@ -715,6 +733,9 @@\n \n \tDEBUG(10, (\"ibw_wc_send(cmid: %p, wr_id: %u, bl: %u)\\n\",\n \t\tpconn->cm_id, (uint32_t)wc->wr_id, (uint32_t)wc->byte_len));\n+\t#ifdef IBW_ENABLE_STATS\n+\t\tpctx->stats.n_send_wc++;\n+\t#endif\n \n \tassert(pconn->cm_id->qp->qp_num==wc->qp_num);\n \tassert(wc->wr_id >= pctx->opts.max_recv_wr);\n@@ -826,6 +847,11 @@\n \n \tDEBUG(10, (\"ibw_wc_recv: cmid=%p, wr_id: %u, bl: %u\\n\",\n \t\tpconn->cm_id, (uint32_t)wc->wr_id, remain));\n+\t#ifdef IBW_ENABLE_STATS\n+\t\tpctx->stats.n_recv_wc++;\n+\t#endif\n+\n+\tpconn->nrecv++;\n \n \tassert(pconn->cm_id->qp->qp_num==wc->qp_num);\n \tassert((int)wc->wr_id < pctx->opts.max_recv_wr);\n@@ -891,9 +917,6 @@\n \t\t}\n \t} /*  is always decreased at least by 1 */\n \n-\tif (ibw_refill_cq_recv(conn))\n-\t\tgoto error;\n-\n \treturn 0;\n \n error:\n@@ -1216,6 +1239,9 @@\n \t\t\tgoto error;\n \t\t}\n \t\t*buf = (void *)p->buf_large;\n+\t\t#ifdef IBW_ENABLE_STATS\n+\t\t\tpctx->stats.n_large_allocs++;\n+\t\t#endif\n \n \t\tDLIST_REMOVE(pconn->extra_avail, p);\n \t\t/* we don't have prepared index for this, so that\n@@ -1312,6 +1338,9 @@\n \n \t\tDEBUG(10, (\"ibw_send#frag(cmid: %p, buf: %p, len: %u)\\n\",\n \t\t\tpconn->cm_id, buf, len));\n+\t\t#ifdef IBW_ENABLE_STATS\n+\t\t\tpctx->stats.n_frags++;\n+\t\t#endif\n \n \t\t/* single threaded => no race here: */\n \t\tassert(p->ref_cnt==0);\n@@ -1337,33 +1366,6 @@\n \treturn rc;\n }\n \n-int ibw_cancel_send_buf(struct ibw_conn *conn, void *buf, void *key)\n-{\n-\tstruct ibw_ctx_priv *pctx = talloc_get_type(conn->ctx->internal, struct ibw_ctx_priv);\n-\tstruct ibw_conn_priv *pconn = talloc_get_type(conn->internal, struct ibw_conn_priv);\n-\tstruct ibw_wr *p = talloc_get_type(key, struct ibw_wr);\n-\n-\tassert(p!=NULL);\n-\tassert(buf!=NULL);\n-\tassert(conn!=NULL);\n-\n-\tif (p->buf_large!=NULL)\n-\t\tibw_free_mr(&p->buf_large, &p->mr_large);\n-\n-\t/* parallel case */\n-\tif (p->wr_id < pctx->opts.max_send_wr) {\n-\t\tDEBUG(10, (\"ibw_cancel_send_buf#1 %u\", (int)p->wr_id));\n-\t\tDLIST_REMOVE(pconn->wr_list_used, p);\n-\t\tDLIST_ADD(pconn->wr_list_avail, p);\n-\t} else { /* \"extra\" packet */\n-\t\tDEBUG(10, (\"ibw_cancel_send_buf#2 %u\", (int)p->wr_id));\n-\t\tDLIST_REMOVE(pconn->extra_sent, p);\n-\t\tDLIST_ADD(pconn->extra_avail, p);\n-\t}\n-\n-\treturn 0;\n-}\n-\n const char *ibw_getLastError(void)\n {\n \treturn ibw_lasterr;\n\n=== modified file 'ib/ibwrapper_internal.h'\n--- a/ib/ibwrapper_internal.h\t2007-02-08 18:06:14 +0000\n+++ b/ib/ibwrapper_internal.h\t2007-05-11 11:24:50 +0000\n@@ -21,6 +21,17 @@\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  */\n \n+\n+#define IBW_MAX_SEND_WR 256\n+#define IBW_MAX_RECV_WR 1024\n+#define IBW_RECV_BUFSIZE 256\n+#define IBW_RECV_THRESHOLD (1 * 1024 * 1024)\n+#define IBW_MAX_WC_POLL 10\n+\n+/* eats some CPU - can't afford here in production */\n+#define talloc_get_type(ptr, type) (type *)ptr\n+#define IBW_ENABLE_STATS\n+\n struct ibw_opts {\n \tuint32_t\tmax_send_wr;\n \tuint32_t\tmax_recv_wr;\n@@ -45,6 +56,16 @@\n \tstruct ibw_wr *qnext, *qprev; /* in queue */\n };\n \n+struct ibw_stats {\n+\tuint32_t\tn_alloc_mr;\n+\tuint32_t\tn_large_allocs;\n+\tuint32_t\tn_frags;\n+\tuint32_t\tn_max_largebuf_size;\n+\tuint32_t\tn_send_wc;\n+\tuint32_t\tn_recv_wc;\n+\tuint32_t\tn_events;\n+};\n+\n struct ibw_ctx_priv {\n \tstruct event_context *ectx;\n \n@@ -59,6 +80,9 @@\n \tibw_receive_fn_t receive_func; /* see ibw_init */\n \n \tlong\tpagesize; /* sysconf result for memalign */\n+\n+\t/* some stats */\n+\tstruct ibw_stats stats;\n };\n \n struct ibw_part {\n@@ -96,6 +120,7 @@\n \tstruct ibv_mr *mr_recv;\n \tint recv_index; /* index of the next recv buffer when refilling */\n \tstruct ibw_part part;\n+\tint\tnrecv; /* received packets */\n };\n \n /* remove an element from a list - element doesn't have to be in list. */\n\n"}
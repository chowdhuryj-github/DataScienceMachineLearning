{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jpeach@samba.org", "subject": "svn commit: samba r22495 - in branches/SAMBA_3_0/source: . smbd", "body": "Author: jpeach\nDate: 2007-04-23 22:17:06 +0000 (Mon, 23 Apr 2007)\nNew Revision: 22495\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22495\n\nLog:\nCreate wrapper to hide the details of obtaining a set of sockets\nto listen on.\n\nAdded:\n   branches/SAMBA_3_0/source/smbd/sockinit.c\nModified:\n   branches/SAMBA_3_0/source/Makefile.in\n   branches/SAMBA_3_0/source/smbd/server.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/Makefile.in\n===================================================================\n--- branches/SAMBA_3_0/source/Makefile.in\t2007-04-23 21:56:23 UTC (rev 22494)\n+++ branches/SAMBA_3_0/source/Makefile.in\t2007-04-23 22:17:06 UTC (rev 22495)\n@@ -498,7 +498,8 @@\n \t       smbd/change_trust_pw.o smbd/fake_file.o \\\n \t       smbd/quotas.o smbd/ntquotas.o $(AFS_OBJ) smbd/msdfs.o \\\n \t       $(AFS_SETTOKEN_OBJ) smbd/aio.o smbd/statvfs.o \\\n-\t       smbd/dmapi.o lib/launchd.o $(MANGLE_OBJ) @VFS_STATIC@\n+\t       smbd/dmapi.o lib/launchd.o smbd/sockinit.o \\\n+\t       $(MANGLE_OBJ) @VFS_STATIC@\n \n SMBD_OBJ_BASE = $(PARAM_OBJ) $(SMBD_OBJ_SRV) $(LIBSMB_OBJ) \\\n \t\t$(RPC_SERVER_OBJ) $(RPC_PARSE_OBJ) $(SECRETS_OBJ) \\\n\nModified: branches/SAMBA_3_0/source/smbd/server.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/server.c\t2007-04-23 21:56:23 UTC (rev 22494)\n+++ branches/SAMBA_3_0/source/smbd/server.c\t2007-04-23 22:17:06 UTC (rev 22495)\n@@ -22,7 +22,6 @@\n */\n \n #include \"includes.h\"\n-#include \"smb_launchd.h\"\n \n static_decl_rpc;\n \n@@ -298,153 +297,6 @@\n \treturn num_children < max_processes;\n }\n \n-static int init_sockets_smbd(const char *smb_ports,\n-\t\t\t\tint fd_listenset[FD_SETSIZE])\n-{\n-\tint num_interfaces = iface_count();\n-\tchar * ports;\n-\tint num_sockets = 0;\n-\tint i, s;\n-\n-\t/* use a reasonable default set of ports - listing on 445 and 139 */\n-\tif (!smb_ports) {\n-\t\tports = lp_smb_ports();\n-\t\tif (!ports || !*ports) {\n-\t\t\tports = smb_xstrdup(SMB_PORTS);\n-\t\t} else {\n-\t\t\tports = smb_xstrdup(ports);\n-\t\t}\n-\t} else {\n-\t\tports = smb_xstrdup(smb_ports);\n-\t}\n-\n-\tif (lp_interfaces() && lp_bind_interfaces_only()) {\n-\t\t/* We have been given an interfaces line, and been \n-\t\t   told to only bind to those interfaces. Create a\n-\t\t   socket per interface and bind to only these.\n-\t\t*/\n-\t\t\n-\t\t/* Now open a listen socket for each of the\n-\t\t   interfaces. */\n-\t\tfor(i = 0; i < num_interfaces; i++) {\n-\t\t\tstruct in_addr *ifip = iface_n_ip(i);\n-\t\t\tfstring tok;\n-\t\t\tconst char *ptr;\n-\n-\t\t\tif(ifip == NULL) {\n-\t\t\t\tDEBUG(0,(\"init_sockets_smbd: interface %d has NULL IP address !\\n\", i));\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tfor (ptr=ports; next_token(&ptr, tok, \" \\t,\", sizeof(tok)); ) {\n-\t\t\t\tunsigned port = atoi(tok);\n-\t\t\t\tif (port == 0) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\ts = fd_listenset[num_sockets] = open_socket_in(SOCK_STREAM, port, 0, ifip->s_addr, True);\n-\t\t\t\tif(s == -1)\n-\t\t\t\t\treturn 0;\n-\n-\t\t\t\t/* ready to listen */\n-\t\t\t\tset_socket_options(s,\"SO_KEEPALIVE\"); \n-\t\t\t\tset_socket_options(s,user_socket_options);\n-     \n-\t\t\t\t/* Set server socket to non-blocking for the accept. */\n-\t\t\t\tset_blocking(s,False); \n- \n-\t\t\t\tif (listen(s, SMBD_LISTEN_BACKLOG) == -1) {\n-\t\t\t\t\tDEBUG(0,(\"listen: %s\\n\",strerror(errno)));\n-\t\t\t\t\tclose(s);\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\n-\t\t\t\tnum_sockets++;\n-\t\t\t\tif (num_sockets >= FD_SETSIZE) {\n-\t\t\t\t\tDEBUG(0,(\"init_sockets_smbd: Too many sockets to bind to\\n\"));\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\t/* Just bind to 0.0.0.0 - accept connections\n-\t\t   from anywhere. */\n-\n-\t\tfstring tok;\n-\t\tconst char *ptr;\n-\n-\t\tnum_interfaces = 1;\n-\t\t\n-\t\tfor (ptr=ports; next_token(&ptr, tok, \" \\t,\", sizeof(tok)); ) {\n-\t\t\tunsigned port = atoi(tok);\n-\t\t\tif (port == 0) continue;\n-\t\t\t/* open an incoming socket */\n-\t\t\ts = open_socket_in(SOCK_STREAM, port, 0,\n-\t\t\t\t\t   interpret_addr(lp_socket_address()),True);\n-\t\t\tif (s == -1)\n-\t\t\t\treturn 0;\n-\t\t\n-\t\t\t/* ready to listen */\n-\t\t\tset_socket_options(s,\"SO_KEEPALIVE\"); \n-\t\t\tset_socket_options(s,user_socket_options);\n-\t\t\t\n-\t\t\t/* Set server socket to non-blocking for the accept. */\n-\t\t\tset_blocking(s,False); \n- \n-\t\t\tif (listen(s, SMBD_LISTEN_BACKLOG) == -1) {\n-\t\t\t\tDEBUG(0,(\"init_sockets_smbd: listen: %s\\n\",\n-\t\t\t\t\t strerror(errno)));\n-\t\t\t\tclose(s);\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\n-\t\t\tfd_listenset[num_sockets] = s;\n-\t\t\tnum_sockets++;\n-\n-\t\t\tif (num_sockets >= FD_SETSIZE) {\n-\t\t\t\tDEBUG(0,(\"init_sockets_smbd: Too many sockets to bind to\\n\"));\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t}\n-\t} \n-\n-\tSAFE_FREE(ports);\n-\treturn num_sockets;\n-}\n-\n-static int init_sockets_launchd(const struct smb_launch_info *linfo,\n-\t\t\t\tconst char * smb_ports,\n-\t\t\t\tint fd_listenset[FD_SETSIZE])\n-{\n-\tint num_sockets;\n-\tint i;\n-\n-\t/* The launchd service configuration does not have to provide sockets,\n-\t * even though it's basically useless without it.\n-\t */\n-\tif (!linfo->num_sockets) {\n-\t\treturn init_sockets_smbd(smb_ports, fd_listenset);\n-\t}\n-\n-\t/* Make sure we don't get more sockets than we can handle. */\n-\tnum_sockets = MIN(FD_SETSIZE, linfo->num_sockets);\n-\tmemcpy(fd_listenset, linfo->socket_list, num_sockets * sizeof(int));\n-\n-\t/* Get the sockets ready. This could be hoisted into\n-\t * open_sockets_smbd(), but the order of socket operations might\n-\t * matter for some platforms, so this approach seems less risky.\n-\t *\t--jpeach\n-\t */\n-\tfor (i = 0; i < num_sockets; ++i) {\n-\t\tset_socket_options(fd_listenset[i], \"SO_KEEPALIVE\");\n-\t\tset_socket_options(fd_listenset[i], user_socket_options);\n-\n-\t\t/* Set server socket to non-blocking for the accept. */\n-\t\tset_blocking(fd_listenset[i], False);\n-\t}\n-\n-\treturn num_sockets;\n-}\n-\n /****************************************************************************\n  Open the socket communication.\n ****************************************************************************/\n@@ -458,7 +310,6 @@\n \tint maxfd = 0;\n \tint i;\n \tstruct timeval idle_timeout = {0, 0};\n-\tstruct smb_launch_info linfo;\n \n \tif (server_mode == SERVER_MODE_INETD) {\n \t\treturn open_sockets_inetd();\n@@ -480,25 +331,9 @@\n \tFD_ZERO(&listen_set);\n \n \t/* At this point, it doesn't matter what daemon mode we are in, we\n-\t * need some sockets to listen on. If we are in FOREGROUND mode,\n-\t * the launchd checkin might succeed. If we are in DAEMON or\n-\t * INTERACTIVE modes, it will fail and we will open the sockets\n-\t * ourselves.\n+\t * need some sockets to listen on.\n \t */\n-\tif (smb_launchd_checkin(&linfo)) {\n-\t\t/* We are running under launchd and launchd has\n-\t\t * opened some sockets for us.\n-\t\t */\n-\t\tnum_sockets = init_sockets_launchd(&linfo,\n-\t\t\t\t\t    smb_ports,\n-\t\t\t\t\t    fd_listenset);\n-\t\tidle_timeout.tv_sec = linfo.idle_timeout_secs;\n-\t\tsmb_launchd_checkout(&linfo);\n-\t} else {\n-\t\tnum_sockets = init_sockets_smbd(smb_ports,\n-\t\t\t\t\t    fd_listenset);\n-\t}\n-\n+\tnum_sockets = smbd_sockinit(smb_ports, fd_listenset, &idle_timeout);\n \tif (num_sockets == 0) {\n \t\treturn False;\n \t}\n\nAdded: branches/SAMBA_3_0/source/smbd/sockinit.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/sockinit.c\t2007-04-23 21:56:23 UTC (rev 22494)\n+++ branches/SAMBA_3_0/source/smbd/sockinit.c\t2007-04-23 22:17:06 UTC (rev 22495)\n@@ -0,0 +1,201 @@\n+/* \n+   Unix SMB/CIFS implementation.\n+\n+   Copyright (C) Andrew Tridgell\t\t1992-1998\n+   Copyright (C) James Peach\t\t\t2007\n+   \n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+   \n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+*/\n+\n+#include \"includes.h\"\n+#include \"smb_launchd.h\"\n+\n+extern pstring user_socket_options;\n+\n+static int init_sockets_smbd(const char *smb_ports, int listenset[FD_SETSIZE])\n+{\n+\tint num_interfaces = iface_count();\n+\tchar * ports;\n+\tint num_sockets = 0;\n+\tint i, s;\n+\n+\t/* use a reasonable default set of ports - listing on 445 and 139 */\n+\tif (!smb_ports) {\n+\t\tports = lp_smb_ports();\n+\t\tif (!ports || !*ports) {\n+\t\t\tports = smb_xstrdup(SMB_PORTS);\n+\t\t} else {\n+\t\t\tports = smb_xstrdup(ports);\n+\t\t}\n+\t} else {\n+\t\tports = smb_xstrdup(smb_ports);\n+\t}\n+\n+\tif (lp_interfaces() && lp_bind_interfaces_only()) {\n+\t\t/* We have been given an interfaces line, and been \n+\t\t   told to only bind to those interfaces. Create a\n+\t\t   socket per interface and bind to only these.\n+\t\t*/\n+\t\t\n+\t\t/* Now open a listen socket for each of the\n+\t\t   interfaces. */\n+\t\tfor(i = 0; i < num_interfaces; i++) {\n+\t\t\tstruct in_addr *ifip = iface_n_ip(i);\n+\t\t\tfstring tok;\n+\t\t\tconst char *ptr;\n+\n+\t\t\tif(ifip == NULL) {\n+\t\t\t\tDEBUG(0,(\"init_sockets_smbd: interface %d has NULL IP address !\\n\", i));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tfor (ptr=ports; next_token(&ptr, tok, \" \\t,\", sizeof(tok)); ) {\n+\t\t\t\tunsigned port = atoi(tok);\n+\t\t\t\tif (port == 0) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\ts = listenset[num_sockets] = open_socket_in(SOCK_STREAM, port, 0, ifip->s_addr, True);\n+\t\t\t\tif(s == -1)\n+\t\t\t\t\treturn 0;\n+\n+\t\t\t\t/* ready to listen */\n+\t\t\t\tset_socket_options(s,\"SO_KEEPALIVE\"); \n+\t\t\t\tset_socket_options(s,user_socket_options);\n+     \n+\t\t\t\t/* Set server socket to non-blocking for the accept. */\n+\t\t\t\tset_blocking(s,False); \n+ \n+\t\t\t\tif (listen(s, SMBD_LISTEN_BACKLOG) == -1) {\n+\t\t\t\t\tDEBUG(0,(\"listen: %s\\n\",strerror(errno)));\n+\t\t\t\t\tclose(s);\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\n+\t\t\t\tnum_sockets++;\n+\t\t\t\tif (num_sockets >= FD_SETSIZE) {\n+\t\t\t\t\tDEBUG(0,(\"init_sockets_smbd: Too many sockets to bind to\\n\"));\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\t/* Just bind to 0.0.0.0 - accept connections\n+\t\t   from anywhere. */\n+\n+\t\tfstring tok;\n+\t\tconst char *ptr;\n+\n+\t\tnum_interfaces = 1;\n+\t\t\n+\t\tfor (ptr=ports; next_token(&ptr, tok, \" \\t,\", sizeof(tok)); ) {\n+\t\t\tunsigned port = atoi(tok);\n+\t\t\tif (port == 0) continue;\n+\t\t\t/* open an incoming socket */\n+\t\t\ts = open_socket_in(SOCK_STREAM, port, 0,\n+\t\t\t\t\t   interpret_addr(lp_socket_address()),True);\n+\t\t\tif (s == -1)\n+\t\t\t\treturn 0;\n+\t\t\n+\t\t\t/* ready to listen */\n+\t\t\tset_socket_options(s,\"SO_KEEPALIVE\"); \n+\t\t\tset_socket_options(s,user_socket_options);\n+\t\t\t\n+\t\t\t/* Set server socket to non-blocking for the accept. */\n+\t\t\tset_blocking(s,False); \n+ \n+\t\t\tif (listen(s, SMBD_LISTEN_BACKLOG) == -1) {\n+\t\t\t\tDEBUG(0,(\"init_sockets_smbd: listen: %s\\n\",\n+\t\t\t\t\t strerror(errno)));\n+\t\t\t\tclose(s);\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\tlistenset[num_sockets] = s;\n+\t\t\tnum_sockets++;\n+\n+\t\t\tif (num_sockets >= FD_SETSIZE) {\n+\t\t\t\tDEBUG(0,(\"init_sockets_smbd: Too many sockets to bind to\\n\"));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t} \n+\n+\tSAFE_FREE(ports);\n+\treturn num_sockets;\n+}\n+\n+static int init_sockets_launchd(const struct smb_launch_info *linfo,\n+\t\t\t\tconst char * smb_ports,\n+\t\t\t\tint listenset[FD_SETSIZE])\n+{\n+\tint num_sockets;\n+\tint i;\n+\n+\t/* The launchd service configuration does not have to provide sockets,\n+\t * even though it's basically useless without it.\n+\t */\n+\tif (!linfo->num_sockets) {\n+\t\treturn init_sockets_smbd(smb_ports, listenset);\n+\t}\n+\n+\t/* Make sure we don't get more sockets than we can handle. */\n+\tnum_sockets = MIN(FD_SETSIZE, linfo->num_sockets);\n+\tmemcpy(listenset, linfo->socket_list, num_sockets * sizeof(int));\n+\n+\t/* Get the sockets ready. This could be hoisted into\n+\t * open_sockets_smbd(), but the order of socket operations might\n+\t * matter for some platforms, so this approach seems less risky.\n+\t *\t--jpeach\n+\t */\n+\tfor (i = 0; i < num_sockets; ++i) {\n+\t\tset_socket_options(listenset[i], \"SO_KEEPALIVE\");\n+\t\tset_socket_options(listenset[i], user_socket_options);\n+\n+\t\t/* Set server socket to non-blocking for the accept. */\n+\t\tset_blocking(listenset[i], False);\n+\t}\n+\n+\treturn num_sockets;\n+}\n+\n+/* This function is responsible for opening (or retrieving) all the sockets we\n+ * smbd will be listening on. It should apply all the configured socket options\n+ * and return the number of valid sockets in listenset.\n+ */\n+int smbd_sockinit(const char *cmdline_ports, int listenset[FD_SETSIZE],\n+\t\t\tstruct timeval *idle)\n+{\n+\tint num_sockets;\n+\tstruct smb_launch_info linfo;\n+\n+\tZERO_STRUCTP(idle);\n+\n+\tif (smb_launchd_checkin(&linfo)) {\n+\t\t/* We are running under launchd and launchd has\n+\t\t * opened some sockets for us.\n+\t\t */\n+\t\tnum_sockets = init_sockets_launchd(&linfo,\n+\t\t\t\t\t    cmdline_ports,\n+\t\t\t\t\t    listenset);\n+\t\tidle->tv_sec = linfo.idle_timeout_secs;\n+\t\tsmb_launchd_checkout(&linfo);\n+\t} else {\n+\t\tnum_sockets = init_sockets_smbd(cmdline_ports,\n+\t\t\t\t\t    listenset);\n+\t}\n+\n+\treturn num_sockets;\n+}\n+\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r23165 - in branches: SAMBA_3_0/source/include\n\tSAMBA_3_0/source/locking SAMBA_3_0_26/source/include\n\tSAMBA_3_0_26/source/locking", "body": "Author: vlendec\nDate: 2007-05-27 10:35:14 +0000 (Sun, 27 May 2007)\nNew Revision: 23165\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23165\n\nLog:\nConvert brlock.tdb to dbwrap\n\nModified:\n   branches/SAMBA_3_0/source/include/locking.h\n   branches/SAMBA_3_0/source/locking/brlock.c\n   branches/SAMBA_3_0_26/source/include/locking.h\n   branches/SAMBA_3_0_26/source/locking/brlock.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/include/locking.h\n===================================================================\n--- branches/SAMBA_3_0/source/include/locking.h\t2007-05-27 10:25:23 UTC (rev 23164)\n+++ branches/SAMBA_3_0/source/include/locking.h\t2007-05-27 10:35:14 UTC (rev 23165)\n@@ -58,6 +58,7 @@\n \tBOOL read_only;\n \tstruct lock_key key;\n \tstruct lock_struct *lock_data;\n+\tstruct db_record *record;\n };\n \n #define BRLOCK_FN_CAST() \\\n\nModified: branches/SAMBA_3_0/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-27 10:25:23 UTC (rev 23164)\n+++ branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-27 10:35:14 UTC (rev 23165)\n@@ -34,7 +34,7 @@\n \n /* The open brlock.tdb database. */\n \n-static TDB_CONTEXT *tdb;\n+static struct db_context *brlock_db;\n \n /****************************************************************************\n  Debug info at level 10 for lock struct.\n@@ -261,21 +261,20 @@\n \n void brl_init(int read_only)\n {\n-\tif (tdb) {\n+\tif (brlock_db) {\n \t\treturn;\n \t}\n-\ttdb = tdb_open_log(lock_path(\"brlock.tdb\"),\n-\t\t\tlp_open_files_db_hash_size(),\n-\t\t\tTDB_DEFAULT|(read_only?0x0:TDB_CLEAR_IF_FIRST),\n-\t\t\tread_only?O_RDONLY:(O_RDWR|O_CREAT), 0644 );\n-\tif (!tdb) {\n+\tbrlock_db = db_open(NULL, lock_path(\"brlock.tdb\"),\n+\t\t\t    lp_open_files_db_hash_size(),\n+\t\t\t    TDB_DEFAULT\n+\t\t\t    |TDB_VOLATILE\n+\t\t\t    |(read_only?0x0:TDB_CLEAR_IF_FIRST),\n+\t\t\t    read_only?O_RDONLY:(O_RDWR|O_CREAT), 0644 );\n+\tif (!brlock_db) {\n \t\tDEBUG(0,(\"Failed to open byte range locking database %s\\n\",\n \t\t\tlock_path(\"brlock.tdb\")));\n \t\treturn;\n \t}\n-\n-\t/* Activate the per-hashchain freelist */\n-\ttdb_set_max_dead(tdb, 5);\n }\n \n /****************************************************************************\n@@ -284,10 +283,10 @@\n \n void brl_shutdown(int read_only)\n {\n-\tif (!tdb) {\n+\tif (!brlock_db) {\n \t\treturn;\n \t}\n-\ttdb_close(tdb);\n+\tTALLOC_FREE(brlock_db);\n }\n \n #if ZERO_ZERO\n@@ -1453,7 +1452,7 @@\n  on each lock.\n ****************************************************************************/\n \n-static int traverse_fn(TDB_CONTEXT *ttdb, TDB_DATA kbuf, TDB_DATA dbuf, void *state)\n+static int traverse_fn(struct db_record *rec, void *state)\n {\n \tstruct lock_struct *locks;\n \tstruct lock_key *key;\n@@ -1466,13 +1465,14 @@\n \t/* In a traverse function we must make a copy of\n \t   dbuf before modifying it. */\n \n-\tlocks = (struct lock_struct *)memdup(dbuf.dptr, dbuf.dsize);\n+\tlocks = (struct lock_struct *)memdup(rec->value.dptr,\n+\t\t\t\t\t     rec->value.dsize);\n \tif (!locks) {\n \t\treturn -1; /* Terminate traversal. */\n \t}\n \n-\tkey = (struct lock_key *)kbuf.dptr;\n-\torig_num_locks = num_locks = dbuf.dsize/sizeof(*locks);\n+\tkey = (struct lock_key *)rec->key.dptr;\n+\torig_num_locks = num_locks = rec->value.dsize/sizeof(*locks);\n \n \t/* Ensure the lock db is clean of entries from invalid processes. */\n \n@@ -1482,13 +1482,10 @@\n \t}\n \n \tif (orig_num_locks != num_locks) {\n-\t\tdbuf.dptr = (uint8 *)locks;\n-\t\tdbuf.dsize = num_locks * sizeof(*locks);\n-\n-\t\tif (dbuf.dsize) {\n-\t\t\ttdb_store(ttdb, kbuf, dbuf, TDB_REPLACE);\n+\t\tif (rec->value.dsize) {\n+\t\t\trec->store(rec, rec->value, TDB_REPLACE);\n \t\t} else {\n-\t\t\ttdb_delete(ttdb, kbuf);\n+\t\t\trec->delete_rec(rec);\n \t\t}\n \t}\n \n@@ -1512,10 +1509,10 @@\n \n int brl_forall(BRLOCK_FN(fn))\n {\n-\tif (!tdb) {\n+\tif (!brlock_db) {\n \t\treturn 0;\n \t}\n-\treturn tdb_traverse(tdb, traverse_fn, (void *)fn);\n+\treturn brlock_db->traverse(brlock_db, traverse_fn, (void *)fn);\n }\n \n /*******************************************************************\n@@ -1541,25 +1538,31 @@\n \n \tif (br_lck->num_locks == 0) {\n \t\t/* No locks - delete this entry. */\n-\t\tif (tdb_delete(tdb, key) == -1) {\n+\t\tNTSTATUS status = br_lck->record->delete_rec(br_lck->record);\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\tDEBUG(0, (\"delete_rec returned %s\\n\",\n+\t\t\t\t  nt_errstr(status)));\n \t\t\tsmb_panic(\"Could not delete byte range lock entry\\n\");\n \t\t}\n \t} else {\n \t\tTDB_DATA data;\n+\t\tNTSTATUS status;\n+\n \t\tdata.dptr = (uint8 *)br_lck->lock_data;\n \t\tdata.dsize = br_lck->num_locks * sizeof(struct lock_struct);\n \n-\t\tif (tdb_store(tdb, key, data, TDB_REPLACE) == -1) {\n+\t\tstatus = br_lck->record->store(br_lck->record, data,\n+\t\t\t\t\t       TDB_REPLACE);\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\tDEBUG(0, (\"store returned %s\\n\", nt_errstr(status)));\n \t\t\tsmb_panic(\"Could not store byte range mode entry\\n\");\n \t\t}\n \t}\n \n  done:\n \n-\tif (!br_lck->read_only) {\n-\t\ttdb_chainunlock(tdb, key);\n-\t}\n \tSAFE_FREE(br_lck->lock_data);\n+\tTALLOC_FREE(br_lck->record);\n \treturn 0;\n }\n \n@@ -1572,8 +1575,7 @@\n static struct byte_range_lock *brl_get_locks_internal(TALLOC_CTX *mem_ctx,\n \t\t\t\t\tfiles_struct *fsp, BOOL read_only)\n {\n-\tTDB_DATA key;\n-\tTDB_DATA data;\n+\tTDB_DATA key, data;\n \tstruct byte_range_lock *br_lck = TALLOC_P(mem_ctx, struct byte_range_lock);\n \n \tif (br_lck == NULL) {\n@@ -1597,22 +1599,33 @@\n \t}\n \n \tif (read_only) {\n-\t\tbr_lck->read_only = True;\n-\t} else {\n-\t\tif (tdb_chainlock(tdb, key) != 0) {\n+\t\tif (brlock_db->fetch(brlock_db, br_lck, key, &data) == -1) {\n+\t\t\tDEBUG(3, (\"Could not fetch byte range lock record\\n\"));\n+\t\t\tTALLOC_FREE(br_lck);\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tbr_lck->record = NULL;\n+\t}\n+\telse {\n+\t\tbr_lck->record = brlock_db->fetch_locked(brlock_db, br_lck, key);\n+\n+\t\tif (br_lck->record == NULL) {\n \t\t\tDEBUG(3, (\"Could not lock byte range lock entry\\n\"));\n \t\t\tTALLOC_FREE(br_lck);\n \t\t\treturn NULL;\n \t\t}\n-\t\tbr_lck->read_only = False;\n+\n+\t\tdata = br_lck->record->value;\n \t}\n \n+\tbr_lck->read_only = read_only;\n+\n \ttalloc_set_destructor(br_lck, byte_range_lock_destructor);\n \n-\tdata = tdb_fetch(tdb, key);\n-\tbr_lck->lock_data = (struct lock_struct *)data.dptr;\n \tbr_lck->num_locks = data.dsize / sizeof(struct lock_struct);\n-\n+\tbr_lck->lock_data = SMB_MALLOC_ARRAY(struct lock_struct, br_lck->num_locks);\n+\tmemcpy(br_lck->lock_data, data.dptr, data.dsize);\n+\t\n \tif (!fsp->lockdb_clean) {\n \n \t\t/* This is the first time we've accessed this. */\n\nModified: branches/SAMBA_3_0_26/source/include/locking.h\n===================================================================\n--- branches/SAMBA_3_0_26/source/include/locking.h\t2007-05-27 10:25:23 UTC (rev 23164)\n+++ branches/SAMBA_3_0_26/source/include/locking.h\t2007-05-27 10:35:14 UTC (rev 23165)\n@@ -58,6 +58,7 @@\n \tBOOL read_only;\n \tstruct lock_key key;\n \tstruct lock_struct *lock_data;\n+\tstruct db_record *record;\n };\n \n #define BRLOCK_FN_CAST() \\\n\nModified: branches/SAMBA_3_0_26/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-27 10:25:23 UTC (rev 23164)\n+++ branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-27 10:35:14 UTC (rev 23165)\n@@ -34,7 +34,7 @@\n \n /* The open brlock.tdb database. */\n \n-static TDB_CONTEXT *tdb;\n+static struct db_context *brlock_db;\n \n /****************************************************************************\n  Debug info at level 10 for lock struct.\n@@ -261,21 +261,20 @@\n \n void brl_init(int read_only)\n {\n-\tif (tdb) {\n+\tif (brlock_db) {\n \t\treturn;\n \t}\n-\ttdb = tdb_open_log(lock_path(\"brlock.tdb\"),\n-\t\t\tlp_open_files_db_hash_size(),\n-\t\t\tTDB_DEFAULT|(read_only?0x0:TDB_CLEAR_IF_FIRST),\n-\t\t\tread_only?O_RDONLY:(O_RDWR|O_CREAT), 0644 );\n-\tif (!tdb) {\n+\tbrlock_db = db_open(NULL, lock_path(\"brlock.tdb\"),\n+\t\t\t    lp_open_files_db_hash_size(),\n+\t\t\t    TDB_DEFAULT\n+\t\t\t    |TDB_VOLATILE\n+\t\t\t    |(read_only?0x0:TDB_CLEAR_IF_FIRST),\n+\t\t\t    read_only?O_RDONLY:(O_RDWR|O_CREAT), 0644 );\n+\tif (!brlock_db) {\n \t\tDEBUG(0,(\"Failed to open byte range locking database %s\\n\",\n \t\t\tlock_path(\"brlock.tdb\")));\n \t\treturn;\n \t}\n-\n-\t/* Activate the per-hashchain freelist */\n-\ttdb_set_max_dead(tdb, 5);\n }\n \n /****************************************************************************\n@@ -284,10 +283,10 @@\n \n void brl_shutdown(int read_only)\n {\n-\tif (!tdb) {\n+\tif (!brlock_db) {\n \t\treturn;\n \t}\n-\ttdb_close(tdb);\n+\tTALLOC_FREE(brlock_db);\n }\n \n #if ZERO_ZERO\n@@ -1453,7 +1452,7 @@\n  on each lock.\n ****************************************************************************/\n \n-static int traverse_fn(TDB_CONTEXT *ttdb, TDB_DATA kbuf, TDB_DATA dbuf, void *state)\n+static int traverse_fn(struct db_record *rec, void *state)\n {\n \tstruct lock_struct *locks;\n \tstruct lock_key *key;\n@@ -1466,13 +1465,14 @@\n \t/* In a traverse function we must make a copy of\n \t   dbuf before modifying it. */\n \n-\tlocks = (struct lock_struct *)memdup(dbuf.dptr, dbuf.dsize);\n+\tlocks = (struct lock_struct *)memdup(rec->value.dptr,\n+\t\t\t\t\t     rec->value.dsize);\n \tif (!locks) {\n \t\treturn -1; /* Terminate traversal. */\n \t}\n \n-\tkey = (struct lock_key *)kbuf.dptr;\n-\torig_num_locks = num_locks = dbuf.dsize/sizeof(*locks);\n+\tkey = (struct lock_key *)rec->key.dptr;\n+\torig_num_locks = num_locks = rec->value.dsize/sizeof(*locks);\n \n \t/* Ensure the lock db is clean of entries from invalid processes. */\n \n@@ -1482,13 +1482,10 @@\n \t}\n \n \tif (orig_num_locks != num_locks) {\n-\t\tdbuf.dptr = (uint8 *)locks;\n-\t\tdbuf.dsize = num_locks * sizeof(*locks);\n-\n-\t\tif (dbuf.dsize) {\n-\t\t\ttdb_store(ttdb, kbuf, dbuf, TDB_REPLACE);\n+\t\tif (rec->value.dsize) {\n+\t\t\trec->store(rec, rec->value, TDB_REPLACE);\n \t\t} else {\n-\t\t\ttdb_delete(ttdb, kbuf);\n+\t\t\trec->delete_rec(rec);\n \t\t}\n \t}\n \n@@ -1512,10 +1509,10 @@\n \n int brl_forall(BRLOCK_FN(fn))\n {\n-\tif (!tdb) {\n+\tif (!brlock_db) {\n \t\treturn 0;\n \t}\n-\treturn tdb_traverse(tdb, traverse_fn, (void *)fn);\n+\treturn brlock_db->traverse(brlock_db, traverse_fn, (void *)fn);\n }\n \n /*******************************************************************\n@@ -1541,25 +1538,31 @@\n \n \tif (br_lck->num_locks == 0) {\n \t\t/* No locks - delete this entry. */\n-\t\tif (tdb_delete(tdb, key) == -1) {\n+\t\tNTSTATUS status = br_lck->record->delete_rec(br_lck->record);\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\tDEBUG(0, (\"delete_rec returned %s\\n\",\n+\t\t\t\t  nt_errstr(status)));\n \t\t\tsmb_panic(\"Could not delete byte range lock entry\\n\");\n \t\t}\n \t} else {\n \t\tTDB_DATA data;\n+\t\tNTSTATUS status;\n+\n \t\tdata.dptr = (uint8 *)br_lck->lock_data;\n \t\tdata.dsize = br_lck->num_locks * sizeof(struct lock_struct);\n \n-\t\tif (tdb_store(tdb, key, data, TDB_REPLACE) == -1) {\n+\t\tstatus = br_lck->record->store(br_lck->record, data,\n+\t\t\t\t\t       TDB_REPLACE);\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\tDEBUG(0, (\"store returned %s\\n\", nt_errstr(status)));\n \t\t\tsmb_panic(\"Could not store byte range mode entry\\n\");\n \t\t}\n \t}\n \n  done:\n \n-\tif (!br_lck->read_only) {\n-\t\ttdb_chainunlock(tdb, key);\n-\t}\n \tSAFE_FREE(br_lck->lock_data);\n+\tTALLOC_FREE(br_lck->record);\n \treturn 0;\n }\n \n@@ -1572,8 +1575,7 @@\n static struct byte_range_lock *brl_get_locks_internal(TALLOC_CTX *mem_ctx,\n \t\t\t\t\tfiles_struct *fsp, BOOL read_only)\n {\n-\tTDB_DATA key;\n-\tTDB_DATA data;\n+\tTDB_DATA key, data;\n \tstruct byte_range_lock *br_lck = TALLOC_P(mem_ctx, struct byte_range_lock);\n \n \tif (br_lck == NULL) {\n@@ -1597,22 +1599,33 @@\n \t}\n \n \tif (read_only) {\n-\t\tbr_lck->read_only = True;\n-\t} else {\n-\t\tif (tdb_chainlock(tdb, key) != 0) {\n+\t\tif (brlock_db->fetch(brlock_db, br_lck, key, &data) == -1) {\n+\t\t\tDEBUG(3, (\"Could not fetch byte range lock record\\n\"));\n+\t\t\tTALLOC_FREE(br_lck);\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tbr_lck->record = NULL;\n+\t}\n+\telse {\n+\t\tbr_lck->record = brlock_db->fetch_locked(brlock_db, br_lck, key);\n+\n+\t\tif (br_lck->record == NULL) {\n \t\t\tDEBUG(3, (\"Could not lock byte range lock entry\\n\"));\n \t\t\tTALLOC_FREE(br_lck);\n \t\t\treturn NULL;\n \t\t}\n-\t\tbr_lck->read_only = False;\n+\n+\t\tdata = br_lck->record->value;\n \t}\n \n+\tbr_lck->read_only = read_only;\n+\n \ttalloc_set_destructor(br_lck, byte_range_lock_destructor);\n \n-\tdata = tdb_fetch(tdb, key);\n-\tbr_lck->lock_data = (struct lock_struct *)data.dptr;\n \tbr_lck->num_locks = data.dsize / sizeof(struct lock_struct);\n-\n+\tbr_lck->lock_data = SMB_MALLOC_ARRAY(struct lock_struct, br_lck->num_locks);\n+\tmemcpy(br_lck->lock_data, data.dptr, data.dsize);\n+\t\n \tif (!fsp->lockdb_clean) {\n \n \t\t/* This is the first time we've accessed this. */\n\n"}
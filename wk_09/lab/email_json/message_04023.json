{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r22205 - in branches/SAMBA_3_0/source/nsswitch: .", "body": "Author: jra\nDate: 2007-04-13 00:39:06 +0000 (Fri, 13 Apr 2007)\nNew Revision: 22205\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22205\n\nLog:\nAdd some flesh to the bones of the cache validation code.\nJeremy\n\nModified:\n   branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\t2007-04-12 21:10:06 UTC (rev 22204)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\t2007-04-13 00:39:06 UTC (rev 22205)\n@@ -52,6 +52,8 @@\n \tuint32 len, ofs;\n };\n \n+void (*smb_panic_fn)(const char *const why) = smb_panic;\n+\n #define WINBINDD_MAX_CACHE_SIZE (50*1024*1024)\n \n static struct winbind_cache *wcache;\n@@ -160,16 +162,27 @@\n \tfree(centry);\n }\n \n+static BOOL centry_check_bytes(struct cache_entry *centry, size_t nbytes)\n+{\n+\tif (centry->len - centry->ofs < nbytes) {\n+\t\tDEBUG(0,(\"centry corruption? needed %u bytes, have %d\\n\", \n+\t\t\t (unsigned int)nbytes,\n+\t\t\t centry->len - centry->ofs));\n+\t\treturn False;\n+\t}\n+\treturn True;\n+}\n+\n /*\n   pull a uint32 from a cache entry \n */\n static uint32 centry_uint32(struct cache_entry *centry)\n {\n \tuint32 ret;\n-\tif (centry->len - centry->ofs < 4) {\n-\t\tDEBUG(0,(\"centry corruption? needed 4 bytes, have %d\\n\", \n-\t\t\t centry->len - centry->ofs));\n-\t\tsmb_panic(\"centry_uint32\");\n+\n+\tif (centry_check_bytes(centry, 4)) {\n+\t\tsmb_panic_fn(\"centry_uint32\");\n+\t\treturn (uint32)-1;\n \t}\n \tret = IVAL(centry->data, centry->ofs);\n \tcentry->ofs += 4;\n@@ -182,10 +195,9 @@\n static uint16 centry_uint16(struct cache_entry *centry)\n {\n \tuint16 ret;\n-\tif (centry->len - centry->ofs < 2) {\n-\t\tDEBUG(0,(\"centry corruption? needed 2 bytes, have %d\\n\", \n-\t\t\t centry->len - centry->ofs));\n-\t\tsmb_panic(\"centry_uint16\");\n+\tif (centry_check_bytes(centry, 2)) {\n+\t\tsmb_panic_fn(\"centry_uint16\");\n+\t\treturn (uint16)-1;\n \t}\n \tret = CVAL(centry->data, centry->ofs);\n \tcentry->ofs += 2;\n@@ -198,10 +210,9 @@\n static uint8 centry_uint8(struct cache_entry *centry)\n {\n \tuint8 ret;\n-\tif (centry->len - centry->ofs < 1) {\n-\t\tDEBUG(0,(\"centry corruption? needed 1 bytes, have %d\\n\", \n-\t\t\t centry->len - centry->ofs));\n-\t\tsmb_panic(\"centry_uint32\");\n+\tif (centry_check_bytes(centry, 1)) {\n+\t\tsmb_panic_fn(\"centry_uint8\");\n+\t\treturn (uint8)-1;\n \t}\n \tret = CVAL(centry->data, centry->ofs);\n \tcentry->ofs += 1;\n@@ -214,10 +225,9 @@\n static NTTIME centry_nttime(struct cache_entry *centry)\n {\n \tNTTIME ret;\n-\tif (centry->len - centry->ofs < 8) {\n-\t\tDEBUG(0,(\"centry corruption? needed 8 bytes, have %d\\n\", \n-\t\t\t centry->len - centry->ofs));\n-\t\tsmb_panic(\"centry_nttime\");\n+\tif (centry_check_bytes(centry, 8)) {\n+\t\tsmb_panic_fn(\"centry_nttime\");\n+\t\treturn (NTTIME)-1;\n \t}\n \tret = IVAL(centry->data, centry->ofs);\n \tcentry->ofs += 4;\n@@ -232,10 +242,9 @@\n static time_t centry_time(struct cache_entry *centry)\n {\n \ttime_t ret;\n-\tif (centry->len - centry->ofs < sizeof(time_t)) {\n-\t\tDEBUG(0,(\"centry corruption? needed %u bytes, have %u\\n\", \n-\t\t\t (unsigned int)sizeof(time_t), (unsigned int)(centry->len - centry->ofs)));\n-\t\tsmb_panic(\"centry_time\");\n+\tif (centry_check_bytes(centry, sizeof(time_t))) {\n+\t\tsmb_panic_fn(\"centry_time\");\n+\t\treturn (time_t)-1;\n \t}\n \tret = IVAL(centry->data, centry->ofs); /* FIXME: correct ? */\n \tcentry->ofs += sizeof(time_t);\n@@ -257,15 +266,15 @@\n \t\treturn NULL;\n \t}\n \n-\tif (centry->len - centry->ofs < len) {\n-\t\tDEBUG(0,(\"centry corruption? needed %d bytes, have %d\\n\", \n-\t\t\t len, centry->len - centry->ofs));\n-\t\tsmb_panic(\"centry_string\");\n+\tif (centry_check_bytes(centry, (size_t)len)) {\n+\t\tsmb_panic_fn(\"centry_string\");\n+\t\treturn NULL;\n \t}\n \n \tret = TALLOC_ARRAY(mem_ctx, char, len+1);\n \tif (!ret) {\n-\t\tsmb_panic(\"centry_string out of memory\\n\");\n+\t\tsmb_panic_fn(\"centry_string out of memory\\n\");\n+\t\treturn NULL;\n \t}\n \tmemcpy(ret,centry->data + centry->ofs, len);\n \tret[len] = 0;\n@@ -289,15 +298,14 @@\n \t\treturn NULL;\n \t}\n \n-\tif (centry->len - centry->ofs < 16) {\n-\t\tDEBUG(0,(\"centry corruption? needed 16 bytes, have %d\\n\", \n-\t\t\t centry->len - centry->ofs));\n+\tif (centry_check_bytes(centry, 16)) {\n \t\treturn NULL;\n \t}\n \n \tret = TALLOC_ARRAY(mem_ctx, char, 16);\n \tif (!ret) {\n-\t\tsmb_panic(\"centry_hash out of memory\\n\");\n+\t\tsmb_panic_fn(\"centry_hash out of memory\\n\");\n+\t\treturn NULL;\n \t}\n \tmemcpy(ret,centry->data + centry->ofs, 16);\n \tcentry->ofs += 16;\n@@ -622,7 +630,7 @@\n \t\t\t\t\t centry->len);\n \tif (!centry->data) {\n \t\tDEBUG(0,(\"out of memory: needed %d bytes in centry_expand\\n\", centry->len));\n-\t\tsmb_panic(\"out of memory in centry_expand\");\n+\t\tsmb_panic_fn(\"out of memory in centry_expand\");\n \t}\n }\n \n@@ -1053,8 +1061,11 @@\n \t\tgoto do_cached;\n \n \t(*info) = TALLOC_ARRAY(mem_ctx, WINBIND_USERINFO, *num_entries);\n-\tif (! (*info))\n-\t\tsmb_panic(\"query_user_list out of memory\");\n+\tif (! (*info)) {\n+\t\tsmb_panic_fn(\"query_user_list out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n \tfor (i=0; i<(*num_entries); i++) {\n \t\t(*info)[i].acct_name = centry_string(centry, mem_ctx);\n \t\t(*info)[i].full_name = centry_string(centry, mem_ctx);\n@@ -1168,8 +1179,11 @@\n \t\tgoto do_cached;\n \n \t(*info) = TALLOC_ARRAY(mem_ctx, struct acct_info, *num_entries);\n-\tif (! (*info))\n-\t\tsmb_panic(\"enum_dom_groups out of memory\");\n+\tif (! (*info)) {\n+\t\tsmb_panic_fn(\"enum_dom_groups out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n \tfor (i=0; i<(*num_entries); i++) {\n \t\tfstrcpy((*info)[i].acct_name, centry_string(centry, mem_ctx));\n \t\tfstrcpy((*info)[i].acct_desc, centry_string(centry, mem_ctx));\n@@ -1241,8 +1255,11 @@\n \t\tgoto do_cached;\n \n \t(*info) = TALLOC_ARRAY(mem_ctx, struct acct_info, *num_entries);\n-\tif (! (*info))\n-\t\tsmb_panic(\"enum_dom_groups out of memory\");\n+\tif (! (*info)) {\n+\t\tsmb_panic_fn(\"enum_dom_groups out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n \tfor (i=0; i<(*num_entries); i++) {\n \t\tfstrcpy((*info)[i].acct_name, centry_string(centry, mem_ctx));\n \t\tfstrcpy((*info)[i].acct_desc, centry_string(centry, mem_ctx));\n@@ -1657,8 +1674,11 @@\n \t\tgoto do_cached;\n \n \t(*user_gids) = TALLOC_ARRAY(mem_ctx, DOM_SID, *num_groups);\n-\tif (! (*user_gids))\n-\t\tsmb_panic(\"lookup_usergroups out of memory\");\n+\tif (! (*user_gids)) {\n+\t\tsmb_panic_fn(\"lookup_usergroups out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n \tfor (i=0; i<(*num_groups); i++) {\n \t\tcentry_sid(centry, mem_ctx, &(*user_gids)[i]);\n \t}\n@@ -1817,7 +1837,9 @@\n \t(*name_types) = TALLOC_ARRAY(mem_ctx, uint32, *num_names);\n \n \tif (! (*sid_mem) || ! (*names) || ! (*name_types)) {\n-\t\tsmb_panic(\"lookup_groupmem out of memory\");\n+\t\tsmb_panic_fn(\"lookup_groupmem out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n \t}\n \n \tfor (i=0; i<(*num_names); i++) {\n@@ -1911,7 +1933,9 @@\n \t(*dom_sids) \t= TALLOC_ARRAY(mem_ctx, DOM_SID, *num_domains);\n  \n \tif (! (*dom_sids) || ! (*names) || ! (*alt_names)) {\n-\t\tsmb_panic(\"trusted_domains out of memory\");\n+\t\tsmb_panic_fn(\"trusted_domains out of memory\");\n+\t\tcentry_free(centry);\n+\t\treturn NT_STATUS_NO_MEMORY;\n  \t}\n  \n \tfor (i=0; i<(*num_domains); i++) {\n@@ -2595,84 +2619,171 @@\n  Validate functions for all possible cache tdb keys.\n ***********************************************************************/\n \n-static int bad_cache_entry;\n+static BOOL bad_cache_entry;\n \n-static int validate_seqnum(TDB_DATA kbuf, TDB_DATA dbuf)\n+static struct cache_entry *create_centry_validate(const char *kstr, TDB_DATA data)\n {\n+\tstruct cache_entry *centry;\n+\n+\tcentry = SMB_XMALLOC_P(struct cache_entry);\n+\tcentry->data = (unsigned char *)memdup(data.dptr, data.dsize);\n+\tif (!centry->data) {\n+\t\tSAFE_FREE(centry);\n+\t\treturn NULL;\n+\t}\n+\tcentry->len = data.dsize;\n+\tcentry->ofs = 0;\n+\n+\tif (centry->len < 8) {\n+\t\t/* huh? corrupt cache? */\n+\t\tDEBUG(0,(\"validate_create_centry: Corrupt cache for key %s (len < 8) ?\\n\", kstr));\n+\t\tcentry_free(centry);\n+\t\tbad_cache_entry = True;\n+\t\treturn NULL;\n+\t}\n+\n+\tcentry->status = NT_STATUS(centry_uint32(centry));\n+\tcentry->sequence_number = centry_uint32(centry);\n+\treturn centry;\n+}\n+\n+static int validate_seqnum(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n+{\n+\tif (dbuf.dsize != 8) {\n+\t\tDEBUG(0,(\"validate_seqnum: Corrupt cache for key %s (len %u != 8) ?\\n\",\n+\t\t\t\tkeystr, (unsigned int)dbuf.dsize ));\n+\t\tbad_cache_entry = True;\n+\t\treturn 1;\n+\t}\n \treturn 0;\n }\n \n-static int validate_ns(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_ns(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n+\tstruct cache_entry *centry = create_centry_validate(keystr, dbuf);\n+\tif (!centry) {\n+\t\treturn 1;\n+\t}\n+\n+\t(void)centry_uint32(centry);\n+\tif (NT_STATUS_IS_OK(centry->status)) {\n+\t\tDOM_SID sid;\n+\t\t(void)centry_sid(centry, mem_ctx, &sid);\n+\t}\n+\n+\tcentry_free(centry);\n+\n+\tif (bad_cache_entry) {\n+\t\treturn 1;\n+\t}\n+\tDEBUG(10,(\"validate_ns: %s ok\\n\", keystr));\n \treturn 0;\n }\n \n-static int validate_sn(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_sn(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n+\tstruct cache_entry *centry = create_centry_validate(keystr, dbuf);\n+\tif (!centry) {\n+\t\treturn 1;\n+\t}\n+\n+\tif (NT_STATUS_IS_OK(centry->status)) {\n+\t\t(void)centry_uint32(centry);\n+\t\t(void)centry_string(centry, mem_ctx);\n+\t\t(void)centry_string(centry, mem_ctx);\n+\t}\n+\n+\tcentry_free(centry);\n+\n+\tif (bad_cache_entry) {\n+\t\treturn 1;\n+\t}\n+\tDEBUG(10,(\"validate_sn: %s ok\\n\", keystr));\n \treturn 0;\n }\n \n-static int validate_u(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_u(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n+\tstruct cache_entry *centry = create_centry_validate(keystr, dbuf);\n+\tDOM_SID sid;\n+\n+\tif (!centry) {\n+\t\treturn 1;\n+\t}\n+\n+\t(void)centry_string(centry, mem_ctx);\n+\t(void)centry_string(centry, mem_ctx);\n+\t(void)centry_string(centry, mem_ctx);\n+\t(void)centry_string(centry, mem_ctx);\n+\t(void)centry_uint32(centry);\n+\t(void)centry_sid(centry, mem_ctx, &sid);\n+\t(void)centry_sid(centry, mem_ctx, &sid);\n+\n+\tcentry_free(centry);\n+\n+\tif (bad_cache_entry) {\n+\t\treturn 1;\n+\t}\n+\tDEBUG(10,(\"validate_u: %s ok\\n\", keystr));\n \treturn 0;\n }\n \n-static int validate_loc_pol(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_loc_pol(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_pwd_pol(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_pwd_pol(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_cred(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_cred(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_ul(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_ul(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_gl(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_gl(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_ug(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_ug(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_ua(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_ua(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_gm(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_gm(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_dr(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_dr(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_de(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_de(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_trustdoms(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_trustdoms(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n \n-static int validate_offline(TDB_DATA kbuf, TDB_DATA dbuf)\n+static int validate_offline(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf)\n {\n \treturn 0;\n }\n@@ -2684,7 +2795,7 @@\n \n struct key_val_struct {\n \tconst char *keyname;\n-\tint (*validate_data_fn)(TDB_DATA kbuf, TDB_DATA dbuf);\n+\tint (*validate_data_fn)(TALLOC_CTX *mem_ctx, const char *keystr, TDB_DATA dbuf);\n } key_val[] = {\n \t{\"SEQNUM/\", validate_seqnum},\n \t{\"NS/\", validate_ns},\n@@ -2714,11 +2825,39 @@\n {\n \tint i;\n \n+\t/* Paranoia check. */\n+\tif (kbuf.dsize > 1024) {\n+\t\tDEBUG(0,(\"cache_traverse_validate_fn: key length too large (%u) > 1024\\n\\n\",\n+\t\t\t\t(unsigned int)kbuf.dsize ));\n+\t\treturn 1;\n+\t}\n+\n \tfor (i = 0; key_val[i].keyname; i++) {\n \t\tsize_t namelen = strlen(key_val[i].keyname);\n \t\tif (kbuf.dsize >= namelen && (\n \t\t\t\tstrncmp(key_val[i].keyname, (const char *)kbuf.dptr, namelen)) == 0) {\n-\t\t\treturn key_val[i].validate_data_fn(kbuf, dbuf);\n+\t\t\tTALLOC_CTX *mem_ctx;\n+\t\t\tchar *keystr;\n+\t\t\tint ret;\n+\n+\t\t\tkeystr = SMB_MALLOC(kbuf.dsize+1);\n+\t\t\tif (!keystr) {\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\t\t\tmemcpy(keystr, kbuf.dptr, kbuf.dsize);\n+\t\t\tkeystr[kbuf.dsize] = '\\0';\n+\n+\t\t\tmem_ctx = talloc_init(\"validate_ctx\");\n+\t\t\tif (!mem_ctx) {\n+\t\t\t\tSAFE_FREE(keystr);\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\n+\t\t\tret = key_val[i].validate_data_fn(mem_ctx, keystr, dbuf);\n+\n+\t\t\tSAFE_FREE(keystr);\n+\t\t\ttalloc_destroy(mem_ctx);\n+\t\t\treturn ret;\n \t\t}\n \t}\n \n@@ -2729,6 +2868,12 @@\n \treturn 1; /* terminate. */\n }\n \n+static void validate_panic(const char *const why)\n+{\n+\tDEBUG(0,(\"validating cache: would panic %s\\n\", why ));\n+\tbad_cache_entry = True;\n+}\n+\n /* Handle any signals generated when validating a possibly\n    bad cache tdb. */\n \n@@ -2813,6 +2958,8 @@\n \tDEBUG(10,(\"winbindd_validate_cache: cache %s freelist has %d entries\\n\",\n \t\tcache_path, num_entries));\n \n+\tsmb_panic_fn = validate_panic;\n+\n \t/* Now traverse the cache to validate it. */\n \tnum_entries = tdb_traverse(tdb, cache_traverse_validate_fn, NULL);\n \tif (num_entries == -1 || bad_cache_entry) {\n@@ -2827,6 +2974,9 @@\n \n   out:\n \n+\tbad_cache_entry = False;\n+\tsmb_panic_fn = smb_panic;\n+\n \t/* Ensure if we segv on exit we use the original\n \t   handlers to avoid a loop. */\n \n\n"}
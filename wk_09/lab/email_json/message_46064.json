{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "NeonGraal <scifigeeknz@gmail.com>", "subject": "Re: Generalizing ?? !!", "body": "On Jun 11, 9:10 am, datawea...@gmail.com (Jonathan Lang) wrote:\n> Rereading A03, I ran across the original reasoning behind why Perl 5's\n> '?:' trinary operator became '?? ::' first, and then '?? !!'.  Three\n> reasons were given:\n>\n> * the '?' and ':' tokens are far too broadly useful to be gobbled up\n> by the trinary operator.\n>\n> * the doubled symbols bring to mind the short-circuiting operators\n> (e.g., '&&' and '||'), suggesting a similar short-circuiting behavior\n> here.\n>\n> * the '!!' brings to mind \"evaluate this when the condition fails\".\n>\n> IMHO, the first point was always more about the ':' than it was about\n> the '?'; if you were to replace ':' with '!', I suspect that this\n> concern would largely go away.  That is, I don't see any infix: or\n> infix: operators in the current draft.  A case could be made that a\n> trinary '... ? ... ! ...' operator could work within the current state\n> of things without conflict.  Also, the whitespace disambiguation rules\n> that were later implemented go a long way to resolving the original\n> problem of ':' trying to do too much.\n>\n> That said, the latter two points are still valid.  '... ? ... : ...'\n> might be perfectly workable; but so is '... ?? ... !! ...'.\n>\n> However, there still may be room for improvement.  Consider the\n> following possibility:\n>\n> Instead of being a single, inflexible trinary operator, break this\n> into a pair of binary operators: infix: and infix:.  Each can\n> be used on its own, returning the right side if the condition\n> evaluates as expected (i.e., true for ?? and false for !!), and\n> otherwise returns 'undef'.  A variation of chaining associativity gets\n> used, with the \"chaining rule\" being '$v1 op1 $v2 // $v1 op2 $v3'\n> instead of '$v1 op1 $v2 && $v2 op2 $v3', as is the case for comparison\n> chaining.  So all of the following would be valid syntax:\n>\n>   $test ?? $a !! $b  # true: $a; false: $b\n>   $test !! $a ?? $b  # true: $b; false: $a\n>   $test ?? $a       # true: $a; false: undef\n>   $test !! $b       # true: undef; false: $a\n>\n> I suggest this mainly because it's potentially more extensible than\n> the current model.  I could see someone devising a \"fuzzy logic\"\n> module which could allow for such things as:\n>\n>   $test ?? $a !! $b maybe $c likely $d unlikely $e\n>\n> --\n> Jonathan \"Dataweaver\" Lang\n\nSurely if you defined !! to return \"undef but true\" and both operators\nto be left associative then it all works.\n\n 1==0 ?? \"True\" !! \"False\" -> (undef) !! \"False\" which seems right to\nme.\n\n 1==1 !! \"False\" ?? \"True\" -> (undef but true) ?? \"True\" also good.\n\nTTFN, Struan\n\n"}
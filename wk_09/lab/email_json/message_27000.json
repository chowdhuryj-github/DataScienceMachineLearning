{"category": "ham", "to_address": "Chas Owens <chas.owens@gmail.com>, beginners@perl.org", "from_address": "Nisse Tuta <nissetuta@gmail.com>", "subject": "Re: complex sort", "body": "Hi,\n\nThis is exactly what I was looking for.\nThank you very much. You just made my day :)\n\nRegards,\nNisse\n\n\nChas Owens wrote:\n> On 5/7/07, Nisse Tuta  wrote:\n>> Hi All,\n>>\n>> I am having big problems solving this sorting issue and would really\n>> appreciate any help on this.\n>>\n>> I have a list with each row containing 3 numbers(Run In Out).\n>>\n>> For example,\n>> R01 13 19\n>> R01 25 30\n>> R01 23 47\n>> R01 2 14\n>> R02 2 45\n>> R02 55 60\n>> R01 1 17\n>> R03 45 66\n>> R03 20 35\n>> and so on......\n>>\n>> I would like to go through these and check for any overlapping numbers\n>> at both In and Out and replacing either the in out or both if\n>> overlapped. And any cuts/breaks in each run will add a count.\n>>\n>> To create a list like\n>>\n>> Run Count In Out\n>> R01 1 1 19\n>> 2 25 47\n>> R02 1 2 45\n>> 2 55 60\n>>\n> snip\n>\n> If I understand correctly then R03 should look like\n>\n> R03 1 20 35\n> 2 45 46\n>\n> The sort itself isn't that bad; you are just sorting on three columns,\n> column 1 first, column 2 second, and column 3 last:\n>\n> my @sorted = sort {\n>        $a->[0] cmp $b->[0] or #sort on run, if equal then\n>        $a->[1] <=> $b->[1] or #sort on in, if equal then\n>        $a->[2] <=> $b->[2]    #sort on out\n> } @input;\n>\n> But that doesn't solve your problem.  You then need to loop over the\n> sorted values and compress the runs.  Note, if you write the code that\n> transforms the data correctly, it is not necessary to sort it first,\n> but it does make it easier.\n>\n> #!/usr/bin/perl\n>\n> use strict;\n> use warnings;\n>\n> my @input = (\n>        [ qw(R01 13 19) ],\n>        [ qw(R01 25 30) ],\n>        [ qw(R01 23 47) ],\n>        [ qw(R01  2 14) ],\n>        [ qw(R02  2 45) ],\n>        [ qw(R02 55 60) ],\n>        [ qw(R01  1 17) ],\n>        [ qw(R03 45 66) ],\n>        [ qw(R03 20 35) ],\n> );\n>\n> my @sorted = sort {\n>        $a->[0] cmp $b->[0] or #sort on run, if equal then\n>        $a->[1] <=> $b->[1] or #sort on in, if equal then\n>        $a->[2] <=> $b->[2]    #sort on out\n> } @input;\n>\n> #printf \"%s %3d %3d\\n\", @$_ for @sorted;\n>\n> my %output;\n> ROW:\n> for my $row (@sorted) {\n>        my ($runname, $in, $out) = @$row;\n>        for my $run (@{$output{$runname}}) {\n>                if ($in < $run->[2]) {\n>                        if ($out > $run->[2]) {\n>                                $run->[2] = $out;\n>                        }\n>                        next ROW;\n>                }\n>        }\n>        push @{$output{$runname}}, $row;\n> }\n>\n> for my $runname (sort keys %output) {\n>        print \"$runname \";\n>        my $i   = 0;\n>        for my $run (@{$output{$runname}}) {\n>                $i++;\n>                printf \"$i %3d %3d\\n\", @{$run}[1,2];\n>        }\n> }\n>\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
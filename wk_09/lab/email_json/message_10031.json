{"category": "ham", "to_address": "Perl Beginners <beginners@perl.org>", "from_address": "\"John W. Krahn\" <krahnj@telus.net>", "subject": "Re: Nested loop", "body": "Chas Owens wrote:\n> On 4/19/07, Jenda Krynicky  wrote:\n>> From: \"Chas Owens\" \n> snip\n>> > foreach is dead, long live for.\n>>\n>> William is dead, long live Bill?\n>>\n>> foreach and for are two names for the same thing and just as you can\n>> call someone both William and Bill you can use foreach and for\n>> interchangeably.\n>>\n>> foreach(my $i = 0; $i < $whatever; $i++)\n>> for(my $i = 0; $i < $whatever; $i++)\n>>\n>> for my $x (@array)\n>> foreach my $x (@array)\n>>\n>> for (@array)\n>> foreach (@array)\n>>\n>> No difference to the computer. Use whichever reads best!\n> \n> Yes, foreach was aliased to for for backwards compatibility,\n\nHuh?  Do you have something to back up that claim?\n\n> but, like\n> telnet and rsh, it should not be used in new code.\n\nReally?  I assume you mean the protocols and not the programs?\n\n>> I would myself use \"for\" for the C-style loops\n> \n> And this is why.  As long as people think \"well, I have foreach which\n> is for iterating and for which is for C-style loops\" they will\n> continue to write C-style loops.  C-style loops are bad.  They are\n> there for backwards compatibility.  I can't think of a single for loop\n> that isn't better written as a range based for loop or while loop. For\n> instance\n> \n> standard range based loop\n> for (my $i = 0; $i < 10; $i++) {}\n> for my $i (0 .. 9) {}\n\nHow about:\n\nfor ( my $i = 0; $i < 10; $i += 3 ) {}\n\nforeach my $i ( ? .. ? ) {}\n\n> often $i winds up being used as an index which just makes me cringe.\n> \n> The infinite loop\n> for (;;) {}\n> while (1) {}\n> \n> The reason C programmers give for using for (;;) is that it generates\n> less overhead on their platform, but, at least with my tests*,\n> while(1) is more efficient in Perl.\n\nI ran your benchmark on my computer and for(;;) and while(1) ran at about the\nsame speed.\n\n$ perl -le'\nuse Benchmark;\n\nmy %subs = (\n       for   => sub { my $i; for (;;) { last if $i++ > 1_000 } },\n       while => sub { my $i; while (1) { last if $i++ > 1_000 } },\n       bare  => sub { my $i; { last if $i++ > 1_000; redo }  },\n);\n\nBenchmark::cmpthese(-10, \\%subs);\n'\n        Rate  bare   for while\nbare  4471/s    --  -15%  -15%\nfor   5253/s   17%    --   -0%\nwhile 5268/s   18%    0%    --\n\n$ perl -le'\nuse Benchmark;\n\nmy %subs = (\n       for   => q{ my $i; for (;;) { last if $i++ > 1_000 } },\n       while => q{ my $i; while (1) { last if $i++ > 1_000 } },\n       bare  => q{ my $i; { last if $i++ > 1_000; redo }  },\n);\n\nBenchmark::cmpthese(-10, \\%subs);\n'\n        Rate  bare while   for\nbare  4445/s    --  -15%  -15%\nwhile 5219/s   17%    --   -0%\nfor   5233/s   18%    0%    --\n\n\n\n\nJohn\n-- \nPerl isn't a toolbox, but a small machine shop where you can special-order\ncertain sorts of tools at low cost and in short order.       -- Larry Wall\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
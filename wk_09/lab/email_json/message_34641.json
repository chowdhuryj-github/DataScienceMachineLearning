{"category": "ham", "to_address": "Allison Randal <allison@perl.org>", "from_address": "\"Patrick R. Michaud\" <pmichaud@pobox.com>", "subject": "Re: PMC architecture discussion", "body": "On Tue, May 22, 2007 at 04:42:15PM -0700, Allison Randal wrote:\n> Patrick R. Michaud wrote:\n> >\n> >Now then, this assumes that every type knows how to morph itself\n> >into an .Undef and that .Undef can handle assignment from any type.\n> >For many PMC classes this isn't (or hasn't been) the case; from\n> >time to time we stumble across another type that doesn't know\n> >how to morph itself to .Undef or for which .Undef cannot handle\n> >the assignment.  When this happens either Matt or I have gone\n> >in and updated the PMC code to allow these conversions -- the\n> >prime example is .Sub, but there have been a few others.\n> \n> I'm not sure it should be the case. Why should a Sub morph itself to \n> Undef? Why should the default implementation of Sub morph itself to \n> anything?\n\nHere's the perl 6 code:\n\n    my $a = sub { ... };      # $a is a subroutine reference\n    my $b := $a;\n    # ...;\n    $a = 4;                   # $a is now an Int\n\nHow to do the above in PIR if we can't morph a Sub?  (Note that\nthe ability to reassign a variable containing a Sub already exists\nin the 01-sanity tests, which is why we had to make the change.)\n\nIf the plan is to morph a \"Perl6Sub\", then we need a way of\ncompiling PIR into HLL-specific subclasses of Sub, or something like\nthat.  Of course, we need this anyway.  But until we have that,\nI need to be able to assign to Sub PMCs somehow.\n\n> I'm nearly convinced on adding assign_pmc_keyed, assign_pmc_keyed_int, \n> and assign_pmc_keyed_str as vtable functions. The simplified code is a \n> strong motivator, but a stronger motivator is the cross-language \n> abstraction: not all languages want to morph and autovivify this way. \n\nExcellent.  Whatever reason makes it happen makes me happy.  :-)\n\n> So, the morphing behavior would be a feature of the Perl 6 types, not of \n> the system as a whole.\n> \n> Would we also need assign_string_keyed, etc?\n\nI don't think so -- at least I don't seen an immediate need for\nthem.  Having assign_pmc_keyed and assign_pmc_keyed_int would\ncover most everything.\n\n> >For package-scoped and global variables we'd just use \n> >assign_keyed on the namespace objects \n> \n> I'm less convinced that global namespaces should perform the same \n> autovivification and morphing.\n\nSomething will have to handle it.\n\n> >  ## our $y; $y = foo();\n> >    $P0 = 'foo'()\n> >    $P1 = get_namespace\n> >\n> >    assign_keyed $P1['$y'], $P0\n> \n> [...] I can see \n> adding assign_pmc_keyed to namespaces, but if we did it'd be a simple:\n> \n>     $P0 = 'foo'()\n>     get_global $P1, '$y'\n>     unless_null $P1, assign_1\n>     clone $P1, $P0\n>     set_global $P1, '$y'\n>     goto done\n>   assign_1:\n>     assign $P1, $P0\n>   done:\n\nIf the assign opcode is handling morphing, then this is all I'm\nwanting assign_pmc_keyed to do in any case -- namespaces or otherwise.  :-)\n\n> The best default is the simplest default (only provide set), and \n> languages that want more can subclass the namespace PMC.\n\nI think it's important that we have some vtable-based way to\ndistinguish binding from assignment.  The C< set > opcode only\ngives us binding.\n\n> >Also, we get a win because we can get the namespace just\n> >once at the beginning of any sub that needs it, instead of\n> >a separate find_global/test existence/store_global for\n> >each assignment operation:\n> >\n> >  ## our $x, $y, $z; $x = foo(); $y = bar(); $z = baz();\n> \n> You can do this anyway, you don't need the special assign_keyed.\n> ...\n>     $P1 = 'foo'()\n>     $P2 = $P0['$x']\n>     assign $P2, $P1\n> \n> etc.\n\nAgain, I can only do this if the all of the data types going to\nthe C< assign > opcode understand the \"change your type\" semantic.\nIf we have that, then things are indeed a lot simpler.\n\nBut as things stand now, many of Parrot's built in types (including\nSubs and almost all the aggregates), don't know how to do this.\nThat means that we have to come up with Perl6-specific types for\neverything in order to overload the assign opcode.  And I'm really\nnot sure how to create a Perl6Sub from PIR source code.\n\nPm\n\n"}
{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Jonathan Worthington <jonathan@jnthn.net>", "subject": "Re: [perl #42547] [PATCH] fix segfault by implementing init() in\n Object.pmc", "body": "Alek Storm (via RT) wrote:\n> The following code causes a segfault:\n> .sub main :main\n>   $P0 = new \"Object\"\n>   $P0.'foo'()\n> .end\n>\n> This is because the vtable methods in Object assume a valid pointer to\n> the object's internal representation, which is only initialized in\n> init_pmc.\nThat probably has to change too, otherwise people can do:\n\nobj = new Object, class\n\nWhich is bad, because class.new() never gets called in the process and \n(provided it hasn't been instantiated before) you don't end up with a \nvalid class (nor one with the instantiated flag set), so it'll only \ncause breakage further down the line.\n\n> I've attached two patches solving the problem by implementing init(), the first of which creates an empty, anonymous Class for the Object; the second throws an exception when init() is called.  I prefer the former, because it follows the programmer's instinct of what should happen: a completely empty Object is created.\n>   \nThe second was what I had in mind; the patch to do the first of these \nisn't going to work out too well (for the reasons I stated with init_pmc).\n\nWhat should happen: Class manufactures an object and init and init_pmc \nof Object both throw exceptions. That means creating a new Object PMC in \nthe new method of Class using pmc_new_noinit (IIRC) and setting up its \nguts from within Class.\n\nAs part of this, the structs, typedefs and macros for Parrot_Object and \nParrot_Class need to go in a header file pulled in by Class and Object \nPMCs (but *only* by those two - it's fine for Class and Object to know \nabout each others guts, but everything else should use the external \ninterface, so it can work with other, HLL specific classes and object).\n\nThanks,\n\nJonathan\n\n"}
{"category": "ham", "to_address": "\"Vahid Moghaddasi\" <vahid.moghaddasi@gmail.com>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: grep from one file and write to another", "body": "On 6/23/07, Vahid Moghaddasi  wrote:\n\n> I am trying to read a colon delimited text file (filter.in) then\n> search for each field in another file (/etc/passwd) and if it is found\n> then write that line in the third file (passwd.out).\n\n> use File::Copy;\n\nAre you actually using File::Copy? I didn't find any call to it in\nyour posted code.\n\n> use strict;\n> use warnings;\n\nThat's good....\n\n> $|=1;           # flush output buffer\n> open (FILTERfh, \"< filter.in\") || die \"Can not open filter.in: $!\\n\";\n> open PASSWDfh, ' open PASSWDFILfh, \">passwd.out\";\n\nI can't say that I like the style of having filehandle names ending in\n\"fh\", but it's one way to do it. But please standardize the way you\nopen files; I'd adopt a style most like the second one. By the way,\nthe \"output buffer\" that your comment refers to is the buffer for\nSTDOUT. Is somebody waiting for the output on STDOUT? You didn't\nmention that in the task description.\n\n> while () {\n> chomp;\n> my @input = split /:/, $_;\n>     for (my $user = 1; $user <= $#input ; $user++) {\n\nAlthough you may use the three-part for loop to do this, you'll be\nmore likely to get it correct if you use a range instead:\n\n    for my $user (0..$#input) {  # Not 1..$#input, is it?\n\nAnd, unless you needed an index, you'll be even more likely to get it\ncorrect if you use a foreach directly on the array:\n\n    for my $user (@input) {  # Now $user is the user, not the index\n\n>         print \"$input[$user] is being added.\\n\";\n>         while () {\n\nNow you're reading one file in a loop, inside the loop on FILTERfh. Do\nyou mean to re-read the password file for every line in the outer\nloop's file? That sounds slow, but you could do it. (You'll either\nneed to reopen the file, or use seek() to get back to the start.)\n\nA better algorithm would read through the entire FILTERfh datastream,\nstoring away what you'll need. Later, when you read the password file\nin a single pass, you can compare the data in memory to the data read\nfrom the file.\n\nDoes that get you closer to a solution? Good luck with it!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
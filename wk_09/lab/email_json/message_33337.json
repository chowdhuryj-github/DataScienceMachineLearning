{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Leopold Toetsch <lt@toetsch.at>", "subject": "Re: [perl #43006] Tail call force-frees current context", "body": "Am Sonntag, 20. Mai 2007 21:51 schrieb Bram Geron:\n> Bram Geron wrote:\n> > The patch in  fixes the problem for me.\n>\n> I realized that contexts currently initially have a ref_count of 0, if\n> they're not used as :outer targets for other subs. So in 'normal'\n> situations, the caller's context's ref_count now drops from 0 to -1 in a\n> tail call, and since -1 != 0 the caller's context will never be freed,\n> resulting in a memory leak. Attached \n> should fix that.\n\nIt's likely simpler to start all context refcounts equally with 1. This would \nprobably reduce the current special refcount handling. But it would need some \nchanges, which is easily greppable I presume.\n\n> Still, I'm left with a question. How can we DOD a closure? To me it\n> seems that once a closure exists, it references its context. Often the\n> context is still left in a register, so the context references the\n> closure PMC, which in turn references the closure. Because we use\n> reference counting in these cases, no count ever drops to zero, and they\n> all live forever.\n\nThink of (closure) contexts, which were created in \"eval\"-ed code. When the \nouter context ceases to exist, the inner context can be collected. All other \nclosure context is of course persistent.\n\nleo\n\n"}
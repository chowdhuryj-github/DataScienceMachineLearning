{"category": "ham", "to_address": "Jim McDonough <jmcd@samba.org>", "from_address": "Herb Lewis <hlewis@panasas.com>", "subject": "Re: winbindd 32/64 offset issues", "body": "maybe we could do something like bsd does in stat.h\n\nstruct timespec st_birthtimespec; /* time of file creation */\n/*\n  * Explicitly pad st_birthtimespec to 16 bytes so that the size of\n  * struct stat is backwards compatible.  We use bitfields instead\n  * of an array of chars so that this doesn't require a C99 compiler\n  * to compile if the size of the padding is 0.  We use 2 bitfields\n  * to cover up to 64 bits on 32-bit machines.  We assume that\n  * CHAR_BIT is 8...\n  */\nunsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));\nunsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));\n\n\nJim McDonough wrote:\n> Jerry,\n> Despite your comments about testing with 32bit libs on 64bit platforms in\n> the winbindd_request struct in winbindd_nss.h, it seems we're out of sync,\n> and the following comment may be part of the issue:\n> \n> nsswitch/winbindd_nss.h:40\n> -------\n> /* Have to deal with time_t being 4 or 8 bytes due to structure alignment.\n>   On a 64bit Linux box, we have to support a constant structure size\n>   between /lib/libnss_winbind.so.2 and /li64/libnss_winbind.so.2.\n>   The easiest way to do this is to always use 8byte values for time_t. */\n> ------\n> \n> I can say that I've recently found this to not be true.  On multiple\n> platforms (RHEL4 at a customer site, ubuntu Edgy on my laptop right now),\n> the stabs output shows the extra_data union (containing the SMB_TIME_T for\n> alignment) to start at 16544 bits offset, which is 2068 bytes..._not_ a\n> multiple of 8.  This is on 3.0.25...on 3.0.26 there is an extra enum \n> earlier\n> that hides this problem, I think.  I tried several approaches, but there is\n> simply not a guarantee on a 32-bit platform that anything I tried is going\n> to be aligned on an 8-byte boundary.\n> \n> The only solution I found was the old method that hasn't been updated in \n> the\n> code in a while...the padding member of the huge data union needs to be set\n> to that 8-byte boundary, and still, since that data union isn't guaranteed\n> to be on an 8-byte boundary to start, we have to really just look at the\n> offset in stabs output and see if each union lines up between \n> architectures.\n> \n> Or we could just start up that marshalling discussion again :-)\n> \n> In any case, before I check anything in, can someone run any quick tests of\n> your various binaries on 64-bit platforms using 32-bit winbind libs?\n> \n\n"}
{"category": "ham", "to_address": "\"Deepayan Sarkar\" <deepayan.sarkar@gmail.com>", "from_address": "\"Waichler, Scott R\" <Scott.Waichler@pnl.gov>", "subject": "Re: [R] levelplot and unequal cell sizes", "body": "> You are right, panel.levelplot is indeed assuming that the \n> boundaries are between consecutive midpoints. There is no \n> built in way around that; there simply isn't enough \n> information available to the panel function.\n> \n> The cleanest solution, in principle, is to write your own \n> panel function that ends up calling panel.polygon or grid.polygon.\n> panel.levelplot is a good starting point (the only tricky \n> part is getting the colors right, almost everything else you \n> can get rid of).\n> Maybe Hadley will have a simpler solution.\n> \n> Here's a possible implementation using a panel function:\n> \n> \n> my.panel.levelplot <-\n>     function (x, y, z, subscripts, at = pretty(z),\n>               col.regions = regions$col, ...,\n>               w, h)\n> {\n>     regions <- trellis.par.get(\"regions\")\n>     numcol <- length(at) - 1\n>     numcol.r <- length(col.regions)\n>     col.regions <- if (numcol.r <= numcol)\n>         rep(col.regions, length = numcol)\n>     else col.regions[floor(1+(1:numcol-1) * (numcol.r-1)/(numcol-1))]\n>     zcol <- findInterval(z, at, rightmost.closed = TRUE)\n>     x <- as.numeric(x[subscripts])\n>     y <- as.numeric(y[subscripts])\n>     z <- as.numeric(z[subscripts])\n>     w <- as.numeric(w[subscripts])\n>     h <- as.numeric(h[subscripts])\n>     zcol <- as.numeric(zcol[subscripts])\n>     print(data.frame(z, x.node, y.node, w.node, h.node, \n> col.regions[zcol]))\n>     panel.rect(x = x, y = y, width = w, height = h,\n>                col = col.regions[zcol], ...) }\n\nDeepayan, thanks so much for this solution.  It's great for my needs and\nwill allow me to keep using my existing lattice \"infrastructure.\"  I\nnever would have arrived at using findInterval() and panel.rect() on my\nown.  Users might find my slight modification below for handling NA\nvalues useful.  It also hides the cell borders:\n\n\nPANEL.LEVELPLOT1 <-\n    function (x, y, z, subscripts, at = pretty(z),\n              col.regions = regions$col, ...,\n              w, h) {\n    regions <- trellis.par.get(\"regions\")\n    numcol <- length(at) - 1\n    numcol.r <- length(col.regions)\n    col.regions <- if (numcol.r <= numcol)\n        rep(col.regions, length = numcol)\n    else col.regions[floor(1+(1:numcol-1) * (numcol.r-1)/(numcol-1))]\n    zcol <- findInterval(z, at, rightmost.closed = TRUE)\n    x <- as.numeric(x[subscripts])\n    y <- as.numeric(y[subscripts])\n    z <- as.numeric(z[subscripts])\n    w <- as.numeric(w[subscripts])\n    h <- as.numeric(h[subscripts])\n    zcol <- as.numeric(zcol[subscripts])\n    these.colors <- ifelse(!is.na(zcol), col.regions[zcol],\n\"transparent\")  # my addition  :)\n#    print(data.frame(z.vec, x.vec, y.vec, w.vec, h.vec, these.colors))\n    panel.rect(x = x, y = y, width = w, height = h,\n               col = these.colors, border=NA,...)\n}  # end PANEL.LEVELPLOT1()\n\nRegards,\nScott Waichler\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
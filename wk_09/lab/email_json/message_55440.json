{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "gd@samba.org", "subject": "svn commit: samba r23609 - in branches: SAMBA_3_0/source/libsmb\n\tSAMBA_3_0_26/source/libsmb", "body": "Author: gd\nDate: 2007-06-26 10:19:06 +0000 (Tue, 26 Jun 2007)\nNew Revision: 23609\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23609\n\nLog:\nRemoving more redundant codepaths out of smb_krb5_renew_ticket(). \n\nThanks Volker for the pointer hint :)\n\nGuenther\n\nModified:\n   branches/SAMBA_3_0/source/libsmb/clikrb5.c\n   branches/SAMBA_3_0_26/source/libsmb/clikrb5.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/libsmb/clikrb5.c\n===================================================================\n--- branches/SAMBA_3_0/source/libsmb/clikrb5.c\t2007-06-26 09:41:14 UTC (rev 23608)\n+++ branches/SAMBA_3_0/source/libsmb/clikrb5.c\t2007-06-26 10:19:06 UTC (rev 23609)\n@@ -1140,7 +1140,11 @@\n \tkrb5_context context = NULL;\n \tkrb5_ccache ccache = NULL;\n \tkrb5_principal client = NULL;\n+\tkrb5_creds creds, creds_in, *creds_out = NULL;\n \n+\tZERO_STRUCT(creds);\n+\tZERO_STRUCT(creds_in);\n+\n \tinitialize_krb5_error_table();\n \tret = krb5_init_context(&context);\n \tif (ret) {\n@@ -1178,39 +1182,17 @@\n \n #ifdef HAVE_KRB5_GET_RENEWED_CREDS\t/* MIT */\n \t{\n-\t\tkrb5_creds creds;\n-\n-\t\tZERO_STRUCT(creds);\n-\n \t\tret = krb5_get_renewed_creds(context, &creds, client, ccache, CONST_DISCARD(char *, service_string));\n \t\tif (ret) {\n \t\t\tDEBUG(10,(\"smb_krb5_renew_ticket: krb5_get_kdc_cred failed: %s\\n\", error_message(ret)));\n \t\t\tgoto done;\n \t\t}\n-\n-\t\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n-\t\tret = krb5_cc_initialize(context, ccache, client);\n-\t\tif (ret) {\n-\t\t\tgoto done;\n-\t\t}\n-\t\n-\t\tret = krb5_cc_store_cred(context, ccache, &creds);\n-\n-\t\tif (expire_time) {\n-\t\t\t*expire_time = (time_t) creds.times.endtime;\n-\t\t}\n-\n-\t\tkrb5_free_cred_contents(context, &creds);\n \t}\n #elif defined(HAVE_KRB5_GET_KDC_CRED)\t/* Heimdal */\n \t{\n \t\tkrb5_kdc_flags flags;\n-\t\tkrb5_creds creds_in;\n-\t\tkrb5_realm *client_realm;\n-\t\tkrb5_creds *creds;\n+\t\tkrb5_realm *client_realm = NULL;\n \n-\t\tZERO_STRUCT(creds_in);\n-\n \t\tret = krb5_copy_principal(context, client, &creds_in.client);\n \t\tif (ret) {\n \t\t\tgoto done;\n@@ -1237,33 +1219,39 @@\n \t\tflags.i = 0;\n \t\tflags.b.renewable = flags.b.renew = True;\n \n-\t\tret = krb5_get_kdc_cred(context, ccache, flags, NULL, NULL, &creds_in, &creds);\n+\t\tret = krb5_get_kdc_cred(context, ccache, flags, NULL, NULL, &creds_in, &creds_out);\n \t\tif (ret) {\n \t\t\tDEBUG(10,(\"smb_krb5_renew_ticket: krb5_get_kdc_cred failed: %s\\n\", error_message(ret)));\n \t\t\tgoto done;\n \t\t}\n-\t\t\n-\t\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n-\t\tret = krb5_cc_initialize(context, ccache, creds_in.client);\n-\t\tif (ret) {\n-\t\t\tgoto done;\n-\t\t}\n-\t\n-\t\tret = krb5_cc_store_cred(context, ccache, creds);\n \n-\t\tif (expire_time) {\n-\t\t\t*expire_time = (time_t) creds->times.endtime;\n-\t\t}\n-\t\t\t\t\t\t\n-\t\tkrb5_free_cred_contents(context, &creds_in);\n-\t\tkrb5_free_creds(context, creds);\n+\t\tcreds = *creds_out;\n \t}\n #else\n #error NO_SUITABLE_KRB5_TICKET_RENEW_FUNCTION_AVAILABLE\n #endif\n \n+\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n+\tret = krb5_cc_initialize(context, ccache, client);\n+\tif (ret) {\n+\t\tgoto done;\n+\t}\n+\t\n+\tret = krb5_cc_store_cred(context, ccache, &creds);\n \n+\tif (expire_time) {\n+\t\t*expire_time = (time_t) creds.times.endtime;\n+\t}\n+\n done:\n+\tkrb5_free_cred_contents(context, &creds_in);\n+\n+\tif (creds_out) {\n+\t\tkrb5_free_creds(context, creds_out);\n+\t} else {\n+\t\tkrb5_free_cred_contents(context, &creds);\n+\t}\n+\n \tif (client) {\n \t\tkrb5_free_principal(context, client);\n \t}\n\nModified: branches/SAMBA_3_0_26/source/libsmb/clikrb5.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/libsmb/clikrb5.c\t2007-06-26 09:41:14 UTC (rev 23608)\n+++ branches/SAMBA_3_0_26/source/libsmb/clikrb5.c\t2007-06-26 10:19:06 UTC (rev 23609)\n@@ -1140,7 +1140,11 @@\n \tkrb5_context context = NULL;\n \tkrb5_ccache ccache = NULL;\n \tkrb5_principal client = NULL;\n+\tkrb5_creds creds, creds_in, *creds_out = NULL;\n \n+\tZERO_STRUCT(creds);\n+\tZERO_STRUCT(creds_in);\n+\n \tinitialize_krb5_error_table();\n \tret = krb5_init_context(&context);\n \tif (ret) {\n@@ -1178,39 +1182,17 @@\n \n #ifdef HAVE_KRB5_GET_RENEWED_CREDS\t/* MIT */\n \t{\n-\t\tkrb5_creds creds;\n-\n-\t\tZERO_STRUCT(creds);\n-\n \t\tret = krb5_get_renewed_creds(context, &creds, client, ccache, CONST_DISCARD(char *, service_string));\n \t\tif (ret) {\n \t\t\tDEBUG(10,(\"smb_krb5_renew_ticket: krb5_get_kdc_cred failed: %s\\n\", error_message(ret)));\n \t\t\tgoto done;\n \t\t}\n-\n-\t\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n-\t\tret = krb5_cc_initialize(context, ccache, client);\n-\t\tif (ret) {\n-\t\t\tgoto done;\n-\t\t}\n-\t\n-\t\tret = krb5_cc_store_cred(context, ccache, &creds);\n-\n-\t\tif (expire_time) {\n-\t\t\t*expire_time = (time_t) creds.times.endtime;\n-\t\t}\n-\n-\t\tkrb5_free_cred_contents(context, &creds);\n \t}\n #elif defined(HAVE_KRB5_GET_KDC_CRED)\t/* Heimdal */\n \t{\n \t\tkrb5_kdc_flags flags;\n-\t\tkrb5_creds creds_in;\n-\t\tkrb5_realm *client_realm;\n-\t\tkrb5_creds *creds;\n+\t\tkrb5_realm *client_realm = NULL;\n \n-\t\tZERO_STRUCT(creds_in);\n-\n \t\tret = krb5_copy_principal(context, client, &creds_in.client);\n \t\tif (ret) {\n \t\t\tgoto done;\n@@ -1237,33 +1219,39 @@\n \t\tflags.i = 0;\n \t\tflags.b.renewable = flags.b.renew = True;\n \n-\t\tret = krb5_get_kdc_cred(context, ccache, flags, NULL, NULL, &creds_in, &creds);\n+\t\tret = krb5_get_kdc_cred(context, ccache, flags, NULL, NULL, &creds_in, &creds_out);\n \t\tif (ret) {\n \t\t\tDEBUG(10,(\"smb_krb5_renew_ticket: krb5_get_kdc_cred failed: %s\\n\", error_message(ret)));\n \t\t\tgoto done;\n \t\t}\n-\t\t\n-\t\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n-\t\tret = krb5_cc_initialize(context, ccache, creds_in.client);\n-\t\tif (ret) {\n-\t\t\tgoto done;\n-\t\t}\n-\t\n-\t\tret = krb5_cc_store_cred(context, ccache, creds);\n \n-\t\tif (expire_time) {\n-\t\t\t*expire_time = (time_t) creds->times.endtime;\n-\t\t}\n-\t\t\t\t\t\t\n-\t\tkrb5_free_cred_contents(context, &creds_in);\n-\t\tkrb5_free_creds(context, creds);\n+\t\tcreds = *creds_out;\n \t}\n #else\n #error NO_SUITABLE_KRB5_TICKET_RENEW_FUNCTION_AVAILABLE\n #endif\n \n+\t/* hm, doesn't that create a new one if the old one wasn't there? - Guenther */\n+\tret = krb5_cc_initialize(context, ccache, client);\n+\tif (ret) {\n+\t\tgoto done;\n+\t}\n+\t\n+\tret = krb5_cc_store_cred(context, ccache, &creds);\n \n+\tif (expire_time) {\n+\t\t*expire_time = (time_t) creds.times.endtime;\n+\t}\n+\n done:\n+\tkrb5_free_cred_contents(context, &creds_in);\n+\n+\tif (creds_out) {\n+\t\tkrb5_free_creds(context, creds_out);\n+\t} else {\n+\t\tkrb5_free_cred_contents(context, &creds);\n+\t}\n+\n \tif (client) {\n \t\tkrb5_free_principal(context, client);\n \t}\n\n"}
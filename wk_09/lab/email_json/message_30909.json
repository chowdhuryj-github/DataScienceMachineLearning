{"category": "ham", "to_address": "Rob Dixon <rob.dixon@350.com>", "from_address": "Mathew <theillien@yahoo.com>", "subject": "Re: Can't sort error out; strict refs", "body": "\n\nRob Dixon wrote:\n> Mathew Snyder wrote:\n>>\n>> I'm passing two hash references into a subroutine.  One hash is in the\n>> format of\n>> $dept{$env}{$user}.  This contains an amount of time spent by each\n>> user on a\n>> customer ($env).  The second hash is in the format of\n>> $ticCount{$env}{$user}{$ticID}.  This contains a running count of how\n>> many times\n>> a user worked on ticket '$ticID' which belongs to customer '$env'.  I\n>> won't be\n>> using that number though.  What I need is the number of tickets worked\n>> on so I\n>> simply use 'scalar keys' on this hash.\n>>\n>> The problem I'm encountering though, is that I'm passing the hashes\n>> into my\n>> subroutine as references.  When I get to the statement that gets the\n>> key count I\n>> get an error: \"Can't use string (\"2\") as a HASH ref while \"strict\n>> refs\" in use\n>> at user_timesheet.pl line 63.\"  Presumably, 2 is the number of keys at\n>> $ticCount{$env}{$user}{$ticID}.\n>>\n>> sub average {\n>>\n>>   my ($users, $count) = @_;\n>>   my %userAvg;\n>>\n>>   foreach my $env (keys %$count) {\n>>     foreach my $user (keys %{ $count->{$env} }) {\n>>       foreach my $ticID (keys %{ $count->{$env}->{$user} }) {\n>>\n>>         my $ticCount = scalar keys %{$count->{$env}->{$user}->{$ticID}};\n>>\n>>         my @meantemp;\n>>         my @meantime;\n>>         my @endtime;\n>>\n>>         my $temp     = $users->{$env}->{$user};\n>>         @meantemp    = split /\\./, ($temp / $ticCount);\n>>\n>>         # If the time divided by the number of tickets has a decimal\n>>         # value round up if that value is greater than\n>>         # 0.5.  This will give an even number of minutes to figure\n>>         # out the mean time with.\n>>         if ($meantemp[1]) {\n>>           if ($meantemp[1] >= 5) {\n>>             $meantemp[0]++;\n>>           }\n>>         }\n>>         @meantime  = split /\\./, ($meantemp[0] / 60);\n>>         $endtime[0]  = $meantime[0];\n>>         $endtime[1]  = $meantemp[0] % 60;\n>>         $userAvg{$env}{$user} = sprintf '%d:%02d', @endtime[0,1];\n>>       }\n>>     }\n>>   }\n>>\n>>   return %userAvg;\n>> }\n>>\n>> I've run this in the debugger and when I get to the line which assigns\n>> $ticCount\n>> I try to print it out and it's just blank.  If I keep hitting enter it\n>> just\n>> returns to a blank line.  I get the error when I continue to the next\n>> line with 'c'.\n> \n> Hi Mathew\n> \n> First of all, you can replace\n> \n>  $count->{$env}->{$user}->{$ticID}\n> \n> with\n> \n>  $count->{$env}{$user}{$ticID}\n> \n> and Perl will infer the indirection. It makes for neater code.\n> \n> The reason for your problem is that you've gone too far down in the hash\n> structure. You\n> said that $count->{$env}{$user}{$ticID} is a \"count of how many times a\n> user worked on\n> [a] ticket\", in this case 2. so you're then trying to do\n> \n>  my $ticCount = scalar keys %{2};\n> \n> which is failing.\n> \n> Finally, you can round more efficiently by using int(x + 0.5). I suggest\n> something\n> like this (untested):\n> \n>  sub average {\n> \n>    my ($users, $count) = @_;\n>    my %userAvg;\n> \n>    foreach my $env (keys %$count) {\n>      foreach my $user (keys %{ $count->{$env} }) {\n> \n>          my $ticCount = scalar keys %{$count->{$env}{$user}};\n> \n>          my $time = $users->{$env}{$user};\n>          my $meantime = int($time / $ticCount + 0.5);\n> \n>          $userAvg{$env}{$user} = sprintf '%d:%02d',\n>              int($meantime / 60), $meantime % 60;\n>      }\n>    }\n> \n>    return %userAvg;\n>  }\n> \n> HTH,\n> \n> Rob\n> \n\nThanks.  That did the trick.  I'll be working with your provided method\nfor rounding up tonight when I get to work.\n\nMathew\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
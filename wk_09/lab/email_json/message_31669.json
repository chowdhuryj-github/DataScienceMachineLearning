{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>, p2 <parrot-porters@perl.org>", "from_address": "\"jerry gay\" <jerry.gay@gmail.com>", "subject": "r18572 - trunk/compilers/imcc", "body": "this revision breaks parrot on msvc (and i suspect other c89-compliant\ncompilers--sometimes i wonder if there are any others!)\n\nin particular, in the following chunk (snipped from overall patch for\nbrevity) the UNUSED(foo) macro is used before variables are declared\nin the body of the find_outer() function. fixing that (by moving\nC below the declarations leads to problems with\nanother chunk, which i describe after this one.\n\nModified: trunk/compilers/imcc/pbc.c\n==============================================================================\n--- trunk/compilers/imcc/pbc.c  (original)\n+++ trunk/compilers/imcc/pbc.c  Wed May 16 13:58:40 2007\n @@ -565,71 +600,87 @@\n                     lex_info = pmc_new_noinit(interp, lex_info_id);\n                     VTABLE_init_pmc(interp, lex_info, sub);\n                 }\n+\n+                /* at least one lexical name */\n                 n = r->reg;\n-                assert(n); /* at least one lexical name */\n+                assert(n);\n+\n                 while (n) {\n                     k = n->color;\n                     assert(k >= 0);\n+\n                     lex_name = constants[k]->u.string;\n                     assert(PObj_is_string_TEST(lex_name));\n+\n                     IMCC_debug(interp, DEBUG_PBC_CONST,\n                             \"add lexical '%s' to sub name '%s'\\n\",\n                             n->name, (char*)PMC_sub(sub)->name->strstart);\n-                    (decl_func)(interp,\n-                                lex_info, lex_name, r->color);\n+\n+                    (decl_func)(interp, lex_info, lex_name, r->color);\n+\n                     /* next possible name */\n                     n = n->reg;\n                 }\n             }\n         }\n     }\n+\n     if (!lex_info && (unit->outer || need_lex)) {\n         lex_info = pmc_new_noinit(interp, lex_info_id);\n         VTABLE_init_pmc(interp, lex_info, sub);\n     }\n+\n     return lex_info;\n }\n\n static PMC*\n find_outer(Interp *interp, IMC_Unit *unit)\n {\n-    struct subs *s;\n+    UNUSED(interp);\n+\n+    subs_t *s;\n     SymReg *sub;\n-    size_t len;\n-    PMC *current;\n+    size_t  len;\n+    PMC    *current;\n     STRING *cur_name;\n\n     if (!unit->outer)\n         return NULL;\n+\n     /*\n      * we need that the :outer sub is already compiled,\n      * because we are freezing the outer Sub PMC along with this\n      * one\n      */\n-    UNUSED(interp);\n+\n     len = strlen(unit->outer->name);\n+\n     if (!len)\n         return NULL;\n+\n     for (s = globals.cs->first; s; s = s->next) {\n         sub = s->unit->instructions->r[0];\n+\n         if (!strcmp(sub->name, unit->outer->name)) {\n             PObj_get_FLAGS(s->unit->sub_pmc) |= SUB_FLAG_IS_OUTER;\n             return s->unit->sub_pmc;\n         }\n     }\n-    /*\n-     * could be eval too - look, if :outer is the currentsub\n-     */\n+\n+    /* could be eval too; check if :outer is the current sub */\n     current = CONTEXT(interp->ctx)->current_sub;\n+\n     if (! current)\n         IMCC_fatal(interp, 1,\n                    \"Undefined :outer sub '%s'.\\n\",\n                    unit->outer->name);\n+\n     cur_name = PMC_sub(current)->name;\n+\n     if (cur_name->strlen == len &&\n-            !memcmp((char*)cur_name->strstart, unit->outer->name, len)) {\n+            !memcmp((char*)cur_name->strstart, unit->outer->name, len))\n         return current;\n-    }\n+\n     return NULL;\n }\n\n\n\nthe chunk below causes msvc to output the following:\n\ncompilers\\imcc\\pbc.c\ncompilers\\imcc\\pbc.c(921) : error C2275: 'SymReg' : illegal use of this type as\nan expression\n        d:\\usr\\local\\parrot\\head\\compilers\\imcc\\symreg.h(80) : see declaration o\nf 'SymReg'\ncompilers\\imcc\\pbc.c(921) : error C2065: 'reg' : undeclared identifier\ncompilers\\imcc\\pbc.c(923) : error C2223: left of '->nextkey' must point to struc\nt/union\ncompilers\\imcc\\pbc.c(927) : warning C4047: '=' : 'SymReg *' differs in levels of\n indirection from 'int'\nNMAKE : fatal error U1077: 'D:\\usr\\local\\perl\\bin\\perl.exe' : return code '0x2'\nStop.\n\ni've tried various things to get this to work, but i can't find the\nmagic incantation.\n\n @@ -834,47 +898,57 @@\n build_key(Interp *interp, SymReg *key_reg)\n {\n #define KEYLEN 21\n-    opcode_t key[KEYLEN], *pc, size;\n-    char s_key[KEYLEN*10];\n-    int key_length;     /* P0[\"hi;there\"; S0; 2] has length 3 */\n-    char *s;\n-    int k;\n-    SymReg *r, *reg;\n-    int var_type, slice_bits, type;\n-\n-    pc = key + 1;       /* 0 is length */\n-    s = s_key;          /* stringified key */\n-    *s = 0;\n-    reg = key_reg->set == 'K' ? key_reg->nextkey : key_reg;\n+    char      s_key[KEYLEN * 10];\n+    opcode_t  key[KEYLEN];\n+    opcode_t  size;\n+    int       key_length;     /* P0[\"hi;there\"; S0; 2] has length 3 */\n+    int       k;\n+    SymReg   *r;\n+    int       var_type, slice_bits, type;\n+\n+    /* 0 is length */\n+    opcode_t *pc = key + 1;\n+\n+    /* stringified key */\n+    char     *s  = s_key;\n+    *s           = 0;\n+\n+    SymReg *reg  = key_reg->set == 'K' ? key_reg->nextkey : key_reg;\n\n     for (key_length = 0; reg ; reg = reg->nextkey, key_length++) {\n         if ((pc - key - 2) >= KEYLEN)\n             IMCC_fatal(interp, 1, \"build_key:\"\n                     \"key too complex increase KEYLEN\\n\");\n         r = reg;\n+\n         /* if key is a register, the original sym is in r->reg */\n         type = r->type;\n+\n         if (r->reg)\n             r = r->reg;\n-        var_type = type & ~VT_SLICE_BITS;\n-        slice_bits = type & VT_SLICE_BITS;\n+\n+        var_type   = type & ~VT_SLICE_BITS;\n+        slice_bits = type &  VT_SLICE_BITS;\n+\n         switch (var_type) {\n             case VTIDENTIFIER:       /* P[S0] */\n-            case VTPASM:       /* P[S0] */\n-            case VTREG:        /* P[S0] */\n+            case VTPASM:             /* P[S0] */\n+            case VTREG:              /* P[S0] */\n                 if (r->set == 'I')\n                     *pc++ = PARROT_ARG_I | slice_bits;    /* register type */\n                 else if (r->set == 'S')\n                     *pc++ = PARROT_ARG_S | slice_bits;\n                 else\n-                    IMCC_fatal(interp, 1, \"build_key: \"\n-                            \"wrong register set\\n\");\n+                    IMCC_fatal(interp, 1, \"build_key: wrong register set\\n\");\n+\n                 /* don't emit mapped regs in key parts */\n                 if (r->color < 0)\n                     *pc++ = -1 - r->color;\n                 else\n                     *pc++ = r->color;\n+\n                 sprintf(s+strlen(s), \"%c%d\", r->set, (int)r->color);\n+\n                 IMCC_debug(interp, DEBUG_PBC_CONST,\n                         \" keypart reg %s %c%d slice %s\\n\",\n                         r->name, r->set, (int)r->color,\n\n\nthis situation is *extremely* frustrating. the temporary workaround is\nto revert this patch until it works everywhere. the solution is to\nfind a way to make gcc (and other) compilers comply with our most\nimportant coding standard: C89 compliance.\n\ni have all too often experienced broken builds because somebody has\ncommitted non-C89 code. i'm tired of being punished for having a\nstrict compiler. gcc has flags for this--let's use them!\n\ni'll happily pitch in to the extent that i'm able, but i can't be\nresponsible for the whole effort. we need the whole team to focus on\nthis problem, so we can finally resolve this long-standing issue.\n~jerry\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "svn commit: samba r23056 - in\n\tbranches/SAMBA_4_0/source/torture/raw: .", "body": "Author: tridge\nDate: 2007-05-21 23:33:26 +0000 (Mon, 21 May 2007)\nNew Revision: 23056\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23056\n\nLog:\n\nadded automatic reconnect to RAW-BENCH-OPEN, similar to RAW-BENCH-LOCK\n\nModified:\n   branches/SAMBA_4_0/source/torture/raw/openbench.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/torture/raw/openbench.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/openbench.c\t2007-05-21 22:17:13 UTC (rev 23055)\n+++ branches/SAMBA_4_0/source/torture/raw/openbench.c\t2007-05-21 23:33:26 UTC (rev 23056)\n@@ -29,6 +29,8 @@\n #include \"torture/util.h\"\n #include \"lib/events/events.h\"\n #include \"lib/cmdline/popt_common.h\"\n+#include \"libcli/composite/composite.h\"\n+#include \"libcli/smb_composite/smb_composite.h\"\n \n #define BASEDIR \"\\\\benchopen\"\n \n@@ -36,19 +38,108 @@\n static int open_failed;\n static int open_retries;\n static char **fnames;\n+static int num_connected;\n \n struct benchopen_state {\n+\tTALLOC_CTX *mem_ctx;\n+\tstruct event_context *ev;\n \tstruct smbcli_state *cli;\n+\tstruct smbcli_tree *tree;\n+\tint client_num;\n \tint fnum;\n \tint file_num;\n \tint count;\n+\tint lastcount;\n \tBOOL waiting_open, waiting_close;\n \tunion smb_open open_parms;\n \tunion smb_close close_parms;\n \tstruct smbcli_request *req_open;\n \tstruct smbcli_request *req_close;\n+\tstruct smb_composite_connect reconnect;\n+\n+\t/* these are used for reconnections */\n+\tint dest_port;\n+\tconst char *dest_host;\n+\tconst char *called_name;\n+\tconst char *service_type;\n };\n \n+static void next_open(struct benchopen_state *state);\n+static void reopen_connection(struct event_context *ev, struct timed_event *te, \n+\t\t\t      struct timeval t, void *private_data);\n+\n+\n+/*\n+  complete an async reconnect\n+ */\n+static void reopen_connection_complete(struct composite_context *ctx)\n+{\n+\tstruct benchopen_state *state = (struct benchopen_state *)ctx->async.private_data;\n+\tNTSTATUS status;\n+\tstruct smb_composite_connect *io = &state->reconnect;\n+\n+\tstatus = smb_composite_connect_recv(ctx, state->mem_ctx);\n+\tif (!NT_STATUS_IS_OK(status)) {\n+\t\tevent_add_timed(state->ev, state->mem_ctx, \n+\t\t\t\ttimeval_current_ofs(1,0), \n+\t\t\t\treopen_connection, state);\n+\t\treturn;\n+\t}\n+\n+\tstate->tree = io->out.tree;\n+\n+\tnum_connected++;\n+\n+\tDEBUG(0,(\"reconnect to %s finished (%u connected)\\n\", state->dest_host,\n+\t\t num_connected));\n+\n+\tnext_open(state);\n+}\n+\n+\t\n+\n+/*\n+  reopen a connection\n+ */\n+static void reopen_connection(struct event_context *ev, struct timed_event *te, \n+\t\t\t      struct timeval t, void *private_data)\n+{\n+\tstruct benchopen_state *state = (struct benchopen_state *)private_data;\n+\tstruct composite_context *ctx;\n+\tstruct smb_composite_connect *io = &state->reconnect;\n+\tchar *host, *share;\n+\n+\tif (!torture_get_conn_index(state->client_num, state->mem_ctx, &host, &share)) {\n+\t\tDEBUG(0,(\"Can't find host/share for reconnect?!\\n\"));\n+\t\texit(1);\n+\t}\n+\n+\tio->in.dest_host    = state->dest_host;\n+\tio->in.port         = state->dest_port;\n+\tio->in.called_name  = state->called_name;\n+\tio->in.service      = share;\n+\tio->in.service_type = state->service_type;\n+\tio->in.credentials  = cmdline_credentials;\n+\tio->in.fallback_to_anonymous = False;\n+\tio->in.workgroup    = lp_workgroup();\n+\n+\t/* kill off the remnants of the old connection */\n+\ttalloc_free(state->tree);\n+\tstate->tree = NULL;\n+\tstate->fnum = -1;\n+\tstate->waiting_open = False;\n+\tstate->waiting_close = False;\n+\n+\tctx = smb_composite_connect_send(io, state->mem_ctx, state->ev);\n+\tif (ctx == NULL) {\n+\t\tDEBUG(0,(\"Failed to setup async reconnect\\n\"));\n+\t\texit(1);\n+\t}\n+\n+\tctx->async.fn = reopen_connection_complete;\n+\tctx->async.private_data = state;\n+}\n+\n static void open_completed(struct smbcli_request *req);\n static void close_completed(struct smbcli_request *req);\n \n@@ -71,7 +162,7 @@\n \tstate->open_parms.ntcreatex.in.security_flags = 0;\n \tstate->open_parms.ntcreatex.in.fname = fnames[state->file_num];\n \n-\tstate->req_open = smb_raw_open_send(state->cli->tree, &state->open_parms);\n+\tstate->req_open = smb_raw_open_send(state->tree, &state->open_parms);\n \tstate->req_open->async.fn = open_completed;\n \tstate->req_open->async.private = state;\n \tstate->waiting_open = True;\n@@ -84,7 +175,7 @@\n \tstate->close_parms.close.in.file.fnum = state->fnum;\n \tstate->close_parms.close.in.write_time = 0;\n \n-\tstate->req_close = smb_raw_close_send(state->cli->tree, &state->close_parms);\n+\tstate->req_close = smb_raw_close_send(state->tree, &state->close_parms);\n \tstate->req_close->async.fn = close_completed;\n \tstate->req_close->async.private = state;\n \tstate->waiting_close = True;\n@@ -96,7 +187,7 @@\n static void open_completed(struct smbcli_request *req)\n {\n \tstruct benchopen_state *state = (struct benchopen_state *)req->async.private;\n-\tTALLOC_CTX *tmp_ctx = talloc_new(state->cli);\n+\tTALLOC_CTX *tmp_ctx = talloc_new(state->mem_ctx);\n \tNTSTATUS status;\n \n \tstatus = smb_raw_open_recv(req, tmp_ctx, &state->open_parms);\n@@ -105,9 +196,23 @@\n \n \tstate->req_open = NULL;\n \n+\tif (NT_STATUS_EQUAL(status, NT_STATUS_END_OF_FILE) ||\n+\t    NT_STATUS_EQUAL(status, NT_STATUS_LOCAL_DISCONNECT)) {\n+\t\ttalloc_free(state->tree);\n+\t\ttalloc_free(state->cli);\n+\t\tstate->tree = NULL;\n+\t\tstate->cli = NULL;\n+\t\tnum_connected--;\t\n+\t\tDEBUG(0,(\"reopening connection to %s\\n\", state->dest_host));\n+\t\tevent_add_timed(state->ev, state->mem_ctx, \n+\t\t\t\ttimeval_current_ofs(1,0), \n+\t\t\t\treopen_connection, state);\n+\t\treturn;\n+\t}\n+\n \tif (NT_STATUS_EQUAL(status, NT_STATUS_SHARING_VIOLATION)) {\n \t\topen_retries++;\n-\t\tstate->req_open = smb_raw_open_send(state->cli->tree, &state->open_parms);\n+\t\tstate->req_open = smb_raw_open_send(state->tree, &state->open_parms);\n \t\tstate->req_open->async.fn = open_completed;\n \t\tstate->req_open->async.private = state;\n \t\treturn;\n@@ -137,6 +242,20 @@\n \n \tstate->req_close = NULL;\n \n+\tif (NT_STATUS_EQUAL(status, NT_STATUS_END_OF_FILE) ||\n+\t    NT_STATUS_EQUAL(status, NT_STATUS_LOCAL_DISCONNECT)) {\n+\t\ttalloc_free(state->tree);\n+\t\ttalloc_free(state->cli);\n+\t\tstate->tree = NULL;\n+\t\tstate->cli = NULL;\n+\t\tnum_connected--;\t\n+\t\tDEBUG(0,(\"reopening connection to %s\\n\", state->dest_host));\n+\t\tevent_add_timed(state->ev, state->mem_ctx, \n+\t\t\t\ttimeval_current_ofs(1,0), \n+\t\t\t\treopen_connection, state);\n+\t\treturn;\n+\t}\n+\n \tif (!NT_STATUS_IS_OK(status)) {\n \t\topen_failed++;\n \t\tDEBUG(0,(\"close failed - %s\\n\", nt_errstr(status)));\n@@ -150,6 +269,22 @@\n \t}\n }\t\n \n+\n+static void report_rate(struct event_context *ev, struct timed_event *te, \n+\t\t\tstruct timeval t, void *private_data)\n+{\n+\tstruct benchopen_state *state = talloc_get_type(private_data, \n+\t\t\t\t\t\t\tstruct benchopen_state);\n+\tint i;\n+\tfor (i=0;itree;\n+\t\tstate[i].dest_host = talloc_strdup(state[i].mem_ctx, \n+\t\t\t\t\t\t   state[i].cli->tree->session->transport->socket->hostname);\n+\t\tstate[i].dest_port = state[i].cli->tree->session->transport->socket->port;\n+\t\tstate[i].called_name  = talloc_strdup(state[i].mem_ctx,\n+\t\t\t\t\t\t      state[i].cli->tree->session->transport->called.name);\n+\t\tstate[i].service_type = talloc_strdup(state[i].mem_ctx,\n+\t\t\t\t\t\t      state[i].cli->tree->device);\n \t}\n \n+\tnum_connected = i;\n+\n \tif (!torture_setup_dir(state[0].cli, BASEDIR)) {\n \t\tgoto failed;\n \t}\n@@ -193,28 +344,18 @@\n \n \ttv = timeval_current();\t\n \n+\tif (progress) {\n+\t\tevent_add_timed(ev, state, timeval_current_ofs(1, 0), report_rate, state);\n+\t}\n+\n \tprintf(\"Running for %d seconds\\n\", timelimit);\n \twhile (timeval_elapsed(&tv) < timelimit) {\n \t\tevent_loop_once(ev);\n \n-\t\ttotal = 0;\n-\t\tfor (i=0;isession);\n+\t\tsmb_raw_exit(state[i].tree->session);\n \t}\n \n-\tsmbcli_deltree(state[0].cli->tree, BASEDIR);\n+\tsmbcli_deltree(state[0].tree, BASEDIR);\n \ttalloc_free(mem_ctx);\n \treturn ret;\n \n failed:\n-\tfor (i=0;isession);\n-\t}\n-\tsmbcli_deltree(state[0].cli->tree, BASEDIR);\n \ttalloc_free(mem_ctx);\n \treturn False;\n }\n\n"}
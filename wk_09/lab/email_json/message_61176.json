{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "jonathan@cvs.develooper.com", "subject": "[svn:parrot-pdd] r19555 - trunk/docs/pdds/draft", "body": "Author: jonathan\nDate: Tue Jul  3 05:38:21 2007\nNew Revision: 19555\n\nModified:\n   trunk/docs/pdds/draft/pdd17_pmc.pod\n\nLog:\n[PDD17]: Properly document my proposal for how inheriting from PMCs will be made to work.\n\nModified: trunk/docs/pdds/draft/pdd17_pmc.pod\n==============================================================================\n--- trunk/docs/pdds/draft/pdd17_pmc.pod\t(original)\n+++ trunk/docs/pdds/draft/pdd17_pmc.pod\tTue Jul  3 05:38:21 2007\n@@ -77,6 +77,7 @@\n     struct PMC {\n         pobj_t obj;\n         VTABLE *vtable;\n+        PMC *real_self;\n  #if ! PMC_DATA_IN_EXT\n         DPOINTER *data;\n  #endif\n@@ -121,6 +122,15 @@\n L that implement the basic behaviour of the PMC\n (i.e. how it behaves under addition, subtraction, cloning etc.)\n \n+{{ PROPOSED:\n+C holds a pointer to the PMC that dynamically dispatched method\n+calls should be made on. Normally this will be a pointer directly back to the\n+PMC itself. However, in the case that the PMC has been subclassed by a non-PMC\n+it will hold a pointer to the real object. This is so DYNSELF.method() style\n+calls will dispatch correctly, calling any methods and/or v-table methods that\n+have been overridden in PIR.\n+}}\n+\n C (if present) holds a pointer to any additional data associated  with\n the PMC. This may be NULL.\n \n@@ -1024,6 +1034,60 @@\n {{ Address the problem of high-level objects inheriting from low-level PMCs,\n and any structural changes to low-level PMCs that might require. }}\n \n+{{ PROPOSED:\n+\n+High-level objects, as specified in PDD15, need to be able to inherit from\n+PMCs. This is achieved through the combination of a C PMC and\n+delegation.\n+\n+For PDD15 objects, there is a corresponding instance of the C PMC. For\n+a PMC, however, the class definition is written in C and compiled away. There\n+needs to be something that can be placed in the parents list for a PDD15\n+class. That something is the C PMC. Like a PDD15 class, it is\n+attached to the namespace that a PMC is attached to, provides introspection\n+facilities and can sit in an inheritance hierarchy.\n+\n+Therefore, subclassing a PMC looks, at a PIR level, like subclassing a high\n+level class.\n+\n+  $P0 = get_class 'Hash'\n+  $P1 = new 'Class'\n+  addparent $P1, $P0     # The new class inherits from the Hash PMC\n+\n+PMCs store state in a very different way to PDD15 objects. When a method\n+inherited from a PMC is called on a PDD15 object, that method needs to get\n+a chunk of state that it can use as it wishes. Further to this, if multiple\n+PMCs are inherited from, they may use the state in different ways. Users of\n+Parrot at a PIR level should not have to care about such issues.\n+\n+Therefore, when a PDD15 object is instantiated and it inherits from PMCs, an\n+instance of each of the PMCs that it inherits from is also created. These are\n+stored at the end of the object's attributes store.\n+\n+When a method is called on an object whose class has PMC parents, the call is\n+delegated up to each of the PMC parents, in MRO order. The invocant must be\n+the appropriate PMC instance from the object's attribute store. For v-table\n+calls, this is just a case of passing the correct thing. For other methods\n+that are located by C, a C PMC is used to ensure that\n+the method from the PMC is invoked with the correct instance, so it has access\n+to the correct state.\n+\n+When a PMC calls a method on itself, it may have been overridden in a high\n+level class. Therefore dynamic dispatches of method calls need to be done with\n+the vtable of the high level class, not the vtable of the PMC itself.\n+\n+For PMCs that are instantiated and not overridden, the C pointer in\n+the PMC structure is a reference to the PMC instance itself. If, however, it\n+is just acting to provide the state a PMC needs but is not the real instance,\n+this pointer will point to the instance of the high level class (an instance\n+of the C PMC). Method dispatches using C will always go\n+through this mechanism.\n+\n+Attribute access is, like method access, delegated upwards. Since attribute\n+lookup is a vtable method, the down case is covered by the previous paragraph.\n+\n+}}\n+\n If a low-level PMC expects to be overridden by high-level classes (which means\n all the core low-level PMC types), it must respect a standard interface. It\n must implement the C and C vtable entries for any core\n\n"}
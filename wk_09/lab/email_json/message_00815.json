{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jerry@samba.org", "subject": "svn commit: samba r22141 - in\n\tbranches/SAMBA_3_0_RELEASE/source/modules: .", "body": "Author: jerry\nDate: 2007-04-09 17:08:02 +0000 (Mon, 09 Apr 2007)\nNew Revision: 22141\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22141\n\nLog:\nadd forgotten vfs_readahead file\nAdded:\n   branches/SAMBA_3_0_RELEASE/source/modules/vfs_readahead.c\n\n\nChangeset:\nAdded: branches/SAMBA_3_0_RELEASE/source/modules/vfs_readahead.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/modules/vfs_readahead.c\t2007-04-09 16:44:56 UTC (rev 22140)\n+++ branches/SAMBA_3_0_RELEASE/source/modules/vfs_readahead.c\t2007-04-09 17:08:02 UTC (rev 22141)\n@@ -0,0 +1,188 @@\n+/*\n+ * Copyright (c) Jeremy Allison 2007.\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+\n+#include \"includes.h\"\n+\n+#if !defined(HAVE_LINUX_READAHEAD) && !defined(HAVE_POSIX_FADVISE)\n+static BOOL didmsg;\n+#endif\n+\n+struct readahead_data {\n+\tSMB_OFF_T off_bound;\n+\tSMB_OFF_T len;\n+\tBOOL didmsg;\n+};\n+\n+/* \n+ * This module copes with Vista AIO read requests on Linux\n+ * by detecting the initial 0x80000 boundary reads and causing\n+ * the buffer cache to be filled in advance.\n+ */\n+\n+/*******************************************************************\n+ sendfile wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n+\n+static ssize_t readahead_sendfile(struct vfs_handle_struct *handle,\n+\t\t\t\t\tint tofd,\n+\t\t\t\t\tfiles_struct *fsp,\n+\t\t\t\t\tint fromfd,\n+\t\t\t\t\tconst DATA_BLOB *header,\n+\t\t\t\t\tSMB_OFF_T offset,\n+\t\t\t\t\tsize_t count)\n+{\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n+#if defined(HAVE_LINUX_READAHEAD)\n+\t\tint err = readahead(fromfd, offset, (size_t)rhd->len);\n+\t\tDEBUG(10,(\"readahead_sendfile: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n+\t\t\t(unsigned int)fromfd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t        err ));\n+#elif defined(HAVE_POSIX_FADVISE)\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n+\t\tDEBUG(10,(\"readahead_sendfile: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n+\t\t\t(unsigned int)fromfd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t\terr ));\n+#else\n+\t\tif (!rhd->didmsg) {\n+\t\t\tDEBUG(0,(\"readahead_sendfile: no readahead on this platform\\n\"));\n+\t\t\trhd->didmsg = True;\n+\t\t}\n+#endif\n+\t}\n+\treturn SMB_VFS_NEXT_SENDFILE(handle,\n+\t\t\t\t\ttofd,\n+\t\t\t\t\tfsp,\n+\t\t\t\t\tfromfd,\n+\t\t\t\t\theader,\n+\t\t\t\t\toffset,\n+\t\t\t\t\tcount);\n+}\n+\n+/*******************************************************************\n+ pread wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n+\n+static ssize_t readahead_pread(vfs_handle_struct *handle,\n+\t\t\t\tfiles_struct *fsp,\n+\t\t\t\tint fd,\n+\t\t\t\tvoid *data,\n+\t\t\t\tsize_t count,\n+\t\t\t\tSMB_OFF_T offset)\n+{\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n+#if defined(HAVE_LINUX_READAHEAD)\n+\t\tint err = readahead(fd, offset, (size_t)rhd->len);\n+\t\tDEBUG(10,(\"readahead_pread: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n+\t\t\t(unsigned int)fd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t\terr ));\n+#elif defined(HAVE_POSIX_FADVISE)\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n+\t\tDEBUG(10,(\"readahead_pread: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n+\t\t\t(unsigned int)fd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t\t(err ));\n+#else\n+\t\tif (!rhd->didmsg) {\n+\t\t\tDEBUG(0,(\"readahead_pread: no readahead on this platform\\n\"));\n+\t\t\trhd->didmsg = True;\n+\t\t}\n+#endif\n+        }\n+        return SMB_VFS_NEXT_PREAD(handle, fsp, fd, data, count, offset);\n+}\n+\n+/*******************************************************************\n+ Directly called from main smbd when freeing handle.\n+*******************************************************************/\n+\n+static void free_readahead_data(void **pptr)\n+{\n+\tSAFE_FREE(*pptr);\n+}\n+\n+/*******************************************************************\n+ Allocate the handle specific data so we don't call the expensive\n+ conv_str_size function for each sendfile/pread.\n+*******************************************************************/\n+\n+static int readahead_connect(struct vfs_handle_struct *handle,\n+\t\t\t\tconst char *service,\n+\t\t\t\tconst char *user)\n+{\n+\tstruct readahead_data *rhd = SMB_MALLOC_P(struct readahead_data);\n+\tif (!rhd) {\n+\t\tDEBUG(0,(\"readahead_connect: out of memory\\n\"));\n+\t\treturn -1;\n+\t}\n+\tZERO_STRUCTP(rhd);\n+\n+\trhd->didmsg = False;\n+\trhd->off_bound = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"offset\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->off_bound == 0) {\n+\t\trhd->off_bound = 0x80000;\n+\t}\n+\trhd->len = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"length\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->len == 0) {\n+\t\trhd->len = rhd->off_bound;\n+\t}\n+\n+\thandle->data = (void *)rhd;\n+\thandle->free_data = free_readahead_data;\n+\treturn 0;\n+}\n+\n+/*******************************************************************\n+ Functions we're replacing.\n+ We don't replace read as it isn't used from smbd to read file\n+ data.\n+*******************************************************************/\n+\n+static vfs_op_tuple readahead_ops [] =\n+{\n+\t{SMB_VFS_OP(readahead_sendfile), SMB_VFS_OP_SENDFILE, SMB_VFS_LAYER_TRANSPARENT},\n+\t{SMB_VFS_OP(readahead_pread), SMB_VFS_OP_PREAD, SMB_VFS_LAYER_TRANSPARENT},\n+        {SMB_VFS_OP(readahead_connect), SMB_VFS_OP_CONNECT,  SMB_VFS_LAYER_TRANSPARENT},\n+\t{SMB_VFS_OP(NULL), SMB_VFS_OP_NOOP, SMB_VFS_LAYER_NOOP}\n+};\n+\n+/*******************************************************************\n+ Module initialization boilerplate.\n+*******************************************************************/\n+\n+NTSTATUS vfs_readahead_init(void);\n+NTSTATUS vfs_readahead_init(void)\n+{\n+\treturn smb_register_vfs(SMB_VFS_INTERFACE_VERSION, \"readahead\", readahead_ops);\n+}\n\n"}
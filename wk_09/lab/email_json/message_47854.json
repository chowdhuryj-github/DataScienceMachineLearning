{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 11189: Support creating regf files, run tests against regf. in\n\tfile:///home/jelmer/bzr.samba-old/4.0-regwrite/", "body": "At file:///home/jelmer/bzr.samba-old/4.0-regwrite/\n\n------------------------------------------------------------\nrevno: 11189\nrevision-id: jelmer@samba.org-20070612231137-i8mbl1sgmcfkb5vn\nparent: jelmer@samba.org-20070612202736-meu8bltye0rberi6\ncommitter: Jelmer Vernooij \nbranch nick: 4.0-regwrite\ntimestamp: Wed 2007-06-13 01:11:37 +0200\nmessage:\n  Support creating regf files, run tests against regf.\nmodified:\n  source/lib/registry/hive.h     hive.h-20070423140448-w1nvzs8d2qxvyswz-1\n  source/lib/registry/regf.c     svn-v2:4132@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2freg_backend_nt4.c\n  source/lib/registry/tests/hive.c hive.c-20070612151642-hsxkm8j4r69ej3px-1\n=== modified file 'source/lib/registry/hive.h'\n--- a/source/lib/registry/hive.h\t2007-06-12 20:08:26 +0000\n+++ b/source/lib/registry/hive.h\t2007-06-12 23:11:37 +0000\n@@ -167,6 +167,10 @@\n \n WERROR reg_create_directory(TALLOC_CTX *parent_ctx, \n \t\t\tconst char *location, struct hive_key **key);\n+WERROR reg_create_regf_file(TALLOC_CTX *parent_ctx, \n+\t\t\t\t\t\t\t const char *location, \n+\t\t\t\t\t\t\t int major_version, \n+\t\t\t\t\t\t\t struct hive_key **key);\n \n \n #endif /* __REGISTRY_HIVE_H__ */\n\n=== modified file 'source/lib/registry/regf.c'\n--- a/source/lib/registry/regf.c\t2007-06-12 20:08:26 +0000\n+++ b/source/lib/registry/regf.c\t2007-06-12 23:11:37 +0000\n@@ -26,6 +26,8 @@\n #include \"librpc/gen_ndr/ndr_security.h\"\n #include \"librpc/gen_ndr/winreg.h\"\n \n+static struct hive_operations reg_backend_regf;\n+\n /**\n  * There are several places on the web where the REGF format is explained; \n  *\n@@ -127,7 +129,7 @@\n \treturn ret;\n }\n \n-static BOOL hbin_get_tdr (struct regf_data *regf, uint32_t offset, \n+static bool hbin_get_tdr (struct regf_data *regf, uint32_t offset, \n \t\t\t\t\t\t  TALLOC_CTX *ctx, tdr_pull_fn_t pull_fn, void *p)\n {\n \tstruct tdr_pull pull;\n@@ -137,15 +139,15 @@\n \tpull.data = hbin_get(regf, offset);\n \tif (!pull.data.data) {\n \t\tDEBUG(1, (\"Unable to get data at 0x%04x\\n\", offset));\n-\t\treturn False;\n+\t\treturn false;\n \t}\n \t\n \tif (NT_STATUS_IS_ERR(pull_fn(&pull, ctx, p))) {\n \t\tDEBUG(1, (\"Error parsing record at 0x%04x using tdr\\n\", offset));\n-\t\treturn False;\n+\t\treturn false;\n \t}\n \n-\treturn True;\n+\treturn true;\n }\n \n /* Allocate some new data */\n@@ -306,7 +308,8 @@\n \tSIVALS(hbin->data, rel_offset, size);\n }\n \n-/* Store a data blob data was already stored, but has changed in size\n+/**\n+ * Store a data blob data was already stored, but has changed in size\n  * Will try to save it at the current location if possible, otherwise \n  * does a free + store */\n static uint32_t hbin_store_resize (struct regf_data *data, uint32_t orig_offset, DATA_BLOB blob)\n@@ -370,7 +373,8 @@\n \treturn hbin_store(data, blob);\n }\n \n-static uint32_t hbin_store_tdr_resize (struct regf_data *regf, tdr_push_fn_t push_fn, uint32_t orig_offset, void *p)\n+static uint32_t hbin_store_tdr_resize (struct regf_data *regf, tdr_push_fn_t push_fn, \n+\t\t\t\t\t\t\t\t\t   uint32_t orig_offset, void *p)\n {\n \tstruct tdr_push *push = talloc_zero(regf, struct tdr_push);\n \tuint32_t ret;\n@@ -387,7 +391,8 @@\n \treturn ret;\n }\n \n-static uint32_t regf_create_lh_hash(const char *name) {\n+static uint32_t regf_create_lh_hash(const char *name) \n+{\n \tchar *hash_name;\n \tuint32_t ret = 0;\n \tuint16_t i;\n@@ -411,16 +416,21 @@\n \tconst struct regf_key_data *private_data = \n \t\t(const struct regf_key_data *)key;\n \n-\t*num_subkeys = private_data->nk->num_subkeys;\n-\t*num_values = private_data->nk->num_values;\n-\n-\tif (private_data->nk->clsname_offset != -1) {\n-\t\tDATA_BLOB data = hbin_get(private_data->hive, \n-\t\t\t\t\t\t\t\t  private_data->nk->clsname_offset);\n-\t\t*classname = talloc_strndup(mem_ctx, \n-\t\t\t\t\t\t (char*)data.data, private_data->nk->clsname_length);\n-\t} else \n-\t\t*classname = NULL;\n+\tif (num_subkeys != NULL)\n+\t\t*num_subkeys = private_data->nk->num_subkeys;\n+\n+\tif (num_values != NULL)\n+\t\t*num_values = private_data->nk->num_values;\n+\n+\tif (classname != NULL) {\n+\t\tif (private_data->nk->clsname_offset != -1) {\n+\t\t\tDATA_BLOB data = hbin_get(private_data->hive, \n+\t\t\t\t\t\t\t\t\t  private_data->nk->clsname_offset);\n+\t\t\t*classname = talloc_strndup(mem_ctx, \n+\t\t\t\t\t\t\t (char*)data.data, private_data->nk->clsname_length);\n+\t\t} else \n+\t\t\t*classname = NULL;\n+\t}\n \n \t/* FIXME: Last mod time */\n \t\n@@ -435,6 +445,7 @@\n \tstruct regf_key_data *ret;\n \n \tret = talloc_zero(ctx, struct regf_key_data);\n+\tret->key.ops = \u00ae_backend_regf;\n \tret->hive = talloc_reference(ret, regf);\n \tret->offset = offset;\n \tnk = talloc(ret, struct nk_block);\n@@ -656,7 +667,8 @@\n \t\t\t\tbreak;\n \t\t\t} else {\n \t\t\t\tDEBUG(0,(\"Unknown sublist in ri block\\n\"));\n-\t\t\t\tSMB_ASSERT(0);\n+\n+\t\t\t\treturn WERR_GENERAL_FAILURE;\n \t\t\t}\n \t\t\t\n \t\t}\n@@ -769,7 +781,7 @@\n \t\t\t\tbreak;\n \t\t}\n \t\tif (key_off == 0)\n-\t\t\treturn WERR_DEST_NOT_FOUND;\n+\t\t\treturn WERR_NOT_FOUND;\n \t} else if (!strncmp((char *)data.data, \"lf\", 2)) {\n \t\tstruct lf_block lf;\n \t\tstruct tdr_pull pull;\n@@ -799,7 +811,7 @@\n \t\t\t\tbreak;\n \t\t}\n \t\tif (key_off == 0)\n-\t\t\treturn WERR_DEST_NOT_FOUND;\n+\t\t\treturn WERR_NOT_FOUND;\n \t} else if (!strncmp((char *)data.data, \"lh\", 2)) {\n \t\tstruct lh_block lh;\n \t\tstruct tdr_pull pull;\n@@ -831,7 +843,7 @@\n \t\t\t\tbreak;\n \t\t}\t\n \t\tif (key_off == 0)\n-\t\t\treturn WERR_DEST_NOT_FOUND;\n+\t\t\treturn WERR_NOT_FOUND;\n \t} else if (!strncmp((char *)data.data, \"ri\", 2)) {\n \t\tstruct ri_block ri;\n \t\tstruct tdr_pull pull;\n@@ -900,7 +912,7 @@\n \t\t\t\tbreak;\n \t\t}\n \t\tif (!key_off)\n-\t\t\treturn WERR_DEST_NOT_FOUND;\n+\t\t\treturn WERR_NOT_FOUND;\n \t} else {\n \t\tDEBUG(0, (\"Unknown subkey list type.\\n\"));\n \t\treturn WERR_GENERAL_FAILURE;\n@@ -920,7 +932,7 @@\n \tstruct nk_block root;\n \tDATA_BLOB data;\n \tuint32_t sk_offset, cur_sk_offset;\n-\tBOOL update_cur_sk = false;\n+\tbool update_cur_sk = false;\n \n \t/* Get the root nk */\n  \thbin_get_tdr(regf, regf->header->data_offset, regf, \n@@ -1214,7 +1226,7 @@\n \t\tstruct li_block li;\n \t\tstruct tdr_pull pull;\n \t\tuint16_t i;\n-\t\tBOOL found_offset = false;\n+\t\tbool found_offset = false;\n \t\n \t\tDEBUG(10, (\"Subkeys in LI list\\n\"));\n \t\t\n@@ -1255,7 +1267,7 @@\n \t\tstruct lf_block lf;\n \t\tstruct tdr_pull pull;\n \t\tuint16_t i;\n-\t\tBOOL found_offset = false;\n+\t\tbool found_offset = false;\n \t\t\n \t\tDEBUG(10, (\"Subkeys in LF list\\n\"));\n \t\t\n@@ -1298,7 +1310,7 @@\n \t\tstruct lh_block lh;\n \t\tstruct tdr_pull pull;\n \t\tuint16_t i;\n-\t\tBOOL found_offset = false;\n+\t\tbool found_offset = false;\n \t\t\n \t\tDEBUG(10, (\"Subkeys in LH list\\n\"));\n \t\t\n@@ -1356,7 +1368,7 @@\n \tstruct nk_block *nk = private_data->nk;\n \tstruct vk_block vk;\n \tuint32_t vk_offset;\n-\tBOOL found_offset = false;\n+\tbool found_offset = false;\n \tDATA_BLOB values;\n \tuint32_t i;\n \n@@ -1415,15 +1427,15 @@\n \tparent_nk = private_data->nk;\n \n \tif (parent_nk->subkeys_offset == -1) {\n-\t\tDEBUG(0, (\"Subkey list is empty, this key cannot contain subkeys.\\n\"));\n-\t\treturn WERR_DEST_NOT_FOUND;\n+\t\tDEBUG(4, (\"Subkey list is empty, this key cannot contain subkeys.\\n\"));\n+\t\treturn WERR_NOT_FOUND;\n \t}\n \n \t/* Find the key */\n \tif (!W_ERROR_IS_OK(regf_get_subkey_by_name(parent_nk, parent, name, \n \t\t\t\t\t\t\t\t\t   (struct hive_key **)&key))) {\n \t\tDEBUG(0, (\"Key '%s' not found\\n\", name));\n-\t\treturn WERR_DEST_NOT_FOUND;\n+\t\treturn WERR_NOT_FOUND;\n \t}\n \t\n \tif (key->nk->subkeys_offset != -1 || \n@@ -1483,7 +1495,6 @@\n \tnk.clsname_length = 0;\n \tnk.key_name = name;\n \t\n-\n \t/* Get the security descriptor of the root key */\n  \troot = talloc_zero(ctx, struct nk_block);\n \tif (!hbin_get_tdr(regf, regf->header->data_offset, root, (tdr_pull_fn_t)tdr_pull_nk_block, root)) {\n@@ -1645,6 +1656,86 @@\n \treturn WERR_OK;\n }\n \n+WERROR reg_create_regf_file(TALLOC_CTX *parent_ctx, \n+\t\t\t\t\t\t\t const char *location, \n+\t\t\t\t\t\t\t int minor_version,\n+\t\t\t\t\t\t\t struct hive_key **key)\n+{\n+\tstruct regf_data *regf;\n+\tstruct regf_hdr *regf_hdr;\n+\tstruct tdr_pull pull;\n+\tint i;\n+\tstruct nk_block nk;\n+\tWERROR error;\n+\n+\tregf = (struct regf_data *)talloc_zero(NULL, struct regf_data);\n+\n+\tDEBUG(5, (\"Attempting to create registry file\\n\"));\n+\n+\t/* Get the header */\n+\tregf->fd = creat(location, 0644);\n+\n+\tif (regf->fd == -1) {\n+\t\tDEBUG(0,(\"Could not create file: %s, %s\\n\", location,\n+\t\t\t\t strerror(errno)));\n+\t\ttalloc_free(regf);\n+\t\treturn WERR_GENERAL_FAILURE;\n+\t}\n+\n+\tregf_hdr = talloc_zero(regf, struct regf_hdr);\n+\tregf_hdr->REGF_ID = \"regf\";\n+\tunix_to_nt_time(&regf_hdr->modtime, time(NULL));\n+\tregf_hdr->version.major = 1;\n+\tregf_hdr->version.minor = minor_version;\n+\tregf_hdr->last_block = 0x1000; /* Block size */\n+\tregf_hdr->description = talloc_strdup(regf_hdr, \"registry created by Samba 4\");\n+\tregf_hdr->chksum = 0;\n+\n+\tregf->header = regf_hdr;\n+\n+\tpull.offset = 0x1000;\n+\n+\ti = 0;\n+\t/* Read in all hbin blocks */\n+\tregf->hbins = talloc_array(regf, struct hbin_block *, 1);\n+\tregf->hbins[0] = NULL;\n+\n+\tregf_hdr->data_offset = -1; /* FIXME */\n+\n+\tnk.header = \"nk\";\n+\tnk.type = REG_SUB_KEY;\n+\tunix_to_nt_time(&nk.last_change, time(NULL));\n+\tnk.uk1 = 0;\n+\tnk.parent_offset = -1;\n+\tnk.num_subkeys = 0;\n+\tnk.uk2 = 0;\n+\tnk.subkeys_offset = -1;\n+\tnk.unknown_offset = -1;\n+\tnk.num_values = 0;\n+\tnk.values_offset = -1;\n+\tmemset(nk.unk3, 0, 5);\n+\tnk.clsname_offset = -1; /* FIXME: fill in */\n+\tnk.clsname_length = 0;\n+\tnk.key_name = \"\";\n+\t\n+\tnk.sk_offset = -1; /* FIXME: fill in */\n+\t\n+\t/* Store the new nk key */\n+\tregf->header->data_offset = hbin_store_tdr(regf, (tdr_push_fn_t) tdr_push_nk_block, &nk);\n+\t\n+\t*key = (struct hive_key *)regf_get_key(parent_ctx, regf, regf->header->data_offset);\n+\n+\t/* We can drop our own reference now that *key will have created one */\n+\ttalloc_free(regf);\n+\n+\terror = regf_save_hbin(regf);\n+\tif (!W_ERROR_IS_OK(error)) {\n+\t\treturn error;\n+\t}\n+\n+\treturn WERR_OK;\n+}\n+\n WERROR reg_open_regf_file(TALLOC_CTX *parent_ctx, \n \t\t\t\t\t\t  const char *location, struct hive_key **key)\n {\n@@ -1691,11 +1782,6 @@\n \t\treturn WERR_GENERAL_FAILURE;\n \t}\n \n-\tDEBUG(1, (\"Registry '%s' read. Version %d.%d.%d.%d\\n\", \n-\t\t\t  regf_hdr->description, regf_hdr->version.major,\n-\t\t\t  regf_hdr->version.minor, regf_hdr->version.release,\n-\t\t\t  regf_hdr->version.build));\n-\n \t/*\n \t * Validate the header ...\n \t */\n\n=== modified file 'source/lib/registry/tests/hive.c'\n--- a/source/lib/registry/tests/hive.c\t2007-06-12 20:27:36 +0000\n+++ b/source/lib/registry/tests/hive.c\t2007-06-12 23:11:37 +0000\n@@ -119,7 +119,22 @@\n \t*data = key;\n \n \treturn true;\n-\n+}\n+\n+static bool hive_setup_regf(struct torture_context *tctx, void **data)\n+{\n+\tstruct hive_key *key;\n+\tWERROR error;\n+\n+\terror = reg_create_regf_file(tctx, \"bla-regf\", 5, &key);\n+\tif (!W_ERROR_IS_OK(error)) {\n+\t\tfprintf(stderr, \"Unable to create new regf file\\n\");\n+\t\treturn false;\n+\t}\n+\n+\t*data = key;\n+\n+\treturn true;\n }\n \n static bool test_dir_refuses_null_location(struct torture_context *tctx)\n@@ -147,5 +162,10 @@\n \ttcase = torture_suite_add_tcase(suite, \"ldb\");\n \ttorture_tcase_set_fixture(tcase, hive_setup_ldb, NULL);\n \ttcase_add_tests(tcase);\n+\n+\ttcase = torture_suite_add_tcase(suite, \"regf\");\n+\ttorture_tcase_set_fixture(tcase, hive_setup_regf, NULL);\n+\ttcase_add_tests(tcase);\n+\n \treturn suite;\n }\n\n"}
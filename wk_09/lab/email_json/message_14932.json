{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14380 - doc/trunk/design/syn", "body": "Author: larry\nDate: Tue Apr 24 18:05:36 2007\nNew Revision: 14380\n\nModified:\n   doc/trunk/design/syn/S10.pod\n\nLog:\nClarifications to CANDO suggested by TheDamian++\n\n\nModified: doc/trunk/design/syn/S10.pod\n==============================================================================\n--- doc/trunk/design/syn/S10.pod\t(original)\n+++ doc/trunk/design/syn/S10.pod\tTue Apr 24 18:05:36 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 27 Oct 2004\n-  Last Modified: 6 Apr 2006\n+  Last Modified: 24 Apr 2007\n   Number: 10\n-  Version: 6\n+  Version: 7\n \n =head1 Overview\n \n@@ -88,7 +88,7 @@\n that distinguish declaration from definition, but are not restricted\n to declaring subs.  A run-time declarator multisub is declared as:\n \n-    multi CANDO ( MyPackage, $type, $name; *%args --> Container)\n+    multi CANDO ( MyPackage, $type, $name, *%args --> Container)\n \n which stands in for the declaration of a container object within\n another container object; it is called when anyone is searching for\n@@ -100,22 +100,34 @@\n name requested.  In any case, there may be multiple C routines\n that are dispatched via MMD:\n \n-    multi CANDO ( MyPackage, Item, $name; *%args --> Container)\n-    multi CANDO ( MyPackage, Array, $name; *%args --> Container)\n-    multi CANDO ( MyPackage, Hash, $name; *%args --> Container)\n-    multi CANDO ( MyPackage, Code, $name; *%args --> Container)\n-\n-The package itself is just passed as the\n-first argument, since it's the container object.  Subsequent arguments\n-identify the desired type of the inner container and the \"name\" or\n-\"key\" by which the object is to be looked up in the outer container.\n-Such a name does not include its container name, unlike Perl\u00a05's magical\n-C<$AUTOLOAD> variable.\n-\n-The C is expected to return an inner container object of the proper\n-sort (i.e. a variable, subroutine, or method object), or to a proxy\n-object that can \"autovivify\" lazily, or C if that name is not to be\n-considered declared in the namespace in question.\n+    multi CANDO ( MyPackage, Item, $name, *%args --> Container)\n+    multi CANDO ( MyPackage, Array, $name, *%args --> Container)\n+    multi CANDO ( MyPackage, Hash, $name, *%args --> Container)\n+    multi CANDO ( MyPackage, Code, $name, *%args --> Container)\n+\n+The package itself is just passed as the first argument, since it's\n+the container object.  Subsequent arguments identify the desired type\n+of the inner container and the \"name\" or \"key\" by which the object is\n+to be looked up in the outer container.  Such a name does not include\n+its container name, unlike Perl\u00a05's magical C<$AUTOLOAD> variable.\n+Nor does it include the type information of a Code object's \"long\n+name\"; this information comes in via the type parameter, and may be\n+matched against using ordinary subsignature matching:\n+\n+    multi CANDO ( MyPackage, &:($), $name, *%args --> Container)     # 1 arg\n+    multi CANDO ( MyPackage, &:($,$), $name, *%args --> Container)   # 2 args\n+\n+The slurpy C<%args> hash is likely to be empty in standard Perl\u00a06\n+usage, but it's possible that some dialects of Perl will desire\n+a mechanism to pass in additional contextual information, so this\n+parameter is reserved for such purposes.\n+\n+The C is expected to return an inner container object of\n+the proper sort (i.e. a variable, subroutine, or method object),\n+or a proxy object that can \"autovivify\" lazily, or C if that\n+name is not to be considered declared in the namespace in question.\n+(Only bare C is interpreted as \"not there\", since typed undefs\n+may function as autovivifiable proxy objects.  See S12.)\n \n The declaration merely defines the interface to the new object.  That object\n need not be completely defined yet, though the C routine is certainly\n@@ -129,61 +141,12 @@\n When the package in question is a class, it is also possible to declare \n real methods or submethods:\n \n-    multi method CANDO ($self: Code, $name; *%args --> Container)\n+    multi method CANDO ($self: Code, $name, *%args --> Container)\n \n-    multi submethod CANDO ($self: Item, $name; *%args --> Container)\n+    multi submethod CANDO ($self: Item, $name, *%args --> Container)\n \n The method form is inherited by subclasses.  Submethods are never\n inherited but may still do MMD within the class.   (Ordinary multisubs\n are inherited only to the extent allowed by the MMD mechanism.)\n \n-=for DISCUSSION\n-The following should really be in S12 if really works this way, but\n-I'm not sure it does.  Seems like something is wrong, but I can't\n-quite put my finger on it.  Something like, different containers want\n-different default values, but we've probably lost track of the container.\n-So anyway, the rest of this section is considered conjectural.\n-\n-When someone tries to actually call or access an undefined object\n-(which may have come from one of the routines above, or might have just\n-been declared with a body of C<{...}>), or might just be a variable\n-declared without an initializer, a different hook is used to define\n-actual behavior at the last moment:\n-\n-    submethod AUTODEF ($self:) { ... }\n-\n-(Unlike the C interface, we do not pass the package.)\n-\n-This routine is passed an uninitialized (or underinitialized) object,\n-and is expected to define or build the object, but not to call it,\n-since the call is already \"scheduled\" from somewhere else.  (Perl\u00a05's\n-C is implicit, in other words.  But you can hijack\n-the call via the C builtin, in which case the autoloader behaves\n-just like a wrapper--see S06.)\n-\n-In any case, there is no longer any magical C<$AUTOLOAD> variable.\n-The C is a mutator, and thus is not expected to return the\n-object.  No name is passed to C--in a context where a name\n-is being declared at call time, the name is automatically introduced\n-with C before C is called.  The outer container,\n-if available, is accessed via C<$+CONTAINER>.  In the case of a\n-sub call, the call's unbound C object will be available\n-via C<$+ARGLIST>.  C<$+ARGLIST> is a rw variable, and mutations to it\n-will be seen by the eventual \"real\" call.\n-\n-If a C submethod wishes merely to perform some action without\n-defining C<$self>, that is fine.  It needs to signal that desire by\n-use of an explicit \"return;\" statement.\n-\n-A C submethod is really just a variant of C with no named\n-arguments.  As with C, default values for attributes are applied at\n-the end for any attributes not explicitly set.  A typical C\n-definition might be:\n-\n-    submethod AUTODEF { self.=BUILD }\n-\n-or maybe even just:\n-\n-    our &AUTODEF ::= &BUILD\n-\n =for vim:set expandtab sw=4:\n\n"}
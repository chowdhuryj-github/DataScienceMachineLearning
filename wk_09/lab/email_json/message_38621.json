{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14408 - doc/trunk/design/syn", "body": "Author: larry\nDate: Tue May 29 17:38:24 2007\nNew Revision: 14408\n\nModified:\n   doc/trunk/design/syn/S06.pod\n\nLog:\nExtensibility of \"is cached\" explained, as requested by gabriele renzi++\n\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tTue May 29 17:38:24 2007\n@@ -13,9 +13,9 @@\n \n   Maintainer: Larry Wall \n   Date: 21 Mar 2003\n-  Last Modified: 21 May 2007\n+  Last Modified: 29 May 2007\n   Number: 6\n-  Version: 84\n+  Version: 85\n \n \n This document summarizes Apocalypse 6, which covers subroutines and the\n@@ -1472,12 +1472,32 @@\n \n =item C\n \n-Marks a subroutine as being memoized.\n+Marks a subroutine as being memoized, or at least memoizable.  The\n+compiler is free to choose any kind of caching algorithm (including\n+non-expiring, random, lru, pseudo-lru, or adaptive algoritms, or\n+even no caching algorithm at all).  The run-time system is free to\n+choose any kind of maximum cache size depending on the availability\n+of memory and trends in usage patterns.  You may suggest a particular\n+cache size by passing a numeric argument, and some of the possible\n+algorithms may pay attention to it.  You may also pass C<*> for the\n+size to request a non-expiring cache (complete memoization).  The\n+compiler is free to ignore this too.\n+\n+The intent of this pragma is to specify performance hints without\n+mandating any exact behavior.  Use of this pragma should not change\n+semantics of the program, and this pragma will not be extended to\n+reinvent other existing ways of achieving the same effect.  To gain\n+more control, write your own trait handler to allow the use of a more\n+specific trait, such as \"C\".  Alternately, just\n+use a state hash keyed on the sub's argument capture to write\n+your own memoization with complete control from within the subroutine\n+itself.\n \n =item C\n \n I to the compiler that the subroutine is a candidate for\n-optimization via inlining.\n+optimization via inlining.  Basically promises that nobody is going\n+to try to wrap this subroutine (or that if they do, you don't care).\n \n =item C/C/C\n"}
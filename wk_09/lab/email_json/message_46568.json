{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Northstardomus <northstardomus@gmail.com>", "subject": "Database insertion, escape issue", "body": "I have a Perl script where I try to strip some data from a web page\nand insert it\n\ninto a database.  I'm having a problem where, it seems like the method\nof quoting\n\nthe data for insertion don't seem to be working (as far as escaping\nthe text) and\n\nsome of the text is ending up getting injected into the SQL command.\n\nIn this example, I am capturing the paragraphs of text and inserting\neach HTML\n\nparagraph into a new record.  What seems to be hanging up the\ninsertion is the \"or\n\ndie\" portion of the text.  It will also bomb if the text has a word\nlike \"don't\".\n\nI thought the insertion mechanism I'm using would properly escape\nthese special\n\ncharacters/phrases.\n\nThis is an old problem for me, I know I tried multiple methods but had\nto put the\n\nproject down for a few months here so I'm a bit sketchy on the details\nof what I\n\nhave tried already, otherwise I would have posted that as well.\n\nI am currently trying this with a SQLite database.  I tried it on a\nMySQL database\n\nwith the same results.  Here is the database Schema:\n\nCREATE TABLE area_status (updatre_time TEXT, status BLOB, survey_date\nTEXT, areaID\n\nNUMERIC, area_statusID INTEGER PRIMARY KEY);\n\nThe only thing you hsould have to change is the $file_prefix\nvariable.  Also, the\n\nexample webpage and SQLite database are here:\nhttp://www.ottomatica.com/perl/paragraph_insert_issue/test_page.html\nhttp://www.ottomatica.com/perl/paragraph_insert_issue/area.db\n\nThanks in advance!!!!!\n\nHere's the code.\n\n#!/usr/bin/perl\nuse strict;\nuse LWP::Simple qw(!head);\nuse diagnostics;\nuse DBI();\n\nsub trim($);                        # subroutines to trim off\nwhitespace\nsub ltrim($);                       # subroutines to trim off\nwhitespace\nsub rtrim($);                       # subroutines to trim off\nwhitespace\nsub status_of_the_area_insert;      # subroutine that inserts data\ninto database\n\nmy $html_string;                    # This variable will contain the\nwhole web\n\npage\nmy $file_string;                    # This contains the complete file\npath (in the\n\nreal program I loop through many web pages)\nmy $status_of_the_area_error = 0;   # This is a debuging variable that\nis a\n\nboolean and will help decide if I execute certain portions of code\nmy $file_name;                      # The file name and extension\nportion of\n\n$file_string above\nmy $areaID;                         # A field in my area_status table,\nhardcoded\n\nin this case\nmy $inventory_number;               # A field in my area_status table,\nhardcoded\n\nin this case\nmy $survey_date;                    # A field in my area_status table,\nhardcoded\n\nin this case\nmy $time = localtime(time);         # The current time when the code\nis exectued\n\nfor later reference\nmy $status_of_the_area;             # This contains the text I'm\ninterested in\n\ncapture by a Perl Regex\nmy $status_of_the_area_complete;    # The final text that I am\ninterested in\n\n(after trimming)\nmy $status_of_the_area_present;     # This is a boolean that tells me\nwhether the\n\ntext I'm interested in is there or not\nmy $detect_paragraphs;              # A boolean to detect if there are\nmultiple\n\nparagraphs present\nmy @status_of_the_area_array;       # An array that contains multiple\nparagraphs\n\nif present\nmy $status_of_the_area_array;       # Used to loop through the\n\n@status_of_the_area_array array\nmy $file_prefix;                    # The location of the html file on\nthe user's\n\ncomputer.\n\n# Declare the location of the html file on the user's computer.\n$file_prefix = 'file:///C:/Lanosrep/beW/Perl/HelpPage/';\n\n# Print Status\nprint \"Begin looping through the directory \";\n\n# Loop through directory (in this case there will be only one file)\nwhile ( $file_name=glob(\"test_page.html\") ) { #Use this for a test\nstring to limit\n\nresults *downum=0100*.html\n\n    # Reset the $status_of_the_area_error to zero\n    # This is a debuging variable that is a boolean and will help\ndecide if I\n\nexecute certain portions of code\n    $status_of_the_area_error = 0;\n\n    # Create the file string\n    # This contains the complete file path (in the real program I loop\nthrough\n\nmany web pages)\n    $file_string = $file_prefix.$file_name;\n\n    # Assign the contents of the web page to the $html_string variable\n    # This variable will contain the whole web page\n    $html_string = get($file_string);\n\n    # Determine if the text I care about is present\n    # This is a boolean that tells me whether the text I'm interested\nin is there\n\nor not\n    $status_of_the_area_present = $html_string =~ m/.??Status of\nthe\n\nArea.*?<\\/H2>(.*?).??For Additional Information.*?<\\/H2>/si;\n\n    # If it is present, print status that tells me it's there and\nexecute some\n\nadditional code\n    if ($status_of_the_area_present) {\n        print \"Status of the area Found -\n\n$file_string.\";\n\n        # This contains the text I'm interested in capture by a Perl\nRegex\n        ($status_of_the_area) = $html_string =~ m/.??Status of\nthe\n\nArea.*?<\\/H2>(.*?).??For Additional Information.*?<\\/H2>/si;\n\n        # The final text that I am interested in (after trimming)\n        $status_of_the_area_complete = trim($status_of_the_area);\n\n        # A boolean to detect if there are multiple paragraphs present\n        $detect_paragraphs = $status_of_the_area =~ m//i;\n\n        # If multiple paragraphs are detected, split them up and place\nin an array\n        if ($detect_paragraphs) {\n            $status_of_the_area =~ s/.??//sgi;\n            (@status_of_the_area_array) = split //i,\n$status_of_the_area;\n        }\n\n        # Hardcode the following variables as they are unimportant for\nthis\n\ndiscussion\n        $inventory_number = 22222222;\n        $areaID = 22222222;\n        $survey_date = \"01-01-1999\";\n\n        # If multiple paragraphs are detected, loop through the\narray,\n\n@status_of_the_area_array and insert the data\n        if ($detect_paragraphs) {\n            my $i = 1;\n            foreach $status_of_the_area_array\n(@status_of_the_area_array) {\n                # Detect if the paragraph contains any text\n                if ($status_of_the_area_array) {\n\n\nstatus_of_the_area_insert($status_of_the_area_array,$areaID,\n$survey_date,$time,1);\n                }\n                # If paragraph is blank don't insert into the database\n                else {\n                    #print \"Paragraph $iNothing Here\";\n                }\n            $i++;\n            }\n        }\n\n        # If just a single paragraph, insert the data captured in the\nvariable\n\n$status_of_the_area_complete\n        else {\n            #print $status_of_the_area;\n\n\nstatus_of_the_area_insert($status_of_the_area_complete,$areaID,\n$survey_date,$time,\n\n1);\n        }\n            print \"\";\n        }\n    # If text is not detected print status\n    else {\n        print \"Status of the area NOT Found -\n\n$file_string.\";\n    }\n    }\n\n# Done\n# Subroutines below\n\n# Perl trim function to remove whitespace from the start and end of\nthe string\nsub trim($)\n{\n\tmy $string = shift;\n\t$string =~ s/^\\s+//;\n\t$string =~ s/\\s+$//;\n\treturn $string;\n}\n# Left trim function to remove leading whitespace\nsub ltrim($)\n{\n\tmy $string = shift;\n\t$string =~ s/^\\s+//;\n\treturn $string;\n}\n# Right trim function to remove trailing whitespace\nsub rtrim($)\n{\n\tmy $string = shift;\n\t$string =~ s/\\s+$//;\n\treturn $string;\n}\n\n# subroutine that inserts data into database\nsub status_of_the_area_insert {\n    my $var;\n    my $areaID;\n    my $survey_date;\n    my $update_time;\n    my $row_count_final;\n    ($var,$areaID,$survey_date,$update_time,$row_count_final)=@_;\n    my $dbh =\n\nDBI->connect(\"DBI:SQLite:dbname=C:/Lanosrep/beW/Perl/HelpPage/\narea.db\", \"\", \"\",\n\n{'RaiseError' => 1});\n    my $row_count = 0;\n    my $sth;\n    my @values;\n    my @sql_row;\n    my $rv;\n    my $sql;\n    my $OK2INSERT;\n    my $parsed_var;\n\n    $values[0] = trim($areaID);\n    $values[1] = trim($survey_date);\n    $values[2] = trim($update_time);\n    $values[3] = trim($var);\n    $sql = \"SELECT * FROM area_status WHERE areaID='$values[0]' AND\n\nsurvey_date='$values[1]' AND status='$values[3]'\";\n    $sth = $dbh->prepare($sql);\n    $sth->execute;\n    $rv = $sth->rows;\n    if ($rv > 1) {\n        print \"Error: There were $rv rows returned for SQL\nstatement:\n\n$sql\";\n    }\n    else {\n        if ($rv == 1) {\n            print \"Database entry, @values, already exists.\";\n        }\n        else {\n            $OK2INSERT = 1;\n            }\n    }\n    $sth->finish;\n    # Disconnect from the database.\n    $dbh->disconnect();\n    if ($OK2INSERT) {\n        $dbh =\n\nDBI->connect(\"DBI:SQLite:dbname=C:/Lanosrep/beW/Perl/HelpPage/\narea.db\", \"\", \"\",\n\n{'RaiseError' => 1});\n        print \"Inserting into Database , @values.\";\n        $dbh->do(\"INSERT INTO area_status (areaID, survey_date,\nupdate_time,\n\nstatus ) VALUES ('$values[0]', '$values[1]', '$values[2]',\n'$values[3]')\");\n        $dbh->disconnect();\n    }\n}\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>", "from_address": "Patrick Rutkowski <rutski89@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "\nOn Apr 22, 2007, at 5:14 PM, chromatic wrote:\n\n> On Sunday 22 April 2007 14:08, Uri Guttman wrote:\n>\n>>>>>>> \"JP\" == Joerg Plate  writes:\n>>>>\n>>>> const int slot = (reg_alloc + 7) >> 3; reg_alloc = slot << 3;\n>>>>\n>>>> This is where I start not to understand.  Why reg_alloc + 7? Why\n>>>> shift left and right by 3?\n>>\n>>   JP> That's just a rounding up (if necessary) to a multiple of 8  \n>> (2<<3).\n>>\n>> and those sort of things should be macros as they are confusing\n>> otherwise and annoying to change. and named something like\n>> ROUND_UP_TO_BOUNDARY. as others have said it is a common idiom. and i\n>> agree that there should be comments on WHY the rounding is used/ \n>> needed.\n>\n> I figured it was a rounding, but I saw two magic numbers and didn't  \n> want to\n> guess what it was.\n>\n> Any volunteers to macroize this?\n>\n> Also, is anyone *sure* that this boundary is effective on both 32-  \n> and 64-bit\n> platforms?  I hate to make assumptions about alignment.\n\nI would rather make the side effects more explicit and throw in a  \ngood comment.\nHow about something like this?\n\nIndex: src/gc/register.c\n===================================================================\n--- src/gc/register.c\t(revision 18296)\n+++ src/gc/register.c\t(working copy)\n@@ -338,9 +338,16 @@\n      size_t reg_alloc = size_nip +\n          sizeof (STRING*) *  n_regs_used[REGNO_STR];\n-    const int slot = (reg_alloc + 7) >> 3;\n-    reg_alloc = slot << 3;\n+    const int slot;\n+    /* round reg_alloc up to the nearest multiple of 8 */\n+    reg_alloc = ((reg_alloc + 7) >> 3) << 3;\n+\n+    /* reg_alloc now divides evenly by 8 because of the previous\n+       rounding. A granualrity of 8 is arbitratly, it could have been\n+       some bigger power of 2 */\n+    slot = reg_alloc / 8;\n+\n      if (slot >= interp->ctx_mem.n_free_slots) {\n          const int n = slot + 1;\n          int i;\n\n"}
{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "brian d foy <brian.d.foy@gmail.com>", "subject": "Re: [svn:perl6-synopsis] r14421 - doc/trunk/design/syn", "body": "In article <4673C546.5060806@conway.org>, Damian Conway\n wrote:\n\n[ First, I should note that whatever we end up with, that's the party\nline and that's what I teach, but before we end up there, I know from\nmy years of experience teaching that certain sorts of questions are\ngoing to come up. I'm looking at this from the perspective of the\nstudent sitting in a class, not from the implementors perspective. ]\n\n\n> brian wrote:\n> \n>  > As you know, one of the biggest complaints about Perl is that you have\n>  > to have a lot of special rules knowledge to figure some things out.\n>  > Whether that is true doesn't really matter: people still complain about\n>  > it.\n>  >\n>  > In this case, it will actually be true.\n> \n> I don't think that's the case.\n\nI'm speaking at the programmer level, not the implementor level. For the\nguy in the trenches, this is a special case. This is more complexity\nfor the guy typing code, even if it's easier syntactically for the guy\nwriting the parser.\n\n\n>  > This impacts Learning Perl 6 rather early because it's a rule that\n>  > people need to know at the same time that we tell them that whitespace\n>  > is insignificant.\n> \n> I'm pretty sure \"Learning Perl 6\" won't say that.\n\nWell, it won't say that if it's not true, but until pretty recently\nit's been mostly true.\n\n> The rule you have to teach under the Separation model is:\n> \n>      \"Any line that starts with an = is Pod...and not part of your program.\"\n\nAnd that's something that now comes up very early in teaching the\nassignment operator. \n\n\n> Whereas the rule you have to teach under the Integration model is:\n\nWe don't teach any rule under this model, and it's been fine for over a\ndecade :)\n\nWhen we do teach the current Pod, the simple rule is that Pod starts:\n\n   * when Perl is expecting a new statement\n   * there is a =something at the beginning of the line\n\nWhich is considerably simpler than the long rule list you used to say\nthe same thing (which seems a bit of FUD, honestly).\n\n\n>  > So, if this is the case, how will a new Perl 6 user debug a program\n>  > failure when part of their program mysteriously disappears because\n>  > they just happened to have =begin at the beginning of a line?\n> \n> The same way they debug it when part of their program mysteriously\n> disappears because they just happened to have # at the beginning of a\n> line: \n\n> Except, of course, the Pod mysteriously vanishing will be considerably\n> easier to debug, because ALL lines starting with =begin vanish, whereas\n> only some lines beginning with # do.\n\nThat's not really the case. The # only affects one line, and a pound in\na literal string doesn't start a comment. People grok single line\ncomments very well. \n\nThe start of a Pod comment now affects it's line and the ones following\nit.\n\n\n> \n>  > Also, doesn't this then limit Pod to Perl 6 (which I thought was not\n>  > the goal)? I doubt other languages will want to deal with this\n>  > situation.\n> \n> As Smylers so ably pointed out, enabling Pod to be parsed independently\n> of the underlying language syntax actually makes it vastly easier to use\n> Pod with other languages.\n\nWell, easy to use Pod with other languages until they try to use the\nassignment operator at the beginning of the line, or a = in a literal\nstring at the beginning of a line.\n\n\nI know you think it's easier to teach and explain, but that's because\nyou came up with it. The notion that a special character in a certain\ncolumn means something was tough to explain to other people in FORTRAN\ntoo.\n\n\nThere are other things to consider, and to me it looks like this design\ndecision isn't based on what's easier for the Perl 6 programmer but\nwhat's easier for the implementors. It's not that I don't understand\nboth sides, I just disagree about where the complexity should be.\n\n"}
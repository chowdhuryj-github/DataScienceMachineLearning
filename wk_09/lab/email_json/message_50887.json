{"category": "ham", "to_address": "\"zentara\" <zentara@highstream.net>, <beginners@perl.org>", "from_address": "\"Bob McConnell\" <rvm@CBORD.com>", "subject": "RE: Inter-thread communications", "body": "> -----Original Message-----\n> From: Linux@lists.develooper.com \n> [mailto:Linux@lists.develooper.com] On Behalf Of zentara\n> Sent: Tuesday, June 19, 2007 2:55 PM\n> To: beginners@perl.org\n> Subject: Re: Inter-thread communications\n> \n> On Mon, 18 Jun 2007 12:58:31 -0400, rvm@CBORD.com (\"Bob McConnell\")\n> wrote:\n> \n> >I have two questions about this. First, is there a standard Perl IPC\n> >interface between threads? I am not familiar with pipes in \n> this context,\n> >although I have used mailboxes and single word messages in various\n> >multi-processing environments, including POSIX threads.\n> \n> This is a big topic, so I'll briefly try to bring you up to speed.\n> \n> I'm assuming you are talking about threads in the pure sense, \n> as opposed\n> to calling separate processes \"threads\". ( It's further confused by\n> MSWindows, emulating fork with threads).\n> \n> There are totally independent processes, for which you can do IPC with\n> pipes, sockets, shared memory segments, etc.\n> \n> Threads are different.\n> Threads are sort of concurrent code which can all run under the same\n> parent pid. If one thread exits, the whole thread system will die. So\n> care must be taken. However, you can easily share scalar data between\n> running threads, and this is their advantage.\n> \n> So the standard Perl IPC interface for threads, is shared variables:\n> see \"perldoc threads::shared\". Also to be\n> happy with threads under Perl, you need a version greater than 5.8\n> Perl5.6 uses an obsolete thread version which will give you trouble.\n> \n> If you are not specifically interested in perl threads, you \n> may want to\n> read \"perldoc perlipc\". The things mentioned in perlipc, are the\n> original methods of ipc, before threads came along (only recently). \n> \n> There are 2 things threads can do for you.\n> 1. Share variables in realtime between threads.\n> 2. Share filehandles between threads, by passing their fileno\n>     thru the shared variable mechanism.\n> \n> The problem is that one thread will not know if another thread has\n> changed a shared variable, so you either need an event-loop system,\n> or a complex while() loop to constantly monitor the values of \n> the shared\n> variables.\n> \n> The typical setup is a main thread which has an event loop (Tk, POE,\n> Glib, etc), and as many worker threads as you want. The worker threads\n> will do things and set shared variables, and the main thread will\n> monitor the value of the shared vars and do what is needed.\n> \n> The main thread will also clean up the worker threads at program end.\n> \n> >\n> >Second, is there a way to set this up so the transmit thread \n> timeout can\n> >be easily implemented as a side effect of waiting for the ACK/NAK to\n> >arrive on that interface? I was thinking of using a \n> semaphore, but they\n> >don't appear to be implemented on Win32.\n> \n> Yeah, it depends on how your code is written, but you can setup many\n> timers in an event-loop system to time out something. \n> Warning.... alarm \n> does not work well in threads, you need timers.\n> \n> See how GLib can help\n> http://perlmonks.org?node_id=538341\n> \n> Also there is POE, and (Tk and Gtk2 if you want a GUI).\n> \n> >\n> >For this emulation, the outgoing messages are read from a \n> text file and\n> >the incoming messages are stored in another text file. Timing of\n> >outgoing messages is controlled when that file is read. I am \n> hoping this\n> >can provide a workaround for the alarm failure I ran into on \n> the single\n> >threaded version as well as being a better emulation of the actual\n> >system.\n> \n> \n> I run linux, so there may be win32 problems that I'm unfamiliar with,\n> but all of it seems feasible.\n> \n> It seems that once the serial port connection is established, and you\n> have the filehandle, you could have a main thread to control, and 2 \n> worker threads, one to send, and one to receive.  You would setup\n> some shared variables, like \"$ack_received\" , etc., and share \n> the fileno\n> of the port filehandle between the threads.\n> Then again, with a proper IO::Select setup, you may not need threads\n> at all.\n> \n> You might want to ask this on http://perlmonks.org\n> A few monks there are good with win32, and Win32::SerialPort.\n> If you could show some pseudo-code it would be helpful to them.\n> \n> Goodluck,\n> zentara\n\nI have been trying to implement this in ActivePerl 5.8.8.820 on W2K, so\nI am working in the thread based fork() implementation. IPC does not\nseem to exist in that implementation.\n\nI had pretty much figured out that alarm doesn't work in Win32. I had\ntried to use it to interrupt read() on a serial port, and that wasn't\nworking. Neither did SIGINT or SIGTERM. The only way to get out of it\nwas Ctrl->Break, which shuts down the whole process.\n\nUnless the Glib timer can interrupt a serial port read() call, I don't\nsee any way to timeout a serial port input function on Win32.\nUnfortunately, that means I will probably need to steal one of the FC5\nboxes from the next room in order to get it to work.\n\nThank you,\n\nBob McConnell\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 115: added a ctdb_ltdb_lock_fetch_requeue() function in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 115\nrevision-id: tridge@samba.org-20070416135214-cb85876867405bbf\nparent: tridge@samba.org-20070416130336-89ba103e570a8324\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Mon 2007-04-16 23:52:14 +1000\nmessage:\n  added a ctdb_ltdb_lock_fetch_requeue() function\n  this will be the core of the non-blocking lock idea for ctdb, it will be used\n  in place of ctdb_ltdb_fetch(), but will also get a lock. It re-starts a request\n  if it needs to block\nmodified:\n  Makefile.in                    makefile.in-20061117234101-o3qt14umlg9en8z0-1\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  common/ctdb_ltdb.c             ctdb_ltdb.c-20061128065342-to93h6eejj5kon81-2\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'Makefile.in'\n--- a/Makefile.in\t2007-04-16 06:01:37 +0000\n+++ b/Makefile.in\t2007-04-16 13:52:14 +0000\n@@ -21,7 +21,7 @@\n EVENTS_OBJ = lib/events/events.o lib/events/events_standard.o\n \n CTDB_COMMON_OBJ = common/ctdb.o common/ctdb_daemon.o common/ctdb_client.o common/ctdb_io.o common/util.o common/ctdb_util.o \\\n-\tcommon/ctdb_call.o common/ctdb_ltdb.o common/ctdb_message.o \\\n+\tcommon/ctdb_call.o common/ctdb_ltdb.o common/ctdb_lockwait.o common/ctdb_message.o \\\n \tlib/util/idtree.o lib/util/db_wrap.o\n \n CTDB_TCP_OBJ = tcp/tcp_connect.o tcp/tcp_io.o tcp/tcp_init.o\n\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-04-11 04:54:47 +0000\n+++ b/common/ctdb.c\t2007-04-16 13:52:14 +0000\n@@ -190,7 +190,7 @@\n /*\n   called by the transport layer when a packet comes in\n */\n-static void ctdb_recv_pkt(struct ctdb_context *ctdb, uint8_t *data, uint32_t length)\n+void ctdb_recv_pkt(struct ctdb_context *ctdb, uint8_t *data, uint32_t length)\n {\n \tstruct ctdb_req_header *hdr;\n \n\n=== modified file 'common/ctdb_ltdb.c'\n--- a/common/ctdb_ltdb.c\t2007-04-11 01:01:42 +0000\n+++ b/common/ctdb_ltdb.c\t2007-04-16 13:52:14 +0000\n@@ -215,3 +215,49 @@\n \treturn tdb_chainunlock(ctdb_db->ltdb->tdb, key);\n }\n \n+/*\n+  called when we should retry the operation\n+ */\n+static void lock_fetch_callback(void *p)\n+{\n+\tstruct ctdb_req_header *hdr = p;\n+\tstruct ctdb_context *ctdb = talloc_find_parent_bytype(p, struct ctdb_context);\n+\tctdb_recv_pkt(ctdb, (uint8_t *)hdr, hdr->length);\n+\tprintf(\"PACKET REQUEUED\\n\");\n+}\n+\n+/*\n+  do a non-blocking ltdb_fetch with a locked record, deferring this\n+  ctdb request until we have the chainlock\n+ */\n+int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n+\t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n+\t\t\t\t struct ctdb_req_header *hdr, TDB_DATA *data)\n+{\n+\tint ret;\n+\tstruct tdb_context *tdb = ctdb_db->ltdb->tdb;\n+\tstruct lockwait_handle *h;\n+\t\n+\tret = tdb_chainlock_nonblock(tdb, key);\n+\n+\t/* first the non-contended path */\n+\tif (ret == 0) {\n+\t\tret = ctdb_ltdb_fetch(ctdb_db, key, header, hdr, data);\n+\t\tif (ret != 0) {\n+\t\t\ttdb_chainunlock(tdb, key);\n+\t\t}\t\n+\t\treturn ret;\n+\t}\n+\n+\t/* now the contended path */\n+\th = ctdb_lockwait(ctdb_db, key, lock_fetch_callback, hdr);\n+\tif (h == NULL) {\n+\t\ttdb_chainunlock(tdb, key);\n+\t\treturn -1;\n+\t}\n+\n+\t/* we get an extra reference to the packet here, to \n+\t   stop it being freed in the top level packet handler */\n+\t(void)talloc_reference(ctdb_db, hdr);\n+\treturn 0;\n+}\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-04-13 10:38:24 +0000\n+++ b/include/ctdb_private.h\t2007-04-16 13:52:14 +0000\n@@ -353,6 +353,10 @@\n int ctdb_ltdb_store(struct ctdb_db_context *ctdb_db, TDB_DATA key, \n \t\t    struct ctdb_ltdb_header *header, TDB_DATA data);\n void ctdb_queue_packet(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n+int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n+\t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n+\t\t\t\t struct ctdb_req_header *hdr, TDB_DATA *data);\n+void ctdb_recv_pkt(struct ctdb_context *ctdb, uint8_t *data, uint32_t length);\n \n struct ctdb_call_state *ctdb_call_local_send(struct ctdb_db_context *ctdb_db, \n \t\t\t\t\t     struct ctdb_call *call,\n@@ -449,4 +453,8 @@\n */\n int ctdb_client_store_unlock(struct ctdb_record_handle *rec, TDB_DATA data);\n \n+struct lockwait_handle *ctdb_lockwait(struct ctdb_db_context *ctdb_db,\n+\t\t\t\t      TDB_DATA key,\n+\t\t\t\t      void (*callback)(void *), void *private_data);\n+\n #endif\n\n"}
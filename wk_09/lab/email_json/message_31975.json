{"category": "ham", "to_address": "kapatp@gmail.com", "from_address": "Adaikalavan Ramasamy <ramasamy@cancer.org.uk>", "subject": "Re: [R] use loop or use apply?", "body": "Can you check if the following gives you what you want?\n\n    tmp <- rbind( A, B )\n    dis <- dist( tmp )\n    nA  <- nrow(A)\n    nB  <- nrow(B)\n    dis[ 1:nA, nA + 1:nB ] ## output\n\nIf it works, this suggestion comes with the caveat that it might be \ncomputationally inefficient compared with using for() loops for very \nlarge values of (a,b) or highly discordant values of (a,b). However I am \nhoping the gain from dist() being coded in C should offset it.\n\nTry experimenting to find the optimal speed etc. Also have a look at \nmapply() examples to see if they are useful.\n\nRegards, Adai\n\n\n\nPrasenjit Kapat wrote:\n> Hi,\n> \n> I have two matrices, A (axd) and B (bxd). I want to get another matrix C (axb) \n> such that, C[i,j] is the Euclidean distance between the ith row of A and jth \n> row of B. In general, I can say that C[i,j] = some.function (A[i,], B[j,]). \n> What is the best method for doing so? (assume a < b)\n> \n> I have been doing some exploration myself: Consider the following function: \n> get.f, in which, 'method=1' is the rudimentary double for loop; 'method=2' \n> avoids one loop by constructing a bigger matrix, but doesn't use \n> apply(); 'method=3' avoids both the loops by using apply() and constructing \n> bigger matrices; 'method=4' avoids constructing bigger matrices by using \n> apply() twice.\n> \n> get.f <- function (A, B, method=2) {\n> \tif (method == 1){\n> \t\ta <- nrow(A); b <- nrow(B);\n> \t\tC <- matrix(NA, nrow=a, ncol=b);\n> \t\tfor (i in 1:a) \n> \t\t\tfor (j in 1:b) \n> \t\t\t\tC[i,j] <- sum((A[i,]-B[j,])^2)\n> \t} else if (method == 2 ) {\n> \t\ta <- nrow(A); b <- nrow(B); d <- ncol(A);\n> \t\tC <- matrix(NA, nrow=a, ncol=b);\n> \t\tfor (i in 1:a) \n> \t\t\tC[i,] <- rowSums((matrix(A[i,], nrow=b, ncol=d, byrow=TRUE) - B) ^ 2)\n> \t} else if (method == 3) {\n> \t\t\tC <- t(apply(A, MARGIN=1, FUN=\"FUN1\", BB=B)); # transpose is needed\n> \t} else if (method == 4) {\n> \t\t\tC <- t(apply(A, MARGIN=1, FUN=\"FUN2\", BB=B))\n> \t}\n> }\n> \n> FUN1 <- function(aa, BB)\n>   return(rowSums(\n> \t\t(matrix(aa, nrow=nrow(BB), ncol=ncol(BB), byrow=TRUE) - BB)^2)\n>   )\n> \n> FUN2 <- function(aa, BB)\n> \treturn(apply(BB, MARGIN=1, FUN=\"FUN3\", aa=aa))\n> \n> FUN3 <- function(bb,aa) return(sum((aa-bb)^2))\n> \n> ### With these methods and the following intitializations,\n> \n> a <- 100; b <- 1000; d <- 100; n.loop <- 20;\n> \n> A <- matrix(rnorm(a*d), ncol=d)\n> B <- matrix(rnorm(b*d), ncol=d)\n> \n> all.times <- matrix(0,nrow=5,ncol=4)\n> rownames(all.times) <- rownames(as.matrix(system.time(NULL)))\n> \n> for (i in 1:4)  \n> \tfor (j in 1:n.loop)\n> \t\tall.times[,i] <- all.times[,i] + \n> \t\t\t\tas.matrix(system.time(C <- get.f(A=A, B=B, method=i)))\n> \n> all.times <- all.times / n.loop\n> print(all.times)\n> \n>                [,1]    [,2]    [,3]    [,4]\n> user.self   4.0554 1.50010 1.50130 4.51285\n> sys.self     0.0370 0.02420 0.01800 0.04260\n> elapsed    4.2705 1.58865 1.59475 6.07535\n> user.child 0.0000 0.00000 0.00000 0.00000\n> sys.child   0.0000 0.00000 0.00000 0.00000\n> \n> 'method=2' stands out be the best and 'method=1' (for loops) beats 'method=4' \n> (two apply()s)... Is that expected?\n> \n> Is it possible to improve over 'method=2'?\n> \n> Thanks\n> PK\n> \n> PS: The mail text seems fine in my composer, I hope, it looks decent in your \n> reader.\n> \n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n> \n> \n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
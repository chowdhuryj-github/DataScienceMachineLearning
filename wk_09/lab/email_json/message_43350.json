{"category": "ham", "to_address": "\"sgallagh@mail.med.upenn.edu\" <sgallagh@mail.med.upenn.edu>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: transpose/reshape wide dataset to long and vice versa", "body": "On 6/5/07, sgallagh@mail.med.upenn.edu  wrote:\n> hello all--\n>\n> I have been trying to wrap my head around the right approach to doing what I\n> would normally do with SAS's \"PROC TRANSPOSE\" in Perl. The below toy dataset is\n> summarized from http://www.ats.ucla.edu/stat/sas/modules/wtol_transpose.htm.\n>\n> I have searched CPAN and google and the list to the best of my ability for any\n> hints related to transposing a \"long\" dataset to a \"wide\" dataset and vice\n> versa. I assume I am missing an obvious solution to what I presume is a common\n> dilemma?\n>\n> LONG:\n> famid year faminc\n> 1 96 40000\n> 1 97 40500\n> 1 98 41000\n> 2 96 45000\n> 2 97 45400\n> 2 98 45800\n> 3 96 75000\n> 3 97 76000\n> 3 98 77000\n>\n> desired output,WIDE: .\n> Obs    famid    _NAME_    faminc96    faminc97    faminc98\n>  1       1      faminc      40000       40500       41000\n>  2       2      faminc      45000       45400       45800\n>  3       3      faminc      75000       76000       77000\n>\n> Variables I think I would need to make use of would be:\n> 1) BY--uniquely identifies an individual, an observation, a primary key etc\n> 2) ID--the category or grouping\n> 2) var--the variable values to be transposed\n> 3) prefix--(concatenated to the id for naming column output in long to wide)\n>\n> if anyone has any thoughts on how to approach this problem or pointers to an\n> already rolled solution I would be most appreciative.\n>\n> best,\n> sg\n>\n\nIt sounds like you need a hash of HoAs (hash of arrays).  Look at\nperldoc perldsc for more detailed info, but here is some ugly code\nthat seems to do what you want.  It is not very flexible, but probably\ncould be made so.\n\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nmy %ds;\n\n#the first line is the headers, so read it\n#in to use as keys to the hash\n#FIXME: remove the hardcodes and make this a function\nmy $id    = 'famid';\nmy %joins = (\n        _NAME_ => [ 'faminc', 'year' ]\n);\nmy @headers = split ' ', ;\nmy $observation = 1; #aka rows if remember SAS correctly\nwhile () {\n        my %rec = zip(\\@headers, [split ' ']);\n        my $id = $rec{$id}; #this masks the earlier $id\n        unless ($ds{$id}) {\n                $ds{$id}{obs} = $observation++;\n        }\n        for my $name (sort keys %joins) {\n                my ($col, $var) = @{$joins{$name}};\n                my $key = \"$col$rec{$var}\";\n                $ds{$id}{$name} = $col;\n                $ds{$id}{$key} = $rec{$col};\n        }\n}\n\nmy @keys = sort(uniq(map { keys %{$ds{$_}} } keys %ds));\n\nprint join(\"\\t\", $id, @keys), \"\\n\";\nfor my $id (sort keys %ds) {\n        print join(\"\\t\", $id, map { $ds{$id}{$_} } @keys), \"\\n\";\n}\n\n\n#in Perl 6 a function like this, but better,\n#is part of the core, I can't wait\nsub zip {\n        my ($a1, $a2) = @_;\n        my $min = @$a1 < @$a2 ? $#$a1 : $#$a2;\n        my @result;\n        for my $i (0 .. $min) {\n                push @result, $a1->[$i], $a2->[$i];\n        }\n        return @result;\n}\n\nsub uniq {\n        my %hash = map { $_ => 1 } @_;\n        return keys %hash;\n}\n\n__DATA__\nfamid year faminc\n1 96 40000\n1 97 40500\n1 98 41000\n2 96 45000\n2 97 45400\n2 98 45800\n3 96 75000\n3 97 76000\n3 98 77000\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
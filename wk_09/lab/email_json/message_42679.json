{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: [svn:perl6-synopsis] r14415 - doc/trunk/design/syn", "body": "Larry Wall wrote:\n> : * In item context, a list of captures becomes a single Array object,\n> : and the question about whether or not it gets flattened gets deferred\n> : until its contents get looked at in list, slice, or hash context.\n>\n> That's the intent.  $() used to assume @@ inside till this latest\n> change, but that seemed insufficiently lazy to me...\n>\n> But it kinda means there's yet another list context that doesn't\n> decide yet, used explicitly by the insides of \\(...) and implicitly\n> by the $() context.  Not sure if it needs a name yet, or whether it's\n> a design smell.\n\nIMHO, no name is needed; just note that \\(...) generates a variation\nof the list context that is agnostic to flattening, but is otherwise\nequivalent to \"list\".\n\n> Arguably \"list\" should be non-committal and we give\n> @() a different name like \"flat\", but that grates in my brain for\n> some reason, if only because most list contexts would in the end\n> be flat anyway.  And \"list\" in English already implies something\n> flatter than, say, an \"outline\".\n\n...which tends to be more akin to \"slice\".  In fact, consider renaming\n\"slice\" as \"outline\".  Sure, it's two characters longer; but it's\n_much_ more descriptive of what's going on.  \"Slice\" strikes me as\nsomething of a holdover from its origins in array indices.\n\nConversely, our agnostic list _is_ flatter than a slice or outline,\njust like a hardcore list is flatter than an agnostic list.  I'd tend\nto agree about keeping \"list\" tied to the flattened stuff.  IMHO,\nyou're not going to find anything in English to represent the agnostic\n\"list of captures\".\n\nIn essence, we have: list, list-of-captures, and slice (or outline?);\nalso, hash and item.\n\n> : Meanwhile, 'zip' produces a list of captures - which, because list\n> : context is the default \"plural\" context, immediately gets flattened\n> : most of the time.  As I see it, then, the serial equivalent to\n> : 'zip(@a;@b)' would be '(@a;@b)', and 'list(@a;@b)' would be the serial\n> : equivalent to 'list(zip(@a;@b))'.\n>\n> That doesn't make sense to me.  You seem to be thinking that semicolon\n> has zip semantics, when it doesn't.  All ; does is make a list of\n> captures.\n\nMy focus in this comparison is on what is being produced, rather than\non what is being passed in.\n\nMy understanding is that 'zip' produces a list of captures.  It's just\nthat the default context that zip is likely to work in is list\ncontext, which flattens that list of captures.  Or am I wrong about\nthis?  The other alternative is that zip knows whether it's being\ncalled in list or slice/outline context, and produces its output\naccordingly.  I was assuming that zip wouldn't need to know; but I\ncould be wrong about this.\n\nIf zip _does_ tailor its return value according to the variety of list\ncontext that it finds itself in, then 'list()' is _still_ not the\nserial analog to 'zip()', any more than 'slice()' is, since both\nimpose a specific context on the product.  You'd need a new function\nthat takes a list of captures as its parameters, and produces a flat\nlist in list context or a slice or outline in slice/outline context.\n\n> : Or does '(@a;@b)' default to slice context?\n>\n> Parentheses don't supply context.  They only group.  (@a;@b) returns\n> a list of captures.  It requires a binding (or other sigil) coercion\n> to supply context.\n\nThe parentheses weren't concerning me here; the semicolon within\nbrackets was.  I've been working under the assumption that a bracketed\n@a;@b produces an agnostic \"list of captures\", which then gets\nflattened or structured when it hits list or slice context,\nrespectively; I was asking about the possibility that I was wrong\nabout this, and that bracket-within-semicolons produces a\nslice/outline outright.\n\n--\n\nThis does bring up another question, though: when are you in list\ncontext, and when are you in list-of-captures context?  That is, when\ndo you force a list of captures to flatten, and when do you leave it\nalone?\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
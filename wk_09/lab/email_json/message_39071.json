{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14409 - doc/trunk/design/syn", "body": "Author: larry\nDate: Wed May 30 09:13:35 2007\nNew Revision: 14409\n\nModified:\n   doc/trunk/design/syn/S06.pod\n\nLog:\nAdded \"is reparsed\" and removed $ kludge\nExplained caching semantics more thoroughly as suggested by Tim Bunce++\n\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tWed May 30 09:13:35 2007\n@@ -13,9 +13,9 @@\n \n   Maintainer: Larry Wall \n   Date: 21 Mar 2003\n-  Last Modified: 29 May 2007\n+  Last Modified: 30 May 2007\n   Number: 6\n-  Version: 85\n+  Version: 86\n \n \n This document summarizes Apocalypse 6, which covers subroutines and the\n@@ -1467,31 +1467,61 @@\n =item C\n \n Specifies the subrule by which a macro call is parsed.  The parse\n-always starts after the macro token, but the token may be referred\n-to within the subrule as C<< $ >>.\n+always starts after the macro's initial token.\n+\n+=item C\n+\n+Also specifies the subrule by which a macro call is parsed, but restarts\n+the parse before the macro's initial token, usually because you want\n+to parse using an existing rule that expects to traverse the initial\n+token.\n \n =item C\n \n-Marks a subroutine as being memoized, or at least memoizable.  The\n+Marks a subroutine as being memoized, or at least memoizable.\n+In the abstract, this cache is just a hash where incoming argument\n+Cs are mapped to return values.  If the C is found in\n+the hash, the return value need not be recalculated.  If you use\n+this trait, the compiler will assume two things:\n+\n+=over\n+\n+=item *\n+\n+A given C would always calculate the same return value.  That is,\n+there is no state hidden within the dynamic scope of the call.\n+\n+=item *\n+\n+The cache lookup is likely to be more efficient than recalculating\n+the value in at least some cases, because either most uncached calls\n+would be slower (and reduce throughput), or you're trying to avoid a\n+significant number of pathological cases that are unacceptably slow\n+(and increase latency).\n+\n+=back\n+\n+This trait is a suggestion to the compiler that caching is okay.  The\n compiler is free to choose any kind of caching algorithm (including\n non-expiring, random, lru, pseudo-lru, or adaptive algoritms, or\n even no caching algorithm at all).  The run-time system is free to\n choose any kind of maximum cache size depending on the availability\n of memory and trends in usage patterns.  You may suggest a particular\n-cache size by passing a numeric argument, and some of the possible\n+cache size by passing a numeric argument (representing the maximum number\n+of unique C values allowed), and some of the possible\n algorithms may pay attention to it.  You may also pass C<*> for the\n size to request a non-expiring cache (complete memoization).  The\n compiler is free to ignore this too.\n \n-The intent of this pragma is to specify performance hints without\n-mandating any exact behavior.  Use of this pragma should not change\n-semantics of the program, and this pragma will not be extended to\n-reinvent other existing ways of achieving the same effect.  To gain\n-more control, write your own trait handler to allow the use of a more\n-specific trait, such as \"C\".  Alternately, just\n-use a state hash keyed on the sub's argument capture to write\n-your own memoization with complete control from within the subroutine\n-itself.\n+The intent of this trait is to specify performance hints without\n+mandating any exact behavior.  Proper use of this trait should not\n+change semantics of the program; it functions as a kind of \"pragma\".\n+This trait will not be extended to reinvent other existing ways of\n+achieving the same effect.  To gain more control, write your own\n+trait handler to allow the use of a more specific trait, such as\n+\"C\".  Alternately, just use a state hash keyed on the\n+sub's argument capture to write your own memoization with complete\n+control from within the subroutine itself.\n \n =item C\n"}
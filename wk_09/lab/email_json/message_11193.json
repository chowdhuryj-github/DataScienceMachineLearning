{"category": "ham", "to_address": "Perl Beginners <beginners@perl.org>", "from_address": "\"John W. Krahn\" <krahnj@telus.net>", "subject": "Re: Nested loop", "body": "Chas Owens wrote:\n> On 4/20/07, yitzle  wrote:\n>> There's been mentions of efficiency.\n>> I'm under the impression that for the uses Perl is put to, the\n>> efficiency of a loop is sorta irrelevent. If you are doing\n>> harddrive/network access, the performance gain of one loop over the\n>> other is more of less invisible.\n>> Come to think of it, the time for interpretting got to overshadow the\n>> performance gain...\n> \n> I was trying to address all arguments for the use of C-style for.  In\n> general, though, premature optimization is a waste of time.  You\n> should be aware of the general cost of the constructs you use (that is\n> why I occasionally post benchmarks for alternate algorithms), but you\n> should be more concerned with making what you write clearly express\n> your intent.  This is why I prefer\n> \n> my @a = (0 .. 10);\n> my $i = 0;\n> for my $elem (grep {not $i++ % 3} @a) {\n>       func($elem);\n> }\n> \n> to\n> \n> for (my $i = 0; $i < @a; $i += 3) {\n>    func($a[$i]\n> }\n> \n> The grep clearly states that I am looking for something and its block\n> tells me what the criteria are.\n\nYou are omitting one critical argument.  For people who are stuck with older\nversions of Perl and in your grep() example above the foreach expression\ncreates its list in memory which may cause the program to die if the list is\nlarge enough while the C style for loop does not have this problem.\n\n\n\nJohn\n-- \nPerl isn't a toolbox, but a small machine shop where you can special-order\ncertain sorts of tools at low cost and in short order.       -- Larry Wall\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 497: choose the most connected node first in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 497\nrevision-id: tridge@samba.org-20070607091727-nyesysrrvcjrbgf3\nparent: tridge@samba.org-20070607083937-cr7d8z9lf4cyxckz\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Thu 2007-06-07 19:17:27 +1000\nmessage:\n  choose the most connected node first\nmodified:\n  common/ctdb_recoverd.c         recoverd.c-20070503213540-bvxuyd9jm1f7ig90-1\n=== modified file 'common/ctdb_recoverd.c'\n--- a/common/ctdb_recoverd.c\t2007-06-07 08:39:37 +0000\n+++ b/common/ctdb_recoverd.c\t2007-06-07 09:17:27 +0000\n@@ -790,11 +790,67 @@\n }\n \n \n+/*\n+  elections are won by first checking the number of connected nodes, then\n+  the priority time, then the vnn\n+ */\n struct election_message {\n+\tuint32_t num_connected;\n+\tstruct timeval priority_time;\n \tuint32_t vnn;\n-\tstruct timeval priority_time;\n };\n \n+/*\n+  form this nodes election data\n+ */\n+static void ctdb_election_data(struct ctdb_recoverd *rec, struct election_message *em)\n+{\n+\tint ret, i;\n+\tstruct ctdb_node_map *nodemap;\n+\tstruct ctdb_context *ctdb = rec->ctdb;\n+\n+\tZERO_STRUCTP(em);\n+\n+\tem->vnn = rec->ctdb->vnn;\n+\tem->priority_time = rec->priority_time;\n+\n+\tret = ctdb_ctrl_getnodemap(ctdb, CONTROL_TIMEOUT(), CTDB_CURRENT_NODE, rec, &nodemap);\n+\tif (ret != 0) {\n+\t\treturn;\n+\t}\n+\n+\tfor (i=0;inum;i++) {\n+\t\tif (!(nodemap->nodes[i].flags & NODE_FLAGS_DISCONNECTED)) {\n+\t\t\tem->num_connected++;\n+\t\t}\n+\t}\n+\ttalloc_free(nodemap);\n+}\n+\n+/*\n+  see if the given election data wins\n+ */\n+static bool ctdb_election_win(struct ctdb_recoverd *rec, struct election_message *em)\n+{\n+\tstruct election_message myem;\n+\tint cmp;\n+\n+\tctdb_election_data(rec, &myem);\n+\n+\t/* try to use the most connected node */\n+\tcmp = (int)myem.num_connected - (int)em->num_connected;\n+\n+\t/* then the longest running node */\n+\tif (cmp == 0) {\n+\t\tcmp = timeval_compare(&myem.priority_time, &em->priority_time);\n+\t}\n+\n+\tif (cmp == 0) {\n+\t\tcmp = (int)myem.vnn - (int)em->vnn;\n+\t}\n+\n+\treturn cmp > 0;\n+}\n \n /*\n   send out an election request\n@@ -809,8 +865,7 @@\n \t\n \tsrvid = CTDB_SRVID_RECOVERY;\n \n-\temsg.vnn = vnn;\n-\temsg.priority_time = rec->priority_time;\n+\tctdb_election_data(rec, &emsg);\n \n \telection_data.dsize = sizeof(struct election_message);\n \telection_data.dptr  = (unsigned char *)&emsg\n@@ -821,7 +876,7 @@\n \t */\n \tret = ctdb_ctrl_setrecmaster(ctdb, CONTROL_TIMEOUT(), vnn, vnn);\n \tif (ret != 0) {\n-\t\tDEBUG(0, (__location__ \" failed to send recmaster election request\"));\n+\t\tDEBUG(0, (__location__ \" failed to send recmaster election request\\n\"));\n \t\treturn -1;\n \t}\n \n@@ -843,16 +898,14 @@\n \tint ret;\n \tstruct election_message *em = (struct election_message *)data.dptr;\n \tTALLOC_CTX *mem_ctx;\n-\tint cmp;\n \n \tmem_ctx = talloc_new(ctdb);\n-\t\t\n+\n \t/* someone called an election. check their election data\n \t   and if we disagree and we would rather be the elected node, \n \t   send a new election message to all other nodes\n \t */\n-\tcmp = timeval_compare(&em->priority_time, &rec->priority_time);\n-\tif (cmp > 0 || (cmp == 0 && em->vnn > ctdb->vnn)) {\n+\tif (ctdb_election_win(rec, em)) {\n \t\tret = send_election_request(rec, mem_ctx, ctdb_get_vnn(ctdb));\n \t\tif (ret!=0) {\n \t\t\tDEBUG(0, (__location__ \" failed to initiate recmaster election\"));\n\n"}
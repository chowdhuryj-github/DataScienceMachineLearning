{"category": "ham", "to_address": "beginners@perl.org, perl-beginners@moderators.isc.org", "from_address": "Paul Lalli <mritty@gmail.com>", "subject": "Re: Array of Array refs", "body": "On May 28, 3:26 pm, googleA...@screenlight.com (Brian) wrote:\n> On May 27, 9:00 pm, googleA...@screenlight.com (Brian) wrote:\n>\n>\n>\n>\n>\n> > Hi All-\n> >   I am trudging through some DBI, XML, etc.. I had a problem and was\n> > baffled by how to get at array elements out of a series of pushed\n> > array refs. But, by simplifying the problem, I found that the syntax I\n> > used was in error. here is the small sample, already debugged. Hope\n> > this helps someone...\n>\n> > #!/usr/bin/perl\n>\n> >         my @tRespsA;\n>\n> >         my @fieldList = ( \"one\", \"two\", \"three\", \"four\" );\n> >         my @r1 = ( 1, 2, 3, 4 );\n> >         my @r2 = ( 13, 14, 15, 16 );\n> >         my @r3 = ( 23, 24, 25, 26 );\n>\n> >         push @tRespsA, \\@r1;\n> >         push @tRespsA, \\@r2;\n> >         push @tRespsA, \\@r3;\n>\n> >         foreach my $tRowRef ( @tRespsA ) {\n> >                 my $tCnt=0;\n> >                 foreach my $tFld (@fieldList) {\n> >                         #if ( $tRowRef->[ $tCnt] eq \"\") { next; }\n> >                         print $tFld . \"='\" . $tRowRef->[ $tCnt++ ] . \"' \\r\";\n> >                 }\n> >         }\n>\n>  oh yes, more important than all that minutiae... the push did not\n> work for me in the working code.\n\nThe push worked absolutely fine.  It just didn't do what you wanted it\nto.  Learning how to parse your problem should be your first step\ntoward becoming a better programmer.\n\n> The array was being rewritten.\n\nThen you didn't delcare your variables in the correct scope.  As a\ngeneral rule of thumb, declare your variables in the smallest scope\npossible.\n\n> I had to use an array copy\n>\n>   push @tRespsA, [ @r1 ];   ## copy contents to an anonymous array,\n> push array ref\n\nDo you understand *why* that was necessary?  Do you understand the\ndifference between these two pieces of code?\n\n#Sample 1\nmy @array;\nmy @BigArray;\nfor (1..5) {\n   @array = get_contents();\n   push @BigArray(\\@array);\n}\n\n#Sample 2;\nmy @BigArray;\nfor (1..5) {\n   my @array = get_contents();\n   push @BigArray(\\@array);\n}\n\n\nIn the first, you're reusing the same array over and over again.  Each\ntime, you're overwriting the contents of the array with new values,\nbut you keep pushing references to THE SAME ARRAY onto @BigArray.\n\nIn the second, you constantly create and destroy a brand new array\neach time through the for loop.  The array gets created, it is filled\nwith contents, a reference to that array is created, that reference is\npushed onto @BigArray, and then that array goes out of scope.  The\ncontents are still accessable via the reference you pushed onto\n@BigArray, but via no other means.  Next iteration, a brand new array\nis created.\n\nThis might make it more clear:\n\nmy @BigArray;\nmy @array1;\nfor (1..3) {\n   my @array2;\n   my $ref1 = \\@array1;\n   my $ref2 = \\@array2;\n   push @BigArray, $ref1, $ref2;\n\n   print \"$ref1 - $ref2\\n\";\n}\n__END__\n\nOutput:\nARRAY(0x37c38) - ARRAY(0x37c80)\nARRAY(0x37c38) - ARRAY(0x2537c)\nARRAY(0x37c38) - ARRAY(0x25094)\n\n\nDo you see now?  By declaring only one instance of @array1, you're\ngetting the same array every time you take a reference to it, so\nwithin the for loop, you keep changing the contents of the same\narray.  @array2, on the other hand, is a completely new and unrelated\narray each time through the for loop.\n\nPaul Lalli\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "\"perl6-language@perl.org\" <perl6-language@perl.org>", "from_address": "Damian Conway <damian@conway.org>", "subject": "Re: Referring to source code within Perldoc: the new A<> code", "body": "Mark Overmeer wrote:\n\n> This is exactly the form of documentation you do *not* want the\n> user to write, for various reasons:\n\nWell, I agree it is the form that \"you\" (singular, specific) do not want; but \nI'm not sure it's bad for \"you\" (plural, generic) to write in all cases. ;-)\n\n\n>   * The explicit naming of the class name in method and attribute\n>     descriptions is in general a bad idea: by inheritance, you get\n>     sub-classes which also provide this method.  In the people's\n>     mind (I mean \"normal people\", not our \"perl guru\"), this\n>     requires continuous translations which distracts from the message.\n\nA dedicated OO documentation tool could certainly do a better job in that \ncase, I heartily agree. I'm looking forward to using one.\n\n\n>   * How do you see this syntactically work in combination with the\n>     item list? At least the POD(5) needed that.  I need a combined\n>     example.\n\nI'm not sure I understand what you're asking here. Can you describe the \nexample you'd like to see?\n\n\n>   * Having aliases is pratical, for referencing.  However, in this\n>     latter example it is used to help the programmer to shoot himself\n>     in the foot.  If you allow people to say \"class\" each time they\n>     mean \"role\", or \"function\" where it is \"method\", then on the long\n>     run people will start making avoidable programming mistakes.\n> \n>     In the chosen approach, this abuse cannot be avoidable. But it\n>     may be a wise not to promote it by using it as example.\n\nA good point. I will remove the example.\n\n\n>   * Using ambient back-references this way probably requires a\n>     two-pass document generator. AFAIK this is not required for the\n>     design of POD6 so far.\n\nActually a two-pass generator is already required for Pod. A second pass is \nalways necessary whenever there are any forward-targetted L<#local link> \nformatting codes in a document.\n\n\n>   * the A<(..)> syntax is nice, but has a few dangers.  Serious\n>     problems.  Your examples are a bit brief.  A little larger:\n> \n>          method eat(Food $meal) {...}\n> \n>        =for DESCRIPTION\n>        The A() method has the following argument list: A<(..)>\n> \n>     Now the method gets implemented:\n> \n>          method eat(Food $meal) {\n>             if($manger.isFull) { $manger.clean }\n>          }\n> \n>        =for DESCRIPTION\n>        The A() method has the following argument list: A<(..)>\n> \n>     Oops... now the argument list became (without warning)\n>     \"$manger.isFull\"   So, either you impose a strict doc order, forcing\n>     people into \"your style\", or people have to use an alias everywhere,\n>     bulking the file. More subtle examples of this problem can be\n>     created, for instance when the method defines a return type\n\nSure. But this is true of any scheme that doesn't do full parsing of the \nambient source code. Which Pod isn't going to do (but which, of course, you \nmay well choose to do in another documentation mark-up layer built on top of Pod).\n\n\n>   * In the manual-page of my sub-class, I want to refer to the\n>     documentation of specific attributes and methods.  How?\n>     Can I also refer to elements in distributions which are not\n>     mine, so where I cannot add X<> or such?  For instance,\n>     when I inherit from a core Perl class?\n\nThis is not possible, using this mechanism, due to the lexical scoping of the \naliases. An automatic documentation-generator tool (that produces Pod) is more \nappropriate for this task.\n\n\n>   * In my sub-class, I want to enlist automatically the methods\n>     and attributes which are inherited.  Automatically of course,\n>     because I want to avoid mistakes.  In case of multi-level\n>     inheritance, some way I need to know and show where each is\n>     defined. How?\n\nAn automatic documentation-generator tool is more appropriate for this task too.\n\n\n>     For instance, if your look at IO::File in Perl5, it defines\n>     some own method, but then simply says: see also IO::Handle\n>     and IO::Seekable.  IO::Handle says: see also perlfunc and\n>     perlvar.  The more extended your OO model is, (Perl6's\n>     structure is probably much more extended), the more levels\n>     of hierarchy you get.  Are users able to understand this?\n>     Are developers able to maintain manual interface description\n>     lists without mistakes?\n>     Is the shown syntax sufficient for tools to create it\n>     automatically?  As decided, of course without looking at\n>     the perl code itself.\n\nOf course not. Pod is static explicit documentation mark-up. That mark-up may \nbe generated by humans or by clever documentation-from-code tools. Those \nclever tools are what you're looking for, and what I'm sure you will easily be \nable to create, using the Pod 6 and Perl 6 parsers as foundations, and perhaps \nthe Pod syntax as a output format (targetting the wealth of Pod-to-Whatever \ntranslators we will provide).\n\n\n> Your design goal of A<> is to avoid replication of code information,\n> in which you succeeded.  Now your write\n> \n>          method eat(Food $meal) {...}\n> \n>      =for DESCRIPTION\n>      The A() method has the following argument list: A<(..)>\n> \n> In stead of\n> \n>          method eat(Food $meal) {...}\n> \n>      =for DESCRIPTION\n>      The eat() method has the following argument list: Food $meal. \n> \n> What I would like is to get rid of the replication of that description\n> line as well, using back-end specific templates/style-sheets.\n\nSure. I fully and completely understand that. And you will definitely be able \nto build a tool that does that.\n\n\n> What about:\n> \n>       =definition\n>          method eat(Food $meal) {...}\n> \n>       =for DESCRIPTION\n>       ...\n\nWith only a slight modification that is already valid Pod:\n\n         =Definition\n\n            method eat(Food $meal) {...}\n\n         =for DESCRIPTION\n         ...\n\n(The user-specified block type has to be mixed case, and the block requires an \nempty line after it otherwise the \"method...\" line will be Pod, not Perl code)\n\nBut with that slight change in syntax you could then use the standard Pod \nparser to segment your document into mark-up and ambient code, search the \nresulting object tree for 'Definition' nodes, grab the immediately following \nambient code block, parse it using Perl 6's own grammar, then autogenerate \ncontent for the next 'DESCRIPTION' node in whatever form you would like it to \nbe, using information extracted from the parsed code.\n\nOf course, you could just as easily do that without needing the '=Definition' \nblock at all, since you could simply look for 'DESCRIPTION' blocks in the \nparsed Pod and then parse any definition from any preceding ambient block for \ncode.\n\nOr, since the Perl 6 grammar can preserve Perl comments in the parse tree, you \ncould even create a tool that understood an abbreviated notation such as:\n\n            method eat(Food $meal) {...}  #=Definition=#\n\n         =for DESCRIPTION\n         ...\n\nand which documented only Perl definitions that are followed immediately by a \ncomment in the appropriate special form.\n\nThe point is: the design of Pod allows you to use *any* of those alternatives. \nIt does that by providing a simple and extensible mark-up notation, an \nefficient parser for that notation, and good integration with Perl itself, so \nyou can build whatever kind of documentation tools you find most useful.\n\n\nAnd, no, I don't propose to \"canonize\" just one of those special ways of \nauto-creating documentation by designing it into the core specification of \nPerl 6/Pod 6. Instead, I intend to provide a simple, independent mechanism for \nadmixing code and static documentation, with a reliable and efficient parser \nto separate them again. Then I propose to allow more experienced and cleverer \npeople (such as yourself) to develop powerful tools on top of those basic \nmechanisms.\n\nIn other words, in designing Pod I'm attempting to create something at the \nabstraction level of RTF or LaTeX or XHTML, not something analogous to MS Word \nor Maple or HyperCard. That is: something that you can use directly for simple \ntasks, and something you can also build tools on top of...to handle more \nsophisticated requirements.\n\n\n\n> In this case, the Perl and POD are using the text in the file\n> in an overlapping way, but still the Perl6 and POD6 parsers are\n> fully separate. \n\nThat's not the case. As Larry has confirmed recently, to each parser (perl6 or \nPerl6::Pod::Parser) everything in a source file will be either Perl or Pod \n(and never both). And the only place where the two parsers will disagree is \ninside a Perl string that happens to contain a Pod block.\n\nIn the example you gave, both Perl 6 and Pod 6 would treat the line:\n\n >       =definition\n >          method eat(Food $meal) {...}\n\n*only* as Pod. So those two lines are pure documentation, not executable code.\n\n\nDamian\n\n"}
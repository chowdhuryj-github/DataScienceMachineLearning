{"category": "ham", "to_address": "Jeremy Allison <jra@samba.org>", "from_address": "simo <idra@samba.org>", "subject": "Re: svn commit: samba r23290 - in\n\tbranches:\tSAMBA_3_0/source/nsswitch SAMBA_3_0_26/source/nsswitch", "body": "On Sat, 2007-06-02 at 11:32 -0700, Jeremy Allison wrote:\n> On Sat, Jun 02, 2007 at 09:53:20AM -0400, simo wrote:\n> > \n> > I am sorry to contradict you Jeremy, but it is not a matter of taste.\n> > If you alloc all array children on the array, then if you want to\n> > steal/move/free the array, you have to care _only_ about the array\n> > pointer. You don;t risk leaving behind children on the wrong context,\n> > and maybe have them freed while you are still keeping around the parent.\n> \n> That's a very good point, and one I hadn't considered.\n> Thanks for setting me straight on this.\n> \n> I must confess I do find the \"invisible heirarchy\"\n> of talloc extremely confusing. At least in C++\n> heirarchy are explicitly declared.\n\nThis is true, but sometimes, being invisible make it so more powerful :)\n\n> > talloc_steal/talloc_move are the reasons to not alloc everything on the\n> > generic mem_ctx, but to build memory hierarchies that reflect structure\n> > hierarchies :)\n> \n> Indeed, but I wish there was a way to express this in\n> the definitions. I guess if you're careful the structure\n> definition can be used here, but definitions aren't\n> always so clear.\n\nYou definitively must be careful.\nSince I started working with the new talloc I decided to change my\nmindset. Now I give for granted that if I have a structure and I have to\nallocate stuff in it, then the memory hierarchy follows the structure I\nam using.\n\nSimo.\n\n-- \nSimo Sorce\nSamba Team GPL Compliance Officer\nemail: idra@samba.org\nhttp://samba.org\n\n"}
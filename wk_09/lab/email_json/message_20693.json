{"category": "ham", "to_address": "Smylers <Smylers@stripey.com>", "from_address": "\"Luke Palmer\" <lrpalmer@gmail.com>", "subject": "Re: Should a dirhandle be a filehandle-like iterator?", "body": "On 5/1/07, Smylers  wrote:\n> What are the situations in which a programmer really needs to open\n> something but doesn't know wether that thing is a file, a directory, or\n> a URL?  I'm still unpersuaded this is sensible default behaviour.\n\nLots of times.  It's an agnosticism, meaning that you can write a\nmodule which opens things and it doesn't have to know what it's\nopening; as a matter of fact, it doesn't even have to know what kinds\nof things it's *capable* of opening.  That's powerful.\n\nThe point is, even though opening a file and opening a URL are\nreasonably different things, they are both the same logical operation,\nso they can be abstracted.  Not abstracting them will either cause\nmodules to have to take a \"type of file\" parameter whenever they take\na file, or will lead to code like this:\n\n    my $fh = do given $file {\n        when // { openurl($file) }\n        default       { open($file) }\n    }\n\nAnd the programmer of this module may not have been aware that he\ncould operate on directories, even though it's just some sort of line\nprocessing module.\n\nAnyway, my point is that the concept of opening something is\nabstractable, and not abstracting it means that everyone has to\nabstract it separately.\n\nAnd please don't argue from the standpoint of security holes. Security\nholes are possible in every language which talks to the outside world.\n Taint mode is a pretty good way to keep security holes out of a\ncomplex, rich language like Perl.  But if you really want to be free\nof security holes, you either have to make a language which doesn't do\nanything, or make a language in which everyone can be an expert within\nan hour.\n\nLuke\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 11187: Make existing tests pass for dir hives. in\n\tfile:///home/jelmer/bzr.samba-old/4.0-regwrite/", "body": "At file:///home/jelmer/bzr.samba-old/4.0-regwrite/\n\n------------------------------------------------------------\nrevno: 11187\nrevision-id: jelmer@samba.org-20070612200826-54acueedast7lnmr\nparent: jelmer@samba.org-20070612165440-1x7k1m3nb1bzbal0\ncommitter: Jelmer Vernooij \nbranch nick: 4.0-regwrite\ntimestamp: Tue 2007-06-12 22:08:26 +0200\nmessage:\n  Make existing tests pass for dir hives.\nmodified:\n  source/lib/registry/dir.c      svn-v2:4132@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2freg_backend_dir.c\n  source/lib/registry/hive.c     hive.c-20070602140117-9a3wth1mhbrq7ej1-1\n  source/lib/registry/hive.h     hive.h-20070423140448-w1nvzs8d2qxvyswz-1\n  source/lib/registry/local.c    local.c-20070602140117-9a3wth1mhbrq7ej1-2\n  source/lib/registry/regf.c     svn-v2:4132@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2freg_backend_nt4.c\n  source/lib/registry/tests/hive.c hive.c-20070612151642-hsxkm8j4r69ej3px-1\n=== modified file 'source/lib/registry/dir.c'\n--- a/source/lib/registry/dir.c\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/dir.c\t2007-06-12 20:08:26 +0000\n@@ -28,9 +28,11 @@\n \tconst char *path;\n };\n \n+static struct hive_operations reg_backend_dir;\n+\n static WERROR reg_dir_add_key(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t  struct hive_key *parent, \n-\t\t\t\t\t\t\t  const char *name, uint32_t access_mask, \n+\t\t\t\t\t\t\t  const struct hive_key *parent, \n+\t\t\t\t\t\t\t  const char *name, const char *classname,\n \t\t\t\t\t\t\t  struct security_descriptor *desc, \n \t\t\t\t\t\t\t  struct hive_key **result)\n {\n@@ -42,20 +44,30 @@\n \tret = mkdir(path, 0700);\n \tif (ret == 0) {\n \t\tstruct dir_key *key = talloc(mem_ctx, struct dir_key);\n+\t\tkey->key.ops = \u00ae_backend_dir;\n \t\tkey->path = talloc_steal(key, path);\n \t\t*result = (struct hive_key *)key;\n \t\treturn WERR_OK;\n \t}\n-\treturn WERR_INVALID_PARAM;\n+\n+\tif (errno == EEXIST)\n+\t\treturn WERR_ALREADY_EXISTS;\n+\tprintf(\"FAILED %s BECAUSE: %s\\n\", path, strerror(errno));\n+\treturn WERR_GENERAL_FAILURE;\n }\n \n-static WERROR reg_dir_del_key(struct hive_key *k, const char *name)\n+static WERROR reg_dir_del_key(const struct hive_key *k, const char *name)\n {\n \tstruct dir_key *dk = talloc_get_type(k, struct dir_key);\n \tchar *child = talloc_asprintf(NULL, \"%s/%s\", dk->path, name);\n \tWERROR ret;\n \n-\tif (rmdir(child) == 0) ret = WERR_OK; else ret = WERR_GENERAL_FAILURE;\n+\tif (rmdir(child) == 0) \n+\t\tret = WERR_OK; \n+\telse if (errno == ENOENT)\n+\t\tret = WERR_NOT_FOUND;\n+\telse\n+\t\tret = WERR_GENERAL_FAILURE;\n \n \ttalloc_free(child);\n \n@@ -85,6 +97,7 @@\n \t}\n \tclosedir(d);\n \tret = talloc(mem_ctx, struct dir_key);\n+\tret->key.ops = \u00ae_backend_dir;\n \tret->path = talloc_steal(ret, fullpath);\n \t*subkey = (struct hive_key *)ret;\n \treturn WERR_OK;\n@@ -150,6 +163,7 @@\n \t\treturn WERR_INVALID_PARAM;\n \n \tdk = talloc(parent_ctx, struct dir_key);\n+\tdk->key.ops = \u00ae_backend_dir;\n \tdk->path = talloc_strdup(dk, location);\n \t*key = (struct hive_key *)dk;\n \treturn WERR_OK;\n@@ -158,16 +172,39 @@\n WERROR reg_create_directory(TALLOC_CTX *parent_ctx, \n \t\t\t\t\t\t\tconst char *location, struct hive_key **key)\n {\n-\tif (mkdir(location, 0644) != 0) {\n+\tif (mkdir(location, 0700) != 0) {\n+\t\t*key = NULL;\n \t\treturn WERR_GENERAL_FAILURE;\n \t}\n \n \treturn reg_open_directory(parent_ctx, location, key);\n }\n \n+static WERROR reg_dir_get_info(TALLOC_CTX *ctx, const struct hive_key *key, \n+\t\t\t\t\t\t\t   const char **classname,\n+\t\t\t\t\t\t\t   uint32_t *num_subkeys,\n+\t\t\t\t\t\t\t   uint32_t *num_values,\n+\t\t\t\t\t\t\t   NTTIME *lastmod)\n+{\n+\t/* FIXME */\n+\tif (classname != NULL)\n+\t\t*classname = NULL;\n+\n+\tif (num_subkeys != NULL)\n+\t\t*num_subkeys = 0;\n+\n+\tif (num_values != NULL)\n+\t\t*num_values = 0;\n+\n+\tif (lastmod != NULL)\n+\t\t*lastmod = 0;\n+\treturn WERR_OK;\n+}\n+\n static struct hive_operations reg_backend_dir = {\n \t.name = \"dir\",\n \t.get_key_by_name = reg_dir_open_key,\n+\t.get_key_info = reg_dir_get_info,\n \t.add_key = reg_dir_add_key,\n \t.del_key = reg_dir_del_key,\n \t.enum_key = reg_dir_key_by_index\n\n=== modified file 'source/lib/registry/hive.c'\n--- a/source/lib/registry/hive.c\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/hive.c\t2007-06-12 20:08:26 +0000\n@@ -66,7 +66,7 @@\n \t\t\t\t\t\t uint32_t *num_values,\n \t\t\t\t\t\t NTTIME *last_change_time)\n {\n-\treturn key->context->ops->get_key_info(mem_ctx, key, classname, num_subkeys, \n+\treturn key->ops->get_key_info(mem_ctx, key, classname, num_subkeys, \n \t\t\t\t\t\t\t\t\tnum_values, last_change_time);\n }\n \n@@ -74,10 +74,10 @@\n \t\t\t\t\t\t const char *name, const char *classname, struct security_descriptor *desc,\n \t\t\t\t\t\t struct hive_key **key)\n {\n-\treturn parent_key->context->ops->add_key(ctx, parent_key, name, classname, desc, key);\n+\treturn parent_key->ops->add_key(ctx, parent_key, name, classname, desc, key);\n }\n \n _PUBLIC_ WERROR hive_key_del(const struct hive_key *key, const char *name)\n {\n-\treturn key->context->ops->del_key(key, name);\n+\treturn key->ops->del_key(key, name);\n }\n\n=== modified file 'source/lib/registry/hive.h'\n--- a/source/lib/registry/hive.h\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/hive.h\t2007-06-12 20:08:26 +0000\n@@ -36,22 +36,13 @@\n  * does it understand what predefined keys are.\n  */\n \n-struct hive_context {\n+struct hive_key {\n \tconst struct hive_operations *ops;\n };\n \n-struct hive_key {\n-\tstruct hive_context *context;\n-};\n-\n struct hive_operations {\n \tconst char *name;\t\n \n-\t/** \n-\t * Open the root key of this hive\n-\t */\n-\tWERROR (*open_root) (struct hive_context *hive, struct hive_key **key);\n-\t\n \t/**\n \t * Open a specific subkey\n \t */\n\n=== modified file 'source/lib/registry/local.c'\n--- a/source/lib/registry/local.c\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/local.c\t2007-06-12 20:08:26 +0000\n@@ -46,8 +46,8 @@\n };\n \n WERROR reg_mount_hive(struct registry_context *ctx, struct reg_key_path *path, \n-\t\t\t\t\t  struct hive_context *hive);\n-WERROR reg_unmount_hive(struct registry_context *ctx, struct hive_context *hive);\n+\t\t\t\t\t  struct hive_key *hive);\n+WERROR reg_unmount_hive(struct registry_context *ctx, struct hive_key *hive);\n \n static WERROR local_open_key(TALLOC_CTX *mem_ctx,\n \t\t\t\t\t\t   struct registry_key *parent, \n\n=== modified file 'source/lib/registry/regf.c'\n--- a/source/lib/registry/regf.c\t2007-06-02 15:25:04 +0000\n+++ b/source/lib/registry/regf.c\t2007-06-12 20:08:26 +0000\n@@ -43,7 +43,6 @@\n  */\n \n struct regf_data {\n-\tstruct hive_context context;\n \tint fd;\n \tstruct hbin_block **hbins;\n \tstruct regf_hdr *header;\n@@ -53,9 +52,7 @@\n \n struct regf_key_data {\n \tstruct hive_key key;\n-\tstruct regf_data *hive; /* Duplicaton, as it's already in \n-\t\t\t\t\t\t\t   (struct regf_data *)key.context as well, \n-\t\t\t\t\t\t\t   but that's harder to get at */\n+\tstruct regf_data *hive; \n \tuint32_t offset;\n \tstruct nk_block *nk;\n };\n@@ -408,7 +405,8 @@\n \t\t\t\t\t\t\t const struct hive_key *key, \n \t\t\t\t\t\t\t const char **classname,\n \t\t\t\t\t\t\t uint32_t *num_subkeys,\n-\t\t\t\t\t\t\t uint32_t *num_values)\n+\t\t\t\t\t\t\t uint32_t *num_values,\n+\t\t\t\t\t\t\t NTTIME *last_mod_time)\n {\n \tconst struct regf_key_data *private_data = \n \t\t(const struct regf_key_data *)key;\n@@ -423,6 +421,8 @@\n \t\t\t\t\t\t (char*)data.data, private_data->nk->clsname_length);\n \t} else \n \t\t*classname = NULL;\n+\n+\t/* FIXME: Last mod time */\n \t\n \treturn WERR_OK;\n }\n@@ -435,7 +435,7 @@\n \tstruct regf_key_data *ret;\n \n \tret = talloc_zero(ctx, struct regf_key_data);\n-\tret->key.context = talloc_reference(ret, regf);\n+\tret->hive = talloc_reference(ret, regf);\n \tret->offset = offset;\n \tnk = talloc(ret, struct nk_block);\n \tret->nk = nk;\n@@ -460,7 +460,7 @@\n \tconst struct regf_key_data *private_data = \n \t\t\t(const struct regf_key_data *)key;\n \tstruct vk_block *vk;\n-\tstruct regf_data *regf = (struct regf_data *)key->context;\n+\tstruct regf_data *regf = private_data->hive;\n \tuint32_t vk_offset;\n \tDATA_BLOB tmp;\n \n@@ -1402,7 +1402,7 @@\n }\n \n \n-static WERROR regf_del_key(struct hive_key *parent, const char *name)\n+static WERROR regf_del_key(const struct hive_key *parent, const char *name)\n {\n \tconst struct regf_key_data *private_data = \n \t\t(const struct regf_key_data *)parent;\n@@ -1454,8 +1454,8 @@\n \treturn regf_save_hbin(private_data->hive);\n }\n \n-static WERROR regf_add_key(TALLOC_CTX *ctx, struct hive_key *parent, \n-\t\t\t\t\t\t   const char *name, uint32_t access_mask, \n+static WERROR regf_add_key(TALLOC_CTX *ctx, const struct hive_key *parent, \n+\t\t\t\t\t\t   const char *name, const char *classname,\n \t\t\t\t\t\t   struct security_descriptor *sec_desc, \n \t\t\t\t\t\t   struct hive_key **ret)\n {\n@@ -1479,7 +1479,7 @@\n \tnk.num_values = 0;\n \tnk.values_offset = -1;\n \tmemset(nk.unk3, 0, 5);\n-\tnk.clsname_offset = -1;\n+\tnk.clsname_offset = -1; /* FIXME: fill in */\n \tnk.clsname_length = 0;\n \tnk.key_name = name;\n \t\n\n=== modified file 'source/lib/registry/tests/hive.c'\n--- a/source/lib/registry/tests/hive.c\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/tests/hive.c\t2007-06-12 20:08:26 +0000\n@@ -31,7 +31,7 @@\n {\n \tconst struct hive_key *root = test_data;\n \tWERROR error = hive_key_del(root, \"bla\");\n-\ttorture_assert_werr_equal(tctx, error, WERR_BADFILE, \n+\ttorture_assert_werr_equal(tctx, error, WERR_NOT_FOUND, \n \t\t\t\t\t\t\t  \"invalid return code\");\n \n \treturn true;\n@@ -50,11 +50,11 @@\n \t\t\t\t\t\t\t  NULL);\n \ttorture_assert_werr_ok(tctx, error, \"reg_key_num_subkeys()\");\n \n-\ttorture_assert(tctx, num_subkeys != 0, \"New key has non-zero subkey count\");\n+\ttorture_assert_int_equal(tctx, num_subkeys, 0, \"New key has non-zero subkey count\");\n \n \ttorture_assert_werr_ok(tctx, error, \"reg_key_num_values\");\n \n-\ttorture_assert(tctx, num_values != 0, \"New key has non-zero value count\");\n+\ttorture_assert_int_equal(tctx, num_values, 0, \"New key has non-zero value count\");\n \n \treturn true;\n }\n@@ -69,7 +69,7 @@\n \n \terror = hive_key_add_name(mem_ctx, root, \"Nested Key\", NULL, \n \t\t\t\t\t\t\t NULL, &subkey);\n-\ttorture_assert_werr_ok(tctx, error, \"reg_key_add_name\");\n+\ttorture_assert_werr_ok(tctx, error, \"hive_key_add_name\");\n \n \terror = hive_key_del(root, \"Nested Key\");\n \ttorture_assert_werr_ok(tctx, error, \"reg_key_del\");\n@@ -77,17 +77,8 @@\n \treturn true;\n }\n \n-struct torture_suite *torture_registry_hive(TALLOC_CTX *mem_ctx) \n+static void tcase_add_tests(struct torture_tcase *tcase) \n {\n-\tstruct torture_tcase *tcase;\n-\tstruct torture_suite *suite = torture_suite_create(mem_ctx, \n-\t\t\t\t\t\t\t\t\t\t\t\t\t   \"HIVE\");\n-\n-\tstruct hive_key *key;\n-\n-\treg_create_directory(mem_ctx, \"bla\", &key);\n-\n-\ttcase = torture_suite_add_tcase(suite, \"dir\");\n \ttorture_tcase_add_simple_test(tcase, \"del_nonexistant_key\", \n \t\t\t\t\t\t\t\t  test_del_nonexistant_key);\n \n@@ -96,6 +87,45 @@\n \n \ttorture_tcase_add_simple_test(tcase, \"get_info\", \n \t\t\t\t\t\t\t\t  test_keyinfo_root);\n-\n+}\n+\n+static bool hive_setup_dir(struct torture_context *tctx, void **data)\n+{\n+\n+\tstruct hive_key *key;\n+\tWERROR error;\n+\n+\terror = reg_create_directory(tctx, \"bla\", &key);\n+\tif (!W_ERROR_IS_OK(error)) {\n+\t\tfprintf(stderr, \"Unable to initialize dir hive\\n\");\n+\t\treturn false;\n+\t}\n+\n+\t*data = key;\n+\n+\treturn true;\n+}\n+\n+static bool test_dir_refuses_null_location(struct torture_context *tctx)\n+{\n+\ttorture_assert_werr_equal(tctx, WERR_INVALID_PARAM, \n+\t\t\t\t\t\t\t  reg_open_directory(NULL, NULL, NULL),\n+\t\t\t\t\t\t\t  \"reg_open_directory accepts NULL location\");\n+\treturn true;\n+}\n+\n+struct torture_suite *torture_registry_hive(TALLOC_CTX *mem_ctx) \n+{\n+\tstruct torture_tcase *tcase;\n+\tstruct torture_suite *suite = torture_suite_create(mem_ctx, \n+\t\t\t\t\t\t\t\t\t\t\t\t\t   \"HIVE\");\n+\n+\ttorture_suite_add_simple_test(suite, \"dir-refuses-null-location\", \n+\t\t\t\t\t\t\t\t  test_dir_refuses_null_location);\n+\n+\n+\ttcase = torture_suite_add_tcase(suite, \"dir\");\n+\ttorture_tcase_set_fixture(tcase, hive_setup_dir, NULL);\n+\ttcase_add_tests(tcase);\n \treturn suite;\n }\n\n"}
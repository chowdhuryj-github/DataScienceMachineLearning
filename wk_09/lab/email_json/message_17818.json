{"category": "ham", "to_address": "\"Pierre Mariani\" <frenchyp@gmail.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: improving my code: array of references", "body": "On 4/27/07, Pierre Mariani  wrote:\nsnip\n> > - modify_variable() doesn't appear to modify anything, otherwise why\n> > are you assigning its return value to the scalar passed as a parameter?\n> > It seems to be just a function.\n>\n> Modify_variable modifies its input variable.\n\nI think the issue is what you mean by \"modifies\".  In order to say\nthat the modify_variable function modifies its input then something\nlike the following must be true:\n\nmy $foo = 5\nmodify_variable($foo)\nprint \"$foo\\n\"; #prints \"6\\n\"\n\n\n>\n> > - Why are you using references? Are you sure you need to?\n> >\n> Please correct me if I am wrong.\n> My understanding is that:\n> 1) if I do:\n>         my @array = ($a, $b, $c);\n>         for (@array) { $_ = modify_variable($_)}\n> I am going to modify $array[0], $array[1] and $array[2], and NOT $a, $b,\n> $c.\n\nYes, that is correct, but this is most likely an invalid use of an\narray.  Either you should be using a array from the beginning, or you\nshould be using a list.  Assigning a bunch of scalar variables to an\narray just to group them is useless.\n\n$_ = modify_variable($_) for $a, $b, $c;\n\nis a better construct.  However, it would be even better to make\nmodify_variable take multiple arguments:\n\n($a, $b, $c) = modify_variables($a, $b, $c);\n\n\n\n\n\n>\n> 2) if I do:\n>         for ($a, $b, $c) {$_ = modify_variable($_)}\n> I am going to modify $a, $b, $c, which is good, but if $a, $b, $c are\n> big I am going to be passing around lots of data.\n\nAh, here is the crux of the problem.  You thing you are passing\ncopies.  Perl aliases its arguments to functions.  In C++ terms you\nare passing by reference (if I got the terminology right).  Passing\n\"this is a really long string\" and \"a\" both take up the same amount of\ntime and memory.  Only passing around arrays and hashes take up O(n)\nspace and time.  That is why it is good form to pass them as\nreferences.\n\nsnip\n> >   $_ = function($_) foreach ($var1, $var2, $var3);\n> >\n> > Will this do? Or is there more to the problem than you've explained?\nsnip\n\n$_ = function($_) foreach ($var1, $var2, $var3);\n\nis the same as\n\nforeach ($var1, $var2, $var3) {\n    $_ = function($_)\n}\n\nIf you only have one statement* in a loop for can write it in the\nformer method.  It is considered by many to be clearer.\n\n\n* well, you can chain statements using , but that is poor form outside\nof Perl Golf, Obfuscation, and one-liners.\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "parrot-porters@perl.org", "from_address": "chromatic <chromatic@wgz.org>", "subject": "Why You Can Only Call Sub PMCs from C", "body": "If you have a Sub PMC (or subclass), you can invoke that PMC from C code using \nParrot_call_sub() or a similar function.  Of course, if you want to pass \narguments to that PMC, something needs to translate those arguments from C's \ncalling conventions to Parrot's calling conventions.\n\nThat something is a function something like runops_args() in src/inter_run.c.\n\nHere's the fun part.\n\nThis function calls:\n\n\t    dest = VTABLE_invoke(interp, sub, NULL);\n\nThat is, it invokes the PMC.  A Sub PMC returns the address of the next opcode \nto run -- the first opcode of the sub.  runops_args() can check that opcode \nto see if it fetches arguments.  A subroutine that takes arguments will start \nwith an opcode to fetch the arguments.\n\nThe important thing is that this doesn't really execute the subroutine.  It \njust gets the address of the next opcode to run.  Parrot can run that later, \nafter it sets up the arguments appropriately.\n\nOf course, an NCI PMC (a subclass of the Sub PMC) doesn't really have an \nopcodes to execute, as it's a function pointer to execute.  Its invoke() \nvtable override actually calls the function.\n\nNote that this happens *before* Parrot translates the arguments from the C \nconventions into Parrot's conventions, so in the NCI thunk that translate \narguments from Parrot's conventions back into C's conventions, the arguments \nJust Aren't There.\n\nI'm not sure what the right solution is, but Liskov cries a little bit.  \nClearly, invoke() behaves very differently for Sub and NCI subs.\n\nI haven't looked at how Multi behaves, but I have my guesses.\n\n-- c\n\n"}
{"category": "ham", "to_address": "\"brian d foy\" <brian.d.foy@gmail.com>", "from_address": "\"Luke Palmer\" <lrpalmer@gmail.com>", "subject": "Re: File test operators as Pairs", "body": "On 4/13/07, brian d foy  wrote:\n> Which then makes me think I'd want to do something a bit wacky to see\n> if the modtime is greater than 5:\n>\n>\n>    \"doc\" ~~ M => any( 5 ..* );\n\nOr even \"doc\" ~~ M => (5..*).  Then again, (\"doc\" ~~ :M) ~~ 5..* does\nthe same thing, without having to have pattern matching in two\ndifferent places.\n\nIt seems like the pairness of the pair is pretty useless in this case;\ni.e. it's a hack to fudge Lisp- or Ruby-style symbols.  But symbols\nwould be a hack in this case, too.\n\nThese things are methods, and I'm not sure why we've crammed them into\nsmart match. Things like :M have nothing to do with matching. What\nwould it mean if smart match returned false?  \"This file has not been\nmodified ever\"?  :e has a bit more merit for a smart match, but the\noperation has little to do with the concept of a string or the pair e\n=> 1.\n\nI'm inclined to say that the best solution for filetests is to throw\nout our dwimmery altogether.  Back in Perl 4 days, using \"stat\"\nexplicitly was awkward, because you had to use it as a list and\nmemorize the positions of all the returns.  -s $file beats the heck\nout of (stat $file)[7], for sure.  It also had the benefit that shell\npeople would instantly recognize what's going on.\n\nHowever, now we have stat($file).size.  With that, every programmer\nwill recognize what's going on, not just people with shell background.\n And I don't think even people with a shell background will know what\n($file ~~ :s) means (their guess could be right, but they'd have to\nlook it up to confirm, and they would never think to *write* such a\nthing).\n\nI can never remember whether mtime is -m or -M anyway...\n\nLet's get rid of all the filetest magic, in favor of using stat explicitly.\n\nLuke\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23072 - in branches/SAMBA_3_0/source/nsswitch: .", "body": "Author: obnox\nDate: 2007-05-22 12:49:41 +0000 (Tue, 22 May 2007)\nNew Revision: 23072\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23072\n\nLog:\nIn winbindd_ads.c:lookup_groupmem, replace the bottleneck \ndn_lookup loop by a rpccli_lsa_lookupsids_all (see r23070) \ncall. This replaces one ldap search per member sid by one \nrpc call per 1000 sids. This greatly speeds up groupmem\nlookups for groups with lots of users.\n\nSince the loop in lookup_groupmem was the only use of dn_lookup,\nthe function is removed.\n\nMichael\n\n\nModified:\n   branches/SAMBA_3_0/source/nsswitch/winbindd_ads.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd_ads.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd_ads.c\t2007-05-22 12:45:58 UTC (rev 23071)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd_ads.c\t2007-05-22 12:49:41 UTC (rev 23072)\n@@ -402,50 +402,11 @@\n \treturn NT_STATUS_OK;\n }\n \n-/* convert a DN to a name, SID and name type \n-   this might become a major speed bottleneck if groups have\n-   lots of users, in which case we could cache the results\n-*/\n-static BOOL dn_lookup(ADS_STRUCT *ads, TALLOC_CTX *mem_ctx,\n-\t\t      const char *dn,\n-\t\t      char **name, uint32 *name_type, DOM_SID *sid)\n-{\n-\tLDAPMessage *res = NULL;\n-\tconst char *attrs[] = {\"userPrincipalName\", \"sAMAccountName\",\n-\t\t\t       \"objectSid\", \"sAMAccountType\", NULL};\n-\tADS_STATUS rc;\n-\tuint32 atype;\n-\tDEBUG(3,(\"ads: dn_lookup\\n\"));\n+/* If you are looking for \"dn_lookup\": Yes, it used to be here!\n+ * It has gone now since it was a major speed bottleneck in\n+ * lookup_groupmem (its only use). It has been replaced by\n+ * an rpc lookup sids call... R.I.P. */\n \n-\trc = ads_search_retry_dn(ads, &res, dn, attrs);\n-\n-\tif (!ADS_ERR_OK(rc) || !res) {\n-\t\tgoto failed;\n-\t}\n-\n-\t(*name) = ads_pull_username(ads, mem_ctx, res);\n-\n-\tif (!ads_pull_uint32(ads, res, \"sAMAccountType\", &atype)) {\n-\t\tgoto failed;\n-\t}\n-\t(*name_type) = ads_atype_map(atype);\n-\n-\tif (!ads_pull_sid(ads, res, \"objectSid\", sid)) {\n-\t\tgoto failed;\n-\t}\n-\n-\tif (res) \n-\t\tads_msgfree(ads, res);\n-\n-\treturn True;\n-\n-failed:\n-\tif (res) \n-\t\tads_msgfree(ads, res);\n-\n-\treturn False;\n-}\n-\n /* Lookup user information from a rid */\n static NTSTATUS query_user(struct winbindd_domain *domain, \n \t\t\t   TALLOC_CTX *mem_ctx, \n@@ -942,12 +903,15 @@\n \tchar *ldap_exp;\n \tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n \tchar *sidstr;\n-\tchar **members;\n+\tchar **members = NULL;\n \tint i;\n-\tsize_t num_members;\n-\tfstring sid_string;\n+\tsize_t num_members = 0;\n \tads_control args;\n+\tchar **domains = NULL;     /* only needed for rpccli_lsa_lookup_sids */\n+        struct rpc_pipe_client *cli;\n+        POLICY_HND lsa_policy;\n \n+\n \tDEBUG(10,(\"ads: lookup_groupmem %s sid=%s\\n\", domain->name, \n \t\t  sid_string_static(group_sid)));\n \n@@ -980,9 +944,6 @@\n \t}\n \tSAFE_FREE(sidstr);\n \n-\tmembers = NULL;\n-\tnum_members = 0;\n-\n \targs.control = ADS_EXTENDED_DN_OID;\n \targs.val = ADS_EXTENDED_DN_HEX_STRING;\n \targs.critical = True;\n@@ -996,69 +957,78 @@\n \t\tgoto done;\n \t} \n \t\n-\t/* now we need to turn a list of members into rids, names and name types \n-\t   the problem is that the members are in the form of distinguised names\n-\t*/\n-\n-\tif (num_members) {\n-\t\t(*sid_mem) = TALLOC_ZERO_ARRAY(mem_ctx, DOM_SID, num_members);\n-\t\t(*name_types) = TALLOC_ZERO_ARRAY(mem_ctx, uint32, num_members);\n-\t\t(*names) = TALLOC_ZERO_ARRAY(mem_ctx, char *, num_members);\n-\n-\t\tif ((members == NULL) || (*sid_mem == NULL) ||\n-\t\t     (*name_types == NULL) || (*names == NULL)) {\n-\t\t\tDEBUG(1, (\"talloc failed\\n\"));\n-\t\t\tstatus = NT_STATUS_NO_MEMORY;\n-\t\t\tgoto done;\n-\t\t}\n-\t} else {\n-\t\t(*sid_mem) = NULL;\n-\t\t(*name_types) = NULL;\n-\t\t(*names) = NULL;\n+\t(*sid_mem) = TALLOC_ZERO_ARRAY(mem_ctx, DOM_SID, num_members);\n+\tif ((num_members != 0) && \n+\t    ((members == NULL) || (*sid_mem == NULL))) { \n+\t\tDEBUG(1, (\"talloc failed\\n\"));\n+\t\tstatus = NT_STATUS_NO_MEMORY;\n+\t\tgoto done;\n \t}\n- \n-\tfor (i=0;i<num_members;i++) {\n-\t\tuint32 name_type;\n-\t\tchar *name, *domain_name, *dn;\n-\t\tDOM_SID sid;\n \n-\t\tif ((!ads_get_sid_from_extended_dn(mem_ctx, members[i], ADS_EXTENDED_DN_HEX_STRING, &sid)) ||\n-\t\t    (!ads_get_dn_from_extended_dn(mem_ctx, members[i], &dn)))\n-\t\t{\n-\t\t\tstatus = NT_STATUS_INVALID_PARAMETER;\n-\t\t\tgoto done;\n+\tfor (i=0; i<num_members; i++) {\n+\t        if (!ads_get_sid_from_extended_dn(mem_ctx, members[i], args.val, &(*sid_mem)[i])) {\n+\t                goto done;\n \t\t}\n-\n-\t\tif (lookup_cached_sid(mem_ctx, &sid, &domain_name, &name, &name_type)) {\n-\n-\t\t\tDEBUG(10,(\"ads: lookup_groupmem: got sid %s from cache\\n\", \n-\t\t\t\tsid_string_static(&sid)));\n-\n-\t\t\t(*names)[*num_names] = CONST_DISCARD(char *,name);\n-\t\t\t(*name_types)[*num_names] = name_type;\n-\t\t\tsid_copy(&(*sid_mem)[*num_names], &sid);\n-\n+\t}\n+\t\n+\tDEBUG(10, (\"ads lookup_groupmem: got %d sids via extended dn call\\n\", num_members));\n+\t\n+\t/* now that we have a list of sids, we need to get the\n+\t * lists of names and name_types belonging to these sids.\n+\t * even though conceptually not quite clean,  we use the \n+\t * RPC call lsa_lookup_sids for this since it can handle a \n+\t * list of sids. ldap calls can just resolve one sid at a time. */\n+\t\n+\tstatus = cm_connect_lsa(domain, mem_ctx, &cli, &lsa_policy);\n+\tif (!NT_STATUS_IS_OK(status)) {\n+\t\tgoto done;\n+\t}\n+\t\n+\tstatus = rpccli_lsa_lookup_sids_all(cli, mem_ctx, &lsa_policy,\n+\t\t\t\t\t    num_members, *sid_mem, &domains, \n+\t\t\t\t\t    names, name_types);\n+\t\n+\tif (NT_STATUS_IS_OK(status)) {\n+\t\t*num_names = num_members;\n+\t}\n+\telse if (NT_STATUS_EQUAL(status, STATUS_SOME_UNMAPPED)) {\n+\t\t/* We need to remove gaps from the arrays... \n+\t\t * Do this by simply moving entries down in the\n+\t\t * arrays once a gap is encountered instead of\n+\t\t * allocating (and reallocating...) new arrays and\n+\t\t * copying complete entries over. */\n+\t\t*num_names = 0;\n+\t\tfor (i=0; i < num_members; i++) {\n+\t\t\tif (((*names)[i] == NULL) || ((*name_types)[i] == SID_NAME_UNKNOWN)) \n+\t\t\t{\n+\t\t\t\t/* unresolved sid: gap! */\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (i != *num_names) {\n+\t\t\t\t/* if we have already had a gap, copy down: */\n+\t\t\t\t(*names)[*num_names] = (*names)[i];\n+\t\t\t\t(*name_types)[*num_names] = (*name_types)[i];\n+\t\t\t\t(*sid_mem)[*num_names] = (*sid_mem)[i];\n+\t\t\t}\n \t\t\t(*num_names)++;\n-\n-\t\t\tcontinue;\n \t\t}\n-\n-\t\tif (dn_lookup(ads, mem_ctx, dn, &name, &name_type, &sid)) {\n-\n-\t\t\tDEBUG(10,(\"ads: lookup_groupmem: got sid %s from dn_lookup\\n\", \n-\t\t\t\tsid_string_static(&sid)));\n-\t\t\t\n-\t\t\t(*names)[*num_names] = name;\n-\t\t\t(*name_types)[*num_names] = name_type;\n-\t\t\tsid_copy(&(*sid_mem)[*num_names], &sid);\n-\t\t\t\n-\t\t\t(*num_names)++;\n-\n-\t\t}\n-\t}\t\n-\n+\t}\n+\telse if (NT_STATUS_EQUAL(status, NT_STATUS_NONE_MAPPED)) {\n+\t\tDEBUG(10, (\"lookup_groupmem: lsa_lookup_sids could \"\n+\t\t\t   \"not map any SIDs at all.\\n\"));\n+\t\tgoto done;\n+\t}\n+\telse if (!NT_STATUS_IS_OK(status)) {\n+\t\tDEBUG(10, (\"lookup_groupmem: Error looking up %d \"\n+\t\t\t   \"sids via rpc_lsa_lookup_sids: %s\\n\",\n+\t\t\t   num_members, nt_errstr(status)));\n+\t\tgoto done;\n+\t}\n+\t\n \tstatus = NT_STATUS_OK;\n-\tDEBUG(3,(\"ads lookup_groupmem for sid=%s succeeded\\n\", sid_to_string(sid_string, group_sid)));\n+\tDEBUG(3,(\"ads lookup_groupmem for sid=%s succeeded\\n\",\n+\t\t sid_string_static(group_sid)));\n+\n done:\n \n \tif (res) \n\n"}
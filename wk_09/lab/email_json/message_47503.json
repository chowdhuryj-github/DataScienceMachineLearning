{"category": "ham", "to_address": "Stephen Tucker <brown_emu@yahoo.com>", "from_address": "\"Charles C. Berry\" <cberry@tajo.ucsd.edu>", "subject": "Re: [R] passing (or obtaining) index or element name of list to FUN\n in lapply()", "body": "\nThis sounds like a job for mapply, viz:\n\n> a.list <- list(a=cbind(1:4,rnorm(4)),b=cbind(4:1,rnorm(4)))\n> \n> plot.x.main.y <- function(x,y,...) plot( x, main=y, ... )\n> mapply( plot.x.main.y , a.list, names(a.list) )\n\nChuck\n\nOn Wed, 13 Jun 2007, Stephen Tucker wrote:\n\n> Hi Professor Ripley,\n>\n> Thanks for the response. I apologize, my examples were not too real (though\n> your solutions are indeed clever)... I was trying to ask more generally\n> whether the element name or index of 'listObj' could be obtained by the\n> user-function 'myfunction' when used in lapply(X=listObj,FUN=myfunction);\n> below I illustrate two cases in which I have come across this desire:\n> (1) In 'Example 1' I essentially take the list element and do some\n> transformations (optionally some number-crunching), and then plot it with the\n> element name of the list for the title.\n> (2) In 'Example 2' I want to read in data from the list element and write the\n> contents to a file; writing a header line only when operating on the first\n> element of the list.\n>\n> ## data specification\n> data1 <- \"var1 var2\n> -0.44 0.17\n> 1.03 0.93\n> 0.85 0.39\"\n> data2 <- \"var1 var2\n> -0.16 0.97\n> 0.93 0.23\n> 0.80 0.42\"\n> L <- list(data1=data1,data2=data2)\n>\n> ##=== Example 1 (want element name) ===\n> ## function definition\n> plottingfunc <- function(i,x) {\n>  plot(read.table(textConnection(x[[i]]),header=TRUE),main=names(x)[i])\n> }\n> ## function application\n> par(mfrow=c(2,1))\n> lapply(seq(along=L),plottingfunc,x=L)\n>\n> ##=== Example 2 (want element index) ===\n> ## function definition\n> readwritefunc <- function(i,x,fout) {\n>  data <- read.table(textConnection(x[[i]]),header=TRUE)\n>  if(i==1) cat(paste(colnames(data),collapse=\",\"),\"\\n\",file=fout)\n>  write.table(data,file=fout,sep=\",\",col=FALSE,\n>              row=FALSE,quote=FALSE,append=TRUE)\n> }\n> ## function application\n> fout <- file(\"out.dat\",open=\"w\")\n> lapply(seq(along=L),readwritefunc,x=L,fout=fout)\n> close(fout)\n>\n> Since the above code works, I suppose this is more of a question of\n> aesthetics since I thought the spirit of lapply() was to operate on the\n> elements of a list and not its indices - I thought perhaps there is a way to\n> get the index number and element name from within the user-function.\n>\n> Also, I recall a lesson on 'loop avoidance' from an earlier version of MASS;\n> this was in the days of S-PLUS dominance and perhaps less applicable now to R\n> as you mentioned... But old habits die hard; my amygdala still invokes a fear\n> response at the thought of a loop... (and as of recently, I have been\n> infatuated with the notion of adhering, albeit loosely, to the 'functional\n> programming' paradigm which makes me doubly fearful of loops)\n>\n> Thanks and best regards,\n>\n> Stephen\n>\n> --- Prof Brian Ripley  wrote:\n>\n>> On Tue, 12 Jun 2007, Stephen Tucker wrote:\n>>\n>>> Hello everyone,\n>>>\n>>> I wonder if there is a way to pass the index or name of a list to a\n>>> user-specified function in lapply(). For instance, my desired effect is\n>>> something like the output of\n>>>\n>>>> L <- list(jack=4098,sape=4139)\n>>>> lapply(seq(along=L),function(i,x) if(i==1) \"jack\" else \"sape\",x=L)\n>>> [[1]]\n>>> [1] \"jack\"\n>>>\n>>> [[2]]\n>>> [1] \"sape\"\n>>\n>> as.list(names(L))\n>>\n>>>> lapply(seq(along=L),function(i,x) if(names(x)[i]==\"jack\") 1 else 2,x=L)\n>>> [[1]]\n>>> [1] 1\n>>>\n>>> [[2]]\n>>> [1] 2\n>>\n>> as.list(seq_along(L))\n>>\n>> lapply() can be faster than a for-loop, but usually not by much: its main\n>> advantage is clarity of code.\n>>\n>> I think we need a real-life example to see what you are trying to do.\n>>\n>>> But by passing L as the first argument of lapply(). I thought there was a\n>>> tangentially-related post on this mailing list in the past but I don't\n>> recall\n>>> that it was ever addressed directly (and I can't seem to find it now).\n>> The\n>>> examples above are perfectly good alternatives especially if I wrap each\n>> of\n>>> the lines in \"names<-\"() to return lists with appropriate names assigned,\n>> but\n>>\n>> Try something like\n>>\n>> L[] <- lapply(seq_along(L),function(i,x) if(i==1) \"jack\" else \"sape\",x=L)\n>>\n>>> it feels like I am essentially writing a FOR-LOOP - though I was\n>> surprised to\n>>> find that speed-wise, it doesn't seem to make much of a difference\n>> (unless I\n>>> have not selected a rigorous test):\n>>>\n>>>> N <- 10000\n>>>> y <- runif(N)\n>>> ## looping through elements of y\n>>>> system.time(lapply(y,\n>>> +                    function(x) {\n>>> +                      set.seed(222)\n>>> +                      mean(rnorm(1e4,x,1))\n>>> +                    }))\n>>> [1] 21.00  0.17 21.29    NA    NA\n>>> ## looping through indices\n>>>> system.time(lapply(1:N,\n>>> +                    function(x,y) {\n>>> +                      set.seed(222)\n>>> +                      mean(rnorm(1e4,y[x],1))\n>>> +                      },y=y))\n>>> [1] 21.09  0.14 21.26    NA    NA\n>>>\n>>> In Python, there are methods for Lists and Dictionaries called\n>> enumerate(),\n>>> and iteritems(), respectively. Example applications:\n>>>\n>>> ## a list\n>>> L = ['a','b','c']\n>>> [x for x in enumerate(L)]\n>>> ## returns index of list along with the list element\n>>> [(0, 'a'), (1, 'b'), (2, 'c')]\n>>>\n>>> ## a dictionary\n>>> D = {'jack': 4098, 'sape': 4139}\n>>> [x for x in D.iteritems()]\n>>> ## returns element key (name) along with element contents\n>>> [('sape', 4139), ('jack', 4098)]\n>>>\n>>> And this is something of the effect I was looking for...\n>>>\n>>> Thanks to all,\n>>>\n>>> Stephen\n>>>\n>>> ______________________________________________\n>>> R-help@stat.math.ethz.ch mailing list\n>>> https://stat.ethz.ch/mailman/listinfo/r-help\n>>> PLEASE do read the posting guide\n>> http://www.R-project.org/posting-guide.html\n>>> and provide commented, minimal, self-contained, reproducible code.\n>>>\n>>\n>> --\n>> Brian D. Ripley,                  ripley@stats.ox.ac.uk\n>> Professor of Applied Statistics,  http://www.stats.ox.ac.uk/~ripley/\n>> University of Oxford,             Tel:  +44 1865 272861 (self)\n>> 1 South Parks Road,                     +44 1865 272866 (PA)\n>> Oxford OX1 3TG, UK                Fax:  +44 1865 272595\n>>\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n>\n\nCharles C. Berry                            (858) 534-2098\n                                             Dept of Family/Preventive Medicine\nE mailto:cberry@tajo.ucsd.edu\t            UC San Diego\nhttp://famprevmed.ucsd.edu/faculty/cberry/  La Jolla, San Diego 92093-0901\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Rob Dixon <rob.dixon@350.com>", "subject": "Re: $1 $2 var confusion", "body": "Steve Bertrand wrote:\n> John W. Krahn wrote:\n>> Mumia W. wrote:\n>>> That happens because the match variables ($1, $2, ...) are only changed\n>>> when a regular expression matches; otherwise, they are left alone.\n>>>\n>>> In the first case, \"$2 !~ /domain\\.com/\" succeeds but does not capture\n>>> anything, so the numbered match variables are unset.\n>>>\n>>> Your situation reinforces the rule that you should always test if the\n>>> match succeeded before you attempt to use the match variables:\n>>>\n>>>     my $email = 'steveb@domain.com';\n>>>     my @f = (undef, $email =~ /(.*)\\@(.*)/);\n>>\n>> Why did you put undef in there?  It serves no useful purpose other than making\n>> the code harder to understand for beginners.\n> \n> Wow...powerful statement.\n> \n> To be honest, I got what I needed before I really payed attention to the\n> above part as per Rob and Tom's replies, but after re-reading, I agree.\n> \n> In the above, do I assume correctly (without time to test for myself)\n> that 'undef' in this case undefines any instance of $1? (or $N for that\n> matter)?\n\nNo, it has no effect on $1. I thought it would cause confusion! The statement simply\nassigns a list to @f. The first element of the list is undef, and the rest is the\nresult of applying the regex to $email, so it's the same as\n\n  my @f = (undef);\n  push @f, $email =~ /(.*)\\@(.*)/;\n\nand simply offsets the captured results by one. As I said, I can see no reason to have\nwritten it this way unless Mumia wanted $f[1] to correspond to $1 and $f[2] to $2.\n\n>>       my @f = $email =~ /(.*)\\@(.*)/;\n>>\n>>\n>>>     (@f > 1) && ($f[2] =~ /domain\\.com/ ?\n>>>         print \"$f[1]\\n\" : print \"var 2 is bad\\n\" );\n>>>\n>>> The test \"@f > 1\" is my way of testing if the match succeeded.\n>> The rvalue conditional operator should use the returned value:\n> \n> Honestly, I hate to say I'm a beginner, but relative to others here I\n> won't beg otherwise. Without having to spend time reading the ?: method\n> (which I never use as of yet anyway), here is how I would do it now, so\n> I would understand it, and so would my staff who are not programmers\n> whatsoever, and who may have to understand it lest I get hit by a bus. I\n> include comments as I would if a non programmer would have to read it:\n> \n> # Get the username portion, and the domain portion that we\n> # must verify from the input the user types in\n> \n> my ($username, $domain) = split (/\\@/, $email);\n> {... do verification}\n\nYou probably want\n\n  my ($username, $domain) = split /\\@/, $email, 2;\n\notherwise something like 'steve@domain.com@nonsense' would pass your test.\n\n> Now that I've started a controversy, can I ask if the following method\n> is correct and accepted practice if I only care about the username portion?\n> \n> I use the following example often instead of split()ing, and then\n> breaking apart an array. Note this is a simple example, it's more handy\n> for me in circumstances where I may be fed an array with numerous slices:\n> \n> my $username = (split (/\\@/, $email))[0];\n\nHere, I would prefer\n\n  my ($user) = $email =~ /([^@]+)/;\n\n(find all the characters from the beginning of the string that aren't at signs)\nas split() here implicitly generates a list of substrings by splitting $email\nat the at signs, and you then throw all but one of those substrings away. In\npractice the overhead of doing this is negligible, but to my mind it's a little\nugly and not descriptive of the problem. It would be going a little far to say\nthat it's unacceptable practice though.\n\n> Again, I have to say that the speed of the feedback was great today :)\n> Rob, I appreciate your input, and Tom, I don't know if you helped\n> Randall write the books, but it's especially exciting to see yourself\n> and the author of several books I own and have read active on the list.\n\nYou're more than welcome :)\n\nRob\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
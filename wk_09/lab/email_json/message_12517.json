{"category": "ham", "to_address": "Joshua Isom <jrisom@gmail.com>", "from_address": "Patrick Rutkowski <rutski89@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "This is in response to your being puzzled about the \"*(void **)ptr\"\nstatement. I'm going to assume that you know about void/non-void\ncontext in C and that you're already comfortable with the standard\nuses of pointers and type casting.\n\n*(type **)ptr_to_type\n\ngives the same effect as:\n\n(type *)(*ptr_to_type)\n\nhere's a test case that proves it:\n\n=== BEGIN CODE ===\n#include \n\nvoid f(int *p) {\n      /* \"%p\\n\" would be the 'proper' format string, but I think \"%u\\n\"\n       * better illustrates the concept. */\n      printf(\"%u\\n\", p);\n}\n\nint\nmain(int argc, char **argv)\n{\n      int x = 77;\n      int *ptr = &x\n      f( *(int**)ptr );\n      f( (int*)(*ptr) );\n      return 0;\n}\n=== END CODE ===\n\n== BEGIN SHELL DUMP ===\nmini:~/Desktop rutski$ gcc test.c -o test && ./test\n77\n77\nmini:~/Desktop rutski$\n== END SHELL DUMP ===\n\nThe second call to f() works only because the type we're dealing with\nis something other than void; in this case it's int. If you tried to\ndo something like:\n\nf( (void*)(*ptr_to_void) )\n\nthen your compiler would first yell at you for trying to dereference a\nvoid* and then it would die when you actually try to use the void\nvalue whcih you got out of it in non-void context:\n\n=== BEGIN CODE ===\n#include \nvoid f(void *p) {\n      /* \"%p\\n\" would be the 'proper' format string, but I think \"%u\\n\"\n       * better illustrates the concept. */\n      printf(\"%u\\n\", p);\n}\n\nint\nmain(int argc, char **argv)\n{\n      int x = 77;\n      void *ptr = &x\n      f( *(void**)ptr );\n      f( (void*)(*ptr) );\n      return 0;\n}\n=== END CODE ===\n\n== BEGIN SHELL DUMP ===\nmini:~/Desktop rutski$ gcc test.c -o test && ./test\ntest.c: In function 'main':\ntest.c:13: warning: dereferencing 'void *' pointer\ntest.c:13: error: void value not ignored as it ought to be\nmini:~/Desktop rutski$\n=== END SHELL DUMP ===\n\nHowever, notice the first use of f() on line 12 worked just fine! The\nfirst call does in fact compile and print 77; ok... so I didn't paste\nthe output, but trust me, the first call to f() would print 77.\n\nThis works because technically what you're doing is first casing the ptr\nto a void**, which is legal; then you dereference your shiny new\nvoid** to get a void* (who's value is 77), which again is completely\nlegal. You then pass that void* to f(), and it prints it as 77.\n\nSo basically you're cheating your way out of dereferencing a void* by\ncasting ptr to a different type, namely a void**; and that's a perfectly\ndereference-able type and it's dereferenced value is perfectly usable.\n\nIt's a pretty nifty trick if you ask me ;)\n\nNote that I did _not_ say that the thing pointed to by the void* is\n77, I said that the void*'s value is 77.\n\n\"But how can the void*'s value be 77!?\" you might ask. Well, ptr is a\npointer to a an int value which holds the number 77. No matter how\nmuch you cast it around it will always be a pointer to the int holding\n77.\n\nThere are two key things to remember. The first is that an object's\ntype and it's value are two totally separate things. The second is:\n\n\"when you dereference ptr, you _always_ get 77; period, end of\nparagraph\".\n\nIf it's still a bit much to wrap your head around then just keep\nre-reading the examples I gave while keeping the aforementioned two\npoints in mind.\n\n-Patrick\n\nOn Apr 22, 2007, at 2:18 AM, Joshua Isom wrote:\n\n>\n> On Apr 21, 2007, at 8:24 PM, chromatic wrote:\n>\n>> Parrot_alloc_context() performs some calculations about the number of\n>> registers used to determine how much memory to allocate:\n>>\n>>     const size_t size_n = sizeof (FLOATVAL) * n_regs_used[REGNO_NUM];\n>>     const size_t size_nip = size_n +\n>>         sizeof (INTVAL) *   n_regs_used[REGNO_INT] +\n>>         sizeof (PMC*) *     n_regs_used[REGNO_PMC];\n>>     size_t reg_alloc = size_nip +\n>>         sizeof (STRING*) *  n_regs_used[REGNO_STR];\n>>\n>> Then it calculates a slot value:\n>>\n>>     const int slot = (reg_alloc + 7) >> 3;\n>>     reg_alloc = slot << 3;\n>>\n>> This is where I start not to understand.  Why reg_alloc + 7?  Why  \n>> shift left\n>> and right by 3?\n>>\n>\n> I'm not sure if it is actually doing anything that needs to be that  \n> complicated to code that way.  It could be able to be written as:\n>\n>     const int slot = (reg_alloc + 7) / 8; /* divide by eight for  \n> some reason and round up on remainder */\n>     reg_alloc = slot * 8; /* reg_alloc is now evenly divisible by 8 */\n>\n> The difference is that if any of the last three bits are set, the  \n> +7 will let it round up, whereas without it it would round down.   \n> That's what it does, don't ask me why(other than maybe guaranteeing  \n> alignment?).  Might be using eight for an eight byte int, but if  \n> so, it should be using sizeof(void *) instead, I'm assuming would  \n> have been used.  Now, slot is multiplied by sizeof(void*) later on,  \n> which may be why it's divided by eight in the first place.\n>\n> The n = slot + 1 I find a little odd, because the number is already  \n> rounded up, so it's rounding up and then adding an extra place of  \n> memory.\n>\n>> It gets less clear.  The interpreter holds a structure for context  \n>> memory with\n>> a free list (an array of void pointers) and the number of free slots,\n>> presumably in this list.\n>>\n>> After all of that calculation of slot, the function uses it as an  \n>> index into\n>> the free list.\n>>\n>> I don't understand that at all.\n>>\n>> I do understand the purpose of the resizing code, but not how slot  \n>> relates to\n>> it:\n>>\n>>     if (slot >= interp->ctx_mem.n_free_slots) {\n>>         const int n = slot + 1;\n>>         int i;\n>>\n>>         interp->ctx_mem.free_list = (void **)mem_sys_realloc(\n>>                 interp->ctx_mem.free_list, n * sizeof (void*));\n>>\n>>         for (i = interp->ctx_mem.n_free_slots; i < n; ++i)\n>>             interp->ctx_mem.free_list[i] = NULL;\n>>         interp->ctx_mem.n_free_slots = n;\n>>     }\n>>\n>> This is doubly weird because when Parrot initializes the free list in\n>> create_initial_context(), it allocates a small number of free slots:\n>>\n>> #define INITIAL_FREE_SLOTS 8\n>>\n>>     interp->ctx_mem.n_free_slots = INITIAL_FREE_SLOTS;\n>>     interp->ctx_mem.free_list    =\n>>         (void **)mem_sys_allocate(INITIAL_FREE_SLOTS * sizeof  \n>> (void *));\n>>\n>>     for (i = 0; i < INITIAL_FREE_SLOTS; ++i)\n>>         interp->ctx_mem.free_list[i] = NULL;\n>>\n>> The result is that the free_list extends quite a bit over the initial\n>> allocation, but it's mostly just an array of null.  It's fairly  \n>> sparse apart\n>> from that.\n>>\n>> Here's another curious thing when allocating a context:\n>>\n>>     ptr = interp->ctx_mem.free_list[slot];\n>>     old = CONTEXT(interp->ctx);\n>>     if (ptr) {\n>>         interp->ctx_mem.free_list[slot] = *(void **) ptr;\n>>     }\n>>\n>> I wish I could tell you what the assignments to and from ptr do  \n>> here, but I\n>> can't, nor what they signify.  There's a similar form to free a  \n>> context:\n>>\n>>         ptr = ctxp;\n>>         slot = ctxp->regs_mem_size >> 3;\n>>\n>>         assert(slot < interp->ctx_mem.n_free_slots);\n>>         *(void **)ptr = interp->ctx_mem.free_list[slot];\n>>         interp->ctx_mem.free_list[slot] = ptr;\n>>\n>\n> The *(void **) has been confusing me for a long time.  It's also in  \n> smallobject.c where a seg fault sometimes happens.  But I've never  \n> been able to find out how to decipher it.  I can look at the dump  \n> of it with `objdump -dS src/gc/smallobject.c` but still get lost in  \n> it all(although looking at assembly, even intermixed with source  \n> code, requires a little too much of an understanding of the machine  \n> to figure out).\n>\n>> I originally thought the free_list was an array of recycled  \n>> contexts to avoid\n>> malloc() and free() pairs by reusing already-allocated-but-unused  \n>> memory, but\n>> now I can't tell what it's doing.  I tried to change this into a  \n>> linked list,\n>> but that failed with invalid reads.\n>>\n>\n> I thought it was a list of items to be freed, but that may be a  \n> different free_list sadly.  We have more than one in parrot.\n>\n>> My best guess is that this is an odd way to store contexts of a  \n>> specific size\n>> in an array structure so that they're reusable with our new  \n>> variable-sized\n>> register sets... but the code is unclear and undocumented.  I  \n>> think it's also\n>> leaking memory.\n>>\n>\n> Enable the context alloc and free, but probably change what's  \n> printed to make it easy to run through sort, and it might help, maybe.\n>\n>> I'd like to find a simpler scheme, if it's possible.  Otherwise,  \n>> I'd like to\n>> figure out what's going on so we can at least explain it somehow.\n>>\n>> -- c\n>>\n>>\n>\n> Rule one of writing in C for a project for many people to code,  \n> document the (you decide the explicative) out of it.\n>\n\n"}
{"category": "ham", "to_address": "p2 <parrot-porters@perl.org>", "from_address": "Allison Randal <allison@perl.org>", "subject": "modifying classes after they're instantiated", "body": "Jonathan raised a question in the #parrotsketch meeting today about our \nstrategy for safely changing classes that already have instantiated \nobjects. The core problem is this: when you create a class,\n\n   .local pmc classobj, object\n   classobj = newclass 'Foo'\n\ninstantiate an object from it,\n\n   object = classobj.'new'()\n\nand then modify the class,\n\n   classobj.'add_method'('bar', $P3)\n\n- At that point you want 'object' to still reference the old class, so \nit can continue operating without disruption. No problem, you just don't \nmake any changes to it.\n\n- And we can create a new class object inside the add_method call and \nredispatch the add_method to it, leaving the original class object \nunmodified.\n\n- The problem is that after the call you want the 'classobj' variable to \ncontain the new class, rather than the old class. We don't have an \neffective way of morphing that variable to the new class from within a \nmethod call on that class. Or, more specifically, we do, but only by \naltering the class itself, which will morph all references to the class, \nincluding the references from the instantiated objects (which should \nreference the old class instead).\n\nSome alternatives:\n\n1) Do away with safe morphing. Allow all dynamic changes to the class \neven after it has been instantiated. Flag in the class that it's been \nmodified after instantiation, and require each object to check that flag \nbefore it calls a method or accesses an attribute. When the class \nchanges, the object will have to reinitialize with the structure to \nsupport the new class. Disadvantage: Lots of overhead on checking for \nclass modifications, even though modifying a class after it's \ninstantiated is actually pretty rare. (Not my favorite alternative.)\n\n2) Modify the class object so it stores \"version\" information about \nitself (such as an array of pointers to previous class objects). The \ninstantiated object would store both a pointer to its class and a \nversion number for the class. Disadvantage: This adds more complexity to \nthe core object model than seems merited by a feature that's rarely \nused. (Not my favorite alternative.)\n\n3) Modify the core PMC implementation so it tracks information about \nwhich the different containers (registers, temporary variables, \nnamespace entries, etc.) that hold a particular PMC, and which \nparticular container was used to make the method call, so a method call \ncan modify the variable it was called on. Disadvantage: This isn't a \ngenerally useful feature. (Not my favorite alternative.)\n\n4) Do away with automatic morphing. Attempting to make changes to a \nclass that's already been instantiated is not allowed (add_method, etc. \nwill throw an exception). This also eliminates the need for \nremove_method, remove_attribute, remove_role, and remove_parent. To \nmodify a class that has instantiated objects you must clone it first:\n\n   classobj = newclass 'Foo'\n   object = classobj.'new'()\n\n   newclassobj = classobj.'clone'('exclude_methods'=>$P1)\n   newclassobj.'add_method'('bar', $P3)\n   object2 = newclassobj.'new'()\n\nAnd 'clone' could take an option specifying whether this particular \nclone will replace the existing class in the namespace. Disadvantage: It \neliminates some of the DWIMery of the system. On the other hand, it \nmight make it easier to implement a language that doesn't allow \nmodifications to instantiated classes. (This is currently my favorite \nalternative.)\n\nAllison\n\n"}
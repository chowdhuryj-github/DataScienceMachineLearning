{"category": "ham", "to_address": "samba-technical@lists.samba.org", "from_address": "James Peach <jpeach@samba.org>", "subject": "[PATCH 1/4] Make sure groups[0] is the effective gid on FreeBSD. ", "body": "On BSD systems, the first gid passed to setgroups(2) should be the  \neffective\ngid. Make sure we grow the groups list when switching credentials to  \nguarantee\nthis (as far as possible).\n---\nsource/smbd/sec_ctx.c |  128 +++++++++++++++++++++++++++++++++++++ \n+-----------\n1 files changed, 100 insertions(+), 28 deletions(-)\n\ndiff --git a/source/smbd/sec_ctx.c b/source/smbd/sec_ctx.c\nindex be00db9..ca9a6f2 100644\n--- a/source/smbd/sec_ctx.c\n+++ b/source/smbd/sec_ctx.c\n@@ -180,6 +180,70 @@ fail:\n}\n/ \n************************************************************************ \n****\n+ Change our current credential to the given UNIX_USER_TOKEN. This  \ntakes into\n+ account platform-specific quirks surrounding the handling of the  \nsupplementary\n+ groups list.\n+*********************************************************************** \n*****/\n+\n+static BOOL apply_unix_token(const UNIX_USER_TOKEN *ut)\n+{\n+\tint max = groups_max();\n+\n+#ifdef FREEBSD\n+\t/* Most (all?) BSD systems expect that the first element in the groups\n+\t * list passed to setgroups(2) is the effective gid. See also bugzilla\n+\t * bug #3990.\n+\t */\n+\tif (ut->ngroups == NULL || ut->groups[0] != ut->gid) {\n+\t\tgid_t *new_grplist;\n+\n+\t\tut->groups = SMB_REALLOC_ARRAY(ut->groups, gid_t,\n+\t\t\t\t\t\tut->ngroups + 1);\n+\t\tif (ut->groups == NULL)\n+\t\t\tsmb_panic(\"realloc for group list failed\");\n+\t\t}\n+\n+\t\t/* If we already had a group list, shuffle it up to make room\n+\t\t * for the leading effective GID.\n+\t\t */\n+\t\tif (ut->ngroups != 0) {\n+\t\t\tmemmove(ut->groups + 1, ut->groups,\n+\t\t\t\t(ut->ngroups + 1) * sizeof(gid_t));\n+\t\t}\n+\n+\t\tut->ngroups++;\n+\t\tut->groups[0] = ut->gid;\n+\t}\n+\n+#endif /* FREEBSD */\n+\n+\n+\t/* Always truncate the groups list at the system maximum. On most\n+\t * systems, setgroups(2) will fail with EINVAL otherwise.\n+\t */\n+\tif (sys_setgroups((ut->ngroups > max) ? max : ut->ngroups,\n+\t\t\t    ut->groups) == -1) {\n+\t\tif (errno != ENOSYS) {\n+\t\t\tDEBUG(0, (\"WARNING: failed to set group list \"\n+\t\t\t\t\"(%d groups) for UID %ld: %s\\n\",\n+\t\t\t\tut->ngroups, (long)ut->uid, strerror(errno)));\n+\t\t}\n+\t}\n+\n+\t/* If setgroups fails, it's bad, but it might not be the end of\n+\t * the world. OTOH, we don't want to have a group list from\n+\t * some other credential since that could grant access we might\n+\t * not otherwise have.\n+\t */\n+\n+\tif (!become_id(ut->uid, ut->gid)) {\n+\t\treturn False;\n+\t}\n+\n+\treturn True;\n+}\n+\n+/ \n************************************************************************ \n****\n   Create a new security context on the stack.  It is the same as the  \nold\n   one.  User changes are done using the set_sec_ctx() function.\n************************************************************************ \n****/\n@@ -192,7 +256,7 @@ BOOL push_sec_ctx(void)\n\tif (sec_ctx_stack_ndx == MAX_SEC_CTX_DEPTH) {\n\t\tDEBUG(0, (\"Security context stack overflow!\\n\"));\n-\t\tsmb_panic(\"Security context stack overflow!\\n\");\n+\t\tsmb_panic(\"Security context stack overflow!\");\n\t}\n\t/* Store previous user context */\n@@ -243,30 +307,14 @@ void set_sec_ctx(uid_t uid, gid_t gid, int  \nngroups, gid_t *groups, NT_USER_TOKEN\n\tdebug_nt_user_token(DBGC_CLASS, 5, token);\n\tdebug_unix_user_token(DBGC_CLASS, 5, uid, gid, ngroups, groups);\n-\tgain_root();\n-\n-#ifdef HAVE_SETGROUPS\n-\tsys_setgroups(ngroups, groups);\n-#endif\n-\n-\tctx_p->ut.ngroups = ngroups;\n+\t/* Stash the given NT token. */\n-\tSAFE_FREE(ctx_p->ut.groups);\n\tif (token && (token == ctx_p->token)) {\n+\t\tdebug_nt_user_token(DBGC_CLASS, 0, token);\n\t\tsmb_panic(\"DUPLICATE_TOKEN\");\n\t}\n\tTALLOC_FREE(ctx_p->token);\n-\t\n-\tif (ngroups) {\n-\t\tctx_p->ut.groups = (gid_t *)memdup(groups,\n-\t\t\t\t\t\t   sizeof(gid_t) * ngroups);\n-\t\tif (!ctx_p->ut.groups) {\n-\t\t\tsmb_panic(\"memdup failed\");\n-\t\t}\n-\t} else {\n-\t\tctx_p->ut.groups = NULL;\n-\t}\n\tif (token) {\n\t\tctx_p->token = dup_nt_token(NULL, token);\n@@ -277,11 +325,31 @@ void set_sec_ctx(uid_t uid, gid_t gid, int  \nngroups, gid_t *groups, NT_USER_TOKEN\n\t\tctx_p->token = NULL;\n\t}\n-\tbecome_id(uid, gid);\n+\t/* Create the new Unix user token. */\n+\n+\tSAFE_FREE(ctx_p->ut.groups);\n+\n+\tctx_p->ut.ngroups = ngroups;\n+\tif (ngroups) {\n+\t\tctx_p->ut.groups = (gid_t *)memdup(groups,\n+\t\t\t\t\t\t   sizeof(gid_t) * ngroups);\n+\t\tif (!ctx_p->ut.groups) {\n+\t\t\tsmb_panic(\"memdup for groups list failed\");\n+\t\t}\n+\t} else {\n+\t\tctx_p->ut.groups = NULL;\n+\t}\n\tctx_p->ut.uid = uid;\n\tctx_p->ut.gid = gid;\n+\t/* Switch to our new Unix credential. */\n+\tgain_root();\n+\tif (!apply_unix_token(&ctx_p->ut)) {\n+\t\tdebug_unix_user_token(DBGC_CLASS, 0, uid, gid, ngroups, groups);\n+\t\tsmb_panic(\"failed to switch to a new user credential\");\n+\t}\n+\n\t/* Update current_user stuff */\n\tcurrent_user.ut.uid = uid;\n@@ -315,7 +383,7 @@ BOOL pop_sec_ctx(void)\n\tif (sec_ctx_stack_ndx == 0) {\n\t\tDEBUG(0, (\"Security context stack underflow!\\n\"));\n-\t\tsmb_panic(\"Security context stack underflow!\\n\");\n+\t\tsmb_panic(\"Security context stack underflow!\");\n\t}\n\tctx_p = &sec_ctx_stack[sec_ctx_stack_ndx];\n@@ -334,15 +402,19 @@ BOOL pop_sec_ctx(void)\n\tsec_ctx_stack_ndx--;\n-\tgain_root();\n-\n\tprev_ctx_p = &sec_ctx_stack[sec_ctx_stack_ndx];\n-#ifdef HAVE_SETGROUPS\n-\tsys_setgroups(prev_ctx_p->ut.ngroups, prev_ctx_p->ut.groups);\n-#endif\n-\n-\tbecome_id(prev_ctx_p->ut.uid, prev_ctx_p->ut.gid);\n+\t/* Switch to our new Unix credential. */\n+\tgain_root();\n+\tif (!apply_unix_token(&prev_ctx_p->ut)) {\n+\t\tDEBUG(0, (\"failed to restore a user credential\\n\"));\n+\t\tdebug_unix_user_token(DBGC_CLASS, 0,\n+\t\t\tprev_ctx_p->ut.uid,\n+\t\t\tprev_ctx_p->ut.gid,\n+\t\t\tprev_ctx_p->ut.ngroups,\n+\t\t\tprev_ctx_p->ut.groups);\n+\t\tsmb_panic(\"failed to restore to a user credential\");\n+\t}\n\t/* Update current_user stuff */\n--\n1.5.2.1\n\n\n--\nJames Peach | jpeach@samba.org\n\n\n"}
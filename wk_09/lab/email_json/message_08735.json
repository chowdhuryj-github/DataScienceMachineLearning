{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Michael Adam <ma@sernet.de>", "subject": "Rev 5368: merge from upstream in\n\thttp://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/", "body": "At http://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/\n\n------------------------------------------------------------\nrevno: 5368\nrevision-id: ma@sernet.de-20070418113812-9c0c3214f32524be\nparent: ma@sernet.de-20070418111737-d6f0d4da2e435822\nparent: jra@samba.org-20070418050155-9pwpbark0woks5q6\ncommitter: Michael Adam \nbranch nick: SAMBA_3_0-registry.bzr\ntimestamp: Wed 2007-04-18 13:38:12 +0200\nmessage:\n  merge from upstream\nmodified:\n  REVISION                       REVISION-20060530022625-68239662668b41c3\n  source/Makefile.in             Makefile.in-20060530022626-b16dac2328ebe703\n  source/lib/fault.c             fault.c-20060530022627-d2883d4c08c20703\n  source/lib/tdb/common/freelist.c freelist.c-20070416111147-cebijg5x16vcb45j-16\n  source/lib/tdb/common/freelistcheck.c freelistcheck.c-20070416111147-cebijg5x16vcb45j-17\n  source/lib/tdb/common/tdb_private.h tdb_private.h-20070416111147-cebijg5x16vcb45j-22\n  source/lib/tdb/common/transaction.c transaction.c-20070416111147-cebijg5x16vcb45j-24\n  source/libsmb/clifsinfo.c      clifsinfo.c-20060530022627-9360212d14f20006\n  source/libsmb/errormap.c       errormap.c-20060530022627-f469e8a07ae28ddc\n  source/smbd/seal.c             seal.c-20070320050326-brtwj05flzzelvyk-1\n    ------------------------------------------------------------\n    merged: jra@samba.org-20070418050155-9pwpbark0woks5q6\n    parent: jerry@samba.org-20070417231055-nsqlf0n9bi00la0r\n    committer: jra@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Wed 2007-04-18 00:01:55 -0500\n    message:\n      jra@samba.org (r22327)  2007-04-17 19:34:10 -0500 (Tue, 17 Apr 2007)\n          \n          Finish the gss-spnego part of the seal code. Now\n          for testing....\n          Jeremy.\n          \n    ------------------------------------------------------------\n    merged: jerry@samba.org-20070417231055-nsqlf0n9bi00la0r\n    parent: lmuelle@samba.org-20070417230834-tbhy2j2ut6it5ods\n    committer: jerry@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 18:10:55 -0500\n    message:\n      jerry@samba.org (r22321)  2007-04-17 16:32:59 -0500 (Tue, 17 Apr 2007)\n          \n          BUG 4509: Makefile fix linking the sfu.so and rfc2307.so \n          plugins in $libdir/nss_info to idmap/ad.so\n          \n          \n    ------------------------------------------------------------\n    merged: lmuelle@samba.org-20070417230834-tbhy2j2ut6it5ods\n    parent: lmuelle@samba.org-20070417230610-j32kpxs31xsvrb2r\n    committer: lmuelle@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 18:08:34 -0500\n    message:\n      lmuelle@samba.org (r22320)  2007-04-17 13:35:10 -0500 (Tue, 17 Apr 2007)\n          \n          Be more careful and check for the euid instead of the uid.\n          \n          Thx for the hint James!\n          \n    ------------------------------------------------------------\n    merged: lmuelle@samba.org-20070417230610-j32kpxs31xsvrb2r\n    parent: metze@samba.org-20070417230418-t8nztbn7ea6mwz9e\n    committer: lmuelle@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 18:06:10 -0500\n    message:\n      lmuelle@samba.org (r22318)  2007-04-17 12:17:19 -0500 (Tue, 17 Apr 2007)\n          \n          If we're running as non root we might not be able to dump the core file\n          to the corepath.\n          \n          Even the chdir() will fail if the LOGFILEBASE path is set 0700.\n          \n          If the currrent user doesn't have the permission to create the core file\n          we end with:\n          unable to change to \n          refusing to dump core\n          \n          The alternative would be to change the permissions of the directory.\n          But taht would not ensure core dumps are working out of the box.\n          \n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417230418-t8nztbn7ea6mwz9e\n    parent: metze@samba.org-20070417230206-yyt6sohsspghv723\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 18:04:18 -0500\n    message:\n      metze@samba.org (r22317)  2007-04-17 12:07:14 -0500 (Tue, 17 Apr 2007)\n          \n          add tdb_ prefix to non static function\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417230206-yyt6sohsspghv723\n    parent: metze@samba.org-20070417170717-d21x3e2w4vg57tcd\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 18:02:06 -0500\n    message:\n      metze@samba.org (r22316)  2007-04-17 12:03:38 -0500 (Tue, 17 Apr 2007)\n          \n          merge from samba4:\n          \n          this function should be static\n          \n          metze\n=== modified file 'REVISION'\n--- a/REVISION\t2007-04-17 17:07:17 +0000\n+++ b/REVISION\t2007-04-18 05:01:55 +0000\n@@ -2,9 +2,9 @@\n URL: svn+ssh://svn.samba.org/home/svn/samba/branches/SAMBA_3_0\n Repository Root: svn+ssh://svn.samba.org/home/svn/samba\n Repository UUID: 0c0555d6-39d7-0310-84fc-f1cc0bd64818\n-Revision: 22315\n+Revision: 22327\n Node Kind: directory\n-Last Changed Author: metze\n-Last Changed Rev: 22315\n-Last Changed Date: 2007-04-17 11:53:06 -0500 (Tue, 17 Apr 2007)\n+Last Changed Author: jra\n+Last Changed Rev: 22327\n+Last Changed Date: 2007-04-17 19:34:10 -0500 (Tue, 17 Apr 2007)\n \n\n=== modified file 'source/Makefile.in'\n--- a/source/Makefile.in\t2007-04-17 20:33:14 +0000\n+++ b/source/Makefile.in\t2007-04-18 11:38:12 +0000\n@@ -77,6 +77,7 @@\n PDBLIBDIR = $(LIBDIR)/pdb\n RPCLIBDIR = $(LIBDIR)/rpc\n IDMAPLIBDIR = $(LIBDIR)/idmap\n+NSSINFOLIBDIR = $(LIBDIR)/nss_info\n CHARSETLIBDIR = $(LIBDIR)/charset\n AUTHLIBDIR = $(LIBDIR)/auth\n CONFIGLIBDIR = $(LIBDIR)/config\n@@ -1807,6 +1808,7 @@\n \t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(PDBLIBDIR) $(PDB_MODULES)\n \t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(RPCLIBDIR) $(RPC_MODULES)\n \t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(IDMAPLIBDIR) $(IDMAP_MODULES)\n+\t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(NSSINFOLIBDIR) $(NSS_INFO_MODULES)\n \t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(CHARSETLIBDIR) $(CHARSET_MODULES)\n \t@$(SHELL) $(srcdir)/script/installmodules.sh $(INSTALLPERMS) $(DESTDIR) $(prefix) $(AUTHLIBDIR) $(AUTH_MODULES)\n \t@$(SHELL) $(srcdir)/script/linkmodules.sh $(DESTDIR)$(PDBLIBDIR) ldapsam.@SHLIBEXT@ ldapsam_compat.@SHLIBEXT@\n@@ -1814,6 +1816,7 @@\n \t@$(SHELL) $(srcdir)/script/linkmodules.sh $(DESTDIR)$(AUTHLIBDIR) sam.@SHLIBEXT@ sam_ignoredomain.@SHLIBEXT@\n \t@$(SHELL) $(srcdir)/script/linkmodules.sh $(DESTDIR)$(AUTHLIBDIR) domain.@SHLIBEXT@ trustdomain.@SHLIBEXT@ ntdomain.@SHLIBEXT@\n \t@$(SHELL) $(srcdir)/script/linkmodules.sh $(DESTDIR)$(AUTHLIBDIR) builtin.@SHLIBEXT@ guest.@SHLIBEXT@ fixed_challenge.@SHLIBEXT@ name_to_ntstatus.@SHLIBEXT@\n+\t@$(SHELL) $(srcdir)/script/linkmodules.sh $(DESTDIR)$(NSSINFOLIBDIR) ../idmap/ad.@SHLIBEXT@ rfc2307.@SHLIBEXT@ sfu.@SHLIBEXT@\n \n installscripts: installdirs\n \t@$(SHELL) $(srcdir)/script/installscripts.sh $(INSTALLPERMS) $(DESTDIR)$(BINDIR) $(SCRIPTS)\n\n=== modified file 'source/lib/fault.c'\n--- a/source/lib/fault.c\t2007-04-06 23:08:29 +0000\n+++ b/source/lib/fault.c\t2007-04-17 23:08:34 +0000\n@@ -161,6 +161,13 @@\n \t}\n \n #if DUMP_CORE\n+\t/* If we're running as non root we might not be able to dump the core\n+\t * file to the corepath.  There must not be an unbecome_root() before\n+\t * we call abort(). */\n+\tif (geteuid() != 0) {\n+\t\tbecome_root();\n+\t}\n+\n \tif (*corepath != '\\0') {\n \t\t/* The chdir might fail if we dump core before we finish\n \t\t * processing the config file.\n\n=== modified file 'source/lib/tdb/common/freelist.c'\n--- a/source/lib/tdb/common/freelist.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/common/freelist.c\t2007-04-17 23:04:18 +0000\n@@ -29,7 +29,7 @@\n #include \"tdb_private.h\"\n \n /* read a freelist record and check for simple errors */\n-int rec_free_read(struct tdb_context *tdb, tdb_off_t off, struct list_struct *rec)\n+int tdb_rec_free_read(struct tdb_context *tdb, tdb_off_t off, struct list_struct *rec)\n {\n \tif (tdb->methods->tdb_read(tdb, off, rec, sizeof(*rec),DOCONV()) == -1)\n \t\treturn -1;\n@@ -37,7 +37,7 @@\n \tif (rec->magic == TDB_MAGIC) {\n \t\t/* this happens when a app is showdown while deleting a record - we should\n \t\t   not completely fail when this happens */\n-\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"rec_free_read non-free magic 0x%x at offset=%d - fixing\\n\", \n+\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"tdb_rec_free_read non-free magic 0x%x at offset=%d - fixing\\n\", \n \t\t\t rec->magic, off));\n \t\trec->magic = TDB_FREE_MAGIC;\n \t\tif (tdb->methods->tdb_write(tdb, off, rec, sizeof(*rec)) == -1)\n@@ -47,7 +47,7 @@\n \tif (rec->magic != TDB_FREE_MAGIC) {\n \t\t/* Ensure ecode is set for log fn. */\n \t\ttdb->ecode = TDB_ERR_CORRUPT;\n-\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"rec_free_read bad magic 0x%x at offset=%d\\n\", \n+\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"tdb_rec_free_read bad magic 0x%x at offset=%d\\n\", \n \t\t\t   rec->magic, off));\n \t\treturn TDB_ERRCODE(TDB_ERR_CORRUPT, -1);\n \t}\n@@ -286,7 +286,7 @@\n \t   issues when faced with a slowly increasing record size.\n \t */\n \twhile (rec_ptr) {\n-\t\tif (rec_free_read(tdb, rec_ptr, rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, rec_ptr, rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n@@ -311,7 +311,7 @@\n \t}\n \n \tif (bestfit.rec_ptr != 0) {\n-\t\tif (rec_free_read(tdb, bestfit.rec_ptr, rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, bestfit.rec_ptr, rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n\n=== modified file 'source/lib/tdb/common/freelistcheck.c'\n--- a/source/lib/tdb/common/freelistcheck.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/common/freelistcheck.c\t2007-04-17 23:04:18 +0000\n@@ -88,7 +88,7 @@\n \t\t\tgoto fail;\n \t\t}\n \n-\t\tif (rec_free_read(tdb, rec_ptr, &rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, rec_ptr, &rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n\n=== modified file 'source/lib/tdb/common/tdb_private.h'\n--- a/source/lib/tdb/common/tdb_private.h\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/common/tdb_private.h\t2007-04-17 23:04:18 +0000\n@@ -206,7 +206,7 @@\n \t\t\t   struct list_struct *rec);\n void tdb_io_init(struct tdb_context *tdb);\n int tdb_expand(struct tdb_context *tdb, tdb_off_t size);\n-int rec_free_read(struct tdb_context *tdb, tdb_off_t off,\n-\t\t  struct list_struct *rec);\n+int tdb_rec_free_read(struct tdb_context *tdb, tdb_off_t off,\n+\t\t      struct list_struct *rec);\n \n \n\n=== modified file 'source/lib/tdb/common/transaction.c'\n--- a/source/lib/tdb/common/transaction.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/common/transaction.c\t2007-04-17 23:02:06 +0000\n@@ -358,8 +358,8 @@\n /*\n   brlock during a transaction - ignore them\n */\n-int transaction_brlock(struct tdb_context *tdb, tdb_off_t offset, \n-\t\t       int rw_type, int lck_type, int probe, size_t len)\n+static int transaction_brlock(struct tdb_context *tdb, tdb_off_t offset, \n+\t\t\t      int rw_type, int lck_type, int probe, size_t len)\n {\n \treturn 0;\n }\n\n=== modified file 'source/libsmb/clifsinfo.c'\n--- a/source/libsmb/clifsinfo.c\t2007-03-30 15:35:10 +0000\n+++ b/source/libsmb/clifsinfo.c\t2007-04-18 05:01:55 +0000\n@@ -2,6 +2,7 @@\n    Unix SMB/CIFS implementation.\n    FS info functions\n    Copyright (C) Stefan (metze) Metzmacher\t2003\n+   Copyright (C) Jeremy Allison 2007.\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -355,6 +356,22 @@\n }\n \n /******************************************************************************\n+ Make a client state struct.\n+******************************************************************************/\n+\n+static struct smb_trans_enc_state *make_cli_enc_state(enum smb_trans_enc_type smb_enc_type)\n+{\n+\tstruct smb_trans_enc_state *es = NULL;\n+\tes = SMB_MALLOC_P(struct smb_trans_enc_state);\n+\tif (!es) {\n+\t\treturn NULL;\n+\t}\n+\tZERO_STRUCTP(es);\n+\tes->smb_enc_type = smb_enc_type;\n+\treturn es;\n+}\n+\n+/******************************************************************************\n  Start a raw ntlmssp encryption.\n ******************************************************************************/\n \n@@ -367,14 +384,11 @@\n \tDATA_BLOB blob_out = data_blob(NULL, 0);\n \tDATA_BLOB param_out = data_blob(NULL, 0);\n \tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n-\tstruct smb_trans_enc_state *es = NULL;\n+\tstruct smb_trans_enc_state *es = make_cli_enc_state(SMB_TRANS_ENC_NTLM);\n \n-\tes = SMB_MALLOC_P(struct smb_trans_enc_state);\n \tif (!es) {\n \t\treturn NT_STATUS_NO_MEMORY;\n \t}\n-\tZERO_STRUCTP(es);\n-\tes->smb_enc_type = SMB_TRANS_ENC_NTLM;\n \tstatus = ntlmssp_client_start(&es->s.ntlmssp_state);\n \tif (!NT_STATUS_IS_OK(status)) {\n \t\tgoto fail;\n@@ -423,3 +437,166 @@\n \tcommon_free_encryption_state(&es);\n \treturn status;\n }\n+\n+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)\n+\n+#ifndef SMB_GSS_REQUIRED_FLAGS\n+#define SMB_GSS_REQUIRED_FLAGS (GSS_C_CONF_FLAG|GSS_C_INTEG_FLAG|GSS_C_MUTUAL_FLAG|GSS_C_REPLAY_FLAG|GSS_C_SEQUENCE_FLAG)\n+#endif\n+\n+/******************************************************************************\n+ Get client gss blob to send to a server.\n+******************************************************************************/\n+\n+static NTSTATUS make_cli_gss_blob(struct smb_trans_enc_state *es,\n+\t\t\t\tconst char *service,\n+\t\t\t\tconst char *host,\n+\t\t\t\tNTSTATUS status_in,\n+\t\t\t\tDATA_BLOB spnego_blob_in,\n+\t\t\t\tDATA_BLOB *p_blob_out)\n+{\n+\tconst char *krb_mechs[] = {OID_KERBEROS5_OLD, OID_KERBEROS5, NULL};\n+\tOM_uint32 ret;\n+\tOM_uint32 min;\n+\tgss_name_t srv_name;\n+\tgss_buffer_desc input_name;\n+\tgss_buffer_desc *p_tok_in;\n+\tgss_buffer_desc tok_out, tok_in;\n+\tDATA_BLOB blob_out = data_blob(NULL, 0);\n+\tDATA_BLOB blob_in = data_blob(NULL, 0);\n+\tchar *host_princ_s = NULL;\n+\tOM_uint32 ret_flags = 0;\n+\tNTSTATUS status = NT_STATUS_OK;\n+\n+\tmemset(&tok_out, '\\0', sizeof(tok_out));\n+\n+\t/* Get a ticket for the service@host */\n+\tasprintf(&host_princ_s, \"%s@%s\", service, host);\n+\tif (host_princ_s == NULL) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tinput_name.value = host_princ_s;\n+\tinput_name.length = strlen(host_princ_s) + 1;\n+\n+\tret = gss_import_name(&min,\n+\t\t\t\t&input_name,\n+\t\t\t\tGSS_C_NT_HOSTBASED_SERVICE,\n+\t\t\t\t&srv_name);\n+\n+\tif (ret != GSS_S_COMPLETE) {\n+\t\tSAFE_FREE(host_princ_s);\n+\t\treturn map_nt_error_from_gss(ret, min);\n+\t}\n+\n+\tif (spnego_blob_in.length == 0) {\n+\t\tp_tok_in = GSS_C_NO_BUFFER;\n+\t} else {\n+\t\t/* Remove the SPNEGO wrapper */\n+\t\tif (!spnego_parse_auth_response(spnego_blob_in, status_in, OID_KERBEROS5, &blob_in)) {\n+\t\t\tstatus = NT_STATUS_UNSUCCESSFUL;\n+\t\t\tgoto fail;\n+\t\t}\n+\t\ttok_in.value = blob_in.data;\n+\t\ttok_in.length = blob_in.length;\n+\t\tp_tok_in = &tok_in;\n+\t}\n+\n+\tret = gss_init_sec_context(&min,\n+\t\t\t\tGSS_C_NO_CREDENTIAL, /* Use our default cred. */\n+\t\t\t\t&es->s.gss_state->gss_ctx,\n+\t\t\t\tsrv_name,\n+\t\t\t\tGSS_C_NO_OID, /* default OID. */\n+\t\t\t\tGSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG | GSS_C_SEQUENCE_FLAG,\n+\t\t\t\tGSS_C_INDEFINITE,\t/* requested ticket lifetime. */\n+\t\t\t\tNULL,   /* no channel bindings */\n+\t\t\t\tp_tok_in,\n+\t\t\t\tNULL,   /* ignore mech type */\n+\t\t\t\t&tok_out,\n+\t\t\t\t&ret_flags,\n+\t\t\t\tNULL);  /* ignore time_rec */\n+\n+\tstatus = map_nt_error_from_gss(ret, min);\n+\tif (!NT_STATUS_IS_OK(status) && !NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\tgoto fail;\n+\t}\n+\n+\tif ((ret_flags & SMB_GSS_REQUIRED_FLAGS) != SMB_GSS_REQUIRED_FLAGS) {\n+\t\tstatus = NT_STATUS_ACCESS_DENIED;\n+\t}\n+\n+\tblob_out = data_blob(tok_out.value, tok_out.length);\n+\n+\t/* Wrap in an SPNEGO wrapper */\n+\t*p_blob_out = gen_negTokenTarg(krb_mechs, blob_out);\n+\n+  fail:\n+\n+\tdata_blob_free(&blob_out);\n+\tdata_blob_free(&blob_in);\n+\tSAFE_FREE(host_princ_s);\n+\tgss_release_name(&min, &srv_name);\n+\tif (tok_out.value) {\n+\t\tgss_release_buffer(&min, &tok_out);\n+\t}\n+\treturn status;\n+}\n+\n+/******************************************************************************\n+ Start a SPNEGO gssapi encryption context.\n+******************************************************************************/\n+\n+NTSTATUS cli_gss_smb_encryption_start(struct cli_state *cli)\n+{\n+\tDATA_BLOB blob_recv = data_blob(NULL, 0);\n+\tDATA_BLOB blob_send = data_blob(NULL, 0);\n+\tDATA_BLOB param_out = data_blob(NULL, 0);\n+\tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n+\tfstring fqdn;\n+\tconst char *servicename;\n+\tstruct smb_trans_enc_state *es = make_cli_enc_state(SMB_TRANS_ENC_GSS);\n+\n+\tif (!es) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tname_to_fqdn(fqdn, cli->desthost);\n+\tstrlower_m(fqdn);\n+\n+\tservicename = \"cifs\";\n+\tstatus = make_cli_gss_blob(es, servicename, fqdn, NT_STATUS_OK, blob_recv, &blob_send);\n+\tif (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\tservicename = \"host\";\n+\t\tstatus = make_cli_gss_blob(es, servicename, fqdn, NT_STATUS_OK, blob_recv, &blob_send);\n+\t\tif (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\t\tgoto fail;\n+\t\t}\n+\t}\n+\n+\tdo {\n+\t\tdata_blob_free(&blob_recv);\n+\t\tstatus = enc_blob_send_receive(cli, &blob_send, &blob_recv, &param_out);\n+\t\tif (param_out.length == 2) {\n+\t\t\tes->enc_ctx_num = SVAL(param_out.data, 0);\n+\t\t}\n+\t\tdata_blob_free(&blob_send);\n+\t\tstatus = make_cli_gss_blob(es, servicename, fqdn, status, blob_recv, &blob_send);\n+\t} while (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED));\n+\tdata_blob_free(&blob_recv);\n+\n+\tif (NT_STATUS_IS_OK(status)) {\n+\t\t/* Replace the old state, if any. */\n+\t\tif (cli->trans_enc_state) {\n+\t\t\tcommon_free_encryption_state(&cli->trans_enc_state);\n+\t\t}\n+\t\tcli->trans_enc_state = es;\n+\t\tcli->trans_enc_state->enc_on = True;\n+\t\tes = NULL;\n+\t}\n+\n+  fail:\n+\n+\tcommon_free_encryption_state(&es);\n+\treturn status;\n+}\n+#endif\n\n=== modified file 'source/libsmb/errormap.c'\n--- a/source/libsmb/errormap.c\t2007-03-30 15:26:58 +0000\n+++ b/source/libsmb/errormap.c\t2007-04-18 05:01:55 +0000\n@@ -1652,6 +1652,10 @@\n \t\treturn NT_STATUS_OK;\n \t}\n \n+\tif (gss_maj == GSS_S_CONTINUE_NEEDED) {\n+\t\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n+\t}\n+\n \tif (gss_maj == GSS_S_FAILURE) {\n \t\treturn map_nt_error_from_unix((int)minor);\n \t}\n\n=== modified file 'source/smbd/seal.c'\n--- a/source/smbd/seal.c\t2007-04-16 17:01:59 +0000\n+++ b/source/smbd/seal.c\t2007-04-18 05:01:55 +0000\n@@ -333,9 +333,12 @@\n \tOM_uint32 flags = 0;\n \tgss_buffer_desc in_buf, out_buf;\n \tstruct smb_tran_enc_state_gss *gss_state;\n+\tDATA_BLOB auth_reply = data_blob(NULL,0);\n+\tDATA_BLOB response = data_blob(NULL,0);\n+\tNTSTATUS status;\n \n \tif (!partial_srv_trans_enc_ctx) {\n-\t\tNTSTATUS status = make_srv_encryption_context(SMB_TRANS_ENC_GSS, &partial_srv_trans_enc_ctx);\n+\t\tstatus = make_srv_encryption_context(SMB_TRANS_ENC_GSS, &partial_srv_trans_enc_ctx);\n \t\tif (!NT_STATUS_IS_OK(status)) {\n \t\t\treturn status;\n \t\t}\n@@ -361,8 +364,9 @@\n \t\t\t\tNULL,\t\t/* Ingore time. */\n \t\t\t\tNULL);\t\t/* Ignore delegated creds. */\n \n+\tstatus = gss_err_to_ntstatus(ret, min);\n \tif (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {\n-\t\treturn gss_err_to_ntstatus(ret, min);\n+\t\treturn status;\n \t}\n \n \t/* Ensure we've got sign+seal available. */\n@@ -376,20 +380,18 @@\n \t\t}\n \t}\n \n-\tSAFE_FREE(*ppdata);\n-\t*ppdata = memdup(out_buf.value, out_buf.length);\n-\tif (!*ppdata) {\n-\t\tgss_release_buffer(&min, &out_buf);\n-\t\treturn NT_STATUS_NO_MEMORY;\n-\t}\n-\t*p_data_size = out_buf.length;\n+\tauth_reply = data_blob(out_buf.value, out_buf.length);\n \tgss_release_buffer(&min, &out_buf);\n \n-\tif (ret != GSS_S_CONTINUE_NEEDED) {\n-\t\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n-\t} else {\n-\t\treturn NT_STATUS_OK;\n-\t}\n+\t/* Wrap in SPNEGO. */\n+\tresponse = spnego_gen_auth_response(&auth_reply, status, OID_KERBEROS5);\n+\tdata_blob_free(&auth_reply);\n+\n+\tSAFE_FREE(*ppdata);\n+\t*ppdata = response.data;\n+\t*p_data_size = response.length;\n+\n+\treturn status;\n }\n #endif\n \n\n"}
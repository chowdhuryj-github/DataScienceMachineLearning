{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14390 - doc/trunk/design/syn", "body": "Author: larry\nDate: Mon May 14 10:13:16 2007\nNew Revision: 14390\n\nModified:\n   doc/trunk/design/syn/S02.pod\n   doc/trunk/design/syn/S06.pod\n   doc/trunk/design/syn/S12.pod\n\nLog:\ncoercion type renamed from \"returns\" to \"as\" to avoid confusion with \"of\" type.\nambiguity in block-end parsing noted by rhr++\n\n\nModified: doc/trunk/design/syn/S02.pod\n==============================================================================\n--- doc/trunk/design/syn/S02.pod\t(original)\n+++ doc/trunk/design/syn/S02.pod\tMon May 14 10:13:16 2007\n@@ -822,19 +822,19 @@\n \n In either case this sets the C property of the container to C.\n \n-Subroutines have a variant of the C property, C, that sets\n-the C property instead.  The C property specifies a\n+Subroutines have a variant of the C property, C, that sets\n+the C property instead.  The C property specifies a\n constraint (or perhaps coercion) to be enforced on the return value (either\n by explicit call to C or by implicit fall-off-the-end return).\n This constraint, unlike the C property, is not advertised as the\n type of the routine.  You can think of it as the implicit type signature of\n the (possibly implicit) return statement.  It's therefore available for\n-type inferencing within the routine but not outside it.  If no inner type\n+type inferencing within the routine but not outside it.  If no C type\n is declared, it is assumed to be the same as the C type, if declared.\n \n     sub get_pet() of Animal {...}       # of type, obviously\n     our Animal sub get_pet() {...}      # of type\n-    sub get_pet() returns Animal {...}  # inner type\n+    sub get_pet() as Animal {...}       # as type\n \n A value type on an array or hash specifies the type stored by each element:\n \n@@ -892,18 +892,19 @@\n     my Hash of Array of Recipe %book;           # HoHoAoRecipe\n     my %book of Hash of Array of Recipe;        # same thing\n \n-The C form may be used in subroutines:\n+The C form may be used in subroutines:\n \n-    my sub get_book ($key) returns Hash of Array of Recipe {...}\n+    my sub get_book ($key) as Hash of Array of Recipe {...}\n \n Alternately, the return type may be specified within the signature:\n \n     my sub get_book ($key --> Hash of Array of Recipe) {...}\n \n There is a slight difference, insofar as the type inferencer will\n-ignore a C but pay attention to C<< --> >> or prefix type\n+ignore a C but pay attention to C<< --> >> or prefix type\n declarations, also known as the C type.  Only the inside of the\n-subroutine pays attention to C.\n+subroutine pays attention to C, and essentially coerces the return\n+value to the indicated type, just as if you'd coerced each return expression.\n \n You may also specify the C type as the C trait:\n \n@@ -963,18 +964,18 @@\n \n On a scoped subroutine, a return type can be specified before or after\n the name.  We call all return types \"return types\", but distinguish\n-two kinds of return types, the C type and the C type,\n+two kinds of return types, the C type and the C type,\n because the C type is normally an \"official\" named type and\n-declares the official interface to the routine, while the C\n+declares the official interface to the routine, while the C\n type is merely a constraint on what may be returned by the routine\n from the routine's point of view.\n \n-    our sub lay returns Egg {...}       # inner type\n+    our sub lay as Egg {...}            # as type\n     our Egg sub lay {...}               # of type\n     our sub lay of Egg {...}            # of type\n     our sub lay (--> Egg) {...}         # of type\n \n-    my sub hat returns Rabbit {...}     # inner type\n+    my sub hat as Rabbit {...}          # as type\n     my Rabbit sub hat {...}             # of type\n     my sub hat of Rabbit {...}          # of type\n     my sub hat (--> Rabbit) {...}       # of type\n@@ -983,14 +984,14 @@\n namespace (module, class, grammar, or package), as if it's scoped with\n the C scope modifier. Any return type must go after the name:\n \n-    sub lay returns Egg {...}           # inner type\n+    sub lay as Egg {...}                # as type\n     sub lay of Egg {...}                # of type\n     sub lay (--> Egg) {...}             # of type\n \n On an anonymous subroutine, any return type can only go after the C\n keyword:\n \n-    $lay = sub returns Egg {...};       # inner type\n+    $lay = sub as Egg {...};            # as type\n     $lay = sub of Egg {...};            # of type\n     $lay = sub (--> Egg) {...};         # of type\n \n@@ -1003,14 +1004,14 @@\n without affecting the meaning.\n \n The return type may also be specified after a C<< --> >> token within\n-the signature.  This doesn't mean exactly the same thing as C.\n+the signature.  This doesn't mean exactly the same thing as C.\n The C type is the \"official\" return type, and may therefore be\n-used to do type inferencing outside the sub.  The C type only\n+used to do type inferencing outside the sub.  The C type only\n makes the return type available to the internals of the sub so that\n the C statement can know its context, but outside the sub we\n don't know anything about the return value, as if no return type had\n been declared.  The prefix form specifies the C type rather than\n-the C type, so the return type of\n+the C type, so the return type of\n \n     my Fish sub wanda ($x) { ... }\n \n@@ -1020,15 +1021,15 @@\n \n I as if you'd said\n \n-    my sub wanda ($x) returns Fish { ... }\n+    my sub wanda ($x) as Fish { ... }\n \n-It is possible for the C type to disagree with the C type:\n+It is possible for the C type to disagree with the C type:\n \n-    my Squid sub wanda ($x) returns Fish { ... }\n+    my Squid sub wanda ($x) as Fish { ... }\n \n or equivalently,\n \n-    my sub wanda ($x --> Squid) returns Fish { ... }\n+    my sub wanda ($x --> Squid) as Fish { ... }\n \n This is not lying to yourself--it's lying to the world.  Having a\n different inner type is useful if you wish to hold your routine to\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tMon May 14 10:13:16 2007\n@@ -13,9 +13,9 @@\n \n   Maintainer: Larry Wall \n   Date: 21 Mar 2003\n-  Last Modified: 28 Mar 2007\n+  Last Modified: 14 May 2007\n   Number: 6\n-  Version: 82\n+  Version: 83\n \n \n This document summarizes Apocalypse 6, which covers subroutines and the\n@@ -143,7 +143,7 @@\n statement level control syntax.  A bare block where a term is expected\n merely produces a C object.  If the term bare block occurs in a list,\n it is considered the final element of that list unless followed immediately\n-by a comma or comma surrogate.\n+by a comma or comma surrogate (intervening C<\\h*> or \"unspace\" is allowed).\n \n =head2 \"Pointy blocks\"\n \n\nModified: doc/trunk/design/syn/S12.pod\n==============================================================================\n--- doc/trunk/design/syn/S12.pod\t(original)\n+++ doc/trunk/design/syn/S12.pod\tMon May 14 10:13:16 2007\n@@ -1316,13 +1316,13 @@\n     }\n \n Other traits are applied with a single word, and we call one of those a\n-\"trait verb\".  For instance, the \"C\" trait\n+\"trait verb\".  For instance, the \"C\" trait\n is defined something like this:\n \n-    role returns {\n-        has ReturnType $.returns;\n-        multi sub trait_verb:returns($container; ReturnType $arg) {\n-            $container does returns($arg);\n+    role as {\n+        has ReturnType $.as;\n+        multi sub trait_verb:as($container; ReturnType $arg) {\n+            $container does as($arg);\n         }\n         ...\n     }\n@@ -1811,7 +1811,7 @@\n \n     name                the name of the method\n     signature           the parameters of the method\n-    returns             the return type of the method\n+    as                  the coercion type of the method\n     multi               whether duplicate names are allowed\n     do                  the method body\n \n\n"}
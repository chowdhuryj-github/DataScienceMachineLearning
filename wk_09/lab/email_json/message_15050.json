{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14382 - doc/trunk/design/syn", "body": "Author: larry\nDate: Tue Apr 24 22:06:33 2007\nNew Revision: 14382\n\nModified:\n   doc/trunk/design/syn/S06.pod\n   doc/trunk/design/syn/S12.pod\n\nLog:\nClarifications suggested by TheDamian++\nKilled \"next METHOD\", now just use nextsame etc.\nDefined \"lastcall\" to allow return from final candidate.\nSet up WHENCE mechanism for undefined prototype objects to autovivify lazily.\n\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tTue Apr 24 22:06:33 2007\n@@ -2100,7 +2100,15 @@\n C and C, but a tail call is explicitly enforced;\n any code following the call will be unreached, as if a return had\n been executed there before calling into the destination routine.\n-Within a method C is equivalent to C.\n+\n+Within an ordinary method dispatch these functions treat the rest\n+of the dispatcher's candidate list as the wrapped function, which\n+generally works out to calling the same method in one of our parent\n+(or older sibling) classes.  Likewise within a multiple dispatch the\n+current routine may defer to candidates further down the candidate\n+list.  Although not necessarily related by a class hierarchy, such\n+later candidates are considered more generic and hence likelier\n+to be able to handle various unforeseen conditions (perhaps).\n \n =head2 The C<&?ROUTINE> object\n \n\nModified: doc/trunk/design/syn/S12.pod\n==============================================================================\n--- doc/trunk/design/syn/S12.pod\t(original)\n+++ doc/trunk/design/syn/S12.pod\tTue Apr 24 22:06:33 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 27 Oct 2004\n-  Last Modified: 13 Apr 2007\n+  Last Modified: 24 Apr 2007\n   Number: 12\n-  Version: 46\n+  Version: 47\n \n =head1 Overview\n \n@@ -199,14 +199,14 @@\n Indirect object notation now requires a colon after the invocant,\n even if there are no arguments after the colon:\n \n-    $handle.close\n-    close $handle:\n+    $handle.close;\n+    close $handle:;\n \n To reject method call and only consider subs, simply omit the colon\n from the invocation line:\n \n-    close($handle)\n-    close $handle\n+    close($handle);\n+    close $handle;\n \n However, here the built-in B class defines C,\n which puts a C in scope by default.  Thus if the\n@@ -233,7 +233,7 @@\n     .'+'               # same as +$_\n \n And in fact, if there is a choice between a unary prefix and a postfix\n-operator, the indirect forms will choose the prefix operator.  See S03.\n+operator, the quoted forms will choose the prefix operator.  See S03.\n Likewise, presuming that C<$op> does not name an ordinary method on\n C<$left>, this calls any arbitrary infix operator:\n \n@@ -392,8 +392,10 @@\n visible to derived classes via inheritance.  A submethod is called\n only when a method call is dispatched directly to the current class.\n \n-[Conjecture: there is some relationship between \"submethod BUILD\" and\n-\"method ^BUILD\" that possibly rises to the level of a unifiable identity...]\n+Conjecture: in order to catch spelling errors it is a compile-time\n+warning to define a submethod in any class that does not inherit the\n+corresponding method name from some base class.  (But note that the\n+standard C class supplies a default C and C.)\n \n =head1 Attributes\n \n@@ -564,7 +566,7 @@\n The default C and C are inherited from C, so\n you need to write initialization routines only if you wish to modify\n the default behavior.  If the name of a named argument begins with a\n-C<::> and corresponds to a class or role being built, the list value\n+C<::> and corresponds to a (super)class or role being built, the list value\n of that argument is passed as a list of named arguments to that class\n or role's C.  (If the value of that argument is a closure\n instead of a list, that closure will be called to return a list.\n@@ -572,6 +574,9 @@\n being initialized.)  In the absence of a class-labeled pair, all\n the arguments to C are passed to the C.\n \n+    class Dog is Animal {...}\n+    my $pet = Dog.new( :name, Animal => [:blood :legs(4)] );\n+\n You can clone an object, changing some of the attributes:\n \n     $newdog = $olddog.clone(:trick);\n@@ -661,9 +666,7 @@\n     $object.\"+meth\"(@args)\n     $object.'VAR'(@args)\n \n-Any method can defer to the next candidate method in the list by\n-saying C.  Any method can stop the progression by saying\n-C.  The order and selection of the candidates may be\n+The order and selection of the candidates may be\n specified by arguments to a pseudo-class known as C:\n \n     $object.*WALK[:breadth:omit($?CLASS)]::meth(@args);\n@@ -681,10 +684,15 @@\n     :omit(Selector)     # only classes that don't match selector\n     :include(Selector)  # only classes that match selector\n \n-In addition to C, the special functions C,\n-C, C, and C dispatch to the next\n-candidate, possibly with a new argument list, and if the \"next\"\n-variant is used, without returning:\n+Any method can defer to the next candidate method in the list by\n+the special functions C, C, C, and\n+C.  The \"same\" variants reuse the original argument list\n+passed to the current method, whereas the \"with\" variants allow a\n+new argument list to be substituted for the rest of the candidates.\n+The \"call\" variants dispatch to the rest of the candidates and return\n+their values to the current method for subsequent processing, whereas\n+while the \"next\" variants don't return, but merely defer to the rest\n+of the candidate list:\n \n     callsame;           # call with the original arguments (return here)\n     callwith();         # call with no arguments (return here)\n@@ -693,6 +701,21 @@\n     nextwith();         # redispatch with no arguments (no return)\n     nextwith(1,2,3);    # redispatch with a new set of arguments (no return)\n \n+For dispatches using C<.> and C<.?>, the return value is the\n+C returned by the first method completed without deferring.\n+(Such a return value may in fact be failure, but it still counts as a\n+successful call from the standpoint of the dispatcher.)  Likewise the\n+return value of C<.*> and C<.+> is a list of C returned by\n+those methods that ran to completion without deferring to next method.\n+\n+It is also possible to trim the candidate list so that the current\n+call is considered the final candidate.  (This is implicitly the case\n+already for the dispatch variants that want a single successful call.)\n+For the multiple call variants, C will cause the dispatcher\n+to throw away the rest of the candidate list, and the subsequent\n+return from the current method will produce the final C\n+in the returned list.\n+\n =head1 Parallel dispatch\n \n Any of the method call forms may be turned into a hyperoperator by\n@@ -705,6 +728,10 @@\n     @object\u00bb.=meth(@args)  # calls mutator method on each\n     @object\u00bb!meth(@args)   # calls private method on each\n \n+The return value is a list with exactly the same number of elements\n+as C<@object>.  Each such return value is a Capture or List of Captures\n+as specified above for the non-hyper \"dot\" variants.\n+\n Hyperoperators treat a junction as a scalar value, so saying:\n \n     $junction\u00bb.meth(@args);\n@@ -756,10 +783,14 @@\n in a grammar by declaring a C C or C C.  (Perl 6's\n grammar does this, for instance.)\n \n-You can have multiple C variables in the same scope, and they\n-all share the same storage location and type.  Usually these are\n-declared by one C declaration at the top, and leaving the\n-C implicit on the rest of the declarations.\n+You can have multiple C variables of the same name in the\n+same scope, and they all share the same storage location and type.\n+Usually these are declared by one C declaration at the top,\n+and leaving the C implicit on the rest of the declarations.\n+You might do this when you suspect you'll have multiple declarations\n+of the same variable name (such code might be produced by a macro\n+or by a code generator, for instance) and you wish to suppress any\n+possible warnings about redefinition.\n \n In contrast, C routines can have only one instance of the long\n name in any namespace, and that instance hides any outer (or less-derived)\n@@ -896,9 +927,9 @@\n only on positional parameters.  Note that most builtins will map known\n named parameters to positional via a C declaration.\n \n-Within a multiple dispatch, C means to try the next best\n+Within a multiple dispatch, C means to try the next best\n match, or next best default in case of tie, or the proto sub if there\n-is one.  The C function has the same effect.\n+is one.\n \n Attributes are tied to a particular class definition, so a multi method\n can only directly access the attributes of a class it's defined within\n@@ -943,7 +974,7 @@\n         method feed ($food) {\n             $food.open_can;\n             $food.put_in_bowl;\n-            self.some_other_method;\n+            self.eat($food);\n         }\n     }\n \n@@ -999,7 +1030,7 @@\n Roles may have attributes:\n \n     role Pet {\n-        has $.collar = { Collar.new(Tag.new) };\n+        has $.collar = Collar.new(Tag.new);\n         method id () { return $.collar.tag }\n         method lose_collar () { undefine $.collar }\n     }\n@@ -1113,6 +1144,12 @@\n \n     proto method shake {...}\n \n+(This declaration need not preceed the C clause textually, since\n+roles are not actually composed until the end of the class definition,\n+at which point we know how which roles are to be composed together\n+in a single logical operation, as well as how the class intends to\n+override the roles.)\n+\n The proto method will be called if the multi fails:\n \n     proto method shake { warn \"They couldn't decide\" }\n@@ -1135,13 +1172,16 @@\n     $dog.bark();        # picks Dog role's bark method\n     $tree.bark();       # picks Tree role's bark method\n \n+If there is such a mechanism, it may only be used as a tie-breaker.\n+Otherwise we break the normal polymorphism expectations.\n+\n Run-time mixins are done with C and C.  The C binary\n operator is a mutator that derives a new anonymous class (if necessary)\n and binds the object to it:\n \n     $fido does Sentry\n \n-The C operator is non-associative, so this is a syntax error:\n+The C infix operator is non-associative, so this is a syntax error:\n \n     $fido does Sentry does Tricks does TailChasing does Scratch;\n \n@@ -1152,6 +1192,10 @@\n     $fido does TailChasing;\n     $fido does Scratch;\n \n+And since it returns the left side, you can also say:\n+\n+    ((($fido does Sentry) does Tricks) does TailChasing) does Scratch;\n+\n Unlike the compile-time role composition, each of these layers on a new\n mixin with a new level of inheritance, creating a new anonymous class\n for dear old Fido, so that a C<.chase> method from C hides a\n@@ -1161,12 +1205,14 @@\n \n     $fido does (Sentry, Tricks, TailChasing, Scratch);\n \n-This will level the playing field for collisions among the new set of roles,\n-and guarantees the creation of no more than one more anonymous class.\n-\n-A role still can't conflict with itself, but it can hide its previous\n-methods in the parent class, and the calculation of what conflicts\n-is done again for the set of roles being mixed in.\n+This will level the playing field for collisions among the new\n+set of roles, and guarantees the creation of no more than one more\n+anonymous class.  Such a role still can't conflict with itself, but it\n+can hide its previous methods in the parent class, and the calculation\n+of what conflicts is done again for the set of roles being mixed in.\n+If you can't do compile-time composition, we strongly recommend this\n+approach for run-time mixins since it approximates a compile-time\n+composition at least for the new roles involved.\n \n A role applied with C may be parameterized with an initializer\n in parentheses, but only if the role supplies exactly one attribute\n@@ -1175,6 +1221,13 @@\n     $fido does Wag($tail);\n     $line does taint($istainted);\n \n+The supplied initializer will be coerced to type of the attribute.\n+Note that this initializer is in addition to any parametric type\n+supplied in square brackets, which is considered part of the actual\n+type name:\n+\n+    $myobj does Array[:of(Int)](@initial)\n+\n The C operator creates a copy and works on that.  It also knows\n how to generalize a particular enumerated value to its role.  So\n \n@@ -1306,13 +1359,13 @@\n \n You can specify multiple method names:\n \n-    has $.legs handles ;\n+    has $.legs handles ;\n \n It's illegal to call the outer method unless the attribute\n has been initialized to an object of a type supporting the method,\n such as by:\n \n-    has Tail $.tail handles 'wag' = { .new(|%_) };\n+    has Tail $.tail handles 'wag' .= new(|%_);\n \n Note that putting a C type on the attribute does not necessarily\n mean that the method is always delegated to the C class.\n@@ -1383,9 +1436,8 @@\n                  StBernard => $woof,\n                          * => $ruff,\n                 );\n-    method prefix:<~>( return \"$.breed\" )\n \n-If the current object matches no Selector, a \"C\" is\n+If the current object matches no Selector, a \"C\" is\n automatically performed.\n \n =head1 Types and Subtypes\n@@ -1658,11 +1710,11 @@\n By default, all methods and submethods that do not declare an explicit\n C<*%> parameter will get an implicit C<*%_> parameter declared for\n them whether they like it or not.  In other words, all methods allow\n-unexpected named arguments, so that C semantics work\n+unexpected named arguments, so that C semantics work\n consistently.\n \n If you mark a class \"C\", it hides the current class\n-from \"C\" semantics, and incidentally suppresses the\n+from \"C\" semantics, and incidentally suppresses the\n autogeneration of C<*%_> parameters.  Hidden classes may be visited\n as C, but not via \"C\".\n \n@@ -1680,6 +1732,7 @@\n     HOW         the metaclass object: \"Higher Order Workings\"\n     WHEN        (reserved for events?)\n     WHY         (reserved for documentation?)\n+    WHENCE      autovivification closure\n \n These may be used either as methods or as unary operators:\n \n@@ -1738,7 +1791,7 @@\n \n Class traits may include:\n \n-    identifier    Dog-1.2.1-http://www.some.com/~jrandom\n+    identifier  { :name :ver<1.2.1> :auth } \n         name      Dog\n         version   1.2.1\n         authority http://www.some.com/~jrandom\n@@ -1833,4 +1886,16 @@\n a method of a particular name if it's required and hasn't been supplied\n by the class or one of its roles.\n \n+Conjecture: The C property of an object is its autovivifying\n+closure.  Any undefined prototype object may carry such a closure that\n+can lazily create an object of the appropriate type.  For instance,\n+a C routine, instead of creating a C object directly,\n+could instead return something like:\n+\n+    Dog but WHENCE({ .new(:name) })\n+\n+which runs the closure if the object ever needs to be autovivified.\n+The closure can capture whatever initializers were available in the\n+original lexical scope.\n+\n =for vim:set expandtab sw=4:\n\n"}
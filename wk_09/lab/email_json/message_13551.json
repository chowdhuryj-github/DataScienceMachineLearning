{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>", "from_address": "Jonathan Worthington <jonathan@jnthn.net>", "subject": "Re: [perl #42408] Re: [PATCH] refactor vtable overriding, delegate.c\n generation", "body": "chromatic wrote:\n> Jonathan, can you help us figure out why deleting these lines out of init() fixes the problem?  Are they vestigial?\n>\n> \t    /* turn on marking of the class_data array */\n> \t    PObj_data_is_PMC_array_SET(self);\n>   \nI saw those before and thought they were very suspect; I only gave SMOP \na cursory glance for inspiration before digging into PDD15 \nimplementation though. When you set this flag, I believe the GC assumes \nthe data pointer of the PMC points to a chunk of memory containing an \narray of pointers. It then looks at the int in the pmc_ext structure to \nsay how many pointers there are. That way you don't have to write your \nown mark routine for some aggregate types. I may have the specific \ndetails wrong, but it's something like that.\n\nI think in the case of SMOP, the usage of it is bogus/wrong. I don't \nremember the int in pmc_ext being set, and assuming that everything in a \nstruct is and always will be contiguous non-NULL PMCs or STRING pointers \nis probably a fast way to segfaults when you change something about the \nstruct in the future, or if it's uninitialized.\n\nI expect custom mark and destroy are the flags that should be set, and \nthe mark and destroy vtable methods implemented. As for the more general \nfuture of SMOP, I'm don't know.\n\nHope this helps,\n\nJonathan\n\n"}
{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14401 - doc/trunk/design/syn", "body": "Author: larry\nDate: Wed May 23 11:11:34 2007\nNew Revision: 14401\n\nModified:\n   doc/trunk/design/syn/S02.pod\n\nLog:\nClarifications suggested by Jonathan Lang++ and spinclad++.\n\n\nModified: doc/trunk/design/syn/S02.pod\n==============================================================================\n--- doc/trunk/design/syn/S02.pod\t(original)\n+++ doc/trunk/design/syn/S02.pod\tWed May 23 11:11:34 2007\n@@ -738,11 +738,11 @@\n     List        Lazy Perl list (composed of immutables and iterators)\n     Seq         Completely evaluated (hence immutable) sequence\n     Range       A pair of Ordered endpoints; gens immutables when iterated\n-    Set         Unordered group of values that allows no duplicates\n-    Bag         Unordered group of values that allows duplicates\n-    Junction    Sets with additional behaviors\n-    Pair        Two elements that serve as key/value in a one-element Mapping\n-    Mapping     Pair set with no duplicate keys\n+    Set         Unordered collection of values that allows no duplicates\n+    Bag         Unordered collection of values that allows duplicates\n+    Junction    Set with additional behaviors\n+    Pair        A single key-to-value association\n+    Mapping     Set of Pairs with no duplicate keys\n     Signature   Function parameters (left-hand side of a binding)\n     Capture     Function call arguments (right-hand side of a binding)\n     Blob        An undifferentiated mass of bits\n@@ -1053,7 +1053,7 @@\n Perl\u00a06 includes a system of B to mark the fundamental\n structural type of a variable:\n \n-    $   scalar\n+    $   scalar (object)\n     @   ordered array\n     %   unordered hash (associative array)\n     &   code/rule/token/regex\n@@ -1082,16 +1082,54 @@\n =item *\n \n Sigils indicate overall interface, not the exact type of the bound\n-object.  Hence, C<@x> may be bound to an object of the C\n-class, but it may also be bound to any object that does the C\n-role, such as a C, C, C, C, C, C,\n-C, and so on.  Likewise, C<%x> may be bound to a C,\n-C, C, C, C, C, and so on.\n-And C<&x> may be bound to any kind of C or C.\n-The implicit container type is checked at binding time.  If you wish\n-to bind an object that doesn't yet do the appropriate role, you must\n-either stick with the generic C<$> sigil, or mix in the appropriate\n-role before binding to a more specific sigil.\n+object.  Different sigils imply different minimal abilities.\n+\n+C<$x> may be bound to any object, including any object that can be\n+bound to any other sigil.  Such a scalar variable is always treated as\n+a singular item in any kind of list context, regardless of whether the\n+object is essentially composite or unitary.  It will not automatically\n+dereference to its contents unless placed explicitly in some kind of\n+dereferencing context.  In particular, when interpolating into list\n+context, C<$x> never expands its object to anything other than the\n+object itself as a single item, even if the object is a container\n+object containing multiple items.\n+\n+C<@x> may be bound to an object of the C class, but it may also\n+be bound to any object that does the C role, such as a\n+C, C, C, C, or C.  The C\n+role implies the ability to support C<< postcircumfix:<[ ]> >>.\n+\n+Likewise, C<%x> may be bound to any object that does the C\n+role, such as C, C, C, C, C, or\n+C.  The C role implies the ability to support\n+C<< postcircumfix:<{ }> >>.\n+\n+C<&x> may be bound to any object that does the C role, such\n+as any C or C.  The C role implies the ability\n+to support C<< postcircumfix:<( )> >>.\n+\n+C<::x> may be bound to any object that does the C role,\n+such as a typename, package, module, class, role, grammar, or any other\n+protoobject with C<.HOW> hooks.  This C role implies the\n+ability to do various symbol table and/or typological manipulations which\n+may or may not be supported by any given abstraction.  Mostly though it\n+just means that you want to give some abstraction an official name that\n+you can then use later in the compilation without any sigil.\n+\n+In any case, the minimal container role implied by the sigil is\n+checked at binding time at the latest, and may fail earlier (such\n+as at compile time) if a semantic error can be detected sooner.\n+If you wish to bind an object that doesn't yet do the appropriate\n+role, you must either stick with the generic C<$> sigil, or mix in\n+the appropriate role before binding to a more specific sigil.\n+\n+An object is allowed to support both C and C.\n+An object that does not support C may not be bound directly\n+to C<@x>.  However, any construct such as C<%x> that can interpolate\n+the contents of such an object into list context can automatically\n+construct a list value that may then be bound to an array variable.\n+Subscripting such a list does not imply subscripting back into the\n+original object.\n \n =item *\n \n\n"}
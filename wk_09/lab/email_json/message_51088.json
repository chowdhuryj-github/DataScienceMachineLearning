{"category": "ham", "to_address": "\"perl6-language@perl.org\" <perl6-language@perl.org>", "from_address": "Damian Conway <damian@conway.org>", "subject": "And for those who prefer their design documents pre-cooked...", "body": "\n\n\n\n\n\n\nAmbient aliases \nThe A<> formatting code specifies an alias to an \nambient antecedent.\nThis is like a placement link, except\nthat the text that is inserted to replace the A<> \nformatting code is\nsome portion of the ambient section(s)\nof the current document, rather than the entire contents of some\nexternal document.\n\nHence, the A<> code makes it possible to incorporate \npieces of\nambient text (typically source code) into Pod documentation.\nSpecifically, the A<> code is replaced by searching \nbackwards through\nall preceding non-Pod parts of the document, to locate the nearest prior\nsubstring that matches the contents of the A<> code.\n\nThe contents of an A<> code can specify a back-reference \nof this type\nin one of two ways:\n\nas a prefix keyword, or\n\nas a delimited text range.\n\nBy default, A<> aliases are \"keyword oriented\". \nThat is, the contents\nof an A<> block are treated as a keyword or prefix that \nintroduces\nthe desired text. That text is located by searching backwards from the\nlocation of the A<> code, to find the nearest preceding \ninstance of\nthe specified prefix in any previous ambient block. The text that is\nthen used to replace the A<> is the first \"symbol\" \nfollowing that\nlocated prefix. In this context, a \"symbol\" is defined as a sequence of\nnon-whitespace characters terminated by a transition from an identifier\ncharacter to a non-identifier character.\n\nFor example, in the following:\n\nclass Pet {\n\n     has $name;\n\n=DESCRIPTION\nThe class A<class> provides a A<has> attribute.\nthe A<class> formatting code would be \nreplaced by \"Pet\", since that\nis the sequence of non-whitespace characters that immediately follows\n\"class\" in the preceding ambient source code. Likewise, the \nA<has>\nformatting code would be replaced by \"$name\", because that is the\nlongest sequence of non-whitespace characters that follows a \"has\" and\nterminates in an identifier-to-nonidentifier boundary.\n\nIn other words, any formatting code of the form \nA<prefix>\nis replaced by the substring of the nearest preceding\nambient block that matches the pattern:\n\n/  .*  prefix \\s*  <( \\S*? \\w )>  [\\W | $] /\nThis default is designed to work well for the commonest \nkind of\nback-reference in ambient text: a reference to a code construct that\nwas defined using a prefix keyword and whose name ends in an identifier.\n\nThe second and more general way of specifying an alias is to specify\nboth a prefix and a postfix delimiter for the replacement text. If the\ncontents of an A<> formatting code include a range marker \n(..),\nthe sequence before the .. is treated as the left delimiter of the\nreplacement text, and the sequence after the .. is the right\ndelimiter. In this case, there are no other constraints on the\nreplacement text. In particular, it may contain any number of non-\nidentifier or whitespace characters. For example:\n\nclass Pet {\nmethod eat(Food $meal) {...}\n=for DESCRIPTION\nThe A<method>() method has the following argument list: A<(..)>\nThis would be interpreted as:\n\nThe eat() method has the following argument list: Food $meal\nbecause the A<(..)> specifies an \nalias to the closest preceding ambient\ntext that is left-delimited by a '(' and right-delimited by a ')'.\n\nTo specify an alias in which the sequence .. is itself\na left- or right-delimiter (rather than the separator between the two),\nuse a V<> code:\n\nconstant @range = 0..99;\n=para\nThe maximum value is A<V<..>..;>\nExplicit \naliasing \nThe replacement strings for A<> formatting codes are \nnormally\nspecified implicitly, by the closest preceding ambient text that matches\nthe contents of the A<> code.\n\nHowever, it is possible to override this behaviour and create an\nexplicitly defined alias, using the =alias directive:\n\nclass Agent {...}\n=alias component Agent\nclass Transaction is Activity {\n=DESCRIPTION\nThe A<class> class represents a transaction activity between two\nA<component> objects.\nIn the preceding example, A<class> is \na normal \"keyword\" alias\n(which would be replaced by the closest preceding prefixed match:\n\"Transaction\"). However, A<component> is a defined alias\n(which would be replaced by the explicitly specified text: \"Agent\").\n\nEach back-reference name defined by an <=alias> directive is lexically\nscoped within the block structure of the surrounding Pod. To create\n\"global\" aliases, define them at the start of the Pod document, at the\noutermost block level.\n\nExplicitly defined aliases always override normal prefix or delimited\naliases, and thereby allow you to refer to ambient constructs that would\notherwise be inaccessible to an implicit back-reference.\n\nFor example, within the DESCRIPTION block of the previous example,\nthe Agent class couldn't be referred to as A<class>, since the\nintervening Transaction class \"hides\" it from the look-behind matching\nof implicit back-reference mechanism. But the =alias command allows\nthe name of the earlier class to be associated with a distinct symbolic\nalias (i.e. \"component\"), which then allows it to be referred to\nunambiguously, regardless of other intervening code.\n\nAnother way of thinking of this is that explicitly defined aliases\nchange the normal A<> substitution behaviour from being \ndetermined\nrelatively by the location of the A<> code, to \nbeing determined\nabsolutely by the alias name itself.\n\nAn =alias directive expects two arguments:\n\nThe name of the new alias\n\nThe text with which that new alias is to be replaced\n\nThe alias name may be any sequence of non-whitespace characters. The\nremainder of the line (ignoring the whitespace immediately after the\nname) is treated as the replacement text. For example:\n\n=alias Smith  Jones\n=alias G&T    green tea\n=alias #*@%!  Gosh darn\n=para\nA<#*@%!> it, A<Smith>, you spilled my A<G&T>!\nis equivalent to:\n\n=para\nGosh darn it, Jones, you spilled my green tea!\nTo specify an alias name that includes a whitespace, or \na replacement\ntext with surrounding whitespace, use a V<> formatting code:\n\n=alias slow            V< >...slow\n=alias V<extra slow>   s-l-o-w\n=alias V<ultra slow>   V<  >s  l  o  wV<  >\n=para\nThe service was not merely A<slow>, or even A<extra slow>.\nIt was A<ultra slow>\nAlthough only the V<> code is \nsignificant within the name of an alias,\nyou can use any formatting code(s) within the replacement text:\n\n=alias V<ultra slow>   S<  s  l  o  w  >\n=alias V<hyper slow>   B<...s...l...o...w...>\nIn particular, you can use an A<> \ncode in the replacement text of an\n=alias. This is useful to preserve the abstract relationship between\nambient code and Pod documentation. For example, in the earlier Agent\nexample, instead of:\n\nclass Agent {...}\n=alias component Agent\nthe alias could have been defined:\n\nclass Agent {...}\n=alias component A<class>\nso that the class name did not have to be repeated as \npart of the alias.\nThis approach has the important benefit that the alias would not have\nto be modified in any way if the name of the Agent class were\nsubsequently changed:\n\nclass Operative {...}\n=alias component A<class>\nLikewise, in the earlier range example, it would have \nbeen cleaner and\nmore maintainable to write:\n\nconstant @range = 0..99;\n=alias max  A<V<..>..;>\n=para\nThe maximum value is A<max>\nExplicit aliases also provide a way to \"retarget\" \nimplicit back-references\nif they are later invalidated by keyword changes in the\nsource code. For example, given the following documented code:\n\nclass Transaction {\n\n     my Int $trans_counter;\n\n=DESCRIPTION\nThe A<my Int> variable is used to track the total number of\ntransactions active at any one time. The value of A<my Int> is\nincremented by A<class>'s C<BUILD> submethod and decremented by\nthe A<class> destructor.\nIf a subsequent redesign requires that the class be \nchanged to a role,\nand the lexical counter converted to a state variable, then every\ncorresponding A<> code in the documentation would have to be\naltered too:\n\nrole Transaction {\n\n     state Int $trans_counter;\n\n=DESCRIPTION\nThe A<state Int> variable is used to track the total number of\ntransactions active at any one time. The value of A<state Int> is\nincremented by A<role>'s C<BUILD> submethod and decremented by\nthe A<role> destructor.\nA less onerous and error-prone solution would be to \nleave the original\nA<> codes \"as is\", and insert aliases to override the \ndefault prefix\nback-matching:\n\nrole Transaction {\n=alias class  A<role>\n\n     state Int $trans_counter;\n=alias V<my Int>  A<state Int>\n\n=DESCRIPTION\nThe A<my Int> variable is used to track the total number of transactions\nactive at any one time. The value of A<my Int> is incremented by the\nA<class> C<BUILD> submethod and decremented by the A<class> \ndestructor.\nNote that =alias is a fundamental Perldoc \ndirective, like =begin\nor =for; it is not an instance of an\nabbreviated block. Hence there is no paragraph\nor delimited form of the =encoding directive (just as there is no\nparagraph or delimited form of =begin).\n\n\n\n"}
{"category": "ham", "to_address": "Perl Beginners <beginners@perl.org>", "from_address": "\"John W. Krahn\" <krahnj@telus.net>", "subject": "Re: $1 $2 var confusion", "body": "Mumia W. wrote:\n> \n> That happens because the match variables ($1, $2, ...) are only changed\n> when a regular expression matches; otherwise, they are left alone.\n> \n> In the first case, \"$2 !~ /domain\\.com/\" succeeds but does not capture\n> anything, so the numbered match variables are unset.\n> \n> Your situation reinforces the rule that you should always test if the\n> match succeeded before you attempt to use the match variables:\n> \n>     my $email = 'steveb@domain.com';\n>     my @f = (undef, $email =~ /(.*)\\@(.*)/);\n\nWhy did you put undef in there?  It serves no useful purpose other than making\nthe code harder to understand for beginners.\n\n      my @f = $email =~ /(.*)\\@(.*)/;\n\n\n>     (@f > 1) && ($f[2] =~ /domain\\.com/ ?\n>         print \"$f[1]\\n\" : print \"var 2 is bad\\n\" );\n> \n> The test \"@f > 1\" is my way of testing if the match succeeded.\n\nThe rvalue conditional operator should use the returned value:\n\nprint @f > 1 && $f[ 2 ] =~ /domain\\.com/\n      ? $f[ 1 ]\n      : 'var 2 is bad',\n      \"\\n\";\n\n\n\nJohn\n-- \nPerl isn't a toolbox, but a small machine shop where you can special-order\ncertain sorts of tools at low cost and in short order.       -- Larry Wall\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "\"Bob Rogers\" <rogers-perl6@rgrjr.dyndns.org>", "from_address": "\"Alek Storm\" <alek.storm@gmail.com>", "subject": "Re: modifying classes after they're instantiated", "body": "On 4/11/07, Bob Rogers  wrote:\n>    I like this one, but I also have another alternative.  First, make all\n>    class-modification code (add_method, remove_attribute, etc) return a\n>    PMC*.  Whenever one of these methods is called on a class, the class\n>    is cloned . . .\n>\n> What does \"find_class\" return after one of these?  If it returns the new\n> class, then there is no need for the class-mutating ops to do so, except\n> possibly for convenience.\n\n\"find_class\" returns whatever is currently registered as the class.  A\nclass-modifying method doesn't change that; it just returns the cloned\nclass PMC.  If the HLL wants to register the modified version, it can\ndo so, but I'm not in favor of a separate class registry, and I've\nheard it's going away anyway.  In any case, it should be left up to\nthe HLL what it wants to do with the modified class, since one\napproach doesn't work with all languages.\n\n>    classobj = newclass 'Foo'\n>    object = classobj.'new'()\n>\n>    # add_method returns a clone of the original class with \"bar\" added\n>    # C keeps its reference to the original class\n>    classobj = classobj.'add_method'('bar', $P3)\n>    object2 = classobj.'new'()\n>\n> Surely you are not suggesting that any random \"add_method\" should\n> require creating a new class?  Did you mean \"add_attribute\" (or\n> whatever)?\n\nOf course add_method's create new classes; the implementation of that\nis what we've been talking about.  We want the class to be modified,\nbut already-instantiated objects keep their reference to the class\nthey were created with.  Allocating a new class for every add_method,\nadd_attribute, etc. is a downside when there are several in a row and\nall we want is the end result, but I've already proposed a solution to\nthat: create a shortcut method that takes a list or slurpy of\nattributes to add, so it's all done at once.\n\n>    The only downside I can think of is the overhead involved in creating\n>    a new clone of the class for every change to it, for example, when\n>    many attributes are added at once . . .\n>\n> This is not necessary; you only need to clone the class after the first\n> time it is instantiated.  So you can put an \"instantiated_p\" flag in the\n> class to keep track, and keep mutating the same new class until the next\n> instantiation.  The remove_* operations could stay, they would just\n> throw errors on instantiated classes.\n\nThat's a great idea, and is probably better than my shortcut method\nidea; we'll have to see what others think.  But I'm not sure why\nremove_* would be any different than add_* - they create a clone of\nthe class, and remove the attribute.  Instantiated objects of the\nclass don't notice a thing.\n\n>    But in that case, it might be simpler for HLL code to stick to\n> Allison's original alternative 4, i.e. make an explicit clone, mutate it\n> as required, and then install it as \"the\" class returned by find_class.\n\nNot all languages want to clone their classes on modification.  These\nlanguages would use their own class PMCs that don't clone themselves.\nIf one of their classes is passed to and cloned by a different HLL,\ntheir class system will be screwed up/inconsistent.  I'm not sure how\nrequiring HLLs to deal with explicit cloning would be simpler than\nhaving it abstracted away.  This system is much more flexible.\n\n> Error recovery would also be easier for explicit cloning; what happens\n> if one of the class-mutating methods throws an error?\n\nI'm afraid you lost me.  How would this be different?  Could you\nprovide some more information?\n\n-- \nAlek Storm\n\n"}
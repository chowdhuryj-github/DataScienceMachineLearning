{"category": "ham", "to_address": "Alek Storm <alek.storm@gmail.com>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: modifying classes after they're instantiated", "body": "Alek Storm wrote:\n> On 4/11/07, Bob Rogers  wrote:\n>>    I like this one, but I also have another alternative.  First, make all\n>>    class-modification code (add_method, remove_attribute, etc) return a\n>>    PMC*.  Whenever one of these methods is called on a class, the class\n>>    is cloned . . .\n\nYeah, this one came up on IRC too. Two problems, first is the \nnon-obviousness of having a method like 'add_attribute' return a \nmodified version of the class. The disadvantage of the interface \noutweighs the advantage of the DWIM. Second is that the most sensible \nreturn value is some form of error reporting (if exceptions are turned off).\n\n>> What does \"find_class\" return after one of these?  If it returns the new\n>> class, then there is no need for the class-mutating ops to do so, except\n>> possibly for convenience.\n> \n> \"find_class\" returns whatever is currently registered as the class.\n\nYes. Always true if we were to do automatic cloning. Also true in some \ncases of explicit cloning (as a optional feature of 'clone').\n\n>> Surely you are not suggesting that any random \"add_method\" should\n>> require creating a new class?  Did you mean \"add_attribute\" (or\n>> whatever)?\n\nI did mean that, but only if the class has already been instantiated. \n('add_method' can add an additional multi, for example, so it can modify \nexisting behavior.)\n\n>> This is not necessary; you only need to clone the class after the first\n>> time it is instantiated.  So you can put an \"instantiated_p\" flag in the\n>> class to keep track, and keep mutating the same new class until the next\n>> instantiation.\n\nA flag for 'instantiated' is in the new PDD 15 and prototype implementation.\n\n>> The remove_* operations could stay, they would just\n>> throw errors on instantiated classes.\n\nThey could, but how often are people going to add a bunch of attributes \nand methods and then remove them immediately before they ever \ninstantiate the class? The remove_* ops made sense as a feature when \nthey could be used at any time, but when they only work in a narrow \nwindow it's not worth having them. Especially since we already have to \nimplement another way (explicit cloning) to dynamically remove \nattributes and methods after the class has been instantiated.\n\n> Not all languages want to clone their classes on modification.  These\n> languages would use their own class PMCs that don't clone themselves.\n\nThey might not clone their classes from the user perspective, but \ninternally it's the only truly safe way to modify a class that already \nhas objects instantiated (especially when you're talking about remove \noperations). Otherwise, you have objects referencing attributes that \ndon't exist any longer in the class, or methods referencing attributes \nthat were never initialized in the object. The closest they can come is \nthe option 1) I listed.\n\n> If one of their classes is passed to and cloned by a different HLL,\n> their class system will be screwed up/inconsistent.  I'm not sure how\n> requiring HLLs to deal with explicit cloning would be simpler than\n> having it abstracted away.  This system is much more flexible.\n\nThe point about abstraction is a good one. It can also be satisfied by \nthe 'clone' method/vtable. If a class has a different way of handling \nmodifications, it can return a modified version of itself instead of \nreturning a new clone (in those cases where the cloning operation was \nflagged as a modification of an existing class).\n\n>> Error recovery would also be easier for explicit cloning; what happens\n>> if one of the class-mutating methods throws an error?\n> \n> I'm afraid you lost me.  How would this be different?  Could you\n> provide some more information?\n\nEssentially, what if you call 'add_method', it automatically clones the \nclass, and the automatic cloning fails for some reason? Then you get a \nmysterious exception about \"failed to clone class\", leaving the average \nuser wondering why it was trying to clone a class in the first place.\n\nAllison\n\n"}
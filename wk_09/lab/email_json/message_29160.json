{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "abartlet@samba.org", "subject": "svn commit: samba r22838 - in branches/SAMBA_4_0/source: librpc/rpc\n\ttorture torture/raw", "body": "Author: abartlet\nDate: 2007-05-14 05:53:26 +0000 (Mon, 14 May 2007)\nNew Revision: 22838\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22838\n\nLog:\nAdd in an explority test for what QFSINFO operations are valid on IPC$\n\nIt seems most opertaions are supported, but that the values are not\nconsistant.  I think these are very much hand-hacked stubs, which is\nwhat they will be on Samba4 too.\n\nI'll need to add some more 'don't fail for...' hacks before this\npasses against Win2k3.\n\nAndrew Bartlett\n\n\nModified:\n   branches/SAMBA_4_0/source/librpc/rpc/dcerpc_smb.c\n   branches/SAMBA_4_0/source/torture/raw/notify.c\n   branches/SAMBA_4_0/source/torture/raw/qfileinfo.c\n   branches/SAMBA_4_0/source/torture/raw/qfsinfo.c\n   branches/SAMBA_4_0/source/torture/raw/raw.c\n   branches/SAMBA_4_0/source/torture/raw/search.c\n   branches/SAMBA_4_0/source/torture/util_smb.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/librpc/rpc/dcerpc_smb.c\n===================================================================\n--- branches/SAMBA_4_0/source/librpc/rpc/dcerpc_smb.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/librpc/rpc/dcerpc_smb.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -561,3 +561,18 @@\n \n \treturn smb->tree;\n }\n+\n+/*\n+  return the SMB fnum used for a dcerpc over SMB pipe (hack for torture operations)\n+*/\n+uint16_t dcerpc_smb_fnum(struct dcerpc_connection *c)\n+{\n+\tstruct smb_private *smb;\n+\n+\tif (c->transport.transport != NCACN_NP) return 0;\n+\n+\tsmb = talloc_get_type(c->transport.private, struct smb_private);\n+\tif (!smb) return 0;\n+\n+\treturn smb->fnum;\n+}\n\nModified: branches/SAMBA_4_0/source/torture/raw/notify.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/notify.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/raw/notify.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -45,7 +45,7 @@\n \t}} while (0)\n \n #define CHECK_WSTR(field, value, flags) do { \\\n-\tif (!field.s || strcmp(field.s, value) || wire_bad_flags(&field, flags, cli)) { \\\n+\tif (!field.s || strcmp(field.s, value) || wire_bad_flags(&field, flags, cli->transport)) { \\\n \t\tprintf(\"(%d) %s [%s] != %s\\n\",  __LINE__, #field, field.s, value); \\\n \t\t\tret = False; \\\n \t\tgoto done; \\\n@@ -278,7 +278,7 @@\n \t\t\tif ((actions[i].name.s == NULL)\n \t\t\t    || (strcmp(actions[i].name.s, name) != 0)\n \t\t\t    || (wire_bad_flags(&actions[i].name, STR_UNICODE,\n-\t\t\t\t\t       cli))) {\n+\t\t\t\t\t       cli->transport))) {\n \t\t\t\tprintf(\"(%d) name [%s] != %s\\n\", line,\n \t\t\t\t       actions[i].name.s, name);\n \t\t\t\treturn False;\n\nModified: branches/SAMBA_4_0/source/torture/raw/qfileinfo.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/qfileinfo.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/raw/qfileinfo.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -23,6 +23,8 @@\n #include \"libcli/raw/libcliraw.h\"\n #include \"libcli/libcli.h\"\n #include \"torture/util.h\"\n+#include \"librpc/rpc/dcerpc.h\"\n+#include \"torture/rpc/rpc.h\"\n \n static struct {\n \tconst char *name;\n@@ -67,6 +69,8 @@\n \t{ NULL, }\n };\n \n+static bool is_ipc;\n+\n /*\n   compare a dos time (2 second resolution) to a nt time\n */\n@@ -100,6 +104,9 @@\n static union smb_fileinfo *fname_find(const char *name)\n {\n \tint i;\n+\tif (is_ipc) {\n+\t\treturn NULL;\n+\t}\n \tfor (i=0; levels[i].name; i++) {\n \t\tif (NT_STATUS_IS_OK(levels[i].fname_status) &&\n \t\t    strcmp(name, levels[i].name) == 0 && \n@@ -153,56 +160,39 @@\n    for each call we test that it succeeds, and where possible test \n    for consistency between the calls. \n */\n-BOOL torture_raw_qfileinfo(struct torture_context *torture)\n+static BOOL torture_raw_qfileinfo_internals(struct torture_context *torture, TALLOC_CTX *mem_ctx, \t\n+\t\t\t\t\t    struct smbcli_tree *tree, int fnum, const char *fname)\n {\n-\tstruct smbcli_state *cli;\n \tint i;\n \tBOOL ret = True;\n \tint count;\n \tunion smb_fileinfo *s1, *s2;\t\n-\tTALLOC_CTX *mem_ctx;\n-\tint fnum;\n-\tconst char *fname = \"\\\\torture_qfileinfo.txt\";\n \tNTTIME correct_time;\n \tuint64_t correct_size;\n \tuint32_t correct_attrib;\n \tconst char *correct_name;\n \tBOOL skip_streams = False;\n \n-\tif (!torture_open_connection(&cli, 0)) {\n-\t\treturn False;\n-\t}\n-\n-\tmem_ctx = talloc_init(\"torture_qfileinfo\");\n-\n-\tfnum = create_complex_file(cli, mem_ctx, fname);\n-\tif (fnum == -1) {\n-\t\tprintf(\"ERROR: open of %s failed (%s)\\n\", fname, smbcli_errstr(cli->tree));\n-\t\tret = False;\n-\t\tgoto done;\n-\t}\n-\t\n-\t\n \t/* scan all the fileinfo and pathinfo levels */\n \tfor (i=0; levels[i].name; i++) {\n \t\tif (!levels[i].only_paths) {\n \t\t\tlevels[i].fnum_finfo.generic.level = levels[i].level;\n \t\t\tlevels[i].fnum_finfo.generic.in.file.fnum = fnum;\n-\t\t\tlevels[i].fnum_status = smb_raw_fileinfo(cli->tree, mem_ctx, \n+\t\t\tlevels[i].fnum_status = smb_raw_fileinfo(tree, mem_ctx, \n \t\t\t\t\t\t\t\t &levels[i].fnum_finfo);\n \t\t}\n \n \t\tif (!levels[i].only_handles) {\n \t\t\tlevels[i].fname_finfo.generic.level = levels[i].level;\n \t\t\tlevels[i].fname_finfo.generic.in.file.path = talloc_strdup(mem_ctx, fname);\n-\t\t\tlevels[i].fname_status = smb_raw_pathinfo(cli->tree, mem_ctx, \n+\t\t\tlevels[i].fname_status = smb_raw_pathinfo(tree, mem_ctx, \n \t\t\t\t\t\t\t\t  &levels[i].fname_finfo);\n \t\t}\n \t}\n \n \t/* check for completely broken levels */\n \tfor (count=i=0; levels[i].name; i++) {\n-\t\tuint32_t cap = cli->transport->negotiate.capabilities;\n+\t\tuint32_t cap = tree->session->transport->negotiate.capabilities;\n \t\t/* see if this server claims to support this level */\n \t\tif ((cap & levels[i].capability_mask) != levels[i].capability_mask) {\n \t\t\tcontinue;\n@@ -213,7 +203,7 @@\n \t\t\t       levels[i].name, nt_errstr(levels[i].fnum_status));\n \t\t\tcount++;\n \t\t}\n-\t\tif (!levels[i].only_handles && !NT_STATUS_IS_OK(levels[i].fname_status)) {\n+\t\tif (!(is_ipc || levels[i].only_handles) && !NT_STATUS_IS_OK(levels[i].fname_status)) {\n \t\t\tprintf(\"ERROR: level %s failed - %s\\n\", \n \t\t\t       levels[i].name, nt_errstr(levels[i].fname_status));\n \t\t\tcount++;\n@@ -232,8 +222,10 @@\n \t/* see if we can do streams */\n \ts1 = fnum_find(\"STREAM_INFO\");\n \tif (!s1 || s1->stream_info.out.num_streams == 0) {\n-\t\tprintf(\"STREAM_INFO broken (%d) - skipping streams checks\\n\",\n-\t\t       s1 ? s1->stream_info.out.num_streams : -1);\n+\t\tif (!is_ipc) {\n+\t\t\tprintf(\"STREAM_INFO broken (%d) - skipping streams checks\\n\",\n+\t\t\t       s1 ? s1->stream_info.out.num_streams : -1);\n+\t\t}\n \t\tskip_streams = True;\n \t}\t\n \n@@ -511,14 +503,14 @@\n #define NAME_CHECK(sname, stype, tfield, flags) do { \\\n \ts1 = fnum_find(sname); \\\n \tif (s1 && (strcmp_safe(s1->stype.out.tfield.s, correct_name) != 0 || \\\n-\t    \t\twire_bad_flags(&s1->stype.out.tfield, flags, cli))) { \\\n+\t    \t\twire_bad_flags(&s1->stype.out.tfield, flags, tree->session->transport))) { \\\n \t\tprintf(\"(%d) handle %s/%s incorrect - '%s/%d'\\n\", __LINE__, #stype, #tfield,  \\\n \t\t       s1->stype.out.tfield.s, s1->stype.out.tfield.private_length); \\\n \t\tret = False; \\\n \t} \\\n \ts1 = fname_find(sname); \\\n \tif (s1 && (strcmp_safe(s1->stype.out.tfield.s, correct_name) != 0 || \\\n-\t    \t\twire_bad_flags(&s1->stype.out.tfield, flags, cli))) { \\\n+\t    \t\twire_bad_flags(&s1->stype.out.tfield, flags, tree->session->transport))) { \\\n \t\tprintf(\"(%d) path %s/%s incorrect - '%s/%d'\\n\", __LINE__, #stype, #tfield,  \\\n \t\t       s1->stype.out.tfield.s, s1->stype.out.tfield.private_length); \\\n \t\tret = False; \\\n@@ -546,42 +538,44 @@\n \t\t\t\tret = False;\n \t\t\t}\n \t\t}\n-\t\tif (wire_bad_flags(&s1->all_info.out.fname, STR_UNICODE, cli)) {\n+\t\tif (wire_bad_flags(&s1->all_info.out.fname, STR_UNICODE, tree->session->transport)) {\n \t\t\tprintf(\"Should not null terminate all_info/fname\\n\");\n \t\t\tret = False;\n \t\t}\n \t}\n \n \ts1 = fnum_find(\"ALT_NAME_INFO\");\n-\tcorrect_name = s1->alt_name_info.out.fname.s;\n-\tprintf(\"alt_name: %s\\n\", correct_name);\n-\n-\tNAME_CHECK(\"ALT_NAME_INFO\",        alt_name_info, fname, STR_UNICODE);\n-\tNAME_CHECK(\"ALT_NAME_INFORMATION\", alt_name_info, fname, STR_UNICODE);\n-\n-\t/* and make sure we can open by alternate name */\n-\tsmbcli_close(cli->tree, fnum);\n-\tfnum = smbcli_nt_create_full(cli->tree, correct_name, 0, \n-\t\t\t\t     SEC_RIGHTS_FILE_ALL,\n-\t\t\t\t     FILE_ATTRIBUTE_NORMAL,\n-\t\t\t\t     NTCREATEX_SHARE_ACCESS_DELETE|\n-\t\t\t\t     NTCREATEX_SHARE_ACCESS_READ|\n-\t\t\t\t     NTCREATEX_SHARE_ACCESS_WRITE, \n-\t\t\t\t     NTCREATEX_DISP_OVERWRITE_IF, \n-\t\t\t\t     0, 0);\n-\tif (fnum == -1) {\n-\t\tprintf(\"Unable to open by alt_name - %s\\n\", smbcli_errstr(cli->tree));\n-\t\tret = False;\n+\tif (s1) {\n+\t\tcorrect_name = s1->alt_name_info.out.fname.s;\n+\t\tprintf(\"alt_name: %s\\n\", correct_name);\n+\t\t\n+\t\tNAME_CHECK(\"ALT_NAME_INFO\",        alt_name_info, fname, STR_UNICODE);\n+\t\tNAME_CHECK(\"ALT_NAME_INFORMATION\", alt_name_info, fname, STR_UNICODE);\n+\t\t\n+\t\t/* and make sure we can open by alternate name */\n+\t\tsmbcli_close(tree, fnum);\n+\t\tfnum = smbcli_nt_create_full(tree, correct_name, 0, \n+\t\t\t\t\t     SEC_RIGHTS_FILE_ALL,\n+\t\t\t\t\t     FILE_ATTRIBUTE_NORMAL,\n+\t\t\t\t\t     NTCREATEX_SHARE_ACCESS_DELETE|\n+\t\t\t\t\t     NTCREATEX_SHARE_ACCESS_READ|\n+\t\t\t\t\t     NTCREATEX_SHARE_ACCESS_WRITE, \n+\t\t\t\t\t     NTCREATEX_DISP_OVERWRITE_IF, \n+\t\t\t\t\t     0, 0);\n+\t\tif (fnum == -1) {\n+\t\t\tprintf(\"Unable to open by alt_name - %s\\n\", smbcli_errstr(tree));\n+\t\t\tret = False;\n+\t\t}\n+\t\t\n+\t\tif (!skip_streams) {\n+\t\t\tcorrect_name = \"::$DATA\";\n+\t\t\tprintf(\"stream_name: %s\\n\", correct_name);\n+\t\t\t\n+\t\t\tNAME_CHECK(\"STREAM_INFO\",        stream_info, streams[0].stream_name, STR_UNICODE);\n+\t\t\tNAME_CHECK(\"STREAM_INFORMATION\", stream_info, streams[0].stream_name, STR_UNICODE);\n+\t\t}\n \t}\n-\n-\tif (!skip_streams) {\n-\t\tcorrect_name = \"::$DATA\";\n-\t\tprintf(\"stream_name: %s\\n\", correct_name);\n-\n-\t\tNAME_CHECK(\"STREAM_INFO\",        stream_info, streams[0].stream_name, STR_UNICODE);\n-\t\tNAME_CHECK(\"STREAM_INFORMATION\", stream_info, streams[0].stream_name, STR_UNICODE);\n-\t}\n-\n+\t\t\n \t/* make sure the EAs look right */\n \ts1 = fnum_find(\"ALL_EAS\");\n \ts2 = fnum_find(\"ALL_INFO\");\n@@ -714,10 +708,85 @@\n \t\n \n done:\n+\n+\treturn ret;\n+}\n+\n+/* basic testing of all RAW_FILEINFO_* calls \n+   for each call we test that it succeeds, and where possible test \n+   for consistency between the calls. \n+*/\n+BOOL torture_raw_qfileinfo(struct torture_context *torture)\n+{\n+\tstruct smbcli_state *cli;\n+\tBOOL ret = True;\n+\tTALLOC_CTX *mem_ctx;\n+\tint fnum;\n+\tconst char *fname = \"\\\\torture_qfileinfo.txt\";\n+\n+\tis_ipc = 0;\n+\n+\tif (!torture_open_connection(&cli, 0)) {\n+\t\treturn False;\n+\t}\n+\n+\tmem_ctx = talloc_init(\"torture_qfileinfo\");\n+\n+\tfnum = create_complex_file(cli, mem_ctx, fname);\n+\tif (fnum == -1) {\n+\t\tprintf(\"ERROR: open of %s failed (%s)\\n\", fname, smbcli_errstr(cli->tree));\n+\t\tret = False;\n+\t\tgoto done;\n+\t}\n+\n+\tret = torture_raw_qfileinfo_internals(torture, mem_ctx, cli->tree, fnum, fname);\n+\t\n \tsmbcli_close(cli->tree, fnum);\n \tsmbcli_unlink(cli->tree, fname);\n \n+done:\n \ttorture_close_connection(cli);\n \ttalloc_free(mem_ctx);\n \treturn ret;\n }\n+\n+BOOL torture_raw_qfileinfo_pipe(struct torture_context *torture)\n+{\n+\tTALLOC_CTX *mem_ctx;\n+\tBOOL ret = True;\n+\tint fnum;\n+\tconst char *fname = \"\\\\lsass\";\n+\tstruct smbcli_state *cli;\n+\tstruct dcerpc_pipe *p;\n+\tstruct smbcli_tree *ipc_tree;\n+\tNTSTATUS status;\n+\n+\tis_ipc = True;\n+\t\n+\tif (!torture_open_connection(&cli, 0)) {\n+\t\treturn False;\n+\t}\n+\n+\tmem_ctx = talloc_init(\"torture_qfileinfo_pipe\");\n+\n+\tif (!(p = dcerpc_pipe_init(mem_ctx, \n+\t\t\t\t   cli->tree->session->transport->socket->event.ctx))) {\n+\t\treturn False;\n+\t}\n+\n+\tstatus = dcerpc_pipe_open_smb(p, cli->tree, fname);\n+\tif (!NT_STATUS_IS_OK(status)) {\n+\t\td_printf(\"dcerpc_pipe_open_smb failed: %s\\n\",\n+\t\t\t nt_errstr(status));\n+\t\ttalloc_free(p);\n+\t\treturn False;\n+\t}\n+\n+\tipc_tree = dcerpc_smb_tree(p->conn);\n+\tfnum = dcerpc_smb_fnum(p->conn);\n+\n+\tret = torture_raw_qfileinfo_internals(torture, mem_ctx, ipc_tree, fnum, fname);\n+\t\n+\ttalloc_free(p);\n+\treturn ret;\n+}\n\nModified: branches/SAMBA_4_0/source/torture/raw/qfsinfo.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/qfsinfo.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/raw/qfsinfo.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -289,7 +289,7 @@\n #define STR_CHECK(sname, stype, field, flags) do { \\\n \ts1 = find(sname); \\\n \tif (s1) { \\\n-\t\tif (s1->stype.out.field.s && wire_bad_flags(&s1->stype.out.field, flags, cli)) { \\\n+\t\tif (s1->stype.out.field.s && wire_bad_flags(&s1->stype.out.field, flags, cli->transport)) { \\\n \t\t\tprintf(\"(%d) incorrect string termination in %s/%s\\n\", \\\n \t\t\t       __LINE__, #stype, #field); \\\n \t\t\tret = False; \\\n\nModified: branches/SAMBA_4_0/source/torture/raw/raw.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/raw.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/raw/raw.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -34,6 +34,7 @@\n \ttorture_suite_add_simple_test(suite, \"BENCH-OPEN\", torture_bench_open);\n \ttorture_suite_add_simple_test(suite, \"QFSINFO\", torture_raw_qfsinfo);\n \ttorture_suite_add_simple_test(suite, \"QFILEINFO\", torture_raw_qfileinfo);\n+\ttorture_suite_add_simple_test(suite, \"QFILEINFO-IPC\", torture_raw_qfileinfo_pipe);\n \ttorture_suite_add_simple_test(suite, \"SFILEINFO\", torture_raw_sfileinfo);\n \ttorture_suite_add_simple_test(suite, \"SFILEINFO-BUG\", torture_raw_sfileinfo_bug);\n \ttorture_suite_add_simple_test(suite, \"SEARCH\", torture_raw_search);\n\nModified: branches/SAMBA_4_0/source/torture/raw/search.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/search.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/raw/search.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -391,7 +391,7 @@\n \tif (s) { \\\n \t\tif (!s->sname1.field1.s || \\\n \t\t    strcmp(s->sname1.field1.s, v.sname2.out.field2.s) || \\\n-\t\t    wire_bad_flags(&s->sname1.field1, flags, cli)) { \\\n+\t\t    wire_bad_flags(&s->sname1.field1, flags, cli->transport)) { \\\n \t\t\tprintf(\"(%s) %s/%s [%s] != %s/%s [%s]\\n\", \\\n \t\t\t       __location__, \\\n \t\t\t\t#sname1, #field1, s->sname1.field1.s, \\\n@@ -405,7 +405,7 @@\n \tif (s) { \\\n \t\tif (!s->sname1.field1.s || \\\n \t\t    strcmp(s->sname1.field1.s, fname) || \\\n-\t\t    wire_bad_flags(&s->sname1.field1, flags, cli)) { \\\n+\t\t    wire_bad_flags(&s->sname1.field1, flags, cli->transport)) { \\\n \t\t\tprintf(\"(%s) %s/%s [%s] != %s\\n\", \\\n \t\t\t       __location__, \\\n \t\t\t\t#sname1, #field1, s->sname1.field1.s, \\\n\nModified: branches/SAMBA_4_0/source/torture/util_smb.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/util_smb.c\t2007-05-14 03:49:42 UTC (rev 22837)\n+++ branches/SAMBA_4_0/source/torture/util_smb.c\t2007-05-14 05:53:26 UTC (rev 22838)\n@@ -282,7 +282,7 @@\n   check that a wire string matches the flags specified \n   not 100% accurate, but close enough for testing\n */\n-bool wire_bad_flags(struct smb_wire_string *str, int flags, struct smbcli_state *cli)\n+bool wire_bad_flags(struct smb_wire_string *str, int flags, struct smbcli_transport *transport)\n {\n \tbool server_unicode;\n \tint len;\n@@ -290,7 +290,7 @@\n \tlen = strlen(str->s);\n \tif (flags & STR_TERMINATE) len++;\n \n-\tserver_unicode = (cli->transport->negotiate.capabilities&CAP_UNICODE)?True:False;\n+\tserver_unicode = (transport->negotiate.capabilities&CAP_UNICODE)?True:False;\n \tif (getenv(\"CLI_FORCE_ASCII\") || !lp_unicode()) {\n \t\tserver_unicode = False;\n \t}\n\n"}
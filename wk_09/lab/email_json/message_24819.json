{"category": "ham", "to_address": "bugs-bitbucket@netlabs.develooper.com", "from_address": "Paul Cochrane (via RT) <parrotbug-followup@parrotcode.org>", "subject": "[perl #42901] Solutions for the install target problems (was RT#41908) ", "body": "# New Ticket Created by  Paul Cochrane \n# Please include the string:  [perl #42901]\n# in the subject line of all future correspondence about this issue. \n# \n\n\nI'm splitting RT#41908 into two pieces, one which is a now-applied\npatch for extension guessing and this which discusses solutions to the\ninstall target problems in Parrot previously mentioned by Mike Mattie.\n The following is Mike's original discussion as given in RT#41908.\n\n\"\"\"\nAt this point a real discussion is needed with the parrot developer community.\n\nThe ultimate purpose of these patches is to enable developers to write code that\nwill work the same way in both their working-copies and the install tree. To do\nthis the parrot development process will need to be modified. I have thought up\na solution that I believe is extremely un-obtrusive , and possibly a\nunique feature.\n\nbackground:\n\nIf the developers begin removing extensions from their requested files\nthe work-cycle\nwill change to a full-compilation cycle, as the loader will prefer a\n.pbc file over\na .pasm or a .pir.\n\nIn discussions on IRC there was a reluctance to switch to this cycle.\nIt does take\nsome of the dynamic flavor out of the development process.\n\nThere are two solutions.\n\n1. do a clean during development. only the source files will remain\nand there should\nnot be any problems. There could be collisions with a installed tree,\nhowever the\nsecond option is a step towards a complete solution.\n\n2. introduce a environment variable, for example: PARROT_LOAD_PREFER\n\nthis variable when set would have two valid values: source|compile.\n\nif no variable was set, or it was incorrectly set it would default\nto the compile value, giving typical (perl5 for example) behavior\nwhere a compiled version is always loaded over the source version.\n\nwhen the variable would be set to \"source\" then the reverse would\nhappen, and the \".pir\" files would be loaded over a .pbc.\n\nThis allows developers to simply export PARROT_LOAD_PREFER=\"source\"\nwhen developing to guarantee that the loaded files will be\nthe source files with their most recent changes.\n\nby looking at the diff I think you will see the code changes subsequent\nto this patch to implement this will be nearly trivial at this point.\n\n[phase 3] the big win\n\nassuming that environment variables are a suitable way for parrot\ndevelopers to maintain their current behavior a big step forward\nis now possible.\n\nthe last remaining issue is the difference between the layout\nin the working-copy and the install tree.\n\nie: parrot/library vs. runtime/parrot/library\n\nI have been developing a perl5 program in my spare time meant to\naddress this very problem for my own purposes. but either the idea\nor an adapted version of the code can solve this neatly.\n\nthe idea is that markers are placed in the working-copy tree marking\ninstallation paths. so in runtime/ some sort of file (MANIFEST ?) would indicate\nthat the paths below runtime/ are to be preserved in the install\ntree.\n\n[if those files listed what needed to be installed writing the install\ntarget would be a snap, with language-hackers having control over\ntheir installed files.]\n\nWith this information a perl program can recursively traverse the tree\nand create and add each of these directories with a MANIFEST file to\nthe load path ( PARROT_INC ? , I am not sure )\n\nso if you have your source code in ${HOME}/parrot/ , and there is a\nMANIFEST file in runtime/ , the code would add an environment variable\nlike this:\n\nPARROT_INC=\"${HOME}/parrot/runtime\"\n\nthe perl program can simply dump out this list of environment variables\non stdout.\n\nwhen a perl developer is ready to hack in the tree , he runs the program,\nand source's the output, updating his environment for that session.\n\nnow his path \"Digest/MD5\" automatically gets a \".pir\" tried first because\nof PARROT_LOAD_PREFER=\"source\", and the prefix is the exact same in both\nthe working copy and the install tree.\n\nwhen the perl developer installs his code, and the environment variables\nare cleared .pbc files are loaded as they should be and the path prefixes\nare the same.\n\nExtensive release testing is not necessary to maintain the install target\nbecause things break in the working-copy in the same way they would break\nin the install-tree. This is extremely powerful for development.\n\n[leftovers]\n\nthere is a insignificant race, but still a race in the code. This needs\nto be addressed later as a part of fully insulating the src/library.c API.\n\nUltimately a struct like this is needed.\n\nstruct load_file {\nFILE* handle,\nparrot_runtime_ft type\n}\n\n1. Parrot_runtime_locate_runtime_str would be renamed to\nparrot_locate_runtime_file,\nit would return the struct with the handle, the type value would be a\nnull/unkown\nvalue.\n\nthis closes the race by getting rid of a pointless stat() introduced\nby the string\nreturn value, a result of the poor API insulation. dynext.c replicates much of\nParrot_locate_runtime_str in it's own fashion.\n\nalso this should be opened on unix with O_NOCTTY | O_NOFOLLOW btw. maybe even\nfsat for block/char devices too.\n\n2. a a hueristic routine for detecting parrot_runtime_ft\n\nit would take the load_file struct, and do the magic number/heuristic checks\non the first chunk of the file and determine what runtime_ft_type it is,\nsetting the value in the load_file struct.\n\nAt this point the appropriate loader/infrastructure can be chosen to load the\nfile.\n\nalso the handling of shared object extensions can be done in the same way of\ntry_bytecode_extensions now.\n\nThat's all for now. Thanks again for answering all my questions, and I\nlook forward\nto any comments or suggestions.\n\nCheers,\nMike Mattie (codermattie at gmail.com)\n\"\"\"\n\n"}
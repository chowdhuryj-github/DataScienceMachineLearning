{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 205: always use allocated packets to avoid alignment errors in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 205\nrevision-id: tridge@samba.org-20070427151047-fvef601i9ea2dnrj\nparent: tridge@samba.org-20070427145352-19w38cwkghv01x8n\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Fri 2007-04-27 17:10:47 +0200\nmessage:\n  always use allocated packets to avoid alignment errors\nmodified:\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-04-27 14:31:45 +0000\n+++ b/common/ctdb_client.c\t2007-04-27 15:10:47 +0000\n@@ -381,7 +381,7 @@\n \t\t\t     void *private_data)\n \t\t\t\t    \n {\n-\tstruct ctdb_req_register c;\n+\tstruct ctdb_req_register *c;\n \tint res;\n \n \t/* if the domain socket is not yet open, open it */\n@@ -389,15 +389,15 @@\n \t\tctdb_socket_connect(ctdb);\n \t}\n \n-\tZERO_STRUCT(c);\n-\n-\tc.hdr.length       = sizeof(c);\n-\tc.hdr.ctdb_magic   = CTDB_MAGIC;\n-\tc.hdr.ctdb_version = CTDB_VERSION;\n-\tc.hdr.operation    = CTDB_REQ_REGISTER;\n-\tc.srvid            = srvid;\n-\n-\tres = ctdb_client_queue_pkt(ctdb, &c.hdr);\n+\tc = ctdbd_allocate_pkt(ctdb, sizeof(*c));\n+\tc->hdr.length       = sizeof(*c);\n+\tc->hdr.ctdb_magic   = CTDB_MAGIC;\n+\tc->hdr.ctdb_version = CTDB_VERSION;\n+\tc->hdr.operation    = CTDB_REQ_REGISTER;\n+\tc->srvid            = srvid;\n+\n+\tres = ctdb_client_queue_pkt(ctdb, &c->hdr);\n+\ttalloc_free(c);\n \tif (res != 0) {\n \t\treturn res;\n \t}\n@@ -446,15 +446,14 @@\n  */\n void ctdb_connect_wait(struct ctdb_context *ctdb)\n {\n-\tstruct ctdb_req_connect_wait r;\n+\tstruct ctdb_req_connect_wait *r;\n \tint res;\n \n-\tZERO_STRUCT(r);\n-\n-\tr.hdr.length     = sizeof(r);\n-\tr.hdr.ctdb_magic = CTDB_MAGIC;\n-\tr.hdr.ctdb_version = CTDB_VERSION;\n-\tr.hdr.operation = CTDB_REQ_CONNECT_WAIT;\n+\tr = ctdbd_allocate_pkt(ctdb, sizeof(*r));\n+\tr->hdr.length     = sizeof(*r);\n+\tr->hdr.ctdb_magic = CTDB_MAGIC;\n+\tr->hdr.ctdb_version = CTDB_VERSION;\n+\tr->hdr.operation = CTDB_REQ_CONNECT_WAIT;\n \n \tDEBUG(3,(\"ctdb_connect_wait: sending to ctdbd\\n\"));\n \n@@ -463,7 +462,8 @@\n \t\tctdb_socket_connect(ctdb);\n \t}\n \t\n-\tres = ctdb_queue_send(ctdb->daemon.queue, (uint8_t *)&r.hdr, r.hdr.length);\n+\tres = ctdb_queue_send(ctdb->daemon.queue, (uint8_t *)&r->hdr, r->hdr.length);\n+\ttalloc_free(r);\n \tif (res != 0) {\n \t\tDEBUG(0,(__location__ \" Failed to queue a connect wait request\\n\"));\n \t\treturn;\n@@ -596,23 +596,24 @@\n */\n void ctdb_shutdown(struct ctdb_context *ctdb)\n {\n-\tstruct ctdb_req_shutdown r;\n-\tint len;\n+\tstruct ctdb_req_shutdown *r;\n \n \t/* if the domain socket is not yet open, open it */\n \tif (ctdb->daemon.sd==-1) {\n \t\tctdb_socket_connect(ctdb);\n \t}\n \n-\tlen = sizeof(struct ctdb_req_shutdown);\n-\tZERO_STRUCT(r);\n-\tr.hdr.length       = len;\n-\tr.hdr.ctdb_magic   = CTDB_MAGIC;\n-\tr.hdr.ctdb_version = CTDB_VERSION;\n-\tr.hdr.operation    = CTDB_REQ_SHUTDOWN;\n-\tr.hdr.reqid        = 0;\n-\n-\tctdb_client_queue_pkt(ctdb, &(r.hdr));\n+\tr = ctdbd_allocate_pkt(ctdb, sizeof(*r));\n+\tZERO_STRUCT(*r);\n+\tr->hdr.length       = sizeof(*r);\n+\tr->hdr.ctdb_magic   = CTDB_MAGIC;\n+\tr->hdr.ctdb_version = CTDB_VERSION;\n+\tr->hdr.operation    = CTDB_REQ_SHUTDOWN;\n+\tr->hdr.reqid        = 0;\n+\n+\tctdb_client_queue_pkt(ctdb, &(r->hdr));\n+\n+\ttalloc_free(r);\n \n \t/* this event loop will terminate once we receive the reply */\n \twhile (1) {\n\n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-04-27 14:31:45 +0000\n+++ b/common/ctdb_daemon.c\t2007-04-27 15:10:47 +0000\n@@ -216,23 +216,23 @@\n static void daemon_request_connect_wait(struct ctdb_client *client, \n \t\t\t\t\tstruct ctdb_req_connect_wait *c)\n {\n-\tstruct ctdb_reply_connect_wait r;\n+\tstruct ctdb_reply_connect_wait *r;\n \tint res;\n \n \t/* first wait - in the daemon */\n \tctdb_daemon_connect_wait(client->ctdb);\n \n \t/* now send the reply */\n-\tZERO_STRUCT(r);\n-\n-\tr.hdr.length     = sizeof(r);\n-\tr.hdr.ctdb_magic = CTDB_MAGIC;\n-\tr.hdr.ctdb_version = CTDB_VERSION;\n-\tr.hdr.operation = CTDB_REPLY_CONNECT_WAIT;\n-\tr.vnn           = ctdb_get_vnn(client->ctdb);\n-\tr.num_connected = client->ctdb->num_connected;\n+\tr = ctdbd_allocate_pkt(client, sizeof(*r));\n+\tr->hdr.length     = sizeof(*r);\n+\tr->hdr.ctdb_magic = CTDB_MAGIC;\n+\tr->hdr.ctdb_version = CTDB_VERSION;\n+\tr->hdr.operation = CTDB_REPLY_CONNECT_WAIT;\n+\tr->vnn           = ctdb_get_vnn(client->ctdb);\n+\tr->num_connected = client->ctdb->num_connected;\n \t\n-\tres = daemon_queue_send(client, &r.hdr);\n+\tres = daemon_queue_send(client, &r->hdr);\n+\ttalloc_free(r);\n \tif (res != 0) {\n \t\tDEBUG(0,(__location__ \" Failed to queue a connect wait response\\n\"));\n \t\treturn;\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r23313 - in branches: SAMBA_3_0/source/lib\n\tSAMBA_3_0_26/source/lib", "body": "Author: vlendec\nDate: 2007-06-03 06:54:51 +0000 (Sun, 03 Jun 2007)\nNew Revision: 23313\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23313\n\nLog:\nJanitor for tridge:\n\nwe need to use tdb_wrap_open in both these backends to allow for\nmultiple opens.  This is done for notify.tdb. Otherwise we die when a\n2nd share with notify is setup\n\n\nModified:\n   branches/SAMBA_3_0/source/lib/dbwrap_tdb.c\n   branches/SAMBA_3_0_26/source/lib/dbwrap_tdb.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/lib/dbwrap_tdb.c\n===================================================================\n--- branches/SAMBA_3_0/source/lib/dbwrap_tdb.c\t2007-06-02 21:12:47 UTC (rev 23312)\n+++ branches/SAMBA_3_0/source/lib/dbwrap_tdb.c\t2007-06-03 06:54:51 UTC (rev 23313)\n@@ -21,7 +21,7 @@\n #include \"includes.h\"\n \n struct db_tdb_ctx {\n-\tTDB_CONTEXT *tdb;\n+\tstruct tdb_wrap *wtdb;\n };\n \n static NTSTATUS db_tdb_store(struct db_record *rec, TDB_DATA data, int flag);\n@@ -36,7 +36,7 @@\n \t\t   hex_encode(data, (unsigned char *)data->key.dptr,\n \t\t\t      data->key.dsize)));\n \n-\tif (tdb_chainunlock(ctx->tdb, data->key) != 0) {\n+\tif (tdb_chainunlock(ctx->wtdb->tdb, data->key) != 0) {\n \t\tDEBUG(0, (\"tdb_chainunlock failed\\n\"));\n \t\treturn -1;\n \t}\n@@ -78,7 +78,7 @@\n \t\tTALLOC_FREE(keystr);\n \t}\n \n-\tif (tdb_chainlock(ctx->tdb, key) != 0) {\n+\tif (tdb_chainlock(ctx->wtdb->tdb, key) != 0) {\n \t\tDEBUG(3, (\"tdb_chainlock failed\\n\"));\n \t\tTALLOC_FREE(result);\n \t\treturn NULL;\n@@ -86,7 +86,7 @@\n \n \ttalloc_set_destructor(result, db_tdb_record_destr);\n \n-\tvalue = tdb_fetch(ctx->tdb, key);\n+\tvalue = tdb_fetch(ctx->wtdb->tdb, key);\n \n \tif (value.dptr == NULL) {\n \t\treturn result;\n@@ -119,7 +119,7 @@\n \t * anymore after it was stored.\n \t */\n \n-\treturn (tdb_store(ctx->tdb, rec->key, data, flag) == 0) ?\n+\treturn (tdb_store(ctx->wtdb->tdb, rec->key, data, flag) == 0) ?\n \t\tNT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;\n }\n \n@@ -129,13 +129,13 @@\n \t\t\t\t\t\t       struct db_tdb_ctx);\n \tint res;\n \t\n-\tres = tdb_delete(ctx->tdb, rec->key);\n+\tres = tdb_delete(ctx->wtdb->tdb, rec->key);\n \n \tif (res == 0) {\n \t\treturn NT_STATUS_OK;\n \t}\n \n-\treturn map_nt_error_from_tdb(tdb_error(ctx->tdb));\n+\treturn map_nt_error_from_tdb(tdb_error(ctx->wtdb->tdb));\n }\n \n struct db_tdb_traverse_ctx {\n@@ -171,7 +171,7 @@\n \tctx.db = db;\n \tctx.f = f;\n \tctx.private_data = private_data;\n-\treturn tdb_traverse(db_ctx->tdb, db_tdb_traverse_func, &ctx);\n+\treturn tdb_traverse(db_ctx->wtdb->tdb, db_tdb_traverse_func, &ctx);\n }\n \n static NTSTATUS db_tdb_store_deny(struct db_record *rec, TDB_DATA data, int flag)\n@@ -211,7 +211,7 @@\n \tctx.db = db;\n \tctx.f = f;\n \tctx.private_data = private_data;\n-\treturn tdb_traverse_read(db_ctx->tdb, db_tdb_traverse_read_func, &ctx);\n+\treturn tdb_traverse_read(db_ctx->wtdb->tdb, db_tdb_traverse_read_func, &ctx);\n }\n \n static int db_tdb_get_seqnum(struct db_context *db)\n@@ -219,19 +219,9 @@\n {\n \tstruct db_tdb_ctx *db_ctx =\n \t\ttalloc_get_type_abort(db->private_data, struct db_tdb_ctx);\n-\treturn tdb_get_seqnum(db_ctx->tdb);\n+\treturn tdb_get_seqnum(db_ctx->wtdb->tdb);\n }\n \n-static int db_tdb_ctx_destr(struct db_tdb_ctx *ctx)\n-{\n-\tif (tdb_close(ctx->tdb) != 0) {\n-\t\tDEBUG(0, (\"Failed to close tdb: %s\\n\", strerror(errno)));\n-\t\treturn -1;\n-\t}\n-\n-\treturn 0;\n-}\n-\n struct db_context *db_open_tdb(TALLOC_CTX *mem_ctx,\n \t\t\t       const char *name,\n \t\t\t       int hash_size, int tdb_flags,\n@@ -252,14 +242,13 @@\n \t\tgoto fail;\n \t}\n \n-\tdb_tdb->tdb = tdb_open_log(name, hash_size, tdb_flags,\n-\t\t\t\t   open_flags, mode);\n-\tif (db_tdb->tdb == NULL) {\n+\tdb_tdb->wtdb = tdb_wrap_open(db_tdb, name, hash_size, tdb_flags,\n+\t\t\t\t     open_flags, mode);\n+\tif (db_tdb->wtdb == NULL) {\n \t\tDEBUG(3, (\"Could not open tdb: %s\\n\", strerror(errno)));\n \t\tgoto fail;\n \t}\n \n-\ttalloc_set_destructor(db_tdb, db_tdb_ctx_destr);\n \tresult->fetch_locked = db_tdb_fetch_locked;\n \tresult->traverse = db_tdb_traverse;\n \tresult->traverse_read = db_tdb_traverse_read;\n\nModified: branches/SAMBA_3_0_26/source/lib/dbwrap_tdb.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/dbwrap_tdb.c\t2007-06-02 21:12:47 UTC (rev 23312)\n+++ branches/SAMBA_3_0_26/source/lib/dbwrap_tdb.c\t2007-06-03 06:54:51 UTC (rev 23313)\n@@ -21,7 +21,7 @@\n #include \"includes.h\"\n \n struct db_tdb_ctx {\n-\tTDB_CONTEXT *tdb;\n+\tstruct tdb_wrap *wtdb;\n };\n \n static NTSTATUS db_tdb_store(struct db_record *rec, TDB_DATA data, int flag);\n@@ -36,7 +36,7 @@\n \t\t   hex_encode(data, (unsigned char *)data->key.dptr,\n \t\t\t      data->key.dsize)));\n \n-\tif (tdb_chainunlock(ctx->tdb, data->key) != 0) {\n+\tif (tdb_chainunlock(ctx->wtdb->tdb, data->key) != 0) {\n \t\tDEBUG(0, (\"tdb_chainunlock failed\\n\"));\n \t\treturn -1;\n \t}\n@@ -77,7 +77,7 @@\n \t\tTALLOC_FREE(keystr);\n \t}\n \n-\tif (tdb_chainlock(ctx->tdb, key) != 0) {\n+\tif (tdb_chainlock(ctx->wtdb->tdb, key) != 0) {\n \t\tDEBUG(3, (\"tdb_chainlock failed\\n\"));\n \t\tTALLOC_FREE(result);\n \t\treturn NULL;\n@@ -85,7 +85,7 @@\n \n \ttalloc_set_destructor(result, db_tdb_record_destr);\n \n-\tvalue = tdb_fetch(ctx->tdb, key);\n+\tvalue = tdb_fetch(ctx->wtdb->tdb, key);\n \n \tif (value.dptr == NULL) {\n \t\treturn result;\n@@ -117,7 +117,7 @@\n \t * anymore after it was stored.\n \t */\n \n-\treturn (tdb_store(ctx->tdb, rec->key, data, flag) == 0) ?\n+\treturn (tdb_store(ctx->wtdb->tdb, rec->key, data, flag) == 0) ?\n \t\tNT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;\n }\n \n@@ -127,13 +127,13 @@\n \t\t\t\t\t\t       struct db_tdb_ctx);\n \tint res;\n \t\n-\tres = tdb_delete(ctx->tdb, rec->key);\n+\tres = tdb_delete(ctx->wtdb->tdb, rec->key);\n \n \tif (res == 0) {\n \t\treturn NT_STATUS_OK;\n \t}\n \n-\treturn map_nt_error_from_tdb(tdb_error(ctx->tdb));\n+\treturn map_nt_error_from_tdb(tdb_error(ctx->wtdb->tdb));\n }\n \n struct db_tdb_traverse_ctx {\n@@ -169,7 +169,7 @@\n \tctx.db = db;\n \tctx.f = f;\n \tctx.private_data = private_data;\n-\treturn tdb_traverse(db_ctx->tdb, db_tdb_traverse_func, &ctx);\n+\treturn tdb_traverse(db_ctx->wtdb->tdb, db_tdb_traverse_func, &ctx);\n }\n \n static NTSTATUS db_tdb_store_deny(struct db_record *rec, TDB_DATA data, int flag)\n@@ -209,7 +209,7 @@\n \tctx.db = db;\n \tctx.f = f;\n \tctx.private_data = private_data;\n-\treturn tdb_traverse_read(db_ctx->tdb, db_tdb_traverse_read_func, &ctx);\n+\treturn tdb_traverse_read(db_ctx->wtdb->tdb, db_tdb_traverse_read_func, &ctx);\n }\n \n static int db_tdb_get_seqnum(struct db_context *db)\n@@ -217,19 +217,9 @@\n {\n \tstruct db_tdb_ctx *db_ctx =\n \t\ttalloc_get_type_abort(db->private_data, struct db_tdb_ctx);\n-\treturn tdb_get_seqnum(db_ctx->tdb);\n+\treturn tdb_get_seqnum(db_ctx->wtdb->tdb);\n }\n \n-static int db_tdb_ctx_destr(struct db_tdb_ctx *ctx)\n-{\n-\tif (tdb_close(ctx->tdb) != 0) {\n-\t\tDEBUG(0, (\"Failed to close tdb: %s\\n\", strerror(errno)));\n-\t\treturn -1;\n-\t}\n-\n-\treturn 0;\n-}\n-\n struct db_context *db_open_tdb(TALLOC_CTX *mem_ctx,\n \t\t\t       const char *name,\n \t\t\t       int hash_size, int tdb_flags,\n@@ -250,14 +240,13 @@\n \t\tgoto fail;\n \t}\n \n-\tdb_tdb->tdb = tdb_open_log(name, hash_size, tdb_flags,\n-\t\t\t\t   open_flags, mode);\n-\tif (db_tdb->tdb == NULL) {\n+\tdb_tdb->wtdb = tdb_wrap_open(db_tdb, name, hash_size, tdb_flags,\n+\t\t\t\t     open_flags, mode);\n+\tif (db_tdb->wtdb == NULL) {\n \t\tDEBUG(3, (\"Could not open tdb: %s\\n\", strerror(errno)));\n \t\tgoto fail;\n \t}\n \n-\ttalloc_set_destructor(db_tdb, db_tdb_ctx_destr);\n \tresult->fetch_locked = db_tdb_fetch_locked;\n \tresult->traverse = db_tdb_traverse;\n \tresult->traverse_read = db_tdb_traverse_read;\n\n"}
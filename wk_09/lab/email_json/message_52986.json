{"category": "ham", "to_address": "damian@conway.org", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: Referring to source code within Perldoc: the new A<> code", "body": "OK.  After much thinking on the subject, here are my recommendations:\n\nFirst: give Pod the ability to delimit blocks of ambient text, e.g.:\n\n  =text\n  class Foo {\n    has $bar;\n  }\n  =stop\n\n'=text' and '=stop' would be considered to be separate but related\nsingle-line Pod Sections, so Pod-stripping utilities would remove them\nwhile leaving the lines between them intact.  (I'm not sold on the\nspecific names for these tags; just the principles behind them.)\n\nBy default, 'A<>' searches backward from its current position within\nthe scope of the current ambient text block.  This helps you catch\ngotchas such as removing a piece of code and failing to remove the\ndocumentation that was referencing it.  Consider, for example,\ndocumenting the first attribute of a class that follows another class.\n The coder removes the attribute, but fails to remove the\ndocumentation that references it.  Suddenly, that documentation is\nreferencing the last attribute of the previous class.  If each class\nwere encapsulated in a separate ambient text section, Pod would then\nknow to complain that there is no attribute to reference anymore.\n\n--\n\nAllow ambient text blocks to be named, and allow 'A<>' to choose a\nnamed ambient text block to search.  When you do this, the position of\nthe A<> tag relative to the ambient text block becomes irrelevant.\nExample:\n\n  =begin pod\n  A\n  =end pod\n\n  =text Foo\n  class Foo {\n    has $bar;\n  }\n  =stop Foo\n\nYou might also consider changing the rules when searching ambient text\nblocks in this way, so that it searches for the first instance of the\nprefix in the block instead of searching for the last one.\n\n--\n\nLet a pod section specify a default ambient code block, causing all\nambient references within its scope to automatically reference that\nblock:\n\n  =begin pod :A\n  A\n  =end pod\n\n  =text Foo\n  class Foo {\n    has $bar;\n  }\n  =stop Foo\n\n--\n\nAllow ambient text blocks to be nested:\n\n  =begin pod :A\n    =ATTRIBUTE A\n    =METHOD A :A\n      =NAME A\n      =RETURNS A\n\n  =end pod\n\n  =text Foo\n  class Foo {\n    has $bar;\n\n  =text baz\n    method baz () returns Number { ... }\n  =stop baz\n  }\n  =stop Foo\n\n--\n\nAllow an optional \"array index\" for the prefix so that you can skip\nover a given number of matches, rather than being limited to the first\none you find:\n\n  =begin pod :A\n  A\n  A\n  =end pod\n\n  =text Foo\n  class Foo {\n    has $bar;\n    has $baz;\n  }\n  =stop Foo\n\n--\n\nFinally, there are cases where prefix handles won't be readily\navailable.  Consider what happens when you try to document a C++\nfunction:\n\n  extern void swap(int*, int*);\n  =NAME A\n  =RETURN A\n\nHow do you reference the 'extern' in that function definition?\n\nNow let's say that the C++ programmer decides that he wants this\nfunction to return a success flag:\n\n  extern int swap(int*, int*);\n  =NAME A\n  =RETURN A\n\nNote that he had to change 'void' to 'int' in two places: once in the\ncode, and once in the documentation.  This, combined with the\ndistinctly unintuitive prefixes being used in the ambient references,\ncan lead to a real mess.\n\nIn cases such as these, it might be best to have Pod punt to an\n'assistant parser' that returns the equivalent of a list of '=alias'\ntags.  I see this as being a case of \"All's fair if you predeclare\",\nand I was inspired by XML's Processor Instructions (conceptually) and\nnamespaces (syntactically).  Using this, the above might be handled\nas:\n\n  =parser C++ uri\n\n  ...\n\n  =text swap :parsed\n  extern void swap(int*, int*);\n  =stop text\n  =for pod :A\n  =NAME A\n  =RETURN A\n\nThe '=parser' line tells Pod that some later ambient text sections\nwill be parsed using a C++ helper utility.  It's assumed that Pod will\nsearch for said helper utility, and will complain if it can't find it.\n\nI'm assuming that the helper utility would return the equivalent of:\n\n  =alias name swap\n  =alias return void\n\nwhen given the ambient text section in question.  I'm also figuring\nthat these parser-generated aliases would take precedence over\nprefix-based referencing, but that explicit '=alias' tags would take\nprecedence over them.\n\n--\n\nOne ramification of Larry's earlier suggestion that Perl not handle\nPod sections exactly the same way that Pod does is that it's possible\nfor certain sections of Perl code to not register as ambient text in a\nPod Parser:\n\n  say qq:to(END)\n  =begin pod\n  oops\n  =end pod\n  END\n  =for pod\n  A<=begin>\n\nTo a Perl Parser, the code is as follows:\n\n  say qq:to(END)\n  =begin pod\n  oops\n  =end pod\n  END\n\nTo the Pod Parser, the ambient text is this:\n\n  say qq:to(END)\n  END\n\nThis wasn't a big deal when Pod was completely ignoring the ambient\ntext.  But once it starts referencing ambient text, you're best off\nkeeping Perl code and Pod ambient text in sync with each other.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
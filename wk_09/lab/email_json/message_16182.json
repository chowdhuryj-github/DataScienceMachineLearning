{"category": "ham", "to_address": "Nishi <nishiprafull@gmail.com>", "from_address": "yitzle <yitzle@users.sourceforge.net>", "subject": "Re: basename equivalent?", "body": "> >   my ($name) = $path =~ m|([^/]+)$|;\nShouldn't that be a  \"=~ s|([^/]+)$|;\" not m?\n\n\nOn 4/26/07, Nishi  wrote:\n> Rob:\n>\n>\n> On 4/25/07, Rob Dixon  wrote:\n> >\n> > Nishi wrote:\n> > >\n> > > What is the equivalent of basename? Ie if I dont want to use basename\n> > > package to get the filename off a path, what reg expr can i use in perl?\n> > >\n> > > Would this work --\n> > > my $fileName=$path =~ /.*\\/(.+)$/;\n> >\n> > Why don't you try it?!\n> >\n> > It wouldn't work because $fileName would end up with either a true or a\n> > false value depending on whether the regex matched. To get the captured\n> > string put the regex in list context:\n> >\n> >   my ($fileName) = $path =~ /.*\\/(.+)$/;\n> >\n> > But it would still fail if there was no slash in the $path string. You\n> > may want to use the slightly simpler\n> >\n> >   my ($name) = $path =~ m|([^/]+)$|;\n>\n>\n> I tried it, but somehow doesnt work for me, printing $name returns me the\n> entire string such as C:\\temp\\abc\\abc.txt and not abc.txt.\n> Am I missing something?\n>\n> which just grabs all the characters at the end of the string that aren't\n> > slashes, and works whether or not there is a path as well as a file name\n> > in the string.\n> >\n> > Cheers,\n> >\n> > Rob\n> >\n> >\n> >\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "Volker.Lendecke@SerNet.DE, samba-technical@samba.org", "from_address": "tridge@samba.org", "subject": "Re: ctdb status", "body": "Volker,\n\n > If we are leaking memory, then I suspect the real problem is a missing\n > talloc_free() somewhere else. I'll have a look this morning and see if\n > I can spot it.\n\nI've committed a fix for this.\n\nWhat was happening was this:\n\n  - in ctdb_recv_pkt() we were freeing the packet after\n    processing. That is the right thing to do in nearly every case, as\n    it ensures we don't leak packets. \n\n  - some of the packet processing routines (in particular\n    ctdb_request_dmaster()) needed to keep the packet around for a\n    while, so they were stealing the packet into their own hierarchy\n\n  - in one code path, the packet processing routine would steal the\n    packet into its own hierarchy, then free that hierarchy. That\n    actually makes sense on that code path, but it meant we had a\n    double free when ctdb_recv_pkt() also freed the packet\n\nThe solution was this:\n\n - in ctdb_recv_pkt() create a temporary local context, and put the\n   packet under that context\n\n - free this temporary context at the end of ctdb_recv_pkt()\n\n - if the packet processing function frees, steals or does anything\n   else with the packet, then that's now fine, as it just means that\n   when we free the temporary context that the packet is no longer a\n   child of that context. If the packet processing routine doesn't\n   move or free the packet then freeing the temporary context frees\n   the packet\n\nThis solution applies to all 3 of our packet recv routines (the 3\noperation switch routines).\n\nCheers, Tridge\n\n"}
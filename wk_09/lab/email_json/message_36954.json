{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 356: added function to send a raw tcp ack packet in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 356\nrevision-id: tridge@samba.org-20070527033936-fhaceqmyqu4hrr6r\nparent: tridge@samba.org-20070526234325-u41a50wc6bnwahl1\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sun 2007-05-27 13:39:36 +1000\nmessage:\n  added function to send a raw tcp ack packet\nmodified:\n  takeover/system.c              system.c-20070525071636-a5n1ihghjtppy08r-3\n=== modified file 'takeover/system.c'\n--- a/takeover/system.c\t2007-05-26 04:01:08 +0000\n+++ b/takeover/system.c\t2007-05-27 03:39:36 +0000\n@@ -28,6 +28,7 @@\n #include \n \n \n+\n /*\n   send gratuitous arp reply after we have taken over an ip address\n \n@@ -44,7 +45,6 @@\n \tunsigned char buffer[64]; /*minimum eth frame size */\n \tchar *ptr;\n \n-\n \t/* for now, we only handle AF_INET addresses */\n \tif (saddr->sin_family != AF_INET) {\n \t\tDEBUG(0,(__location__ \" not an ipv4 address\\n\"));\n@@ -53,7 +53,7 @@\n \n \ts = socket(AF_INET, SOCK_PACKET, htons(ETHERTYPE_ARP));\n \tif (s == -1){\n-\t\tDEBUG(0,(__location__ \"failed to open raw socket\\n\"));\n+\t\tDEBUG(0,(__location__ \" failed to open raw socket\\n\"));\n \t\treturn -1;\n \t}\n \n@@ -128,6 +128,87 @@\n }\n \n /*\n+  simple IP checksum - assumes data is multiple of 2 bytes long\n+ */\n+static uint16_t ip_checksum(uint16_t *data, size_t n)\n+{\n+\tuint16_t sum=0;\n+\twhile (n--) {\n+\t\tsum += ntohs(*data);\n+\t\tdata++;\n+\t}\n+\tif (sum == 0) {\n+\t\treturn 0xFFFF;\n+\t}\n+\treturn htons(sum);\n+}\n+\n+/*\n+  send tcp ack packet from the specified IP/port to the specified\n+  destination IP/port. \n+\n+  This is used to trigger the receiving host into sending its own ACK,\n+  which should trigger early detection of TCP reset by the client\n+  after IP takeover\n+ */\n+int ctdb_sys_send_ack(const struct sockaddr_in *dest, \n+\t\t      const struct sockaddr_in *src)\n+{\n+\tint s, ret;\n+\tuint32_t one = 1;\n+\tstruct {\n+\t\tstruct iphdr ip;\n+\t\tstruct tcphdr tcp;\n+\t} pkt;\n+\n+\t/* for now, we only handle AF_INET addresses */\n+\tif (src->sin_family != AF_INET || dest->sin_family != AF_INET) {\n+\t\tDEBUG(0,(__location__ \" not an ipv4 address\\n\"));\n+\t\treturn -1;\n+\t}\n+\n+\ts = socket(AF_INET, SOCK_RAW, htons(IPPROTO_RAW));\n+\tif (s == -1) {\n+\t\tDEBUG(0,(__location__ \" failed to open raw socket (%s)\\n\",\n+\t\t\t strerror(errno)));\n+\t\treturn -1;\n+\t}\n+\n+\tret = setsockopt(s, SOL_IP, IP_HDRINCL, &one, sizeof(one));\n+\tif (ret != 0) {\n+\t\tDEBUG(0,(__location__ \" failed to setup IP headers (%s)\\n\",\n+\t\t\t strerror(errno)));\n+\t\tclose(s);\n+\t\treturn -1;\n+\t}\n+\n+\tZERO_STRUCT(pkt);\n+\tpkt.ip.version  = 4;\n+\tpkt.ip.ihl      = sizeof(pkt.ip)/4;\n+\tpkt.ip.tot_len  = sizeof(pkt);\n+\tpkt.ip.ttl      = 255;\n+\tpkt.ip.protocol = IPPROTO_TCP;\n+\tpkt.ip.saddr    = src->sin_addr.s_addr;\n+\tpkt.ip.daddr    = dest->sin_addr.s_addr;\n+\tpkt.ip.check    = ip_checksum((uint16_t *)&pkt.ip, sizeof(pkt.ip)/2);\n+\n+\tpkt.tcp.source   = src->sin_port;\n+\tpkt.tcp.dest     = dest->sin_port;\n+\tpkt.tcp.ack      = 1;\n+\tpkt.tcp.check    = ip_checksum((uint16_t *)&pkt.tcp, sizeof(pkt.tcp)/2);\n+\n+\tret = sendto(3, &pkt, sizeof(pkt), 0, dest, sizeof(*dest));\n+\tif (ret != 0) {\n+\t\tDEBUG(0,(__location__ \" failed sendto (%s)\\n\", strerror(errno)));\n+\t}\n+\tclose(s);\n+\n+\treturn ret;\n+}\n+\n+\n+\n+/*\n   takeover an IP on an interface\n  */\n int ctdb_sys_take_ip(const char *ip, const char *interface)\n\n"}
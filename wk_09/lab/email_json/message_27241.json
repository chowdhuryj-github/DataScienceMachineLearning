{"category": "ham", "to_address": "\"Joshua Isom\" <jrisom@gmail.com>, perl6-internals@perl.org,\n   chromatic <chromatic@wgz.org>", "from_address": "\"jerry gay\" <jerry.gay@gmail.com>", "subject": "Re: [svn:parrot] r18381 - trunk/include/parrot", "body": "On 5/10/07, Nicholas Clark  wrote:\n> On Thu, May 10, 2007 at 03:33:41AM -0500, Joshua Isom wrote:\n> >\n> > On May 9, 2007, at 4:01 PM, Nicholas Clark wrote:\n>\n> > >So, !s->strlen does scan as quickly and easily.\n> > >\n> >\n> > To some, but it isn't as easy to just literally read.  \"Not s's strlen\"\n> > is a lot different than \"STRING_IS_EMTPY\".  Since the code will be read\n> > often, and often by people not familiar with parrot's internals, it\n> > makes sense to make it easily readable.  It takes me a second to read\n> > !s->strlen, but half a second to read STRING_IS_EMTPY.\n>\n> Whilst I agree with the .5s vs 1s, I'm still not convinced that I agree\n> [and we may have to agree to disagree]\n>\n> It comes down to the level of understanding of the internals. If every\n> construction is hidden behind macros that explain its function, then\n> I think it will help the beginners (as you say) and the knowledgeable\n> (who know what STRING_IS_EMPTY() expands to).\n>\n> But when I read STRING_IS_EMPTY() I stop and wonder \"right, how?\" and\n> stop to look up what it expands to. Which one does need to do, if one\n> is chasing down a bug. (Because with a bug, things *aren't* working as\n> at least one of the designer or implementor intended, which means\n> assumptions need to be checked. Maybe I'm odd)\n>\nsince i wrote this code, i might as well come clean. i don't have a\ngreat understanding of the internals yet--at least, my c is still a\nbit rusty. while working on some code, i came across\nCstrlen> and a bunch of C. i thought that since\nwe have a PMC_IS_NULL() macro, we should have something similar for\nstrings.\n\nusing vim's tags support with the tags file generated by C\ni looked up PMC_IS_NULL and found that it's not simply C,\nwhich you might expect (however i still make few assumptions in c\ncode, since my c is so rusty.) rather than figuring out why\n\n  #if PARROT_CATCH_NULL\n  PARROT_API extern PMC * PMCNULL;   /* Holds single Null PMC */\n  #  define PMC_IS_NULL(p)  ((p) == PMCNULL || (p) == NULL)\n  #else\n  #  define PMCNULL         ((PMC *)NULL)\n  #  define PMC_IS_NULL(p)  ((p) == PMCNULL)\n  #endif /* PARROT_CATCH_NULL */\n\nis the way it is, i decided to create STRING_IS_NULL and\nSTRING_IS_EMPTY with the thought that maybe there's some room for\nmagic in these new macros, like the one above. i figured somebody else\ncould refine them, or that i'd take a look at it later when i had a\nbetter understanding of the above. however, i didn't comment the code,\nso shame on me.\n\nso, i was kinda leaving room for us to add a STRING *STRINGNULL or\n*STRINGEMPTY or something, if we saw fit. the extend/embed design is\nstill incomplete, so i consider this an open item.\n\n> > >s == NULL is also more tersely written as !s, which, I feel, is also\n> > >clearer\n> > >to regular C programmers.\n> >\n> > Eh, if we have one, may as well have the other, although this one seems\n> > simple enough.\n>\n> STRING_IS_NULL() might not mean !s\n> !s can only mean !s\n>\n>\n> That's why I don't like it.\n>\ni agree, !s is much nicer on the eyes than s == NULL, and i would have\nconverted it to that if i thought it was a good idea. however, once i\ncame across the definition of PMC_IS_NULL, i coded the macro because i\nwasn't sure !s was sufficient. i figured that if there's room to\ncorrect the code, it can be done in one place, rather than replacing\nthe many s == NULL and !s and who knows what else spread throughout\nthe code.\n\ni'll happily accept ideas (or patches) on something better than what i coded.\n~jerry\n\n"}
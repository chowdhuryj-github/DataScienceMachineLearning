{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jpeach@samba.org", "subject": "svn commit: samba r22417 - in branches/SAMBA_3_0/source: include\n\tlibsmb nmbd nsswitch smbd", "body": "Author: jpeach\nDate: 2007-04-20 18:34:33 +0000 (Fri, 20 Apr 2007)\nNew Revision: 22417\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22417\n\nLog:\nRefactor the various daemon run-mode options to make the semantics\nof the various flags explicit.\n\nModified:\n   branches/SAMBA_3_0/source/include/popt_common.h\n   branches/SAMBA_3_0/source/libsmb/namequery.c\n   branches/SAMBA_3_0/source/nmbd/nmbd.c\n   branches/SAMBA_3_0/source/nmbd/nmbd_lmhosts.c\n   branches/SAMBA_3_0/source/nsswitch/winbindd.c\n   branches/SAMBA_3_0/source/smbd/server.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/include/popt_common.h\n===================================================================\n--- branches/SAMBA_3_0/source/include/popt_common.h\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/include/popt_common.h\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -50,6 +50,17 @@\n \tint signing_state;\n };\n \n+enum smb_server_mode {\n+\t/* Daemonize and manage our own sockets */\n+\tSERVER_MODE_DAEMON,\n+\t/* Don't daemonize or manage sockets */\n+\tSERVER_MODE_INETD,\n+\t/* Don't daemonize, but do manage sockets */\n+\tSERVER_MODE_FOREGROUND,\n+\t/* Run in the foreground, log to stdout, don't fork children */\n+\tSERVER_MODE_INTERACTIVE\n+};\n+\n extern struct user_auth_info cmdline_auth_info;\n \n #endif /* _POPT_COMMON_H */\n\nModified: branches/SAMBA_3_0/source/libsmb/namequery.c\n===================================================================\n--- branches/SAMBA_3_0/source/libsmb/namequery.c\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/libsmb/namequery.c\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -651,7 +651,7 @@\n  Start parsing the lmhosts file.\n *********************************************************/\n \n-XFILE *startlmhosts(char *fname)\n+XFILE *startlmhosts(const char *fname)\n {\n \tXFILE *fp = x_fopen(fname,O_RDONLY, 0);\n \tif (!fp) {\n\nModified: branches/SAMBA_3_0/source/nmbd/nmbd.c\n===================================================================\n--- branches/SAMBA_3_0/source/nmbd/nmbd.c\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/nmbd/nmbd.c\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -33,15 +33,6 @@\n \n extern BOOL override_logfile;\n \n-/* are we running as a daemon ? */\n-static BOOL is_daemon;\n-\n-/* fork or run in foreground ? */\n-static BOOL Fork = True;\n-\n-/* log to standard output ? */\n-static BOOL log_stdout;\n-\n /* have we found LanMan clients yet? */\n BOOL found_lm_clients = False;\n \n@@ -578,7 +569,7 @@\n  Open the socket communication.\n  **************************************************************************** */\n \n-static BOOL open_sockets(BOOL isdaemon, int port)\n+static BOOL open_sockets(enum smb_server_mode server_mode, int port)\n {\n \t/*\n \t * The sockets opened here will be used to receive broadcast\n@@ -588,12 +579,13 @@\n \t * now deprecated.\n \t */\n \n-\tif ( isdaemon )\n+\tif ( server_mode == SERVER_MODE_INETD ) {\n+\t\tClientNMB = 0;\n+\t} else {\n \t\tClientNMB = open_socket_in(SOCK_DGRAM, port,\n \t\t\t\t\t   0, interpret_addr(lp_socket_address()),\n \t\t\t\t\t   True);\n-\telse\n-\t\tClientNMB = 0;\n+\t}\n   \n \tClientDGRAM = open_socket_in(SOCK_DGRAM, DGRAM_PORT,\n \t\t\t\t\t   3, interpret_addr(lp_socket_address()),\n@@ -622,15 +614,20 @@\n  int main(int argc, const char *argv[])\n {\n \tpstring logfile;\n-\tstatic BOOL opt_interactive;\n \tpoptContext pc;\n-\tstatic char *p_lmhosts = dyn_LMHOSTSFILE;\n-\tstatic BOOL no_process_group = False;\n+\tconst char *p_lmhosts = dyn_LMHOSTSFILE;\n+\tBOOL no_process_group = False;\n+\tBOOL log_stdout = False;\n+\tenum smb_server_mode server_mode = SERVER_MODE_DAEMON;\n+\n \tstruct poptOption long_options[] = {\n \tPOPT_AUTOHELP\n-\t{\"daemon\", 'D', POPT_ARG_VAL, &is_daemon, True, \"Become a daemon(default)\" },\n-\t{\"interactive\", 'i', POPT_ARG_VAL, &opt_interactive, True, \"Run interactive (not a daemon)\" },\n-\t{\"foreground\", 'F', POPT_ARG_VAL, &Fork, False, \"Run daemon in foreground (for daemontools & etc)\" },\n+\t{\"daemon\", 'D', POPT_ARG_VAL, &server_mode, SERVER_MODE_DAEMON,\n+\t\t\"Become a daemon(default)\" },\n+\t{\"interactive\", 'i', POPT_ARG_VAL, &server_mode,\n+\t\tSERVER_MODE_INTERACTIVE, \"Run interactive (not a daemon)\" },\n+\t{\"foreground\", 'F', POPT_ARG_VAL, &server_mode,\n+\t\tSERVER_MODE_FOREGROUND, \"Run daemon in foreground (for daemontools & etc)\" },\n \t{\"no-process-group\", 0, POPT_ARG_VAL, &no_process_group, True, \"Don't create a new process group\" },\n \t{\"log-stdout\", 'S', POPT_ARG_VAL, &log_stdout, True, \"Log to stdout\" },\n \t{\"hosts\", 'H', POPT_ARG_STRING, &p_lmhosts, 'H', \"Load a netbios hosts file\"},\n@@ -680,12 +677,11 @@\n \tBlockSignals(True, SIGUSR2);\n #endif\n \n-\tif ( opt_interactive ) {\n-\t\tFork = False;\n+\tif (server_mode == SERVER_MODE_INTERACTIVE) {\n \t\tlog_stdout = True;\n \t}\n \n-\tif ( log_stdout && Fork ) {\n+\tif (log_stdout && server_mode == SERVER_MODE_DAEMON) {\n \t\tDEBUG(0,(\"ERROR: Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\\n\"));\n \t\texit(1);\n \t}\n@@ -712,14 +708,19 @@\n \n \tset_samba_nb_type();\n \n-\tif (!is_daemon && !is_a_socket(0)) {\n-\t\tDEBUG(0,(\"standard input is not a socket, assuming -D option\\n\"));\n-\t\tis_daemon = True;\n+\tif (is_a_socket(0)) {\n+\t\tif (server_mode == SERVER_MODE_DAEMON) {\n+\t\t\tDEBUG(0,(\"standard input is a socket, \"\n+\t\t\t\t    \"assuming -F option\\n\"));\n+\t\t}\n+\t\tserver_mode = SERVER_MODE_INETD;\n \t}\n-  \n-\tif (is_daemon && !opt_interactive) {\n+\n+\tif (server_mode == SERVER_MODE_DAEMON) {\n \t\tDEBUG( 2, ( \"Becoming a daemon.\\n\" ) );\n-\t\tbecome_daemon(Fork, no_process_group);\n+\t\tbecome_daemon(True, no_process_group);\n+\t} else if (server_mode == SERVER_MODE_FOREGROUND) {\n+\t\tbecome_daemon(False, no_process_group);\n \t}\n \n #if HAVE_SETPGID\n@@ -727,7 +728,7 @@\n \t * If we're interactive we want to set our own process group for \n \t * signal management.\n \t */\n-\tif (opt_interactive && !no_process_group)\n+\tif (server_mode == SERVER_MODE_INTERACTIVE && !no_process_group)\n \t\tsetpgid( (pid_t)0, (pid_t)0 );\n #endif\n \n@@ -758,7 +759,7 @@\n \n \tDEBUG( 3, ( \"Opening sockets %d\\n\", global_nmb_port ) );\n \n-\tif ( !open_sockets( is_daemon, global_nmb_port ) ) {\n+\tif ( !open_sockets( server_mode, global_nmb_port ) ) {\n \t\tkill_async_dns_child();\n \t\treturn 1;\n \t}\n\nModified: branches/SAMBA_3_0/source/nmbd/nmbd_lmhosts.c\n===================================================================\n--- branches/SAMBA_3_0/source/nmbd/nmbd_lmhosts.c\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/nmbd/nmbd_lmhosts.c\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -29,7 +29,7 @@\n Load a lmhosts file.\n ****************************************************************************/\n \n-void load_lmhosts_file(char *fname)\n+void load_lmhosts_file(const char *fname)\n {  \n \tpstring name;\n \tint name_type;\n\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd.c\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd.c\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -30,7 +30,6 @@\n #define DBGC_CLASS DBGC_WINBIND\n \n BOOL opt_nocache = False;\n-static BOOL interactive = False;\n \n extern BOOL override_logfile;\n \n@@ -911,15 +910,17 @@\n int main(int argc, char **argv, char **envp)\n {\n \tpstring logfile;\n-\tstatic BOOL Fork = True;\n-\tstatic BOOL log_stdout = False;\n-\tstatic BOOL no_process_group = False;\n+\tBOOL log_stdout = False;\n+\tBOOL no_process_group = False;\n+\n+\tenum smb_server_mode server_mode = SERVER_MODE_DAEMON;\n+\n \tstruct poptOption long_options[] = {\n \t\tPOPT_AUTOHELP\n \t\t{ \"stdout\", 'S', POPT_ARG_VAL, &log_stdout, True, \"Log to stdout\" },\n-\t\t{ \"foreground\", 'F', POPT_ARG_VAL, &Fork, False, \"Daemon in foreground mode\" },\n+\t\t{ \"foreground\", 'F', POPT_ARG_VAL, &server_mode, SERVER_MODE_FOREGROUND, \"Daemon in foreground mode\" },\n \t\t{ \"no-process-group\", 0, POPT_ARG_VAL, &no_process_group, True, \"Don't create a new process group\" },\n-\t\t{ \"interactive\", 'i', POPT_ARG_NONE, NULL, 'i', \"Interactive mode\" },\n+\t\t{ \"interactive\", 'i', POPT_ARG_VAL, &server_mode, SERVER_MODE_INTERACTIVE, \"Interactive mode\" },\n \t\t{ \"no-caching\", 'n', POPT_ARG_VAL, &opt_nocache, True, \"Disable caching\" },\n \t\tPOPT_COMMON_SAMBA\n \t\tPOPT_TABLEEND\n@@ -957,20 +958,17 @@\n \tpc = poptGetContext(\"winbindd\", argc, (const char **)argv, long_options,\n \t\t\t\t\t\tPOPT_CONTEXT_KEEP_FIRST);\n \n-\twhile ((opt = poptGetNextOpt(pc)) != -1) {\n-\t\tswitch (opt) {\n-\t\t\t/* Don't become a daemon */\n-\t\tcase 'i':\n-\t\t\tinteractive = True;\n-\t\t\tlog_stdout = True;\n-\t\t\tFork = False;\n-\t\t\tbreak;\n+\twhile ((opt = poptGetNextOpt(pc)) != -1) {}\n+\n+\tif (server_mode == SERVER_MODE_INTERACTIVE) {\n+\t\tlog_stdout = True;\n+\t\tif (DEBUGLEVEL >= 9) {\n+\t\t\ttalloc_enable_leak_report();\n \t\t}\n \t}\n \n-\n-\tif (log_stdout && Fork) {\n-\t\tprintf(\"Can't log to stdout (-S) unless daemon is in foreground +(-F) or interactive (-i)\\n\");\n+\tif (log_stdout && server_mode == SERVER_MODE_DAEMON) {\n+\t\tprintf(\"Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\\n\");\n \t\tpoptPrintUsage(pc, stderr, 0);\n \t\texit(1);\n \t}\n@@ -1041,8 +1039,12 @@\n \tCatchSignal(SIGUSR2, sigusr2_handler);         /* Debugging sigs */\n \tCatchSignal(SIGHUP, sighup_handler);\n \n-\tif (!interactive)\n-\t\tbecome_daemon(Fork, no_process_group);\n+\tif (server_mode == SERVER_MODE_DAEMON) {\n+\t\tDEBUG( 3, ( \"Becoming a daemon.\\n\" ) );\n+\t\tbecome_daemon(True, no_process_group);\n+\t} else if (server_mode == SERVER_MODE_FOREGROUND) {\n+\t\tbecome_daemon(False, no_process_group);\n+\t}\n \n \tpidfile_create(\"winbindd\");\n \n@@ -1067,8 +1069,9 @@\n \t * If we're interactive we want to set our own process group for\n \t * signal management.\n \t */\n-\tif (interactive && !no_process_group)\n+\tif (server_mode == SERVER_MODE_INTERACTIVE && !no_process_group) {\n \t\tsetpgid( (pid_t)0, (pid_t)0);\n+\t}\n #endif\n \n \tTimeInit();\n\nModified: branches/SAMBA_3_0/source/smbd/server.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/server.c\t2007-04-20 18:12:07 UTC (rev 22416)\n+++ branches/SAMBA_3_0/source/smbd/server.c\t2007-04-20 18:34:33 UTC (rev 22417)\n@@ -300,7 +300,7 @@\n  Open the socket communication.\n ****************************************************************************/\n \n-static BOOL open_sockets_smbd(BOOL is_daemon, BOOL interactive, const char *smb_ports)\n+static BOOL open_sockets_smbd(enum smb_server_mode server_mode, const char *smb_ports)\n {\n \tint num_interfaces = iface_count();\n \tint num_sockets = 0;\n@@ -311,11 +311,10 @@\n \tint i;\n \tchar *ports;\n \n-\tif (!is_daemon) {\n+\tif (server_mode == SERVER_MODE_INETD) {\n \t\treturn open_sockets_inetd();\n \t}\n \n-\t\t\n #ifdef HAVE_ATEXIT\n \t{\n \t\tstatic int atexit_set;\n@@ -531,8 +530,13 @@\n \t\t\t/* Ensure child is set to blocking mode */\n \t\t\tset_blocking(smbd_server_fd(),True);\n \n-\t\t\tif (smbd_server_fd() != -1 && interactive)\n+\t\t\t/* In interactive mode, return with a connected socket.\n+\t\t\t * Foreground and daemon modes should fork worker\n+\t\t\t * processes.\n+\t\t\t */\n+\t\t\tif (server_mode == SERVER_MODE_INTERACTIVE) {\n \t\t\t\treturn True;\n+\t\t\t}\n \t\t\t\n \t\t\tif (allowable_number_of_smbd_processes() &&\n \t\t\t    smbd_server_fd() != -1 &&\n@@ -857,22 +861,25 @@\n  int main(int argc,const char *argv[])\n {\n \t/* shall I run as a daemon */\n-\tstatic BOOL is_daemon = False;\n-\tstatic BOOL interactive = False;\n-\tstatic BOOL Fork = True;\n-\tstatic BOOL no_process_group = False;\n-\tstatic BOOL log_stdout = False;\n-\tstatic char *ports = NULL;\n-\tstatic char *profile_level = NULL;\n+\tBOOL no_process_group = False;\n+\tBOOL log_stdout = False;\n+\tconst char *ports = NULL;\n+\tconst char *profile_level = NULL;\n \tint opt;\n \tpoptContext pc;\n \n+\tenum smb_server_mode server_mode = SERVER_MODE_DAEMON;\n+\n \tstruct poptOption long_options[] = {\n \tPOPT_AUTOHELP\n-\t{\"daemon\", 'D', POPT_ARG_VAL, &is_daemon, True, \"Become a daemon (default)\" },\n-\t{\"interactive\", 'i', POPT_ARG_VAL, &interactive, True, \"Run interactive (not a daemon)\"},\n-\t{\"foreground\", 'F', POPT_ARG_VAL, &Fork, False, \"Run daemon in foreground (for daemontools, etc.)\" },\n-\t{\"no-process-group\", '\\0', POPT_ARG_VAL, &no_process_group, True, \"Don't create a new process group\" },\n+\t{\"daemon\", 'D', POPT_ARG_VAL, &server_mode, SERVER_MODE_DAEMON,\n+\t\t\"Become a daemon (default)\" },\n+\t{\"interactive\", 'i', POPT_ARG_VAL, &server_mode, SERVER_MODE_INTERACTIVE,\n+\t\t\"Run interactive (not a daemon)\"},\n+\t{\"foreground\", 'F', POPT_ARG_VAL, &server_mode, SERVER_MODE_FOREGROUND,\n+\t\t\"Run daemon in foreground (for daemontools, etc.)\" },\n+\t{\"no-process-group\", '\\0', POPT_ARG_VAL, &no_process_group, True,\n+\t\t\"Don't create a new process group\" },\n \t{\"log-stdout\", 'S', POPT_ARG_VAL, &log_stdout, True, \"Log to stdout\" },\n \t{\"build-options\", 'b', POPT_ARG_NONE, NULL, 'b', \"Print build options\" },\n \t{\"port\", 'p', POPT_ARG_STRING, &ports, 0, \"Listen on the specified ports\"},\n@@ -912,16 +919,14 @@\n \n \tset_remote_machine_name(\"smbd\", False);\n \n-\tif (interactive) {\n-\t\tFork = False;\n+\tif (server_mode == SERVER_MODE_INTERACTIVE) {\n \t\tlog_stdout = True;\n+\t\tif (DEBUGLEVEL >= 9) {\n+\t\t\ttalloc_enable_leak_report();\n+\t\t}\n \t}\n \n-\tif (interactive && (DEBUGLEVEL >= 9)) {\n-\t\ttalloc_enable_leak_report();\n-\t}\n-\n-\tif (log_stdout && Fork) {\n+\tif (log_stdout && server_mode == SERVER_MODE_DAEMON) {\n \t\tDEBUG(0,(\"ERROR: Can't log to stdout (-S) unless daemon is in foreground (-F) or interactive (-i)\\n\"));\n \t\texit(1);\n \t}\n@@ -1011,21 +1016,19 @@\n \n \tDEBUG(3,( \"loaded services\\n\"));\n \n-\tif (!is_daemon && !is_a_socket(0)) {\n-\t\tif (!interactive)\n-\t\t\tDEBUG(0,(\"standard input is not a socket, assuming -D option\\n\"));\n-\n-\t\t/*\n-\t\t * Setting is_daemon here prevents us from eventually calling\n-\t\t * the open_sockets_inetd()\n-\t\t */\n-\n-\t\tis_daemon = True;\n+\tif (is_a_socket(0)) {\n+\t\tif (server_mode == SERVER_MODE_DAEMON) {\n+\t\t\tDEBUG(0,(\"standard input is a socket, \"\n+\t\t\t\t    \"assuming -F option\\n\"));\n+\t\t}\n+\t\tserver_mode = SERVER_MODE_INETD;\n \t}\n \n-\tif (is_daemon && !interactive) {\n+\tif (server_mode == SERVER_MODE_DAEMON) {\n \t\tDEBUG( 3, ( \"Becoming a daemon.\\n\" ) );\n-\t\tbecome_daemon(Fork, no_process_group);\n+\t\tbecome_daemon(True, no_process_group);\n+\t} else if (server_mode == SERVER_MODE_FOREGROUND) {\n+\t\tbecome_daemon(False, no_process_group);\n \t}\n \n #if HAVE_SETPGID\n@@ -1033,15 +1036,18 @@\n \t * If we're interactive we want to set our own process group for\n \t * signal management.\n \t */\n-\tif (interactive && !no_process_group)\n+\tif (server_mode == SERVER_MODE_INTERACTIVE && !no_process_group) {\n \t\tsetpgid( (pid_t)0, (pid_t)0);\n+\t}\n #endif\n \n \tif (!directory_exist(lp_lockdir(), NULL))\n \t\tmkdir(lp_lockdir(), 0755);\n \n-\tif (is_daemon)\n+\tif (server_mode != SERVER_MODE_INETD &&\n+\t    server_mode != SERVER_MODE_INTERACTIVE) {\n \t\tpidfile_create(\"smbd\");\n+\t}\n \n \t/* Setup all the TDB's - including CLEAR_IF_FIRST tdb's. */\n \tif (!message_init())\n@@ -1099,9 +1105,10 @@\n \t   running as a daemon -- bad things will happen if\n \t   smbd is launched via inetd and we fork a copy of \n \t   ourselves here */\n-\n-\tif ( is_daemon && !interactive )\n+\tif (server_mode != SERVER_MODE_INETD &&\n+\t    server_mode != SERVER_MODE_INTERACTIVE) {\n \t\tstart_background_queue(); \n+\t}\n \n \t/* Always attempt to initialize DMAPI. We will only use it later if\n \t * lp_dmapi_support is set on the share, but we need a single global\n@@ -1109,8 +1116,9 @@\n \t */\n \tdmapi_init_session();\n \n-\tif (!open_sockets_smbd(is_daemon, interactive, ports))\n+\tif (!open_sockets_smbd(server_mode, ports)) {\n \t\texit(1);\n+\t}\n \n \t/*\n \t * everything after this point is run after the fork()\n@@ -1123,7 +1131,8 @@\n \t/* Possibly reload the services file. Only worth doing in\n \t * daemon mode. In inetd mode, we know we only just loaded this.\n \t */\n-\tif (is_daemon) {\n+\tif (server_mode != SERVER_MODE_INETD &&\n+\t    server_mode != SERVER_MODE_INTERACTIVE) {\n \t\treload_services(True);\n \t}\n \n\n"}
{"category": "ham", "to_address": "Perl Beginners <beginners@perl.org>", "from_address": "\"John W. Krahn\" <krahnj@telus.net>", "subject": "Re: Redirecting STDOUT & STDERR", "body": "Karyn Williams wrote:\n> I have this script I have been working on where I need to redirect STDOUT\n> and STDERR to files at the beginning of the script and then back to default\n> (terminal) at the end of the script. I found an example on-line and used it\n> and it works, however it generates a warning when running my script.\n\nTry using the example that comes with Perl:\n\nperldoc -f open\n\n> I would prefer to make that warning go away. This is the output of the script:\n> \n> alum# ./match.pl\n> Name \"main::OLDERR\" used only once: possible typo at ./match.pl line 38.\n> Name \"main::OLDOUT\" used only once: possible typo at ./match.pl line 37.\n> Records processed: 2\n> Kicked as dups: 1\n> Kicked as exceptions: 0\n> Accounts created: 1\n> \n> This is the script:\n> \n> #!/usr/bin/perl\n> \n> # match.pl expanded\n> # Checks the current csv against the passwd file to detect and prevent\n> creating duplicate accounts\n> \n> use strict;\n> use warnings;\n> \n> my $dir = \"/usr/local/accounts\";\n> \n> my $csv = \"isirin.csv\";\n> my $expin = \"exceptions.csv\";\n> my $pwfile = \"/etc/passwd\";\n> my $expout = \"exceptions.log\";\n> my $clog = \"account_change.log\";\n> my $as400 = \"as400.txt\";\n> my $admiss = \"admissions.txt\";\n> my $err = \"error.log\";\n> \n> my $description = \"SIR Fall 2007\";\n> \n> my $date = localtime();\n> my ($sec,$min,$hour,$mday,$mon,$year) = (localtime)[0,1,2,3,4,5];\n> $mday++;\n\nYou are incrementing the day of the month so if today is 31 May your string\nwill display the 32nd day of May!\n\n\n> $mon++;\n> $year += 1900;\n> my $today = sprintf(\"%04d%02d%02d-%02d%02d%02d\", $year, $mon, $mday, $hour,\n> $min, $sec);\n> \n> # Read in csv file from Accounting and check for existing accounts.\n> \n> open (IN, \"$dir/$csv\") or die \"$dir/$csv does not exist. This file must be\n> available to run this script: $!\";\n> open (EX, \"$dir/$expin\") or die \"Can't open EX $expin : $!\";\n> open (PW, \"$pwfile\") or die \"Can't open PW $pwfile : $!\";\n> open (EXCEP, \">>$dir/$expout\") or die \"Can't open EXCEP: $!\";\n> open (OUT, \">>$dir/$clog\") or die \"Can't open OUT: $!\";\n> open (AOUT, \">$dir/$as400\") or die \"Can't open AOUT: $!\";\n> open (OLDOUT, \">&STDOUT\");\n> open (OLDERR, \">&STDERR\");\n> open (STDOUT, \">$dir/$admiss\") or die \"Can't open STDOUT: $!\";\n> open (STDERR, \">>$dir/$err\") or die \"Can't open STDERR: $!\";\n\nYou should use the three argument form of open and you should *ALWAYS* verify\nthat open succeeded:\n\nopen IN,     '<',  \"$dir/$csv\"    or die \"$dir/$csv does not exist. This file\nmust be available to run this script: $!\";\nopen EX,     '<',  \"$dir/$expin\"  or die \"Can't open EX $expin : $!\";\nopen PW,     '<',  $pwfile        or die \"Can't open PW $pwfile : $!\";\nopen EXCEP,  '>>', \"$dir/$expout\" or die \"Can't open EXCEP: $!\";\nopen OUT,    '>>', \"$dir/$clog\"   or die \"Can't open OUT: $!\";\nopen AOUT,   '>',  \"$dir/$as400\"  or die \"Can't open AOUT: $!\";\nopen OLDOUT, '>&', \\*STDOUT       or die \"Can't dup STDOUT: $!\";\nopen OLDERR, '>&', \\*STDERR       or die \"Can't dup STDERR: $!\";\nopen STDOUT, '>',  \"$dir/$admiss\" or die \"Can't open STDOUT: $!\";\nopen STDERR, '>>', \"$dir/$err\"    or die \"Can't open STDERR: $!\";\n\n\n> my $pwf;\n> my $exp;\n> my $gecos;\n> my $login;\n> my $rcount = 0;\n> my $acount = 0;\n> my $ecount = 0;\n> my $lcount = 0 ;\n> \n> my @line = ;\n\nWhy are you reading the entire file into memory if you don't really have to?\n\n> printf STDOUT (\"$date\\n\");\n\nThat should be print instead of printf:\n\nprint STDOUT \"$date\\n\";\n\nprintf() requires that the first string is a format string and will\ninterpolate certain characters.\n\n\n> # Slurp the /etc/passwd file into one string and then search for matching\n> Student IDs in that \n> # string. Use this later for checking unused loginnames also.\n> \n> while () {\n>         $pwf .= $_;\n>         }\n\nmy $pwf = do { local $/;  };\n\n\n> while () {\n>         $exp .= $_;\n>         }\n\nmy $exp = do { local $/;  };\n\n\n> # Create GECOS and login info and then create account using pw\n> \n> foreach my $line (@line) {\n\nYou probably should use a while loop instead of a foreach loop.\n\n>         next if $line =~ /^nameid/;\n>         next if $line =~ /^$/;\n>         next if $line =~ /^\\s+$/;\n>         # file format is nameid,first,init,last\n>         #print $line;\n>         chomp $line;\n>         $rcount++;\n>         my ($sid,$name) = split(/,/, $line,2);\n>         if ($pwf =~ /\\b$sid\\b/) {\n\nYou should probably store the $sid values in a hash.\n\n>                 printf EXCEP (\"$date, $name, $sid, possible dup\n\nYou should use print instead of printf.\n\n> account\\n\"); $acount++;\n>                 } elsif ($exp =~ /\\b$sid\\b/) {\n\nYou should probably store the $sid values in a hash.\n\n>                 printf EXCEP (\"$date, $name, $sid, listed in\n\nYou should use print instead of printf.\n\n> exceptions.csv\\n\"); $ecount++;\n>                 } else {\n> \n>         my ($first, $initial, $last) = split(/,/, $name, 3);\n>         # Create gecos info\n>         $last =~ s/[\",]//g;\n>         $first =~ s/[\",]//g;\n>         $initial =~ s/[\",]//g;\n\n          tr/\",//d for $first, $initial, $last;\n\n\n>         if ($initial) { \n>                 $gecos = \"\\\"$first $initial $last, $sid, $description\\\"\";\n>                 } else {\n>                 $gecos = \"\\\"$first $last, $sid, $description\\\"\"; }\n>         #print \"GECOS IS $gecos\\n\";\n>         # Now guess at a login\n>         my $lfirst = $first;\n>         $lfirst =~ s/[^a-zA-Z]//g;\n>         #(my $lfirst = $first) =~ s/[^a-zA-Z]//g);\n>         my @last = split(/\\s/, $last, 2);\n>         my $llast = $last[0];\n\nYou don't need the array if you are only extracting one value:\n\n         my $llast = ( split ' ', $last )[ 0 ];\n\n>         $llast =~ s/[-\\s]//g;\n>         #print \"LoginLast is $llast\\n\";\n>         if (length($lfirst) + length($llast) <= 16) {\n>                 $login = $lfirst . $llast; \n>                 } else {\n>                 my $f = substr(($lfirst),0,1);\n>                 $login = $f . $llast;\n>                 }\n>         $login = lc($login); \n>         #print \"Login is $login\\n\";\n>         #printf STDOUT (\"$first $initial $last, $sid, $login, passwd\\n\");\n>         printf STDOUT (\"$first $initial $last, $sid, $login, \");\n\nYou should use print instead of printf.\n\n>         #This next line is for testing purposes\n>         system(\"pw useradd -n $login -c $gecos -m -s /bin/ftpshell -N\");\n\nYou should verify that 'pw' executed correctly:\n\n        system( 'pw', 'useradd', '-n', $login, '-c', $gecos, '-m', '-s',\n'/bin/ftpshell', '-N' ) == 0 or die \"Cannot run 'pw' $?\";\n\n\n>         #system(\"pw useradd -n $login -c $gecos -m -s /bin/ftpshell -w\n> random\");\n>         printf OUT (\"$date Account Added, $first $initial $last, $login,\n\nYou should use print instead of printf.\n\n> $sid\\n\");\n>         printf AOUT (\"$sid, $first $initial $last, $login\\n\");\n\nYou should use print instead of printf.\n\n>         $lcount++;\n>         }\n> }\n> \n> close IN;\n> close OUT;\n> close AOUT;\n> close STDOUT;\n> close STDERR;\n> close EX;\n> close PW;\n> close EXCEP;\n> \n> rename (\"$dir/$csv\", \"$dir/$csv.$today\") or die \"Can't rename $dir/$csv : $!\";\n> \n> open(STDOUT, \">&OLDOUT\");\n> open(STDERR, \">&OLDERR\");\n\nYou should use the three argument form of open and you should *ALWAYS* verify\nthat open succeeded:\n\nopen STDOUT, '>&', \\*OLDOUT or die \"Cannot dup OLDOUT: $!\";\nopen STDERR, '>&', \\*OLDERR or die \"Cannot dup OLDERR: $!\";\n\n\n> print \"Records processed: $rcount\\n\";\n> print \"Kicked as dups: $acount\\n\";\n> print \"Kicked as exceptions: $ecount\\n\";\n> print \"Accounts created: $lcount\\n\";\n> \n> # send via e-mail output of this script.\n> \n> my $to = \"To: karyn\\@calarts.edu\";\n> my $from = \"From: accounts\\@alum.calarts.edu\";\n> my $subject = \"Subject: Test Output for SIRs\";\n> my $sendmail = \"/usr/sbin/sendmail -t\";\n> \n> my @files = (\"$dir/$as400\", \"$dir/$admiss\");\n> my @mail = ();\n> \n> foreach my $file (@files) {\n> \n> open (MAIL, \"|$sendmail\") or die \"Can't open $sendmail: $!\";\n> open (AOUT, \"<$file\") or die \"Can't open AOUT for read: $!\";\n> \n> print MAIL \"$to\\n\";    \n> print MAIL \"$from\\n\";      \n> print MAIL \"$subject\\n\";         \n> \n> @mail = ;\n>         foreach my $line (@mail) {\n>                 print MAIL $line;\n>         }\n\nYou don't need the array or loop there:\n\nprint MAIL \"$to\\n\",\n           \"$from\\n\",\n           \"$subject\\n\",\n           ;\n\n\n> close (MAIL);\n\nWhen you close a piped open you should verify that it closed correctly:\n\nperldoc -f close\n\n\n> close AOUT;\n> \n> }\n> \n> # end of script\n\n\nJohn\n-- \nPerl isn't a toolbox, but a small machine shop where you can special-order\ncertain sorts of tools at low cost and in short order.       -- Larry Wall\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
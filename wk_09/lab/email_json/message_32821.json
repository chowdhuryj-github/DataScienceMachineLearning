{"category": "ham", "to_address": "tridge@samba.org", "from_address": "Jeremy Allison <jra@samba.org>", "subject": "Re: posix locking and the brlock database", "body": "On Sat, May 19, 2007 at 07:43:53PM +1000, tridge@samba.org wrote:\n> \n> While the file is locked, a windows client tries to get the lock. It\n> will check the posix lock in brlock.c, and see that it can't get the\n> lock, so it puts in a pending lock entry in the brlock.tdb record for\n> that file.\n> \n> Then the NFS client or local unix application releases the byte range\n> lock. What triggers the retry of the pending lock? We don't get any\n> notification from the kernel, and we don't retry internally.\n\nAh, phew. You had me worried there :-). Yes we do retry internally,\njust not as often as we used to :-).\n\nLook in smbd/process.c :\n\nWhen calculating the select timeout we call blocking_locks_timeout_ms()\nwhich calculates the timeout to the next blocking lock expiry, or\nreturns a default timeout if they're all infinite timeout.\n\nThe timeout processing code in smbd then calls :\nprocess_blocking_lock_queue() which will retry for any pending\nPOSIX locks. So we do retry, it's just that we might\nhave to wait 30 seconds or so.\n\nThe old code used to return a timeout of 10s from the old\nequivalent of blocking_locks_timeout_ms() if there were any\npending locks on the queue. These days we get messages for\nsuch locks if they're blocked on a Windows lock so what we\nneed to do is mark any locks blocked on a POSIX lock rather\nthan a Windows lock and return a shorter (10s) timeout if this\nis the case. I'll fix this.\n\nThis will be much simpler when everything is eventually\nevent driven in Samba3. Getting there slowly :-) :-).\n\nJeremy.\n\n"}
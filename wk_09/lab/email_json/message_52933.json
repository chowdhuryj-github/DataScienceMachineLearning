{"category": "ham", "to_address": "jerry@samba.org, samba-technical@samba.org", "from_address": "\"Jim McDonough\" <jmcd@samba.org>", "subject": "winbindd 32/64 offset issues", "body": "Jerry,\nDespite your comments about testing with 32bit libs on 64bit platforms in\nthe winbindd_request struct in winbindd_nss.h, it seems we're out of sync,\nand the following comment may be part of the issue:\n\nnsswitch/winbindd_nss.h:40\n-------\n/* Have to deal with time_t being 4 or 8 bytes due to structure alignment.\n   On a 64bit Linux box, we have to support a constant structure size\n   between /lib/libnss_winbind.so.2 and /li64/libnss_winbind.so.2.\n   The easiest way to do this is to always use 8byte values for time_t. */\n------\n\nI can say that I've recently found this to not be true.  On multiple\nplatforms (RHEL4 at a customer site, ubuntu Edgy on my laptop right now),\nthe stabs output shows the extra_data union (containing the SMB_TIME_T for\nalignment) to start at 16544 bits offset, which is 2068 bytes..._not_ a\nmultiple of 8.  This is on 3.0.25...on 3.0.26 there is an extra enum earlier\nthat hides this problem, I think.  I tried several approaches, but there is\nsimply not a guarantee on a 32-bit platform that anything I tried is going\nto be aligned on an 8-byte boundary.\n\nThe only solution I found was the old method that hasn't been updated in the\ncode in a while...the padding member of the huge data union needs to be set\nto that 8-byte boundary, and still, since that data union isn't guaranteed\nto be on an 8-byte boundary to start, we have to really just look at the\noffset in stabs output and see if each union lines up between architectures.\n\nOr we could just start up that marshalling discussion again :-)\n\nIn any case, before I check anything in, can someone run any quick tests of\nyour various binaries on 64-bit platforms using 32-bit winbind libs?\n\n-- \n-------------------\nJim McDonough\nSamba Team\njmcd at samba dot org\n\n"}
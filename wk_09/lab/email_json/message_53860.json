{"category": "ham", "to_address": "\"Patrick R. Michaud\" <pmichaud@pobox.com>", "from_address": "Bob Rogers <rogers-perl6@rgrjr.dyndns.org>", "subject": "Re: pdd15 - How do I add a class method?", "body": "   From: \"Patrick R. Michaud\" \n   Date: Thu, 21 Jun 2007 00:27:07 -0500\n\n   On Wed, Jun 20, 2007 at 10:38:08PM -0400, Bob Rogers wrote:\n   >    From: \"Patrick R. Michaud\" \n   >\n   >    . . . If I want to define a\n   >    new method or or override an existing method on a metaclass instance\n   >    [a class], then how do I do that?\n   > \n   > AFAICS, there isn't currently a good way to do that.  (Depending, of\n   > course, on whether you think Jonathan's suggestion qualifies.  ;-)\n   > Nor does PDD15 seem to cover this; it actually says very little about\n   > metaclasses, beyond just the fact that they exist (and even then only\n   > mentions class metaclasses).\n\n   To somewhat see where I came from in this, pdd15 has a =head3 section\n   titled \"Class Methods\", where all of the methods appear to be\n   operations on classes, as opposed to instances of the class.\n\nIMHO, these are not \"Class Methods\" in the Ruby sense of being methods\non a particular Class instance, but \"Class metaclass methods\",\ni.e. methods defined for all Class instances.\n\n   There's also a line in pdd15 that reads:\n\n       =item - Classes are instances of a meta-class and have their \n       own sets of class methods and class attributes\n\n   So, I was wondering how one would create a class method.\n\nSeems like this ought to be two items:\n\n       =item - Classes are instances of a meta-class\n\n       =item - Classes have their own sets of class methods and class attributes\n\nsince they are (arguably) independent.  In any case, it seems that the\nsecond part needs more API spec (not to mention an implementation).\n\n   >    The particular instance I'm looking at is a C class for\n   >    Perl 6, where I want the get_string vtable function for the\n   >    C metaclass instance is different from get_string of \n   >    a C class object.\n   > \n   > To me, the phrases \"C metaclass instance\" and \"C class object\"\n   > sound like the same thing.  Did you mean \"C object\" in the second\n   > case?  \n\n   I did.  Apologies for the ambiguity.\n\nNo need to apologize; there may be some who can throw in the right\nnumber of \"meta's\" all the time, but I'm not one of them.  ;-}\n\n   . . .\n\n   I was wanting to know how to do something similar, except with\n   get_string instead of typeof.  In particular, the example I've\n   been thinking of is:\n\n       $P0 = get_class \"Str\"  # get the Str class\n       $P1 = new $P0          # create a Str instance\n       assign $P1, \"XYZ\"      # give it a value\n\n       $S0 = $P0              # returns \"Str\"\n       $S1 = $P1              # returns \"XYZ\"\n\n   In short, I was wondering how I would get a class to stringify\n   to its name (or possibly some mocked value), while having \n   the instances of that class continue to stringify to their values.  \n\nThank you; that's quite clear.\n\n   Getting the class instance and the object instance to stringify\ndifferently ought to be straightforward, since they are of different\nclasses (\"Class\" and \"Str\" respectively).  The problem is that you want\nto affect just the way the Class instance for Str stringifies, without\naffecting any other Class instances.  (Right?)\n\n   If so, and IIUC, Parrot doesn't have direct support for this.  Your\nbest bet for the time being might be to emulate the Ruby subclassing\ntechnique by creating a StrClass (a subclass of Class) whose only\ninstance is Str.  If you generalized this to a Perl6Class (also a\nsubclass of Class) with a class_name_string slot used by the get_string\nmethod, then you could do the same thing for other Perl 6 classes.\n\n   Since get_string is a vtable method, and since I doubt there is any\nreal call for supporting vtable method dispatch on specfic objects, I\ndon't think the Lisp technique I mentioned is appropriate.\n\n   As I mentioned above, my re-reading of S12 may make this\n   particular question moot, although it's important to note\n   that Jonathan apparently encountered something like it as\n   well.  :-)  . . .\n\nRegardless, I think you've touched on a general problem that requires a\ngeneral solution.  Since Ruby is the only language with which I have any\nacquaintance that provides both class methods and a metaobject protocol,\nand since I have only a superficial understanding of Ruby's MOP, I am\nnot the one to propose such a solution.\n\n   FWIW, I find it interesting that Common Lisp provides a rich MOP that\nallows you to make fairly substantial changes to the way objects work,\nbut doesn't support \"class methods\" as such -- you can define a method\non a particular class object, but there is no syntactic sugar, for\neither definition or invocation, so people just don't do that.  This may\nbe a conscious design decision, or it may be that the basic protocols\nevolved before language designers came to believe that class methods\nwere necessary.  Not that it makes any difference to Parrot, but I\nwonder if class methods aren't in fact a kludge that a sufficiently\npowerful MOP makes unnecessary?\n\n   Not sure if this helps, but at least it shouldn't hurt.  Much.  ;-}\n\n\t\t\t\t\t-- Bob\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23070 - in branches/SAMBA_3_0/source/rpc_client:\n\t.", "body": "Author: obnox\nDate: 2007-05-22 11:30:35 +0000 (Tue, 22 May 2007)\nNew Revision: 23070\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23070\n\nLog:\nThe lsa rpc lookup sids call has a maximum number of SIDS to be\nlooked up at one time. This limit is at 20480 for w2k3.\nOur rpccli_lsa_lookup_sids function ignores this limit, so when\nwe give the server too long a list of SIDs, then we will get\nnothing back. Since typically rpccli_lsa_lookup_sids is given\none SID  (or a small number of SIDS), this did not do harm \nup to now. But since I want to use lsa_lookup_sids in a subsequent\nmodification to winbindd_ads.c:lookup_groupmem to get rid of\na vast number of dn_lookup calls to the server, I had to make \nsure we do it correctly. \n\nI have added a function rpccli_lsa_lookup_sids_all function\nthat has the same prototype but internally splits the list\nof SIDs up into hunks of a (conservative, hard coded) 1000\nSIDs each for a first go.\n\nIf this approach is agreed upon, the new function could replace\nthe original rpccli_lsa_lookup_sids function.\n\nMichael\n\n\nModified:\n   branches/SAMBA_3_0/source/rpc_client/cli_lsarpc.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/rpc_client/cli_lsarpc.c\n===================================================================\n--- branches/SAMBA_3_0/source/rpc_client/cli_lsarpc.c\t2007-05-22 11:23:36 UTC (rev 23069)\n+++ branches/SAMBA_3_0/source/rpc_client/cli_lsarpc.c\t2007-05-22 11:30:35 UTC (rev 23070)\n@@ -127,6 +127,97 @@\n \treturn result;\n }\n \n+/* Lookup a list of sids\n+ *\n+ * internal version withOUT memory allocation.\n+ * this assumes suffciently sized arrays to store\n+ * domains, names and types */\n+\n+static NTSTATUS rpccli_lsa_lookup_sids_noalloc(struct rpc_pipe_client *cli,\n+\t\t\t\t\t       TALLOC_CTX *mem_ctx,\n+\t\t\t\t\t       POLICY_HND *pol,\n+\t\t\t\t\t       int num_sids,\n+\t\t\t\t\t       const DOM_SID *sids,\n+\t\t\t\t\t       char **domains,\n+\t\t\t\t\t       char **names,\n+\t\t\t\t\t       enum lsa_SidType *types)\n+{\n+\tprs_struct qbuf, rbuf;\n+\tLSA_Q_LOOKUP_SIDS q;\n+\tLSA_R_LOOKUP_SIDS r;\n+\tDOM_R_REF ref;\n+\tLSA_TRANS_NAME_ENUM t_names;\n+\tNTSTATUS result = NT_STATUS_OK;\n+\tint i;\n+\n+\tZERO_STRUCT(q);\n+\tZERO_STRUCT(r);\n+\n+\tinit_q_lookup_sids(mem_ctx, &q, pol, num_sids, sids, 1);\n+\n+\tZERO_STRUCT(ref);\n+\tZERO_STRUCT(t_names);\n+\n+\tr.dom_ref = &ref\n+\tr.names = &t_names;\n+\n+\tCLI_DO_RPC( cli, mem_ctx, PI_LSARPC, LSA_LOOKUPSIDS,\n+\t\t\tq, r,\n+\t\t\tqbuf, rbuf,\n+\t\t\tlsa_io_q_lookup_sids,\n+\t\t\tlsa_io_r_lookup_sids,\n+\t\t\tNT_STATUS_UNSUCCESSFUL );\n+\n+\tif (!NT_STATUS_IS_OK(r.status) &&\n+\t    !NT_STATUS_EQUAL(r.status, STATUS_SOME_UNMAPPED)) \n+\t{\n+\t\t/* An actual error occured */\n+\t\tresult = r.status;\n+\t\tgoto done;\n+\t}\n+\n+\t/* Return output parameters */\n+\n+\tif (r.mapped_count == 0) {\n+\t\tresult = NT_STATUS_NONE_MAPPED;\n+\t\tgoto done;\n+\t}\n+\n+\tfor (i = 0; i < num_sids; i++) {\n+\t\tfstring name, dom_name;\n+\t\tuint32 dom_idx = t_names.name[i].domain_idx;\n+\n+\t\t/* Translate optimised name through domain index array */\n+\n+\t\tif (dom_idx != 0xffffffff) {\n+\n+\t\t\trpcstr_pull_unistr2_fstring(\n+                                dom_name, &ref.ref_dom[dom_idx].uni_dom_name);\n+\t\t\trpcstr_pull_unistr2_fstring(\n+                                name, &t_names.uni_name[i]);\n+\n+\t\t\t(names)[i] = talloc_strdup(mem_ctx, name);\n+\t\t\t(domains)[i] = talloc_strdup(mem_ctx, dom_name);\n+\t\t\t(types)[i] = (enum lsa_SidType)t_names.name[i].sid_name_use;\n+\t\t\t\n+\t\t\tif (((names)[i] == NULL) || ((domains)[i] == NULL)) {\n+\t\t\t\tDEBUG(0, (\"cli_lsa_lookup_sids(): out of memory\\n\"));\n+\t\t\t\tresult = NT_STATUS_UNSUCCESSFUL;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t(names)[i] = NULL;\n+\t\t\t(domains)[i] = NULL;\n+\t\t\t(types)[i] = SID_NAME_UNKNOWN;\n+\t\t}\n+\t}\n+\n+ done:\n+\n+\treturn result;\n+}\n+\n /** Lookup a list of sids */\n \n NTSTATUS rpccli_lsa_lookup_sids(struct rpc_pipe_client *cli,\n@@ -238,6 +329,116 @@\n \treturn result;\n }\n \n+/* Lookup a list of sids \n+ *\n+ * do it the right way: there is a limit (of 20480 for w2k3) entries\n+ * returned by this call. when the sids list contains more entries,\n+ * empty lists are returned. This version of lsa_lookup_sids passes\n+ * the list of sids in hunks of LOOKUP_SIDS_HUNK_SIZE to the lsa call. */\n+\n+/* This constant defines the limit of how many sids to look up\n+ * in one call (maximum). the limit from the server side is\n+ * at 20480 for win2k3, but we keep it at a save 1000 for now. */\n+#define LOOKUP_SIDS_HUNK_SIZE 1000\n+\n+NTSTATUS rpccli_lsa_lookup_sids_all(struct rpc_pipe_client *cli,\n+\t\t\t\t    TALLOC_CTX *mem_ctx,\n+\t\t\t\t    POLICY_HND *pol, \n+\t\t\t\t    int num_sids,\n+\t\t\t\t    const DOM_SID *sids, \n+\t\t\t\t    char ***domains,\n+\t\t\t\t    char ***names,\n+\t\t\t\t    enum lsa_SidType **types)\n+{\n+\tNTSTATUS result = NT_STATUS_OK;\n+\tint sids_left = 0;\n+\tint sids_processed = 0;\n+\tconst DOM_SID *hunk_sids = sids;\n+\tchar **hunk_domains = NULL;\n+\tchar **hunk_names = NULL;\n+\tenum lsa_SidType *hunk_types = NULL;\n+\n+\tif (num_sids) {\n+\t\tif (!((*domains) = TALLOC_ARRAY(mem_ctx, char *, num_sids))) {\n+\t\t\tDEBUG(0, (\"rpccli_lsa_lookup_sids_all(): out of memory\\n\"));\n+\t\t\tresult = NT_STATUS_NO_MEMORY;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\tif (!((*names) = TALLOC_ARRAY(mem_ctx, char *, num_sids))) {\n+\t\t\tDEBUG(0, (\"rpccli_lsa_lookup_sids_all(): out of memory\\n\"));\n+\t\t\tresult = NT_STATUS_NO_MEMORY;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\tif (!((*types) = TALLOC_ARRAY(mem_ctx, enum lsa_SidType, num_sids))) {\n+\t\t\tDEBUG(0, (\"rpccli_lsa_lookup_sids_all(): out of memory\\n\"));\n+\t\t\tresult = NT_STATUS_NO_MEMORY;\n+\t\t\tgoto done;\n+\t\t}\n+\t} else {\n+\t\t(*domains) = NULL;\n+\t\t(*names) = NULL;\n+\t\t(*types) = NULL;\n+\t}\n+\t\n+\tsids_left = num_sids;\n+\thunk_domains = *domains;\n+\thunk_names = *names;\n+\thunk_types = *types;\n+\n+\twhile (sids_left > 0) {\n+\t\tint hunk_num_sids;\n+\t\tNTSTATUS hunk_result = NT_STATUS_OK;\n+\n+\t\thunk_num_sids = ((sids_left > LOOKUP_SIDS_HUNK_SIZE) \n+\t\t\t\t? LOOKUP_SIDS_HUNK_SIZE \n+\t\t\t\t: sids_left);\n+\n+\t\tDEBUG(10, (\"rpccli_lsa_lookup_sids_all: processing items \"\n+\t\t\t   \"%d -- %d of %d.\\n\", \n+\t\t\t   sids_processed, \n+\t\t\t   sids_processed + hunk_num_sids - 1,\n+\t\t\t   num_sids));\n+\n+\t\thunk_result = rpccli_lsa_lookup_sids_noalloc(cli, mem_ctx, \n+\t\t\t\t\t\t\t     pol,\n+\t\t\t\t\t\t\t     hunk_num_sids, \n+\t\t\t\t\t\t\t     hunk_sids,\n+\t\t\t\t\t\t\t     hunk_domains,\n+\t\t\t\t\t\t\t     hunk_names,\n+\t\t\t\t\t\t\t     hunk_types);\n+\n+\t\tif (!NT_STATUS_IS_OK(hunk_result) &&\n+\t\t    !NT_STATUS_EQUAL(hunk_result, STATUS_SOME_UNMAPPED) &&\n+\t\t    !NT_STATUS_EQUAL(hunk_result, NT_STATUS_NONE_MAPPED)) \n+\t\t{\n+\t\t\t/* An actual error occured */\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t/* adapt overall result */\n+\t\tif (( NT_STATUS_IS_OK(result) && \n+\t\t     !NT_STATUS_IS_OK(hunk_result)) \n+\t\t    ||\n+\t\t    ( NT_STATUS_EQUAL(result, NT_STATUS_NONE_MAPPED) &&\n+\t\t     !NT_STATUS_EQUAL(hunk_result, NT_STATUS_NONE_MAPPED)))\n+\t\t{\n+\t\t\tresult = STATUS_SOME_UNMAPPED;\n+\t\t}\n+\n+\t\tsids_left -= hunk_num_sids;\n+\t\tsids_processed += hunk_num_sids; /* only used in DEBUG */\n+\t\thunk_sids += hunk_num_sids;\n+\t\thunk_domains += hunk_num_sids;\n+\t\thunk_names += hunk_num_sids;\n+\t\thunk_types += hunk_num_sids;\n+\t}\n+\n+done:\n+\treturn result;\n+}\n+\n /** Lookup a list of names */\n \n NTSTATUS rpccli_lsa_lookup_names(struct rpc_pipe_client *cli,\n\n"}
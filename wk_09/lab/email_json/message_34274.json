{"category": "ham", "to_address": "Allison Randal <allison@perl.org>, p2 <parrot-porters@perl.org>", "from_address": "\"Patrick R. Michaud\" <pmichaud@pobox.com>", "subject": "Re: PMC architecture discussion", "body": "On Tue, May 22, 2007 at 01:25:33PM +0100, Nicholas Clark wrote:\n> \n> And how often does the type of a PMC change, such that its internal \n> data layout changes? In Perl 5 this morphing happens everywhere, \n> but in Parrot?\n\nActually, until/unless we have a \"scalar container\" or \"reference\"\nPMC of some sort, it appears to occur a lot.  The example I \nkeep coming back to is something like (Perl 6):\n\n   my @a = (1, 2, 3);\n   my $b := @a[2];\n\n   @a[2] = foo();\n\nIn PIR this becomes something like (simplified):\n\n   ##  my @a = (1, 2, 3);\n   $P1 = '_buildlist'(1, 2, 3)     # create a list\n   .lex '@a', $P1                  # bind as @a\n\n   ##  my $b := @a[2];\n   find_lex $P2, '@a'              # look up @a\n   set $P3, $P2[2]                 # get reference to @a[2]\n   .lex '$b', $P3                  # bind as $b\n\n   ##  @a[2] = foo();\n   $P4 = 'foo'()                   # $P4 could be any type\n   find_lex $P5, '@a'              # look up @a\n   set $P6, $P5[2]                 # get reference to @a[2]\n   assign $P6, $P4                 # $P6 (Integer) has to morph \n                                   #   to whatever type $P4 is\n\nIf we try to use a set opcode instead, as in:\n\n   ##  @a[2] = foo();\n   $P4 = 'foo'()                   # $P4 could be any type\n   find_lex $P5, '@a'              # look up @a\n   set $P5[2], $P4                 # set @a[2] to $P4\n\nthen we end up losing the binding between $b and @a[2] that\nwas established earlier ($b still refers to the Integer).  \n\nPm\n\n"}
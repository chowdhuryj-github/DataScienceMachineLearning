{"category": "ham", "to_address": "damian@conway.org", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Quirky comments", "body": "In \"[svn:perl6-synopsis] r14421 - doc/trunk/design/syn\",\nDamian Conway wrote:\n> brian wrote:\n> > So, if this is the case, how will a new Perl 6 user debug a program\n> > failure when part of their program mysteriously disappears because\n> > they just happened to have =begin at the beginning of a line?\n>\n> The same way they debug it when part of their program mysteriously\n> disappears because they just happened to have # at the beginning of a\n> line: by learning to distinguish between code and commentary.\n>\n> Except, of course, the Pod mysteriously vanishing will be considerably\n> easier to debug, because ALL lines starting with =begin vanish, whereas\n> only some lines beginning with # do.\n\nBy this reasoning, a case could be made for declaring that all lines\nthat begin with '#' are comments (either block or line, depending on\nthe second character), no matter what.  That way, you'll have more\nconsistency between block comments and Pod Sections (which, from\nPerl's perspective, should be equivalent).\n\nThe price to be paid (in both cases) is that you have to finagle any\ncode that would normally start a line with a '#' or '=' respectively,\nsuch as the aforementioned block quote.  Admittedly, this isn't hard\nto do: starting the line with whitespace or an unspace will do the\ntrick.  (But ending the previous line with an unspace won't, as\ncomments are apparently found and turned into whitespace by the\nlexer.)\n\nThere is an additional price to be paid in the case of '#': you'd have\nto distinguish between end-of-line comments (which cease to be\ncomments if placed in quotes) and line comments (which are always\ncomments, no matter what).  In effect, you would have four kinds of\ncomments, not counting Pod sections:\n\nbracketed?  starts line?\n            yes:   no:\n no:         line   end-of-line\nyes:        block  embedded\n\nThe semantic similarities would be as follows:\n\n* line-oriented comments (line and block) don't care about quotes;\ncharacter-oriented comments (end-of-line and embedded) do.\n* block and embedded comments continue until explicitly terminated;\nline and end-of-line comments are terminated by newline.\n\n--\n\nAnother quirk concerning comments: if I'm reading S02 correctly, C<\\#>\nis an unspaced comment whenever it would normally be a comment, and is\nonly an escaped pound sign when it would normally be a quoted pound\nsign.  This is one (possibly the only) case where backslashing a\nspecial character does _not_ shut off its special behavior.  As a\nresult, you have to quote a pound sign if you want to use it in a\npattern.  If this behavior is kept (I don't care either way), it\nshould probably be noted in \"Learning Perl 6\" or the like, as a\n\"gotcha\".\n\n--\n\nI also can't seem to find any means of starting a comment from within\na quote, aside from Pod Sections (and, if my first suggestion is\nadopted, line and block comments).  Perhaps C<\\#> should count as the\nstart of a comment when appearing in a quote?  This has the advantage\nthat almost every appearance of that pair of characters will act to\ncomment out what follows; the only exception would be when it appears\nas part of the C<\\\\#> sequence, which is easily tested for.  It does,\nhowever, mean that you can't start a line that's within a quote with\nC<\\#> in order to start that line with a literal pound sign.  C<\\ #>\nwould work, though, as would indenting the quote in the case of a\nheredoc.\n\n--\n\nAlso from S02:\n\n  Although we say that the unspace hides the whitespace from the\n  parser, it does not hide whitespace from the lexer. As a\n  result, unspace is not allowed within a token.\n\nTechnically true; but what does this mean?  If I were to say\n\n  foo\\ bar\n\nwould the lexer generate a pair of tokens ('foo' and 'bar') that don't\nhave any intervening whitespace (which might be important in some\ncases that involve whitespace-based disambiguation), or would it\ncomplain about finding an unspace where it doesn't belong?  I hope\nthat the former is true; although Larry seems to have been very\nconscientious about making sure that whitespace is never forbidden\nbetween tokens unless a dot can be placed there instead.  Still,\nletting unspace split tokens provides a more general solution.\n\n--\n\nFinally, from S02:\n\n  Since there is a newline before the first =, the POD form of\n  comment counts as whitespace equivalent to a newline.\n\nThis rationale doesn't hold, for two reasons.  First, there is not\ngoing to be a newline before the first = in a Pod Section if said Pod\nSection starts the file.  Second, the stated behavior doesn't follow\nfrom the premise.  Given the logic that Pod Sections are effectively\nstripped out of the file before anything else happens, one would\nexpect:\n\n  say qq:to'END';\n  =begin comment\n  END\n  =end comment\n  END\n\nto be equivalent to:\n\n  say qq:to'END';\n  END\n\ninstead of:\n\n  say qq:to'END';\n\n  END\n\nHowever, the latter is what occurs under the current rule.  I submit\nthat Pod Sections shouldn't be equivalent to whitespace; they should\nbe equivalent to empty strings.  Likewise with line and block\ncomments: all line-oriented comments should remove all traces of the\nline(s) being commented out, including the trailing newline\ncharacter(s).  There will still be a newline between the last line\nbefore the comment and the first line after it (assuming that there\n_is_ a line before the comment): the trailing newline of the preceding\nline.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
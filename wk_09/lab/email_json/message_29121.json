{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "svn commit: samba r22837 - in\n\tbranches/SAMBA_4_0/source/torture/raw: .", "body": "Author: tridge\nDate: 2007-05-14 03:49:42 +0000 (Mon, 14 May 2007)\nNew Revision: 22837\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22837\n\nLog:\n\nmake RAW-BENCH-LOCK reconnect asynchronously when one of its servers\ngoges away\n\nModified:\n   branches/SAMBA_4_0/source/torture/raw/lockbench.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/torture/raw/lockbench.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/lockbench.c\t2007-05-14 01:05:09 UTC (rev 22836)\n+++ branches/SAMBA_4_0/source/torture/raw/lockbench.c\t2007-05-14 03:49:42 UTC (rev 22837)\n@@ -29,6 +29,8 @@\n #include \"torture/util.h\"\n #include \"lib/events/events.h\"\n #include \"lib/cmdline/popt_common.h\"\n+#include \"libcli/composite/composite.h\"\n+#include \"libcli/smb_composite/smb_composite.h\"\n \n #define CHECK_STATUS(status, correct) do { \\\n \tif (!NT_STATUS_EQUAL(status, correct)) { \\\n@@ -45,7 +47,8 @@\n \n struct benchlock_state {\n \tstruct event_context *ev;\n-\tstruct smbcli_state *cli;\n+\tstruct smbcli_tree *tree;\n+\tTALLOC_CTX *mem_ctx;\n \tint client_num;\n \tint fnum;\n \tint offset;\n@@ -53,6 +56,13 @@\n \tunion smb_lock io;\n \tstruct smb_lock_entry lock[2];\n \tstruct smbcli_request *req;\n+\tstruct smb_composite_connect reconnect;\n+\n+\t/* these are used for reconnections */\n+\tint dest_port;\n+\tconst char *dest_host;\n+\tconst char *called_name;\n+\tconst char *service_type;\n };\n \n static void lock_completion(struct smbcli_request *);\n@@ -64,11 +74,11 @@\n {\n \tstate->io.lockx.in.file.fnum = state->fnum;\n \tstate->io.lockx.in.ulock_cnt = 1;\n-\tstate->lock[0].pid = state->cli->session->pid;\n-\tstate->lock[1].pid = state->cli->session->pid;\n+\tstate->lock[0].pid = state->tree->session->pid;\n+\tstate->lock[1].pid = state->tree->session->pid;\n \tstate->lock[0].offset = state->offset;\n \tstate->lock[1].offset = (state->offset+1)%nprocs;\n-\tstate->req = smb_raw_lock_send(state->cli->tree, &state->io);\n+\tstate->req = smb_raw_lock_send(state->tree, &state->io);\n \tif (state->req == NULL) {\n \t\tDEBUG(0,(\"Failed to setup lock\\n\"));\n \t\tlock_failed++;\n@@ -78,24 +88,26 @@\n \tstate->offset = (state->offset+1)%nprocs;\n }\n \n-/*\n-  reopen dead connections\n- */\n-static void reopen_connection(struct benchlock_state *state)\n+static void reopen_connection(struct benchlock_state *state);\n+\n+\n+static void reopen_file(struct event_context *ev, struct timed_event *te, \n+\t\t\t\t      struct timeval t, void *private_data)\n {\n-\tdo {\n-\t\tDEBUG(0,(\"reopening connection %u\\n\", state->client_num));\n-\t} while (!torture_open_connection_ev(&state->cli, state->client_num, state->ev));\n-\t\n-\tstate->fnum = smbcli_open(state->cli->tree, FNAME, O_RDWR|O_CREAT, DENY_NONE);\n+\tstruct benchlock_state *state = (struct benchlock_state *)private_data;\n+\n+\t/* reestablish our open file */\n+\tstate->fnum = smbcli_open(state->tree, FNAME, O_RDWR|O_CREAT, DENY_NONE);\n \tif (state->fnum == -1) {\n \t\tprintf(\"Failed to open %s on connection %d\\n\", FNAME, state->client_num);\n \t\texit(1);\n \t}\n \n+\t/* reestablish one lock, preparing for the async lock loop */\n \tstate->lock[0].offset = state->offset;\n \tstate->io.lockx.in.ulock_cnt = 0;\n-\tstate->req = smb_raw_lock_send(state->cli->tree, &state->io);\n+\tstate->io.lockx.in.file.fnum = state->fnum;\n+\tstate->req = smb_raw_lock_send(state->tree, &state->io);\n \tif (state->req == NULL) {\n \t\tDEBUG(0,(\"Failed to setup lock\\n\"));\n \t\tlock_failed++;\n@@ -106,6 +118,70 @@\n }\n \n /*\n+  complete an async reconnect\n+ */\n+static void reopen_connection_complete(struct composite_context *ctx)\n+{\n+\tstruct benchlock_state *state = (struct benchlock_state *)ctx->async.private_data;\n+\tNTSTATUS status;\n+\tstruct smb_composite_connect *io = &state->reconnect;\n+\n+\tstatus = smb_composite_connect_recv(ctx, state->mem_ctx);\n+\tif (!NT_STATUS_IS_OK(status)) {\n+\t\treopen_connection(state);\n+\t\treturn;\n+\t}\n+\n+\ttalloc_free(state->tree);\n+\tstate->tree = io->out.tree;\n+\n+\t/* do the reopen as a separate event */\n+\tevent_add_timed(state->ev, state->mem_ctx, timeval_zero(), reopen_file, state);\n+}\n+\n+\t\n+\n+/*\n+  reopen dead connections\n+ */\n+static void reopen_connection(struct benchlock_state *state)\n+{\n+\tstruct composite_context *ctx;\n+\tstruct smb_composite_connect *io = &state->reconnect;\n+\tchar *host, *share;\n+\n+\tif (!torture_get_conn_index(state->client_num, state->mem_ctx, &host, &share)) {\n+\t\tDEBUG(0,(\"Can't find host/share for reconnect?!\\n\"));\n+\t\texit(1);\n+\t}\n+\n+\tio->in.dest_host    = state->dest_host;\n+\tio->in.port         = state->dest_port;\n+\tio->in.called_name  = state->called_name;\n+\tio->in.service      = share;\n+\tio->in.service_type = state->service_type;\n+\tio->in.credentials  = cmdline_credentials;\n+\tio->in.fallback_to_anonymous = False;\n+\tio->in.workgroup    = lp_workgroup();\n+\n+\tDEBUG(0,(\"reopening connection to //%s/%s\\n\", host, share));\n+\n+\t/* kill off the remnants of the old connection */\n+\ttalloc_free(state->tree);\n+\tstate->tree = NULL;\n+\n+\tctx = smb_composite_connect_send(io, state->mem_ctx, state->ev);\n+\tif (ctx == NULL) {\n+\t\tDEBUG(0,(\"Failed to setup async reconnect\\n\"));\n+\t\texit(1);\n+\t}\n+\n+\tctx->async.fn = reopen_connection_complete;\n+\tctx->async.private_data = state;\n+}\n+\n+\n+/*\n   called when a lock completes\n */\n static void lock_completion(struct smbcli_request *req)\n@@ -114,10 +190,11 @@\n \tNTSTATUS status = smbcli_request_simple_recv(req);\n \tstate->req = NULL;\n \tif (!NT_STATUS_IS_OK(status)) {\n-\t\tlock_failed++;\n-\t\tDEBUG(0,(\"Lock failed - %s\\n\", nt_errstr(status)));\n \t\tif (NT_STATUS_EQUAL(status, NT_STATUS_END_OF_FILE)) {\n \t\t\treopen_connection(state);\n+\t\t} else {\n+\t\t\tDEBUG(0,(\"Lock failed - %s\\n\", nt_errstr(status)));\n+\t\t\tlock_failed++;\n \t\t}\n \t} else {\n \t\tstate->count++;\n@@ -139,6 +216,7 @@\n \tstruct benchlock_state *state;\n \tint total = 0, loops=0, minops=0;\n \tNTSTATUS status;\n+\tstruct smbcli_state *cli;\n \t\n \tnprocs = lp_parm_int(-1, \"torture\", \"nprocs\", 4);\n \n@@ -146,20 +224,29 @@\n \n \tprintf(\"Opening %d connections\\n\", nprocs);\n \tfor (i=0;itree;\n+\t\tstate[i].dest_host = talloc_strdup(state[i].mem_ctx, \n+\t\t\t\t\t\t   cli->tree->session->transport->socket->hostname);\n+\t\tstate[i].dest_port = cli->tree->session->transport->socket->port;\n+\t\tstate[i].called_name  = talloc_strdup(state[i].mem_ctx,\n+\t\t\t\t\t\t      cli->tree->session->transport->called.name);\n+\t\tstate[i].service_type = talloc_strdup(state[i].mem_ctx,\n+\t\t\t\t\t\t      cli->tree->device);\n \t}\n \n-\tif (!torture_setup_dir(state[0].cli, BASEDIR)) {\n+\tif (!torture_setup_dir(cli, BASEDIR)) {\n \t\tgoto failed;\n \t}\n \n \tfor (i=0;itree, \n+\t\tstate[i].fnum = smbcli_open(state[i].tree, \n \t\t\t\t\t    FNAME, \n \t\t\t\t\t    O_RDWR|O_CREAT, DENY_NONE);\n \t\tif (state[i].fnum == -1) {\n@@ -179,8 +266,8 @@\n \t\tstate[i].offset = i;\n \t\tstate[i].io.lockx.in.file.fnum = state[i].fnum;\n \t\tstate[i].lock[0].offset = state[i].offset;\n-\t\tstate[i].lock[0].pid    = state[i].cli->session->pid;\n-\t\tstatus = smb_raw_lock(state[i].cli->tree, &state[i].io);\n+\t\tstate[i].lock[0].pid    = state[i].tree->session->pid;\n+\t\tstatus = smb_raw_lock(state[i].tree, &state[i].io);\n \t\tCHECK_STATUS(status, NT_STATUS_OK);\n \t}\n \n@@ -226,19 +313,14 @@\n \n \tfor (i=0;isession);\n+\t\tsmb_raw_exit(state[i].tree->session);\n \t}\n \n-\tsmbcli_deltree(state[0].cli->tree, BASEDIR);\n+\tsmbcli_deltree(state[0].tree, BASEDIR);\n \ttalloc_free(mem_ctx);\n \treturn ret;\n \n failed:\n-\tfor (i=0;isession);\n-\t}\n-\tsmbcli_deltree(state[0].cli->tree, BASEDIR);\n \ttalloc_free(mem_ctx);\n \treturn False;\n }\n\n"}
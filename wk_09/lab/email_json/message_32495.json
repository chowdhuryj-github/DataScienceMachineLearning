{"category": "ham", "to_address": "Mike Mattie <codermattie@gmail.com>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [RFC] extension guessing, functionally better loader behavior\n ->  working install target", "body": "I wanted to reply to this before you left on vacation, but Thunderbird \ncrashed taking several unfinished replies with it. (Fresh install, which \nI hadn't yet configured to automatically save drafts.)\n\nSo, the abbreviated version...\n\nMike Mattie wrote:\n> Hello,\n> \n> I have been working on implementing extension guessing consistently in parrot.\n> These changes make parrot much more usable, robust, flexible, and maintainable.\n> \n> Usable:\n> \n> the current parrot implementation requires the extension to be specified. First\n> what is a extension ? An extension is just a few extra characters tacked on\n> to a path. All things being right an extension implies a file format.\n> \n> In parrot however a file extension is much more. It indicates which stage\n> of compilation for a module. A module may have multiple stages cached on\n> disk.\n> \n> foo.pir  <- source\n> foo.pbc  <- bytecode compiled\n> \n> The parrot implementation is completely backwards in that the user of\n> module \"foo\" cannot simply use \"foo\". The user has to explicitly hardwire\n> which stage of compilation they want along with the module name itself.\n> \n> In using parrot there is no good reason for the compilation stage to\n> matter. (I know about the jit issues on web-servers, it is not relevant).\n> \n> In fact having this information \"filter-down\" from the request to load\n> a module has broken the install target. There are several cases where\n> someone does \".load_bytecode \"foo.pir\"\" because in the working-copy\n> they have both foo.pbc and foo.pir. In the install tree only\n> foo.pbc is installed.\n\nThis can be solved by simply referencing the .pbc file and building the \nPBC in the make process for a particular subsystem. Which is only to say \nthat automatic extension selection is an optional refinement, not a core \nrequirement.\n\n> So parrot is not able to load code that exists on disk, because parrot\n> must be explicitly told the exact compilation stage along with the\n> module, and some compilation stages aren't always useful (intermediate)\n> or available.\n> \n> Two behavioral rules can be formulated to solve this problem:\n> \n> Rule 1. When a user requests a module, parrot will load that module using\n>         whatever format/loader is available. (dlopen, bytecode loaders, compilers)\n> \n> Rule 2. When a module is requested , for performance the most compiled form\n>         of that module will be chosen.\n> \n>    This is in fact the behavior of perl5 , and I think it should be\n>    the behavior of perl6. In fact in discussing this on #perl6 someone\n>    mentioned that there is already perl5 code that relies on this behavior (strange?).\n\nMy take on this is that we should have two opcodes. One that tries to \nwork out the extension for you, and one that is quite literal-minded. \nWhen the \"smart loader\" isn't sufficiently smart, the code can fall back \nto the literal-minded loader. For the sake of sane migration, \nload_bytecode should continue to work as it always has, and we come up \nwith a new name for the new opcode. (load_bytecode is a misleading name \nanyway.)\n\n\n> Rule 3:  PARROT_PREFER_SOURCE when this environment variable is exported parrot\n>          will reverse it's normal preference for low-level compiled forms , and\n>          prefer high level source forms.\n\nAn environment variable should not be used to select the behavior of \nParrot opcodes. If both behaviors are useful, then provide both as \nseparate opcodes.\n\n> Flexible:\n> \n> I am working on making parrot more flexible by allowing languages/compilers\n> to have a \"namespace\" within the loader. \n> \n> Please do *not* tie this part to the rest. It only exists in my working-tree \n> and is easily ripped out of the rest of the proposal.\n> \n> This is a more speculative feature, but I think a good one. While reading\n> pdd21 concerning HLL name-spaces and interoperability I decided to try\n> the time-machine experiment.\n> \n> Fast-fowarding to a future where parrot rules the earth I see parrot\n> having byte-code loaders for a range of languages: java, CLR, python,\n> perl5, perl6, etc.\n> \n> Each language has it's own runtime, a set of libraries, architecture\n> objects (machine-code) , bytecode objects, and source files. Parrot\n> can interpret all of these but there is no reason to re-implement them\n> all from source.\n> \n> If each language could have a \"namespace\" within the loader then the\n> java runtime distributed by Sun/whoever could be used by parrot\n> without any collisions for the wheels that everyone has to re-invent\n> like string,file,io etc.\n\nI halfway get the impression that you're working backwards here. You \nwant to make extensions irrelevant, but once you do that, you need some \nway to distinguish between different languages, so you add the \ndistinctions back in as directory hierarchy.\n\nThere is some provision to specify a custom library that is loaded when \nthe HLL is selected in the second argument to .HLL. It's limited, and \nnot really used AFAIK.\n\n> Rule: when a loader namespace for a language has not been defined\n>       the default namespace \"parrot\" is used. If a lookup fails\n>       within the parrot namespace the load fails.\n\nWhat's the distinction between loader namespace and Parrot namespace?\n\n> RFC: I noticed compreg, and quickly scanned through HLLCompiler.\n>      compiler implies either a translation stage, a sequence of\n>      translation stages, or a language.\n> \n>      Has the meanings been refined architecturally somewhere ?\n> \n> Basically the lib_paths global which is currently built like this\n> \n> fixed-array[\n>   paths,      -> resizable array of strings\n>   extensions, -> resizable array of strings (note how parrot already implements extension guessing)\n> ]\n> \n> becomes this:\n> \n> hash keyed by namespace {\n> \n>   parrot -> fixed array of loaders [\n>      ARCH     /*dlopen loader*/       -> [ ... ]\n>      BYTECODE /* bytecode loaders */  -> [ ... ]\n>      SOURCE   /* source compilers */  -> fixed array [\n>                                          SEARCH_PATH  -> resizable array of strings\n>                                          SEARCH_EXT   -> resizable array of strings\n>   ]\n> }\n> \n> With this new structure parrot has enough flexibility that it can construct a search space\n> for any language distribution, and can use them all within the same parrot instance without\n> collisions in the search space between languages.\n\nThis doesn't quite work because you have to be able to load one \nlanguage's libraries from another language. So, you need to be able to \nload Python's Mail.Filter and Perl's Mail::Filter (fictional examples) \nat the same time and use them both within the same program.\n\nThe directories on disk correspond to the Parrot namespace of the \nlibraries as a convention. You could potentially optimize the loading \noperation by having a load of a Python module only search the Python HLL \ndirectory. But, a user-defined module might not follow the convention.\n\nSimilarly, there is a convention (not entirely consistent) that foo.pbc \nis the compiled form of foo.pir, but that's not always the case, and \ncertainly not required.\n\n> It could also be used to implement binary compatibility. If \"parrot\" is versioned , say\n> as \"parrot-pre\" \"parrot1\" etc then the loader could support selecting a compatible version\n> of multiple runtime installs.\n\nWhat you haven't addressed (and what I consider the most important \nproblem to solve for library loading), is a mechanism for extending \nParrot's search path.\n\nIf that were defined, then versioning would be a simple matter of \nselecting an appropriate search path.\n\n> Maintainability:\n> \n> This issue will get a bit more involved. the parrot loader is very alpha, aka put\n> together early in the development process. It let people explore the rest of the design \n> space but a refactor is apparent throughout the code and API.\n\nThis section is a mixture of code refactor ideas and architecture ideas. \nWould be simpler to process the two separately, but I'll take a stab.\n\n\n\n> First let's focus on Parrot_locate_runtime_str.\n> \n> current HEAD has this library.h:\n> \n> typedef enum {\n>     PARROT_RUNTIME_FT_LIBRARY = 0x0001,\n>     PARROT_RUNTIME_FT_INCLUDE = 0x0002,\n>     PARROT_RUNTIME_FT_DYNEXT  = 0x0004,\n>     PARROT_RUNTIME_FT_PBC     = 0x0010,\n>     PARROT_RUNTIME_FT_PASM    = 0x0100,\n>     PARROT_RUNTIME_FT_PIR     = 0x0200,\n>     PARROT_RUNTIME_FT_PAST    = 0x0400,\n>     PARROT_RUNTIME_FT_SOURCE  = 0x0F00\n> } enum_runtime_ft;\n> \n> There is one valuable idea to keep from this enum:\n> \n> DYNEXT,LIBRARY,INCLUDE,SOURCE,\n> \n> there are four basic loaders for parrot.\n> \n> ARCH    : the platform loader for machine-code shared objects. aka ld\n> INCLUDE : macro/include pre-processing, link-editing on a translation unit level.\n> LIBRARY : bytecode loaders. parrot can support multiple bytecode loaders, extension will depend on language.\n> SOURCE  : something compiled\n> \n> These are fundamental distinctions of interpretation that are sound across the current computing landscape.\n> We have link-loaders (machine specific), byte-code loaders (link editor internal to VM), and compilers:\n> generates objects for linking. INCLUDE is a special case for SOURCE, but necessary.\n> \n> my new version looks like this:\n> \n> /* enum_runtime_ft\n>  *\n>  * There are four basic paths for the loader.\n>  *\n>  * ARCH      : link-editor for an architecture shared object (machine code)\n>  * BYTECODE  : link-editor for bytecode linked into the virtual machine's\n>  *             op lists\n>  * INCLUDE   : a source form linked by a pre-processor creating translation-units\n>  *             for compilation\n>  * SOURCE    : source code compiled by the HLL framework\n>  *\n>  * These different paths for the loader are necessary to\n>  * resolve collisions in the library search space. For example\n>  * a module may have both a NCI part, and a HLL part:\n>  *\n>  * foo.so , foo.pbc\n>  */\n> \n> typedef enum  {\n>     PARROT_RUNTIME_FT_ARCH     = 0x0001,\n>     PARROT_RUNTIME_FT_BYTECODE = 0x0002,\n>     PARROT_RUNTIME_FT_INCLUDE  = 0x0004\n>     PARROT_RUNTIME_FT_SOURCE   = 0x0006,\n>     PARROT_RUNTIME_FT_SIZE     = 4\n> } enum_runtime_ft;\n> \n> \n> by behavioral rule 1 Parrot should load whatever it can. Parrot_locate_runtime_file_str is a routine\n> that does the discovery of what is available. First cut would eliminate the distinction altogether,\n> pass of the discovery list to heuristic checks, and then select a loader.\n> \n> However it is essential to keep the distinction between loaders at this level. A simple case would be\n> sqlite or a similar db wrapper. It likely has a ARCH component that glues the DB API to the languages\n> NCI API. It also has a language file that will export the interface and provide convenience/features\n> enhancing the DB API.\n> \n> I this case loading a library ( a higher level concept than .load_bytecode ) would have a collision. This\n> scenario is not one file selected from a set of candidates, but two.\n> \n> In the scenario of best form selected from candidates, multiple loaders can be selected in the mask\n> (think .pir | .pbc ) . In the case of more than one loader/format to completely load a module a \n> single loader can be selected eliminating legitimate collisions that would parts of a multiple-format\n> module unreachable.\n> \n> The enumeration of PBC etc is gone. Heuristics should be abstracted into a different stage of\n> loading. Each loader should provide header magic for a common routine to implement. This is punted\n> because parrot is simple enough. I want to fix library.c first without bogging down in a new\n> layer.\n\nPARROT_RUNTIME_FT_LIBRARY, PARROT_RUNTIME_FT_PASM, \nPARROT_RUNTIME_FT_PIR, PARROT_RUNTIME_FT_PAST are never used at all. \nPARROT_RUNTIME_FT_PAST can certainly go away, since it corresponded to \nthe old ast/ implementation which has been deleted.\n\nPARROT_RUNTIME_FT_INCLUDE is used once in imcc as an argument to \nParrot_locate_runtime_file.\n\nPARROT_RUNTIME_FT_DYNEXT is used in src/dynext.c as an argument to \nParrot_locate_runtime_file_str, and in src/library.c to select for \nget_search_paths, and to select between try_load_path and \ntry_bytecode_extensions for setting the full name.\n\nPARROT_RUNTIME_FT_PBC is used in src/library.c to select for \nget_search_paths, and in src/packfile.c passed to \nParrot_locate_runtime_file_str and to decide whether to call \nPackFile_append_pbc.\n\nPARROT_RUNTIME_FT_SOURCE is used in src/library.c to select for \nget_search_paths, and in src/packfile.c passed to \nParrot_locate_runtime_file_str. If it really does mean the *compiled* \nform of anything, it could use a better name.\n\nConsidering how rarely these flags are used, if you can adequately cover \nthe needed behavior, I have no objections to renaming the flags to \nsomething more meaningful, and removing unused flags. (Though, I can't \nsee keeping the \"RUNTIME_FT\" naming convention if they no longer refer \nto actual runtime file types.)\n\nI'm not sure ARCH is the most meaningful replacement for DYNEXT.\n\n(Note, there may be hardcoded constants still lingering around for these \nscattered through the repository.)\n\n> enum_lib_paths:\n> \n> This chunk below should simply not be in a header. It should be in the .c file. Other modules\n> need to access the information from iglobal->lib_paths, but they should do it through functions\n> provided in library.c there should be a library.pir or something like that for accessing\n> the information on a parrot level. \n> \n> typedef enum {\n>     PARROT_LIB_PATH_INCLUDE,            /* .include \"foo\" */\n>     PARROT_LIB_PATH_LIBRARY,            /* load_bytecode \"bar\" */\n>     PARROT_LIB_PATH_DYNEXT,             /* loadlib \"baz\" */\n>     PARROT_LIB_DYN_EXTS,                /* \".so\", \".dylib\" .. */\n>     /* must be last: */\n>     PARROT_LIB_PATH_SIZE\n> } enum_lib_paths;\n> \n> I am already feeling the pain from the lack of insulation here. I am doing\n> a discovery in the rest of the tree for how this is used, more later on this.\n\nThe main reason for having these in library.h is to avoid scattering \nhardcoded values through the system. Aside from one reference in \nsrc/dynext.c, the enum could be located in src/library.c (though, again, \nthere may be hardcoded constants littered through the system that really \nshould be using these flags or function calls instead).\n\nPARROT_LIB_PATH_INCLUDE is only used in src/library.c as a key to set \n[IGLOBALS_LIB_PATHS; PARROT_LIB_PATH_INCLUDE] on interp->iglobals, and \nas the default argument to get_search_paths.\n\nPARROT_LIB_PATH_LIBRARY is only used in src/library.c as a key to set \n[IGLOBALS_LIB_PATHS; PARROT_LIB_PATH_INCLUDE] on interp->iglobals, as an \nargument to get_search_paths, and in a comment in \nt/compilers/imcc/syn/file.t.\n\nPARROT_LIB_PATH_DYNEXT is only used in src/library.c as a key to set \n[IGLOBALS_LIB_PATHS; PARROT_LIB_PATH_DYNEXT] on interp->iglobals and as \nan argument to get_search_paths.\n\nPARROT_LIB_DYN_EXTS is used in src/library.c as a key to set \n[IGLOBALS_LIB_PATHS; PARROT_LIB_PATH_DYNEXT] on interp->iglobals and in \nsrc/dynext.c as a key to retrieve the same value.\n\nPARROT_LIB_PATH_SIZE is only used in src/library.c to set the size of \nthe array that contains the above flags (stored at the key \n[IGLOBALS_LIB_PATHS] on interp->iglobals).\n\n\nIf the access in src/dynext.c can be replaced by a function call in \nlibrary.c, I see no reason not to move the enum out of the header, \nthough, I also don't see it as a big problem to leave it in the header.\n\n> This is the main focus of the effort.\n> \n> PARROT_API STRING* Parrot_locate_runtime_file_str(Interp *, STRING *file_name,\n>         enum_runtime_ft);\n> \n> The role is weakly defined.\n> \n\n\n> \n> Parrot_locate_runtime_file_str performs a search to find the best available form\n> of a code object.\n> \n> PARROT_API STRING* Parrot_locate_runtime_file_str(Interp *,\n>                                                   STRING *object_name,\n>                                                   STRING *hll,\n>                                                   enum_runtime_ft *loader);\n> \n> file_name is now object_name. A file name is the result of this function, not the input.\n\nSane renaming.\n\n> The hll argument is the key to the HLL name-space. If the HLL name-space does not exist\n> or is null the default name-space is used. The default name-space is \"parrot\".\n\nOkay, this is adding the concept of HLL namespace to the loader, which \nmay be useful for bytecode files, though not necessarily, since they \nspecify their HLL namespace inside the file.\n\n> loader is passed as a pointer to a modifiable enum_ft_loader variable. As an argument\n> it is a bit-mask of loaders to consider when discovering a object file path. As a return\n> value it is the loader chosen. \n\n Parrot_locate_runtime_file_str is only called twice in \nsrc/dynext.c, once in src/packfile.c, and once in src/library.c. The \ncall in src/library.c is just a pass through from \nParrot_locate_runtime_file, which is only called once from \ncompilers/imcc/imcc.l (compilers/imcc/imclexer.c).\n\nIn src/dynext.c, both calls are guaranteed to be \nPARROT_RUNTIME_FT_DYNEXT, and in src/packfile.c it's either \nPARROT_RUNTIME_FT_PBC or PARROT_RUNTIME_FT_SOURCE. The call in \ncompilers/imcc/imcc.l is guaranteed to be PARROT_RUNTIME_FT_INCLUDE.\n\nAs refactors go, it would make more sense to simplify here. Something \nlike: entirely do away with the flags, make separate routines for \nParrot_locate_runtime_file_bytecode, Parrot_locate_runtime_file_include, \nand Parrot_locate_runtime_file_dynext. (With the common functionality \nbetween them factored out into helper functions.)\n\nI don't see the benefit of passing in a pointer to an enum of loaders \nand passing back a loader. If we have code looking for a selected \nloader, it would make more sense to define a function like \nParrot_locate_runtime_file_loader that just returns a pointer to the \nselected loader. We really can't expect imcc.l to put together an enum \nof loaders anyway. It makes more sense to contain that logic within \nlibrary.c.\n\n> The return value is the preferred object's path, or NULL if not found. Note that the \n> returned path string has a hidden 0 making it suitable for direct use in C API calls \n> (artifact of previous implementation).\n\nThe current strategy of calling string_to_cstring before returning from \nthe C string version of the call is a standard Parrot interface. Best \nnot to mix STRING*s and C strings.\n\n> If NULL is returned the value of *loader\n> is semantically NULL, possibly modified, and should be reset by subsequent calls.\n\nAgain, not a useful addition here.\n\n> The object_name is first tried as given, and then by extension guessing. Further\n> location attempts are influenced by the search path and extension lists in\n> iglobal[IGLOBAL_LIB_PATHS]. These lists are examined recursively breadth-first, \n> by loader, by search paths, and then extensions.\n\nThis I see as the core of your proposal, and would like to see a good \ndeal more on it. (Not so much a code patch, but how it would work from \nthe perspective of the user.)\n\n> The order of examination is influenced\n> by the PARROT_PREFER_SOURCE environment variable. When the variable is not\n> set The lowest level forms of the object will be tried up to the highest\n> level bounded by the loader mask. When the environment variable is defined\n> this order is reversed.\n\nNot influenced by an environment variable, but selectable by opcode, so \nrethink how to pass the option around.\n\n> TODO: the extension , which is actually the stage of interpretation contained\n>       by the format is returned in the extension of the file. This should be\n>       returned as a optimization hint to heuristics.\n> \n> TODO: instead of a string that is checked by stat() , a handle should be\n>       returned instead to close the classic access() race. Additional\n>       flags are needed for that such as NO_TTY and other basic cross-platform\n>       security checks. <-- huge warning. This should be a list within the search\n>       spaces index.\n> \n> TODO: OS IO/VM hinting. some loaders could benefit from IO hinting such as\n>       mapped/streamed, use-once etc. depends on returning a handle and open flags.\n\nInteresting, need more detail (but not necessarily right now, since \nthey're beyond the current proposal).\n\n> \n\n> Of particular benefit is gutting src/dynext.c:114 (get_path) which is almost a complete duplication\n> of Parrot_get_runtime_file_str's algorithm because extension guessing is implemented there. \n> When get_path is considered , extension-guessing is not new behavior , rather a re-factor\n> of existing behavior to build a single API, documented/implemented in one place, that\n> provides safe/secure implementation consistent across loaders. HLL name-spacing is\n> a true feature on top of that re-factor.\n\nsrc/dynext.c's get_path currently calls Parrot_get_runtime_file_str. If \nwe went with the refactor splitting out Parrot_get_runtime_file_dynext, \nthen get_path could be completely gutted.\n\n\n> Refactoring parrot_init_library_paths:\n> \n> This re-factor can be implemented independent of the Parrot_locate_runtime_str work. This completes\n> the changes necessary in parrot internals to get the install target to work the same as the working-copy.\n\nThis section mixes together several design questions: install \nconfiguration, HLL configuration, library search paths, etc.\n> \n> Currently parrot_init_library instantiates in a very tedious way\n> \n>     paths = pmc_new(interp, enum_class_ResizableStringArray);\n>     VTABLE_set_pmc_keyed_int(interp, lib_paths,\n>             PARROT_LIB_PATH_INCLUDE, paths);\n>     entry = CONST_STRING(interp, \"runtime/parrot/include/\");\n>     VTABLE_push_string(interp, paths, entry);\n>     entry = CONST_STRING(interp, \"runtime/parrot/\");\n>     VTABLE_push_string(interp, paths, entry);\n>                   ...........\n> \n> It generates a table of paths within the working-copy, and a table for the install. It also has a hook\n> for vendors to append to the default search space. This is the crux of the working-tree and the install\n> being the same. Parrot_locate_runtime_str provides a virtual unified search space. When people request\n> an object such as \"PGE\" , or \"PGE/util\" the burden of hiding the difference between the paths in the\n> two trees is hardcoded here by hand with the parrot internal API in C.\n> \n> I have ripped this out completely and replaced it with this:\n> \n> #include \"builtin-loader-paths.c\"\n> \n> void\n> parrot_init_library_paths(Interp *interp)\n> {\n>     PMC *iglobals, *lib_paths;\n> \n>     if( query_load_prefer(interp) )\n>         load_prefer = PREFER_SOURCE;\n> \n>     lib_paths = pmc_new(interp, enum_class_Hash);\n> \n>     populate_builtin_library_paths(interp, lib_paths);\n> \n>     iglobals = interp->iglobals;\n>     VTABLE_set_pmc_keyed_int(interp, iglobals,\n>                              IGLOBALS_LIB_PATHS, lib_paths);\n> }\n> I have a function with this signature that performs the traversal\n> of the new hll namespace'd lib_paths , creating intermediary data\n> structures as needed, and populating the structure.\n\nI do like the general idea of populating the lib_paths in a more dynamic \nfashion than a long series of manually coded and statically compiled \ncalls to construct the table.\n\nHave you considered a strategy for modifying lib_paths at runtime?\n\n> and is contained in builtin-loader-paths.c which is a generated source created from a input file\n> looking like this:\n> [parrot]\n> \n> # note: the search ./ entries can be used to discover who has not\n> #       migrated to this format. by removing this entry any part\n> #       of the tree not using a .paths file will break.\n> \n> #----------------------------------------------------------------------\n> # shared objects\n> #----------------------------------------------------------------------\n> \n> loader arch\n> \n> install runtime/parrot/dynext/\n> build lib/parrot/dynext/\n> \n> dlopen load so\n\n[...]\n\nIf we're going to have configuration files, I'd prefer to have them in a \nstandard format (YAML?) than a custom format. But, I'm not sure that a \nconfiguration file is a better way of setting installation options than \ncommand-line flags. HLLs may have some form of configuration file, but \nit hasn't been needed yet.\n\n\n> The extensions and the phase information could later be extended for\n> processing by other programs to generate HLLCompiler integration so\n> the the loader aspect does not get separated. A HLLCompiler-integration-generator\n> may be a worthy TODO.\n> \n> The potential for the file is to integrate installation,loading, and maybe\n> even HLLCompiler integration in a single place that can be edited with\n> zero knowledge of parrot internals, only architecture.\n\nThis \"single location\" I would say is Configure.pl, and also runtime \nmodification for loading and HLLCompiler.\n\n> Since my patches were going against the trunk I need to introduce changes incrementally,\n\nYes, definitely, and much appreciated.\n\nAllison\n\n"}
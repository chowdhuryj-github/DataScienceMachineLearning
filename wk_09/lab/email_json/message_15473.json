{"category": "ham", "to_address": "gyadav@ccilindia.co.in", "from_address": "Duncan Murdoch <murdoch@stats.uwo.ca>", "subject": "Re: [R] regarding 3d Bar Plot", "body": "On 4/25/2007 7:56 AM, gyadav@ccilindia.co.in wrote:\n> Hi Duncan\n> \n> I am restating the problem and thanks you for sending me such a good \n> function histogram in 3d. Thanks for that but i think my problem has been \n> misinterpreted. I just wanted a simple 3d bar Plot. Although I have not \n> written anything for R but i will surely like to contribute to R and if i \n> can assist someone in writing then it would be a great help to me.\n> \n> Problem was :-)\n> \n> I have data in a two dimensional table. each row of the data adds upto 100 \n> \n> ( hence they are percentages ). \n> it can be interpreted as like this A - I are the matches and  P - X are \n> the players. Thus Player P scored 20% of the runs during this season in \n> Match C, 60% in Match D and remaining 20% in Match G. \n> \n> I want to plot 3-d bar plot, where X axis have players, Y axis have \n> Matches and Z axis as the percentage(0 - 100%) \n> Please help me in this regards. (Please note on my X and Y axes Numbers \n> are not there instead alphabets)\n\nThe plot.histogram function I sent does most of what you want.  The \nhist3d function calculates the matrix of counts that it plots, and \nplot.histogram plots the resulting bar chart.\n\nDuncan Murdoch\n\n\n> \n>         A       B       C       D       E       F       G       H       I \n> P       0       0       20      60      0       0       20      0       0 \n> Q       0       16.86747        26.907631       11.646586       0 \n> 12.449799       0.8032129       0       31.325301 \n> R       0       59.649123       10.526316       12.280702       0       0 \n> 1.754386        0       15.789474 \n> S       3.57909807      20.281556       33.404915       7.31329 0.584586 \n> 5.965163        1.1930327       0       27.678358 \n> T       0       0       0       0       0       0       0       0       0 \n> U       0       9.090909        27.272727       18.181818       0 \n> 36.363636       0       0       9.090909 \n> V       0       33.333333       33.333333       0       0       33.333333 \n> 0       0       0 \n> W       0       2.188184        1.094092        36.105033       0 \n> 44.420131       5.2516411       0       10.940919 \n> X       0.05994234      51.550409       16.304315       6.997668        0 \n> 17.383277       0.5994234       0.4741439       6.630821 \n> \n> \n> \n> Thanks in advance\n> -gaurav\n> \n> \n> \n> \n> Duncan Murdoch  \n> 25-04-07 04:42 PM\n> \n> To\n> rolf@math.unb.ca\n> cc\n> gyadav@ccilindia.co.in, r-help@stat.math.ethz.ch\n> Subject\n> Re: [R] regarding 3d Bar Plot\n> \n> \n> \n> \n> \n> \n> On 4/24/2007 9:38 AM, rolf@math.unb.ca wrote:\n>> gyadav@ccilindia.co.in wrote:\n>>\n>>> I have data in a two dimensional table. each row of the data adds\n>>> upto 100 ( hence they are percentages ).  it can be interpreted as\n>>> like this A - I are the matches and  P - X are the players. Thus\n>>> Player P scored 20% of the runs during this season in Match C, 60% in\n>>> Match D and remaining 20% in Match G.\n>>>\n>>> I want to plot 3-d bar plot, where X axis have players, Y axis have\n>>> Matches and Z axis as the percentage(0 - 100%) Please help me in this\n>>> regards.\n>>          \n>>\n>>                Many years ago I picked up from the snews mailing list a\n>>                suite of functions for plotting 2D barplots (barplots \n> with 2D\n>>                bases) written by a chap named Colin Goodall, from (at \n> that\n>>                time) the University of Bristol and/or from Penn State.\n>>\n>>                I never actually did anything with this suite until\n>>                recently.  Seeing no replies to the enquiry about 3D\n>>                histograms,  I thought I'd try to get Goodal's code \n> running\n>>                in R to see if it might solve guarav's problem.\n>>\n>>                The trouble is, all the guts of the procedure, \n> *including*\n>>                the plotting are done from within Fortran.  The actual\n>>                plotting seems to be done through a call to a subroutine\n>>                ``segmtz'' which is a piece of Splus software that does \n> not\n>>                exist in R.\n>>\n>>                Is there an equivalent subroutine in R that could be \n> called?\n>>                I dug around a bit but couldn't figure out what was going\n>>                on.  The function segments() simply calls\n>>                .Internal(segments(....\n>>\n>>                I looked around a bit for corresponding C or Fortran code \n> but\n>>                obviously didn't know how to look properly.\n>>\n>>                I think that the Fortran code could be translated into \n> raw R\n>>                and the call to segmtz changed to a call to segments() \n> ---\n>>                but this would seem to be a lot of work.\n>>\n>>                Can anyone suggest a reasonably simple way of replacing \n> the\n>>                call to segmtz in the Fortran?\n> \n> I don't know how to do what you want, but I'd suggest working in R code \n> rather than Fortran.  I did write a hist3d function for the djmrgl \n> package (based on hist), mostly to show off the graphics, but haven't \n> found it useful enough to port to rgl.  Here's a quick port, not good \n> enough to use, but maybe it will give you a starting point.\n> \n> Duncan Murdoch\n> \n> \n> \n> \n> hist3d <-\n>     function (x, y, xbreaks, ybreaks, freq= NULL, probability = !freq, \n> include.lowest= TRUE,\n>               right= TRUE, \n>               xlim = range(xbreaks), ylim = range(ybreaks), zlim = NULL,\n>               xlab = xname, ylab = yname, zlab,\n>               plot = TRUE, top = TRUE, nclass = NULL, ...)\n> {\n>     if (!is.numeric(x) | !is.numeric(y))\n>         stop(\"`x' and `y' must be numeric\")\n>     xname <- deparse(substitute(x))\n>     yname <- deparse(substitute(y))\n>     n <- length(x <- x[!is.na(x)])\n>     use.xbr <- !missing(xbreaks)\n>     if(use.xbr) {\n>         if(!missing(nclass))\n>             warning(\"`nclass' not used when `xbreaks' specified\")\n>     }\n>     else if(!is.null(nclass) && length(nclass) == 1)\n>         xbreaks <- nclass\n>     use.xbr <- use.xbr && (nB <- length(xbreaks)) > 1\n>     if(use.xbr)\n>         xbreaks <- sort(xbreaks)\n>     else {                              # construct vector of breaks\n>         rx <- range(x)\n>         nnb <-\n>             if(missing(xbreaks)) 1 + log2(n)\n>             else {                      # breaks = `nclass'\n>                 if (is.na(xbreaks) | xbreaks < 2)\n>                     stop(\"invalid number of xbreaks\")\n>                 xbreaks\n>             }\n>         xbreaks <- pretty (rx, n = nnb, min.n=1, eps.corr = 2)\n>                  }\n>     nxB <- length(xbreaks)\n>     if(nxB <= 1) ##-- Impossible !\n>     stop(paste(\"hist3d: error, xbreaks=\",format(xbreaks)))\n>  \n>     storage.mode(x) <- \"double\"\n>     storage.mode(xbreaks) <- \"double\"\n>         use.ybr <- !missing(ybreaks)\n>         if(use.ybr) {\n>             if(!missing(nclass))\n>                 warning(\"`nclass' not used when `ybreaks' specified\")\n>         }\n>         else if(!is.null(nclass) && length(nclass) == 1)\n>             ybreaks <- nclass\n>         use.ybr <- use.ybr && (nB <- length(ybreaks)) > 1\n>         if(use.ybr)\n>             ybreaks <- sort(ybreaks)\n>         else {                              # construct vector of breaks\n>             ry <- range(y)\n>             nnb <-\n>                 if(missing(ybreaks)) 1 + log2(n)\n>                 else {                      # breaks = `nclass'\n>                     if (is.na(ybreaks) | ybreaks < 2)\n>                         stop(\"invalid number of ybreaks\")\n>                     ybreaks\n>                 }\n>             ybreaks <- pretty (ry, n = nnb, min.n=1, eps.corr = 2)\n>                                  }\n>         nyB <- length(ybreaks)\n>         if(nyB <= 1) ##-- Impossible !\n>         stop(paste(\"hist3d: error, ybreaks=\",format(ybreaks)))\n>  \n>         storage.mode(y) <- \"double\"\n>     storage.mode(ybreaks) <- \"double\"\n>     counts <- table(cut(x,xbreaks),cut(y,ybreaks))\n>     if (sum(counts) < n)\n>         stop(\"some data not counted; maybe breaks do not span range of \n> data\")\n>     xh <- diff(xbreaks)\n>     if (!use.xbr && any(xh <= 0))\n>         stop(\"not strictly increasing `xbreaks'.\")\n>     yh <- diff(ybreaks)\n>     if (!use.ybr && any(yh <= 0))\n>         stop(\"not strictly increasing `ybreaks'.\")\n>     if (is.null(freq)) {\n>         freq <- if(!missing(probability))\n>             !as.logical(probability)\n>         else if(use.xbr | use.ybr) {\n>             ##-- Do frequencies if breaks are evenly spaced\n>             (max(xh)-min(xh) < 1e-7 * mean(xh)) &  (max(yh)-min(yh) < 1e-7 \n> * mean(yh))\n>         } else TRUE\n>     } else if(!missing(probability) && any(probability == freq))\n>         stop(\"`probability' is an alias for `!freq', however they \n> differ.\")\n>     density <- counts/(n*outer(xh,yh))\n>     xmids <- 0.5 * (xbreaks[-1] + xbreaks[-nxB])\n>     ymids <- 0.5 * (ybreaks[-1] + ybreaks[-nyB])\n>     equidist <- (!use.xbr & !use.ybr) || (diff(range(xh)) < 1e-7 * \n> mean(yh)) & (diff(range(yh)) < 1e-7 * mean(yh))\n>     r <- structure(list(xbreaks = xbreaks, ybreaks = ybreaks, counts = \n> counts,\n>                         intensities = density, \n>             density = density, xmids = xmids, ymids = ymids,\n>                         xname = xname, yname = yname, equidist = \n> equidist),\n>                    class=\"histogram3d\")\n>     if (plot) {\n>         plot(r, freq = freq, \n>              xlim = xlim, ylim = ylim, zlim = zlim, xlab = xlab, ylab = \n> ylab, zlab = zlab,\n>                                                   top = top, ...)\n>         invisible(r)\n>     }\n>     else r\n> }\n> \n> plot.histogram3d <-\n>     function (x, freq = equidist, col = 'gray', rgb = col,\n>               main = paste(\"Histogram of\", x$xname, \"and\", x$yname),\n>               xlim = range(x$xbreaks), ylim = range(x$ybreaks), zlim = \n> NULL,\n>               xlab = x$xname, ylab = x$yname, zlab,\n>               axes = TRUE, box = TRUE, add = FALSE, \n>                                                    top = TRUE, ...)\n> {\n>     if (!add) clear3d()\n>     save <- par3d(skipRedraw = TRUE, ...)\n>     on.exit(par3d(save))\n> \n>     equidist <- x$equidist\n>     if(freq && !equidist)\n>         warning(\"the AREAS in the plot are wrong -- rather use \n> `freq=FALSE'!\")\n> \n>     z <- if (freq) x$counts else x$density\n>     nxB <- length(x$xbreaks)\n>     nyB <- length(x$ybreaks)\n> \n>     if(is.null(z) || 0 == nxB || 0 == nyB) stop(\"`x' is wrongly \n> structured\")\n> \n>                  rgb <- matrix(rgb,nxB-1,nyB-1)\n>     for (i in 1:(nyB-1)) {\n>         keep <- z[,i] > 0\n>         quads3d(as.double(t(cbind(x$xbreaks[-nxB], x$xbreaks[-1], \n> x$xbreaks[-1], x$xbreaks[-nxB])[keep,])),\n>  \n> as.double(t(cbind(rep(x$ybreaks[i],nxB-1),rep(x$ybreaks[i],nxB-1),rep(x$ybreaks[i+1],nxB-1),rep(x$ybreaks[i+1],nxB-1))[keep,])),\n>                 as.double(t(cbind(z[,i],z[,i],z[,i],z[,i])[keep,])),\n>                 col = t(cbind(rgb[,i],rgb[,i],rgb[,i],rgb[,i])[keep,]))\n>         quads3d(as.double(t(cbind(x$xbreaks[-nxB], x$xbreaks[-1], \n> x$xbreaks[-1], x$xbreaks[-nxB])[keep,])),\n>                 as.double(rep(rep(x$ybreaks[i],(nxB-1))[keep],4)),\n>                 as.double(t(cbind(rep(0,nxB-1),    rep(0,nxB-1),  z[,i],   \n>  z[,i])[keep,])),\n>                                                                  col = \n> t(cbind(rgb[,i],rgb[,i],rgb[,i],rgb[,i])[keep,]))\n>         quads3d(as.double(t(cbind(x$xbreaks[-nxB], x$xbreaks[-1], \n> x$xbreaks[-1], x$xbreaks[-nxB])[keep,])),\n>                 as.double(rep(rep(x$ybreaks[i+1],(nxB-1))[keep],4)),\n>                 as.double(t(cbind(rep(0,nxB-1),    rep(0,nxB-1),  z[,i],   \n>  z[,i])[keep,])),\n>                                                                  col = \n> t(cbind(rgb[,i],rgb[,i],rgb[,i],rgb[,i])[keep,]))\n>         quads3d(as.double(t(cbind(x$xbreaks[-nxB], x$xbreaks[-nxB], \n> x$xbreaks[-nxB], x$xbreaks[-nxB])[keep,])),\n>  \n> as.double(t(cbind(rep(x$ybreaks[i],nxB-1),rep(x$ybreaks[i+1],nxB-1),rep(x$ybreaks[i+1],nxB-1),rep(x$ybreaks[i],nxB-1))[keep,])),\n>                 as.double(t(cbind(rep(0,nxB-1),    rep(0,nxB-1),  z[,i],   \n>  z[,i])[keep,])),\n>                 col = t(cbind(rgb[,i],rgb[,i],rgb[,i],rgb[,i])[keep,]))\n>         quads3d(as.double(t(cbind(x$xbreaks[-1], x$xbreaks[-1], \n> x$xbreaks[-1], x$xbreaks[-1])[keep,])),\n>  \n> as.double(t(cbind(rep(x$ybreaks[i],nxB-1),rep(x$ybreaks[i+1],nxB-1),rep(x$ybreaks[i+1],nxB-1),rep(x$ybreaks[i],nxB-1))[keep,])),\n>                 as.double(t(cbind(rep(0,nxB-1),    rep(0,nxB-1),  z[,i],   \n>  z[,i])[keep,])),\n>                                                                  col = \n> t(cbind(rgb[,i],rgb[,i],rgb[,i],rgb[,i])[keep,]))\n>     }\n>     if(!add) {\n>         if(is.null(zlim))\n>             zlim <- range(z, 0)\n>         if (missing(zlab))\n>             zlab <- if (!freq) \"Density\" else \"Frequency\"\n>         title3d(main = main, xlab = xlab, ylab = ylab, zlab = zlab)\n>         if(axes) {\n>            axes3d()\n>         }\n>         if(box) {\n>            box3d()\n>         }\n>     }\n>                  if (top) rgl.bringtotop()\n>                  invisible()\n> }\n> \n> \n> ============================================================================================\n> DISCLAIMER AND CONFIDENTIALITY CAUTION:\n> \n> This message and any attachments with it (the \"message\") are confidential and intended\n> solely for the addressees. Unauthorized reading, copying, dissemination, distribution or\n> disclosure either whole or partial, is prohibited. If you receive this message in error,\n> please delete it and immediately notify the sender. Communicating through email is not\n> secure and capable of interception, corruption and delays. Anyone communicating with The\n> Clearing Corporation of India Limited (CCIL) by email accepts the risks involved and their\n> consequences. The internet can not guarantee the integrity of this message. CCIL shall\n> (will) not therefore be liable for the message if modified. The recipient should check this\n> email and any attachments for the presence of viruses. CCIL accepts no liability for any\n> damage caused by any virus transmitted by this email.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
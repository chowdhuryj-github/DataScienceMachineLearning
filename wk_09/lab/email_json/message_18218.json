{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14386 - doc/trunk/design/syn", "body": "Author: larry\nDate: Fri Apr 27 17:08:44 2007\nNew Revision: 14386\n\nModified:\n   doc/trunk/design/syn/S02.pod\n   doc/trunk/design/syn/S12.pod\n\nLog:\nmore cleanup from TheDamian++\nthe ugly ::Animal initializers to .bless are gone; named args only bind params\nsub-blesses are now just initialized using our new autovivifiable protoobjects\n(.bless now allows those as positionals, in addition to the named args)\nautovivifiable protoobjects now specified with Animal{ :foo } notation\n\n\nModified: doc/trunk/design/syn/S02.pod\n==============================================================================\n--- doc/trunk/design/syn/S02.pod\t(original)\n+++ doc/trunk/design/syn/S02.pod\tFri Apr 27 17:08:44 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 10 Aug 2004\n-  Last Modified: 12 Apr 2007\n+  Last Modified: 27 Apr 2007\n   Number: 2\n-  Version: 101\n+  Version: 102\n \n This document summarizes Apocalypse 2, which covers small-scale\n lexical items and typological issues.  (These Synopses also contain\n@@ -1457,6 +1457,10 @@\n     GLOBAL::<$IN>       # Same as $*IN\n     Foo::<::Bar><::Baz> # same as Foo::Bar::Baz\n \n+The final C<::> is required here, because the C syntax\n+is reserved for defining an autovivifiable protoobject along with\n+it's initialization closure (see S12).\n+\n Unlike C<::()> symbolic references, this does not parse the argument\n for C<::>, nor does it initiate a namespace scan from that initial\n point.  In addition, for constant subscripts, it is guaranteed to\n\nModified: doc/trunk/design/syn/S12.pod\n==============================================================================\n--- doc/trunk/design/syn/S12.pod\t(original)\n+++ doc/trunk/design/syn/S12.pod\tFri Apr 27 17:08:44 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 27 Oct 2004\n-  Last Modified: 24 Apr 2007\n+  Last Modified: 27 Apr 2007\n   Number: 12\n-  Version: 47\n+  Version: 48\n \n =head1 Overview\n \n@@ -121,16 +121,17 @@\n Every object (including any class object) delegates to an instance of\n its metaclass.  You can get at the metaclass of any object via the\n C method.  A \"class\" object is just considered an \"empty\"\n-instance in Perl\u00a06, more properly called a \"prototype\" object.\n+instance in Perl\u00a06, more properly called a \"prototype\" object, or just\n+\"protoobject\".\n The actual class object is the metaclass object pointed to by the\n-C syntax.  So when you say \"Dog\", you're referring to both a\n-package and a prototype object, that latter of which points to the\n-actual object representing the class via C.  The prototype\n-object differs from an instance object not by having a different\n+C syntax.  So when you say \"C\", you're referring to both a\n+package and a protoobject, that latter of which points to the\n+actual object representing the class via C.  The protoobject\n+differs from an instance object not by having a different\n type but rather in the extent to which it is defined.  Some objects\n may tell you that they are defined, while others may tell you that\n they are undefined.  That's up to the object, and depends on how the\n-metaclass chooses to dispatch the .defined method.\n+metaclass chooses to dispatch the C<.defined> method.\n \n The notation C<^Dog> is syntactic sugar for C, so C<^> can be\n considered the \"class\" sigil when you want to talk about the current\n@@ -358,7 +359,7 @@\n Other OO languages give you the ability to declare \"class\" methods that either don't\n need or actively prohibit calls on instances.  Perl\u00a06 gives you a choice.\n If you declare an ordinary method, it can function as a \"class\" method when you\n-pass it a prototype object such as \"Dog\" regardless of how defined the prototype\n+pass it a protoobject such as \"C\" regardless of how defined the prototype\n object is, as long as the method body doesn't try to access any information that\n is undefined in the current instance.\n \n@@ -394,8 +395,9 @@\n \n Conjecture: in order to catch spelling errors it is a compile-time\n warning to define a submethod in any class that does not inherit the\n-corresponding method name from some base class.  (But note that the\n-standard C class supplies a default C and C.)\n+corresponding method name from some base class.  More importantly, this\n+would help safeguard Liskov substitutability. (But note that the\n+standard C class already supplies a default C and C.)\n \n =head1 Attributes\n \n@@ -538,8 +540,14 @@\n \n (The default C makes an opaque object.)\n \n-All arguments to this form of C must be named arguments, not\n-positional.\n+In addition to the candidate position argument, C also\n+allows one or more positional arguments representing autovivifying\n+protoobjects.  Such an object looks like a prototype followed by a\n+hash subscript (see \"Autovivifying objects\" below).  These are used\n+to initialize superclasses.\n+\n+Other than the candidate object and any autovivifying protoobjects,\n+all arguments to C must be named arguments, not positional.\n Hence, the main purpose of custom constructors is to turn positional\n arguments into named arguments for C.  The C method\n allows an object to be used for its class invocant.  (Your constructor\n@@ -563,19 +571,24 @@\n which initializes the object in least-derived to most-derived order.\n C and C work the same way, only in reverse.\n \n-The default C and C are inherited from C, so\n-you need to write initialization routines only if you wish to modify\n-the default behavior.  If the name of a named argument begins with a\n-C<::> and corresponds to a (super)class or role being built, the list value\n-of that argument is passed as a list of named arguments to that class\n-or role's C.  (If the value of that argument is a closure\n-instead of a list, that closure will be called to return a list.\n-The argument to that closure will be the name of the class currently\n-being initialized.)  In the absence of a class-labeled pair, all\n-the arguments to C are passed to the C.\n+The default C and C are inherited from C,\n+so you need to write initialization routines only if you wish to\n+modify the default behavior.  The C function automatically\n+passes the appropriate argument list to the C of its various\n+parent classes.  If the type of the parent class corresponds to one\n+of the protoobjects passed to bless, that protoobject's argument\n+list is used.  Otherwise all the arguments to bless are passed to\n+the parent class's C.  For the final C of the current\n+object, all the arguments to C are passed to the C, so\n+it can deal with any protoobjects that need special handling.  (It is\n+allowed to pass protoobjects that don't correspond to any parent class.)\n \n     class Dog is Animal {...}\n-    my $pet = Dog.new( :name, Animal => [:blood :legs(4)] );\n+    my $pet = Dog.new( :name, Animal{ :blood, :legs(4) } );\n+\n+Here we are using an autovivifying C protoobject to specify what\n+the arguments to C's C routine should look like.  (It does\n+not actually autovivify an C apart from the one being created.)\n \n You can clone an object, changing some of the attributes:\n \n@@ -1154,27 +1167,6 @@\n \n     proto method shake { warn \"They couldn't decide\" }\n \n-Conjectural: If the original invocant is in a variable that is\n-constrained to be of one role or another, then that type could be used\n-to dispatch to the correct role's method in cases where they can't\n-be distinguished by differences in the actual argument types:\n-\n-    class DogTree {\n-        does DogBark;\n-        does TreeBark;\n-        proto method bark {...}\n-        ...\n-    }\n-\n-    my DogBark $dog = new DogTree;\n-    my TreeBark $tree = new DogTree;\n-\n-    $dog.bark();        # picks Dog role's bark method\n-    $tree.bark();       # picks Tree role's bark method\n-\n-If there is such a mechanism, it may only be used as a tie-breaker.\n-Otherwise we break the normal polymorphism expectations.\n-\n Run-time mixins are done with C and C.  The C binary\n operator is a mutator that derives a new anonymous class (if necessary)\n and binds the object to it:\n@@ -1886,16 +1878,48 @@\n a method of a particular name if it's required and hasn't been supplied\n by the class or one of its roles.\n \n-Conjecture: The C property of an object is its autovivifying\n-closure.  Any undefined prototype object may carry such a closure that\n-can lazily create an object of the appropriate type.  For instance,\n+=head1 Autovivifying objects\n+\n+The C property of an object is its autovivifying closure.\n+Any undefined prototype object may carry such a closure that can\n+lazily create an object of the appropriate type.  When the closure\n+is eventually evaluated it is expected to return an argument list\n+corresponding to the arguments to a C<.bless> call.  For instance,\n a C routine, instead of creating a C object directly,\n could instead return something like:\n \n-    Dog but WHENCE({ .new(:name) })\n+    Dog but WHENCE({ :name })\n \n which runs the closure if the object ever needs to be autovivified.\n The closure can capture whatever initializers were available in the\n original lexical scope.\n \n+The short form of the above is simply:\n+\n+    Dog{ :name }\n+\n+This is still lazily evaluated:\n+\n+    my $dog = Dog{ :name };\n+    defined $dog or say \"doesn't exist\";  # Fido doesn't exist\n+    $dog.wag()                            # Fido wags his tail\n+\n+Note that when used as an argument to a method like C, the\n+protoobject is sufficiently lazy that autovivifying is done only by\n+the appropriate C routine.  It does not waste energy creating\n+a C object when that object's attributes would later have to be\n+copied into the actual object.\n+\n+The object autovivification syntax works only for literal named types,\n+so any indirection must be written more explicitly:\n+\n+    ::($dogproto){ :name }\n+    $dogproto but WHENCE({ :name })\n+    $dogproto.WHAT{ :name }\n+\n+Note that in contrast to this syntax, a lookup of a symbol in the C\n+package requires a final C<::> before the subscript:\n+\n+    Dog::{$varname}\n+\n =for vim:set expandtab sw=4:\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r22539 - in branches: SAMBA_3_0/source/lib/talloc\n\tSAMBA_3_0_25/source/lib/talloc SAMBA_4_0/source/lib/talloc", "body": "Author: jra\nDate: 2007-04-27 21:09:16 +0000 (Fri, 27 Apr 2007)\nNew Revision: 22539\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22539\n\nLog:\nAdded _strict varients of the talloc calls to\nreturn NULL on size == 0 varients.\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/lib/talloc/talloc.c\n   branches/SAMBA_3_0/source/lib/talloc/talloc.h\n   branches/SAMBA_3_0_25/source/lib/talloc/talloc.c\n   branches/SAMBA_3_0_25/source/lib/talloc/talloc.h\n   branches/SAMBA_4_0/source/lib/talloc/talloc.c\n   branches/SAMBA_4_0/source/lib/talloc/talloc.h\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/lib/talloc/talloc.c\n===================================================================\n--- branches/SAMBA_3_0/source/lib/talloc/talloc.c\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_3_0/source/lib/talloc/talloc.c\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -1087,6 +1087,28 @@\n }\n \n \n+/* \n+   talloc and zero memory. \n+   Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_zero_strict(const void *ctx, size_t size, const char *name)\n+{\n+\tvoid *p;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tp = _talloc_named_const(ctx, size, name);\n+\n+\tif (p) {\n+\t\tmemset(p, '\\0', size);\n+\t}\n+\n+\treturn p;\n+}\n+\n+\n /*\n   memdup with a talloc. \n */\n@@ -1102,6 +1124,26 @@\n }\n \n /*\n+  memdup with a talloc. \n+  Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_memdup_strict(const void *t, const void *p, size_t size, const char *name)\n+{\n+\tvoid *newp;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tnewp = _talloc_named_const(t, size, name);\n+\tif (likely(newp)) {\n+\t\tmemcpy(newp, p, size);\n+\t}\n+\n+\treturn newp;\n+}\n+\n+/*\n   strdup with a talloc \n */\n char *talloc_strdup(const void *t, const char *p)\n@@ -1282,6 +1324,23 @@\n }\n \n /*\n+  alloc an array, checking for integer overflow in the array size.\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_named_const(ctx, el_size * count, name);\n+}\n+\n+/*\n   alloc an zero array, checking for integer overflow in the array size\n */\n void *_talloc_zero_array(const void *ctx, size_t el_size, unsigned count, const char *name)\n@@ -1292,7 +1351,24 @@\n \treturn _talloc_zero(ctx, el_size * count, name);\n }\n \n+/*\n+  alloc an zero array, checking for integer overflow in the array size\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_zero_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n \n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_zero(ctx, el_size * count, name);\n+}\n+\n+\n /*\n   realloc an array, checking for integer overflow in the array size\n */\n@@ -1421,3 +1497,14 @@\n \t}\n \treturn 0;\n }\n+\n+/*\n+  Talloc wrapper that returns NULL if size == 0.\n+*/\n+void *talloc_strict(const void *context, size_t size, const char *name)\n+{\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\treturn _talloc_named_const(context, size, name);\n+}\n\nModified: branches/SAMBA_3_0/source/lib/talloc/talloc.h\n===================================================================\n--- branches/SAMBA_3_0/source/lib/talloc/talloc.h\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_3_0/source/lib/talloc/talloc.h\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -89,10 +89,16 @@\n #define talloc_new(ctx) talloc_named_const(ctx, 0, \"talloc_new: \" __location__)\n \n #define talloc_zero(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type)\n+/* Varient of talloc_zero that returns NULL if size is zero. */\n+#define talloc_zero_strict(ctx, type) (type *)_talloc_zero_strict(ctx, sizeof(type), #type)\n #define talloc_zero_size(ctx, size) _talloc_zero(ctx, size, __location__)\n \n #define talloc_zero_array(ctx, type, count) (type *)_talloc_zero_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_zero_array that returns NULL if count is zero. */\n+#define talloc_zero_array_strict(ctx, type, count) (type *)_talloc_zero_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array(ctx, type, count) (type *)_talloc_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_array that returns NULL if count is zero. */\n+#define talloc_array_strict(ctx, type, count) (type *)_talloc_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array_size(ctx, size, count) _talloc_array(ctx, size, count, __location__)\n #define talloc_array_ptrtype(ctx, ptr, count) (_TALLOC_TYPEOF(ptr))talloc_array_size(ctx, sizeof(*(ptr)), count)\n \n@@ -100,6 +106,8 @@\n #define talloc_realloc_size(ctx, ptr, size) _talloc_realloc(ctx, ptr, size, __location__)\n \n #define talloc_memdup(t, p, size) _talloc_memdup(t, p, size, __location__)\n+/* Varient of talloc_memdup that returns NULL if count is zero. */\n+#define talloc_memdup_strict(t, p, size) _talloc_memdup_strict(t, p, size, __location__)\n \n #define talloc_set_type(ptr, type) talloc_set_name_const(ptr, #type)\n #define talloc_get_type(ptr, type) (type *)talloc_check_name(ptr, #type)\n@@ -169,6 +177,6 @@\n void *talloc_find_parent_byname(const void *ctx, const char *name);\n void talloc_show_parents(const void *context, FILE *file);\n int talloc_is_parent(const void *context, const void *ptr);\n+void *talloc_strict(const void *context, size_t size, const char *name);\n \n #endif\n-\n\nModified: branches/SAMBA_3_0_25/source/lib/talloc/talloc.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/lib/talloc/talloc.c\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_3_0_25/source/lib/talloc/talloc.c\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -1087,6 +1087,28 @@\n }\n \n \n+/* \n+   talloc and zero memory. \n+   Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_zero_strict(const void *ctx, size_t size, const char *name)\n+{\n+\tvoid *p;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tp = _talloc_named_const(ctx, size, name);\n+\n+\tif (p) {\n+\t\tmemset(p, '\\0', size);\n+\t}\n+\n+\treturn p;\n+}\n+\n+\n /*\n   memdup with a talloc. \n */\n@@ -1102,6 +1124,26 @@\n }\n \n /*\n+  memdup with a talloc. \n+  Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_memdup_strict(const void *t, const void *p, size_t size, const char *name)\n+{\n+\tvoid *newp;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tnewp = _talloc_named_const(t, size, name);\n+\tif (likely(newp)) {\n+\t\tmemcpy(newp, p, size);\n+\t}\n+\n+\treturn newp;\n+}\n+\n+/*\n   strdup with a talloc \n */\n char *talloc_strdup(const void *t, const char *p)\n@@ -1282,6 +1324,23 @@\n }\n \n /*\n+  alloc an array, checking for integer overflow in the array size.\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_named_const(ctx, el_size * count, name);\n+}\n+\n+/*\n   alloc an zero array, checking for integer overflow in the array size\n */\n void *_talloc_zero_array(const void *ctx, size_t el_size, unsigned count, const char *name)\n@@ -1292,7 +1351,24 @@\n \treturn _talloc_zero(ctx, el_size * count, name);\n }\n \n+/*\n+  alloc an zero array, checking for integer overflow in the array size\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_zero_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n \n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_zero(ctx, el_size * count, name);\n+}\n+\n+\n /*\n   realloc an array, checking for integer overflow in the array size\n */\n@@ -1421,3 +1497,14 @@\n \t}\n \treturn 0;\n }\n+\n+/*\n+  Talloc wrapper that returns NULL if size == 0.\n+*/\n+void *talloc_strict(const void *context, size_t size, const char *name)\n+{\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\treturn _talloc_named_const(context, size, name);\n+}\n\nModified: branches/SAMBA_3_0_25/source/lib/talloc/talloc.h\n===================================================================\n--- branches/SAMBA_3_0_25/source/lib/talloc/talloc.h\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_3_0_25/source/lib/talloc/talloc.h\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -85,10 +85,16 @@\n #define talloc_new(ctx) talloc_named_const(ctx, 0, \"talloc_new: \" __location__)\n \n #define talloc_zero(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type)\n+/* Varient of talloc_zero that returns NULL if size is zero. */\n+#define talloc_zero_strict(ctx, type) (type *)_talloc_zero_strict(ctx, sizeof(type), #type)\n #define talloc_zero_size(ctx, size) _talloc_zero(ctx, size, __location__)\n \n #define talloc_zero_array(ctx, type, count) (type *)_talloc_zero_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_zero_array that returns NULL if count is zero. */\n+#define talloc_zero_array_strict(ctx, type, count) (type *)_talloc_zero_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array(ctx, type, count) (type *)_talloc_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_array that returns NULL if count is zero. */\n+#define talloc_array_strict(ctx, type, count) (type *)_talloc_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array_size(ctx, size, count) _talloc_array(ctx, size, count, __location__)\n #define talloc_array_ptrtype(ctx, ptr, count) (_TALLOC_TYPEOF(ptr))talloc_array_size(ctx, sizeof(*(ptr)), count)\n \n@@ -96,6 +102,8 @@\n #define talloc_realloc_size(ctx, ptr, size) _talloc_realloc(ctx, ptr, size, __location__)\n \n #define talloc_memdup(t, p, size) _talloc_memdup(t, p, size, __location__)\n+/* Varient of talloc_memdup that returns NULL if count is zero. */\n+#define talloc_memdup_strict(t, p, size) _talloc_memdup_strict(t, p, size, __location__)\n \n #define talloc_set_type(ptr, type) talloc_set_name_const(ptr, #type)\n #define talloc_get_type(ptr, type) (type *)talloc_check_name(ptr, #type)\n@@ -165,6 +173,6 @@\n void *talloc_find_parent_byname(const void *ctx, const char *name);\n void talloc_show_parents(const void *context, FILE *file);\n int talloc_is_parent(const void *context, const void *ptr);\n+void *talloc_strict(const void *context, size_t size, const char *name);\n \n #endif\n-\n\nModified: branches/SAMBA_4_0/source/lib/talloc/talloc.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/talloc/talloc.c\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_4_0/source/lib/talloc/talloc.c\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -1087,6 +1087,28 @@\n }\n \n \n+/* \n+   talloc and zero memory. \n+   Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_zero_strict(const void *ctx, size_t size, const char *name)\n+{\n+\tvoid *p;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tp = _talloc_named_const(ctx, size, name);\n+\n+\tif (p) {\n+\t\tmemset(p, '\\0', size);\n+\t}\n+\n+\treturn p;\n+}\n+\n+\n /*\n   memdup with a talloc. \n */\n@@ -1102,6 +1124,26 @@\n }\n \n /*\n+  memdup with a talloc. \n+  Strict version - returns NULL if size is zero.\n+*/\n+void *_talloc_memdup_strict(const void *t, const void *p, size_t size, const char *name)\n+{\n+\tvoid *newp;\n+\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tnewp = _talloc_named_const(t, size, name);\n+\tif (likely(newp)) {\n+\t\tmemcpy(newp, p, size);\n+\t}\n+\n+\treturn newp;\n+}\n+\n+/*\n   strdup with a talloc \n */\n char *talloc_strdup(const void *t, const char *p)\n@@ -1282,6 +1324,23 @@\n }\n \n /*\n+  alloc an array, checking for integer overflow in the array size.\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_named_const(ctx, el_size * count, name);\n+}\n+\n+/*\n   alloc an zero array, checking for integer overflow in the array size\n */\n void *_talloc_zero_array(const void *ctx, size_t el_size, unsigned count, const char *name)\n@@ -1292,7 +1351,24 @@\n \treturn _talloc_zero(ctx, el_size * count, name);\n }\n \n+/*\n+  alloc an zero array, checking for integer overflow in the array size\n+  Strict version - returns NULL if count or el_size are zero.\n+*/\n+void *_talloc_zero_array_strict(const void *ctx, size_t el_size, unsigned count, const char *name)\n+{\n+\tif (count >= MAX_TALLOC_SIZE/el_size) {\n+\t\treturn NULL;\n+\t}\n \n+\tif (el_size == 0 || count == 0) {\n+\t\treturn NULL;\n+\t}\n+\n+\treturn _talloc_zero(ctx, el_size * count, name);\n+}\n+\n+\n /*\n   realloc an array, checking for integer overflow in the array size\n */\n@@ -1421,3 +1497,14 @@\n \t}\n \treturn 0;\n }\n+\n+/*\n+  Talloc wrapper that returns NULL if size == 0.\n+*/\n+void *talloc_strict(const void *context, size_t size, const char *name)\n+{\n+\tif (unlikely(size == 0)) {\n+\t\treturn NULL;\n+\t}\n+\treturn _talloc_named_const(context, size, name);\n+}\n\nModified: branches/SAMBA_4_0/source/lib/talloc/talloc.h\n===================================================================\n--- branches/SAMBA_4_0/source/lib/talloc/talloc.h\t2007-04-27 17:35:15 UTC (rev 22538)\n+++ branches/SAMBA_4_0/source/lib/talloc/talloc.h\t2007-04-27 21:09:16 UTC (rev 22539)\n@@ -89,10 +89,16 @@\n #define talloc_new(ctx) talloc_named_const(ctx, 0, \"talloc_new: \" __location__)\n \n #define talloc_zero(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type)\n+/* Varient of talloc_zero that returns NULL if size is zero. */\n+#define talloc_zero_strict(ctx, type) (type *)_talloc_zero_strict(ctx, sizeof(type), #type)\n #define talloc_zero_size(ctx, size) _talloc_zero(ctx, size, __location__)\n \n #define talloc_zero_array(ctx, type, count) (type *)_talloc_zero_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_zero_array that returns NULL if count is zero. */\n+#define talloc_zero_array_strict(ctx, type, count) (type *)_talloc_zero_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array(ctx, type, count) (type *)_talloc_array(ctx, sizeof(type), count, #type)\n+/* Varient of talloc_array that returns NULL if count is zero. */\n+#define talloc_array_strict(ctx, type, count) (type *)_talloc_array_strict(ctx, sizeof(type), count, #type)\n #define talloc_array_size(ctx, size, count) _talloc_array(ctx, size, count, __location__)\n #define talloc_array_ptrtype(ctx, ptr, count) (_TALLOC_TYPEOF(ptr))talloc_array_size(ctx, sizeof(*(ptr)), count)\n \n@@ -100,6 +106,8 @@\n #define talloc_realloc_size(ctx, ptr, size) _talloc_realloc(ctx, ptr, size, __location__)\n \n #define talloc_memdup(t, p, size) _talloc_memdup(t, p, size, __location__)\n+/* Varient of talloc_memdup that returns NULL if count is zero. */\n+#define talloc_memdup_strict(t, p, size) _talloc_memdup_strict(t, p, size, __location__)\n \n #define talloc_set_type(ptr, type) talloc_set_name_const(ptr, #type)\n #define talloc_get_type(ptr, type) (type *)talloc_check_name(ptr, #type)\n@@ -169,6 +177,6 @@\n void *talloc_find_parent_byname(const void *ctx, const char *name);\n void talloc_show_parents(const void *context, FILE *file);\n int talloc_is_parent(const void *context, const void *ptr);\n+void *talloc_strict(const void *context, size_t size, const char *name);\n \n #endif\n-\n\n"}
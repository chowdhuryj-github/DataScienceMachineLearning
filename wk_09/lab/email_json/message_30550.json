{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: explicit line termination with \";\": why?", "body": "Larry Wall wrote:\n> Dave Whipp wrote:\n> : A slightly tangental thought: is the behavior of C with no block\n> : defined? I.e. is\n>\n> It would be illegal syntax currently.\n\nAs I understand it, the proposal is to say that if the parser finds a\n';' where it was expecting to find a control block, it treats the rest\nof the current block as the expected control block - or something to\nthat effect.  Eh... messy, and with no substantial gain.\n\n> : given $foo { when 1 {...} };\n> :\n> : equivalent to\n> :\n> : given $foo;\n> : when 1 {...};\n>\n> Both of these suggestions would seem to duplicate the existing construct:\n>\n>     $_ = $foo;\n>\n> :-)\n\nAgreed.  But I think that postfix: is rather clean:\n\n    $foo?\n    when 1 {...}\n\nTwo catches:\n\n1. I could easily define postfix: myself, save for one thing: what\nwould I put as the parameter for the 'is equiv' trait, so that it has\nterminator precedence?\n\n2. 'when' implicitly leaves its current block after successfully being\nexecuted (as per 'last'), since it's designed primarily for use as one\nof a set of mutually-exclusive options.  I'm not sure how wise of a\ndecision that is, since it's easier to add a \"last\" to a block that\nimplicitly lacks one than it is to remove a \"last\" from a block that\nimplicitly includes one.  Part of me would strongly prefer that \"when\n$x { ... }\" be exactly equivalent to \"if $_ ~~ $x { ... }\", except for\nthe inability to append an else block to the former.\n\n> Of course, now someone will argue that unary:<=> should assign to $_ by\n> default, in which case we'd have to find a new iteration operator...\n\nHorrors, no!  '=$filehandle' works just fine for reading an iterator,\nthank you...\n\nI _might_ flirt with the idea of postfix:<=> being equivalent to a\nfilehandle's '.say' method (i.e., writing to an iterator) - or not.\nGiven the mandatory whitespace that a postfix operator imposes on an\nequivalent infix operator, I'd strongly suggest that good practice for\nPerl 6 would be to avoid defining both forms if at all reasonable; and\ninfix:<=> definitely has the edge here.  (Rule of thumb: if you can\navoid doing something that will mandate or forbid whitespace, avoid\nit.)\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
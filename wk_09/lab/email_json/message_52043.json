{"category": "ham", "to_address": "p2 <parrot-porters@perl.org>, Andy Lester <andy@petdance.com>", "from_address": "jerry gay <jerry.gay@gmail.com>", "subject": "Fwd: r19207 - in trunk: compilers/imcc config/gen/makefiles tools/build", "body": "---------- Forwarded message ----------\nFrom: petda...@cvs.perl.org\nDate: Jun 20, 8:59 pm\nSubject: r19207 - in trunk: compilers/imcc config/gen/makefiles tools/\nbuild\nTo: perl.cvs.parrot\n\n\nAuthor: petdance\nDate: Wed Jun 20 20:58:59 2007\nNew Revision: 19207\n\nModified:\n   trunk/compilers/imcc/imcparser.c\n   trunk/compilers/imcc/instructions.c\n   trunk/compilers/imcc/instructions.h\n   trunk/compilers/imcc/parser_util.c\n   trunk/compilers/imcc/unit.h\n   trunk/config/gen/makefiles/root.in\n   trunk/tools/build/headerize.pl\n\nLog:\nheaderized instructions.c\n\n\nModified: trunk/compilers/imcc/instructions.c\n==============================================================================\n--- trunk/compilers/imcc/instructions.c (original)\n+++ trunk/compilers/imcc/instructions.c Wed Jun 20 20:58:59 2007\n@@ -29,10 +29,13 @@\n int n_comp_units;\n #endif\n\n+/* HEADERIZER TARGET: compilers/imcc/instructions.h */\n\n+/* HEADERIZER BEGIN: static */\n static int e_file_open(Interp *, void *);\n static int e_file_close(Interp *, void *);\n static int e_file_emit(Interp *, void *param, IMC_Unit *, Instruction\n*);\n+/* HEADERIZER END: static */\n\n Emitter emitters[2] = {\n     {e_file_open,\n@@ -121,7 +124,7 @@\n  * Returns TRUE if instruction ins reads from a register of type t\n  */\n int\n-ins_reads2(Instruction *ins, int t)\n+ins_reads2(Instruction *ins /*NN*/, int t)\n {\n     size_t i, idx;\n     const char types[] = \"INPS\";\n@@ -167,19 +170,15 @@\n /* next 2 functions are called very often, says gprof\n  * they should be fast\n  */\n-#ifdef HAS_INLINE\n-inline\n-#endif\n-int\n-instruction_reads(Instruction* ins, SymReg* r) {\n+inline int\n+instruction_reads(Instruction *ins /*NN*/, SymReg *r) {\n     int f, i;\n     SymReg *key;\n-    SymReg *ri;\n\n     if (ins->opnum == PARROT_OP_set_args_pc ||\n             ins->opnum == PARROT_OP_set_returns_pc) {\n         for (i = 0; i < ins->n_r; i++) {\n-            ri = ins->r[i];\n+            const SymReg * const ri = ins->r[i];\n             if (ri == r)\n                 return 1;\n         }\n@@ -192,7 +191,7 @@\n     f = ins->flags;\n     for (i = 0; i < ins->n_r; i++) {\n         if (f & (1<r[i];\n+            const SymReg * const ri = ins->r[i];\n             if (ri == r)\n                 return 1;\n             /* this additional test for _kc ops seems to slow\n@@ -220,10 +219,7 @@\n     return 0;\n }\n\n-#ifdef HAS_INLINE\n-inline\n-#endif\n-int\n+inline int\n instruction_writes(Instruction* ins, SymReg* r) {\n     int f, i;\n\n\nremember the days when we were C89 compliant? i do.\nin fact, my compiler still lives in those days.\n'inline' is a swear word.\n\nsince compilers don't have earmuffs, i had to make some.\nhow about\n  #ifndef HAS_INLINE\n  #  define inline\n  #endif\n\ni even put it in parrot.h so it'll work everywhere. see r19212.\n~jerry\n\n"}
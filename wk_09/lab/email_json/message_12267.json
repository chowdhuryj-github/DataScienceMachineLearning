{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>", "from_address": "Joshua Isom <jrisom@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "\nOn Apr 21, 2007, at 8:24 PM, chromatic wrote:\n\n> Parrot_alloc_context() performs some calculations about the number of\n> registers used to determine how much memory to allocate:\n>\n>     const size_t size_n = sizeof (FLOATVAL) * n_regs_used[REGNO_NUM];\n>     const size_t size_nip = size_n +\n>         sizeof (INTVAL) *   n_regs_used[REGNO_INT] +\n>         sizeof (PMC*) *     n_regs_used[REGNO_PMC];\n>     size_t reg_alloc = size_nip +\n>         sizeof (STRING*) *  n_regs_used[REGNO_STR];\n>\n> Then it calculates a slot value:\n>\n>     const int slot = (reg_alloc + 7) >> 3;\n>     reg_alloc = slot << 3;\n>\n> This is where I start not to understand.  Why reg_alloc + 7?  Why \n> shift left\n> and right by 3?\n>\n\nI'm not sure if it is actually doing anything that needs to be that \ncomplicated to code that way.  It could be able to be written as:\n\n     const int slot = (reg_alloc + 7) / 8; /* divide by eight for some \nreason and round up on remainder */\n     reg_alloc = slot * 8; /* reg_alloc is now evenly divisible by 8 */\n\nThe difference is that if any of the last three bits are set, the +7 \nwill let it round up, whereas without it it would round down.  That's \nwhat it does, don't ask me why(other than maybe guaranteeing \nalignment?).  Might be using eight for an eight byte int, but if so, it \nshould be using sizeof(void *) instead, I'm assuming would have been \nused.  Now, slot is multiplied by sizeof(void*) later on, which may be \nwhy it's divided by eight in the first place.\n\nThe n = slot + 1 I find a little odd, because the number is already \nrounded up, so it's rounding up and then adding an extra place of \nmemory.\n\n> It gets less clear.  The interpreter holds a structure for context \n> memory with\n> a free list (an array of void pointers) and the number of free slots,\n> presumably in this list.\n>\n> After all of that calculation of slot, the function uses it as an \n> index into\n> the free list.\n>\n> I don't understand that at all.\n>\n> I do understand the purpose of the resizing code, but not how slot \n> relates to\n> it:\n>\n>     if (slot >= interp->ctx_mem.n_free_slots) {\n>         const int n = slot + 1;\n>         int i;\n>\n>         interp->ctx_mem.free_list = (void **)mem_sys_realloc(\n>                 interp->ctx_mem.free_list, n * sizeof (void*));\n>\n>         for (i = interp->ctx_mem.n_free_slots; i < n; ++i)\n>             interp->ctx_mem.free_list[i] = NULL;\n>         interp->ctx_mem.n_free_slots = n;\n>     }\n>\n> This is doubly weird because when Parrot initializes the free list in\n> create_initial_context(), it allocates a small number of free slots:\n>\n> #define INITIAL_FREE_SLOTS 8\n>\n>     interp->ctx_mem.n_free_slots = INITIAL_FREE_SLOTS;\n>     interp->ctx_mem.free_list    =\n>         (void **)mem_sys_allocate(INITIAL_FREE_SLOTS * sizeof (void \n> *));\n>\n>     for (i = 0; i < INITIAL_FREE_SLOTS; ++i)\n>         interp->ctx_mem.free_list[i] = NULL;\n>\n> The result is that the free_list extends quite a bit over the initial\n> allocation, but it's mostly just an array of null.  It's fairly sparse \n> apart\n> from that.\n>\n> Here's another curious thing when allocating a context:\n>\n>     ptr = interp->ctx_mem.free_list[slot];\n>     old = CONTEXT(interp->ctx);\n>     if (ptr) {\n>         interp->ctx_mem.free_list[slot] = *(void **) ptr;\n>     }\n>\n> I wish I could tell you what the assignments to and from ptr do here, \n> but I\n> can't, nor what they signify.  There's a similar form to free a \n> context:\n>\n>         ptr = ctxp;\n>         slot = ctxp->regs_mem_size >> 3;\n>\n>         assert(slot < interp->ctx_mem.n_free_slots);\n>         *(void **)ptr = interp->ctx_mem.free_list[slot];\n>         interp->ctx_mem.free_list[slot] = ptr;\n>\n\nThe *(void **) has been confusing me for a long time.  It's also in \nsmallobject.c where a seg fault sometimes happens.  But I've never been \nable to find out how to decipher it.  I can look at the dump of it with \n`objdump -dS src/gc/smallobject.c` but still get lost in it \nall(although looking at assembly, even intermixed with source code, \nrequires a little too much of an understanding of the machine to figure \nout).\n\n> I originally thought the free_list was an array of recycled contexts \n> to avoid\n> malloc() and free() pairs by reusing already-allocated-but-unused \n> memory, but\n> now I can't tell what it's doing.  I tried to change this into a \n> linked list,\n> but that failed with invalid reads.\n>\n\nI thought it was a list of items to be freed, but that may be a \ndifferent free_list sadly.  We have more than one in parrot.\n\n> My best guess is that this is an odd way to store contexts of a \n> specific size\n> in an array structure so that they're reusable with our new \n> variable-sized\n> register sets... but the code is unclear and undocumented.  I think \n> it's also\n> leaking memory.\n>\n\nEnable the context alloc and free, but probably change what's printed \nto make it easy to run through sort, and it might help, maybe.\n\n> I'd like to find a simpler scheme, if it's possible.  Otherwise, I'd \n> like to\n> figure out what's going on so we can at least explain it somehow.\n>\n> -- c\n>\n>\n\nRule one of writing in C for a project for many people to code, \ndocument the (you decide the explicative) out of it.\n\n"}
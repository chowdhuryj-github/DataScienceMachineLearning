{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "\"Charles C. Berry\" <cberry@tajo.ucsd.edu>", "subject": "Re: [R] Randomising matrices", "body": "Nick Cutler  sms.ed.ac.uk> writes:\n\n> \n> I would like to be able to randomise presence-absence (i.e. binary) \n> matrices whilst keeping both the row and column totals constant. Is \n> there a function in R that would allow me to do this?\n> \n> I'm working with vegetation presence-absence matrices based on field \n> observations. The matrices are formatted to have sites as rows and \n> species as columns. The presence of a species on a site is indicated \n> with a 1 (absence is obviously indicated with a 0).\n> \n> I would like to randomise the matrices many times in order to construct \n> null models. However, I cannot identify a function in R to do this, and \n> the programming looks tricky for someone of my limited skills.\n> \n> Can anybody help me out?\n\nNick,\n\nFor a 1001 x 1001 matrix, this method takes less than 2 seconds on my 2 year old\nWindows PC.\n\nronetab( marg1, marg2 ) returns a table of 0's and 1's according to the marginal\ncontraints. \n\nck.ronetab( marg1, marg2 ) checks that all the constraints were honored.\n\n\nmsample <- function(x,marg)\n{\n  ## Purpose: sample at most one each from each cell of a margin\n  ## ----------------------------------------------------------------------\n  ## Arguments: x - number to sample, marg - a vector of integers\n  ## ----------------------------------------------------------------------\n  ## Author: Charles C. Berry, Date: 28 Apr 2007, 08:17\n  ## GPL 2.0 or better\n\n  if (!(x<=sum(marg) && all(marg>=0))) browser()\n  wm <- which(marg!=0)\n  if (length(wm)==1) {\n    wm\n  } else {\n    sample( seq(along=marg), x, prob=marg )\n  }\n}\n\nronetab <- function(m1,m2,debug=F)\n{\n  ## Purpose: sample from a table with fixed margins and {0,1} cell values\n  ## ----------------------------------------------------------------------\n  ## Arguments: m1, m2 - two margins\n  ## ----------------------------------------------------------------------\n  ## Author: Charles C. Berry, Date: 28 Apr 2007, 08:21\n  ## GPL 2.0 or better\n\n  stopifnot( sum(m1)==sum(m2)|| max(m1)>length(m2) || max(m2)>length(m1) )\n  \n  i.list <- j.list <- list()\n  k <- 0\n  while( sum(m1)>0 ){\n    k <- k+1\n    if ( sum(m1!=0) > sum(m2!=0) ){\n      i <- which.max( m1)\n      j <- msample( m1[i], m2 )\n      i.list[[ k ]] <- rep( i, m1[i] )\n      j.list[[ k ]] <- j\n      m1[i] <- 0\n      m2[ j ] <- m2[ j ] - 1\n    } else {\n      j <- which.max( m2 )\n      i <- msample( m2[j], m1 )\n      i.list[[ k ]] <- i\n      j.list[[ k ]] <- rep( j, m2[j] )\n      m2[j] <- 0\n      m1[ i ] <- m1[ i ] - 1\n    }\n  }\n  res <- array(0, c(length(m1), length(m2) ) )\n  res[ cbind( unlist(i.list), unlist(j.list) ) ] <- 1\n  res\n}\n\nck.ronetab <- function(m1,m2){\n  tab <- ronetab(m1,m2)\n  m1.ck <- all(m1==rowSums(tab))\n  m2.ck <- all(m2==colSums(tab))\n  cell.ck <- all( tab %in% 0:1 )\n  res <- m1.ck & m2.ck & cell.ck\n  if (!res) attr(res,\"tab\") <- tab\n  res\n}\n\nI'll warn you that I have not worked through what looks to be a tedious proof\nthat this randomly samples matrices under the constraints. The heuristics seem\nright, and a few simulation spot checks look reasonable. If you do not want to\ntrust it, you can still use it to generate a starting value for an MCMC run.\n\nHTH,\n\nChuck\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
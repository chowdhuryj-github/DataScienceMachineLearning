{"category": "ham", "to_address": "Allison Randal <allison@perl.org>", "from_address": "Jonathan Worthington <jonathan@jnthn.net>", "subject": "Re: PMC Proxy high-level review", "body": "Hi,\n\nAllison Randal wrote:\n> It looks like every low-level PMC is creating a proxy object for \n> itself and these proxies are stored in the interpreter global \n> parrot_interp_t.\nThat's what's implemented, yes. I pondered hanging them off the v-table \ntoo. That's perhaps more desirable.\n\n> I intended that proxies would only be created when they were needed by \n> a subclassing Class PMC, and would only be stored in the Class PMC.\nI don't think this is the way to go.\n\n1) It'd be good to be able to use the get_class opcode with PMCs as well \nas PDD15 classes. For that to Just Work, you need something hanging off \nthe class slot of the appropriate namespace. That something is the \nPMCProxy. Thus it needs to be there from the start.\n\n2) It's desirable that there is only ever one instance of PMCProxy per \nPMC. Then \"is this the same class\" is just a case of checking the \npointers, as with PDD15 classes. Plus memory issues.\n\n3) At the moment method lookup (for non-vtable methods, of course) is \ndone through the namespace. We moved away from that in PDD15 classes, \nand with PMCProxy can do the same for methods of PMCs too. If you want \nto be able to have a list of methods inside PMCProxy, you need it stored \nsomewhere runtime-accessible. If you're going to hang that data \nsomewhere, why not just make the PMCProxy in the first place and store \nit in there.\n\n4) PMCProxy also allows introspection of PMCs, not just placing them in \nan inheritance hierarchy.\n\n5) It's just less code complexity to create them up-front.\n\nWhat was the motivation for having them instantiated lazily?\n\n> Looking at the code from another perspective, though, maybe what we've \n> got here is the beginning of an \"HLLSubclassable\" role that adds a \n> handful of Class methods to low-level PMCs.\nI wander if we have different thoughts of what PMCProxy is supposed to \nachieve. Here's what I thought: when you have a PDD15 class, you have \nthe instance of Class and you have the instance of Object. For PMCs, you \nhave the second of these - an instance of the PMC. PMCProxy fills in the \ngap - it's like the Class PMC for PDD15, only for PMCs rather than PDD15 \nclasses.\n\n> Ultimately all PMCs need to be able to respond to inspect_str. \nYeah, but there you're inspecting the object, not the class. Those are \ndifferent, I think?\n\n> And ultimately, all PMCs need to have an entry in their NameSpace so \n> the type IDs can go away entirely. \nThey already do, and by hanging PMCProxy off the class slot in the \nNameSpace PMC, we're a step closer to that, if it's the Right Thing to do.\n\nThanks,\n\nJonathan\n\n"}
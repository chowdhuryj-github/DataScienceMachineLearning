{"category": "ham", "to_address": "\"gabriele renzi\" <surrender_it@rc.europe.yahoo-eu1.akadns.net>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: explicit line termination with \";\": why?", "body": "gabriele renzi wrote:> Hi everyone,>> I don't want to argue about the design of perl6, I just wonder: why> the semicolon is still needed in the end of lines in perl6?\nIt isn't - sometimes.  S03 identifies a number of ways that anexpression can be terminated: the semicolon (';'), a block-final('}'), a control block (' { ... }'), a statement modifier('if'|'unless'|'while'|'until'|'for'|'given'|'when')^, or a feedoperator ('<<==', '<==', '==>', '==>>').\n^ FWIW, S03 needs updating, since it doesn't list 'given' or 'when'among the statement modifiers in the block termination section.\nA couple of thoughts:\n1. There's a subtlety here: termination of an expression is not alwaysthe same as termination of a statement.  In particular, ';' is prettymuch equivalent to the '<==' feed operator when used in a bracketingconstruct [1]^, and feed operators in general don't appear to forcestatement termination the way that control blocks, statementmodifiers, and block-finals do.  Of course, this distinction may be memisunderstanding how expression termination works.\n2. This brings up the possibility of custom-designed terminationoperators.  Question: which kinds of operators can have thisprecedence?  That is, prefix, postfix, infix, circumfix, orpostcircumfix?  It appears to me that our current list of terminationoperators includes analogs of most of these: postfix:<;>,infix:{'<=='}, circumfix:<{ }>, and postcircumfix:\u00ab\\s{ }\u00bb [2]^.\n   Meanwhile, how much clarity does the parser have between postfixand infix?  That is, if I defined both postfix: and infix:,would the parser be able to reliably distinguish between them?  Thismatters to the current topic because ';' could be thought of as'postfix-like' when used to terminate a statement, and 'infix-like'when being used to construct feeds; if clarity between postfix andinfix exists, you might be able to do away with the \"bracketedcontext\" clause - though it might not be wise to do so, even if youcould.)\n   I'm thinking about this in terms of the possibility of adding morepunctuation to the syntax: consider something akin to a postfix:operator that behaves exactly like postfix:<;>, except that itautomatically topicalizes the expression's value.  Or a postfix:<.>that always behaves the way that postfix:<;> does at statement level[3]^.  Borrowing from Spanish, circumfix:<\u00bf ?> might be tocircumfix:<{ }> as postfix: would be to postfix:<;>.  And so on.\n   As long as we maintain clarity between the grammatical categories,such \"punctuation operators\" shouldn't present any difficulty; e.g.,postfix: will not clobber prefix: or vice versa, even if theformer has terminator precedence and the latter has symbolic unaryprecedence.\n   Or is this the sort of thing that you'd rather consign to explicithacks of the parser?\n^[1]: see S09.^[2]: Admittedly, this last one cheats a bit by putting whitespaceinto the delimiter.  But the principle is the same.^[3]: If this were included in the core, you might even reverse thingsso that ';' is defined in terms of postfix:<.> or infix:{'<=='},depending on the context; in this case, postfix: would be definedin terms of postfix:<.>, rather than postfix:<;>.  In fact, the onlything keeping postfix:<.> from completely replacing postfix:<;> as astatement terminator and insisting that the latter always be used as ashortcut for feeds is the long tradition that the latter has inprogramming languages - much like perl 6's infix:<.> replaces perl 5's'->' because that's what everyone else uses.\n-- Jonathan \"Dataweaver\" Lang\n\n"}
{"category": "ham", "to_address": "Mark Glines <mark@glines.org>", "from_address": "Bernhard Schmalhofer <Bernhard.Schmalhofer@gmx.de>", "subject": "Re: [perl #42883] [PATCH] Fix up headerfile guards", "body": "Mark Glines schrieb:\n>>> * Fix up the indentation problems caused by the above bullet point.\n>>> (TODO: why does t/codingstd/c_indent.t require indentation for #if\n>>> and #ifdef, but not for #ifndef?)\n>>>       \n>> As far as I understand c_indent.t, #ifndef is also covered\n>>     \n>\n> Except that it isn't.  If you apply the attached patch, you will see\n> that t/codingstd/c_indent.t starts failing.  C_indent.t will not be\n> happy until you reindent everything else, inside of it.  (This patch\n> should not be checked in, it only exhibits the problem, it does not\n> solve anything.)\n>\n>   \nAfter applying c_indent_doesnt_recognise_ifndef.diff\nI got no complaints from c_indent.t.\nCould you check again?\n\nIn r18452 I checked in a small beautification of c_indent.t, which shouldn't\nhave chaned the algorithm.\n\n\nOn Sat, 05 May 2007 07:58:45 -0700\n\"Bernhard Schmalhofer via RT\"  wrote:\n\n>   \n>>> I'd like to write some tests for this stuff, and then fix up the\n>>> rest of the cases (I know I've missed a bunch).  How would the list\n>>> feel about a patch to PDD07 specifying the above for header files,\n>>> and a codingstd test to enforce it?\n>>>       \n>> My feeling is that we need to differentiate two cases:\n>> i. header files that define an interfaces for e.g. a subsystem\n>> ii. Convenience headers, that contain declaration of internal\n>> functions\n>>\n>> Case i. might need stricter checks than ii.\n>>     \n>\n>\n> Thanks for your input.  I have written a test case for this,\n> t/codingstd/c_header_guards.t (attached), which checks the following:\n>\n> * The existence of an #ifndef PARROT_*_GUARD\n> * That each header file only contains one #ifndef PARROT_*_GUARD\n> * The existence of a matching #define (this caught a few misspells)\n> * The existence of an #endif /* PARROT_*_GUARD */\n> * That the PARROT_*_GUARD macro is unique (doesn't stomp on any other\n> files)\n>\n> I patched up another large set of headers, to pass this test.  But\n> before I send in another big patch with some changes to type ii\n> (\"convenience\") headers, can you please tell me if there's a clean,\n> programmatic way to determine which headers it should perform strict\n> checks on?  That way I can fix the test to only run on the\n> non-\"convenience\" subset of headers.\n>   \nIMHO the above tests looks quite sane for all header files.\n\nFor API defining headers I was vaguely pondering a check like.\n  \"Make sure that the API does not change, unless there has been a\n   deprecation cycle.\"\nThis might be along the lined of 'tools/dev/parrot_api.pl'.\n\n> Also, should any of the above tests be applied to type ii headers, or\n> should they only apply to type i headers?  (Should type ii headers be\n> ignored completely, or only subjected to a subset of the tests?)\n>   \nChecking for header guards in  all *.h files sounds good to me.\n\nRegards,\n  Bernhard\n\n"}
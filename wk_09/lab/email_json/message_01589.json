{"category": "ham", "to_address": "beginners@perl.org", "from_address": "\"Jan Chorowski\" <jan.chorowski@gmail.com>", "subject": "Trouble with backtracking in RE", "body": "Hi,\n\nI can't understand why the following regexp matches. It was part of a\nlarger program transformig c++ files:\n\nWhen running:\n\n#!/usr/bin/perl\n\"dummy dummy { ;\" =~\nm{(\n^(\n   [^;{}]\n   (?>  #<--- disable backtracking\n       (\\s|\\\\\\n)*                         # treat escaped \\n as space\n       (// ([^\\n]|\\\\\\n)* (?<!\\\\)\\n)?   # skip // comments\n   )*\n )+?\n;        #<--- though there is a match, it doesn't include this semicolon\n)}xs && print '$&: |',$&,\"|\\n\",'$1: |',$1,\"|\\n\";\n\nI get:\n\n$&: |dummy dummy |\n$1: ||\n\nInstead of an expected match failure.\n\nHere is what I don't understand:\n1) why does it match? Why it matches without the semicolon?\n2) why $& isn't equal to $1, set to capture whole match?\n3) even though ther is no //-style comment, commenting out the check\ncauses the match to fail.\n\nIf I reenable backtracking in the marked place, all works fine\n(meaning the match fails, as expected).\n\nI'm using perl 5.8.8, tested on Gentoo and Debian.\n\nJan Chorowski\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22824 - in\n\tbranches/SAMBA_4_0/source/torture/smb2: .", "body": "Author: metze\nDate: 2007-05-13 12:52:13 +0000 (Sun, 13 May 2007)\nNew Revision: 22824\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22824\n\nLog:\n- add a simple test which shows how a lock rejects\n  a write on a different file handle.\n  SMB2-LOCK-BLOCK-WRITE\n\n- make it possible to run each SMB2-LOCK-* test on its own\n \nmetze\nModified:\n   branches/SAMBA_4_0/source/torture/smb2/lock.c\n   branches/SAMBA_4_0/source/torture/smb2/smb2.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/torture/smb2/lock.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/smb2/lock.c\t2007-05-13 11:56:25 UTC (rev 22823)\n+++ branches/SAMBA_4_0/source/torture/smb2/lock.c\t2007-05-13 12:52:13 UTC (rev 22824)\n@@ -27,6 +27,8 @@\n #include \"torture/torture.h\"\n #include \"torture/smb2/proto.h\"\n \n+#include \"librpc/gen_ndr/ndr_security.h\"\n+\n #define CHECK_STATUS(status, correct) do { \\\n \tif (!NT_STATUS_EQUAL(status, correct)) { \\\n \t\tprintf(\"(%s) Incorrect status %s - should be %s\\n\", \\\n@@ -43,7 +45,7 @@\n \t\tgoto done; \\\n \t}} while (0)\n \n-static BOOL test_valid_request(TALLOC_CTX *mem_ctx, struct smb2_tree *tree)\n+static BOOL test_valid_request(struct torture_context *torture, struct smb2_tree *tree)\n {\n \tBOOL ret = True;\n \tNTSTATUS status;\n@@ -195,21 +197,115 @@\n \treturn ret;\n }\n \n-/* basic testing of SMB2 locking\n-*/\n-BOOL torture_smb2_lock(struct torture_context *torture)\n+static BOOL test_block_write(struct torture_context *torture, struct smb2_tree *tree)\n {\n-\tTALLOC_CTX *mem_ctx = talloc_new(NULL);\n-\tstruct smb2_tree *tree;\n \tBOOL ret = True;\n+\tNTSTATUS status;\n+\tstruct smb2_handle h1, h2;\n+\tuint8_t buf[200];\n+\tstruct smb2_lock lck;\n+\tstruct smb2_create cr;\n+\tstruct smb2_write wr;\n+\tconst char *fname = \"lock2.txt\";\n \n-\tif (!torture_smb2_connection(mem_ctx, &tree)) {\n-\t\treturn False;\n-\t}\n+\tZERO_STRUCT(buf);\n \n-\tret &= test_valid_request(mem_ctx, tree);\n+\tstatus = torture_smb2_testfile(tree, fname, &h1);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n \n-\ttalloc_free(mem_ctx);\n+\tstatus = smb2_util_write(tree, h1, buf, 0, ARRAY_SIZE(buf));\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n \n+\tlck.in.unknown1\t\t= 0x0001;\n+\tlck.in.unknown2\t\t= 0x00000000;\n+\tlck.in.file.handle\t= h1;\n+\tlck.in.offset\t\t= 0;\n+\tlck.in.count\t\t= ARRAY_SIZE(buf)/2;\n+\tlck.in.unknown5\t\t= 0x00000000;\n+\tlck.in.flags\t\t= SMB2_LOCK_FLAG_EXCLUSIV;\n+\tstatus = smb2_lock(tree, &lck);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\tCHECK_VALUE(lck.out.unknown1, 0);\n+\n+\tlck.in.unknown1\t\t= 0x0001;\n+\tlck.in.unknown2\t\t= 0x00000000;\n+\tlck.in.file.handle\t= h1;\n+\tlck.in.offset\t\t= ARRAY_SIZE(buf)/2;\n+\tlck.in.count\t\t= ARRAY_SIZE(buf)/2;\n+\tlck.in.unknown5\t\t= 0x00000000;\n+\tlck.in.flags\t\t= SMB2_LOCK_FLAG_EXCLUSIV;\n+\tstatus = smb2_lock(tree, &lck);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\tCHECK_VALUE(lck.out.unknown1, 0);\n+\n+\tZERO_STRUCT(cr);\n+\tcr.in.oplock_flags = 0;\n+\tcr.in.access_mask = SEC_RIGHTS_FILE_ALL;\n+\tcr.in.file_attr   = FILE_ATTRIBUTE_NORMAL;\n+\tcr.in.open_disposition = NTCREATEX_DISP_OPEN_IF;\n+\tcr.in.share_access = \n+\t\tNTCREATEX_SHARE_ACCESS_DELETE|\n+\t\tNTCREATEX_SHARE_ACCESS_READ|\n+\t\tNTCREATEX_SHARE_ACCESS_WRITE;\n+\tcr.in.create_options = 0;\n+\tcr.in.fname = fname;\n+\n+\tstatus = smb2_create(tree, tree, &cr);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\n+\th2 = cr.out.file.handle;\n+\n+\n+\tZERO_STRUCT(wr);\n+\twr.in.file.handle = h1;\n+\twr.in.offset      = ARRAY_SIZE(buf)/2;\n+\twr.in.data        = data_blob_const(buf, ARRAY_SIZE(buf)/2);\n+\n+\tstatus = smb2_write(tree, &wr);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\n+\tZERO_STRUCT(wr);\n+\twr.in.file.handle = h2;\n+\twr.in.offset      = ARRAY_SIZE(buf)/2;\n+\twr.in.data        = data_blob_const(buf, ARRAY_SIZE(buf)/2);\n+\n+\tstatus = smb2_write(tree, &wr);\n+\tCHECK_STATUS(status, NT_STATUS_FILE_LOCK_CONFLICT);\n+\n+\tlck.in.unknown1\t\t= 0x0001;\n+\tlck.in.unknown2\t\t= 0x00000000;\n+\tlck.in.file.handle\t= h1;\n+\tlck.in.offset\t\t= ARRAY_SIZE(buf)/2;\n+\tlck.in.count\t\t= ARRAY_SIZE(buf)/2;\n+\tlck.in.unknown5\t\t= 0x00000000;\n+\tlck.in.flags\t\t= SMB2_LOCK_FLAG_UNLOCK;\n+\tstatus = smb2_lock(tree, &lck);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\tCHECK_VALUE(lck.out.unknown1, 0);\n+\n+\tZERO_STRUCT(wr);\n+\twr.in.file.handle = h2;\n+\twr.in.offset      = ARRAY_SIZE(buf)/2;\n+\twr.in.data        = data_blob_const(buf, ARRAY_SIZE(buf)/2);\n+\n+\tstatus = smb2_write(tree, &wr);\n+\tCHECK_STATUS(status, NT_STATUS_OK);\n+\n+done:\n \treturn ret;\n }\n+\n+/* basic testing of SMB2 locking\n+*/\n+struct torture_suite *torture_smb2_lock_init(void)\n+{\n+\tstruct torture_suite *suite = torture_suite_create(talloc_autofree_context(), \"LOCK\");\n+\n+\ttorture_suite_add_1smb2_test(suite, \"VALID-REQUEST\", test_valid_request);\n+\ttorture_suite_add_1smb2_test(suite, \"BLOCK-WRITE\", test_block_write);\n+\n+\tsuite->description = talloc_strdup(suite, \"SMB2-LOCK tests\");\n+\n+\treturn suite;\n+}\n+\n\nModified: branches/SAMBA_4_0/source/torture/smb2/smb2.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/smb2/smb2.c\t2007-05-13 11:56:25 UTC (rev 22823)\n+++ branches/SAMBA_4_0/source/torture/smb2/smb2.c\t2007-05-13 12:52:13 UTC (rev 22824)\n@@ -24,12 +24,55 @@\n \n #include \"torture/torture.h\"\n #include \"torture/smb2/proto.h\"\n+#include \"lib/util/dlinklist.h\"\n \n+static bool wrap_simple_1smb2_test(struct torture_context *torture_ctx,\n+\t\t\t\t   struct torture_tcase *tcase,\n+\t\t\t\t   struct torture_test *test)\n+{\n+\tbool (*fn) (struct torture_context *, struct smb2_tree *);\n+\tbool ret;\n+\n+\tstruct smb2_tree *tree1;\n+\n+\tif (!torture_smb2_connection(torture_ctx, &tree1))\n+\t\treturn false;\n+\n+\tfn = test->fn;\n+\n+\tret = fn(torture_ctx, tree1);\n+\n+\ttalloc_free(tree1);\n+\n+\treturn ret;\n+}\n+\n+_PUBLIC_ struct torture_test *torture_suite_add_1smb2_test(struct torture_suite *suite,\n+\t\t\t\t\t\t\t   const char *name,\n+\t\t\t\t\t\t\t   bool (*run) (struct torture_context *,\n+\t\t\t\t\t\t\t\t\tstruct smb2_tree *))\n+{\n+\tstruct torture_test *test; \n+\tstruct torture_tcase *tcase;\n+\t\n+\ttcase = torture_suite_add_tcase(suite, name);\n+\n+\ttest = talloc(tcase, struct torture_test);\n+\n+\ttest->name = talloc_strdup(test, name);\n+\ttest->description = NULL;\n+\ttest->run = wrap_simple_1smb2_test;\n+\ttest->fn = run;\n+\ttest->dangerous = false;\n+\n+\tDLIST_ADD_END(tcase->tests, test, struct torture_test *);\n+\n+\treturn test;\n+}\n+\n NTSTATUS torture_smb2_init(void)\n {\n-\tstruct torture_suite *suite = torture_suite_create(\n-\t\t\t\t\t\t\t\t\t\ttalloc_autofree_context(),\n-\t\t\t\t\t\t\t\t\t\t\"SMB2\");\n+\tstruct torture_suite *suite = torture_suite_create(talloc_autofree_context(), \"SMB2\");\n \ttorture_suite_add_simple_test(suite, \"CONNECT\", torture_smb2_connect);\n \ttorture_suite_add_simple_test(suite, \"SCAN\", torture_smb2_scan);\n \ttorture_suite_add_simple_test(suite, \"SCANGETINFO\", torture_smb2_getinfo_scan);\n@@ -38,11 +81,10 @@\n \ttorture_suite_add_simple_test(suite, \"GETINFO\", torture_smb2_getinfo);\n \ttorture_suite_add_simple_test(suite, \"SETINFO\", torture_smb2_setinfo);\n \ttorture_suite_add_simple_test(suite, \"FIND\", torture_smb2_find);\n-\ttorture_suite_add_simple_test(suite, \"LOCK\", torture_smb2_lock);\n+\ttorture_suite_add_suite(suite, torture_smb2_lock_init());\n \ttorture_suite_add_simple_test(suite, \"NOTIFY\", torture_smb2_notify);\n \n-\tsuite->description = talloc_strdup(suite, \n-\t\t\t\t\t\t\t\"SMB2-specific tests\");\n+\tsuite->description = talloc_strdup(suite, \"SMB2-specific tests\");\n \n \ttorture_register_suite(suite);\n \n\n"}
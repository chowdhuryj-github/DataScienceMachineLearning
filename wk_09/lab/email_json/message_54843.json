{"category": "ham", "to_address": "\"Mihir Kamdar\" <kamdarmihir06@gmail.com>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: Help parsing a CSV file", "body": "On 6/25/07, Mihir Kamdar  wrote:\n\n> if (2 != ($#ARGV+1)) {\n\nThat works, but it's usually written more like this:\n\n    if (@ARGV != 2) {\n\n> open INFILE,  \"<$ARGV[0]\" || die \"unable to open INFILE\";\n> open OUTFILE, \">$ARGV[1]\" || die \"unable to open OUTFILE\";\n\nThese don't do what they look like. The vertical-bar-or operator is\nhigh precedence, so the string sticks too tightly to the die, and so\nthe open will never die. Either put parentheses around the part to the\nleft of the vertical-bar-or operator, or change to the low-precedence\nword 'or' operator. See the precedence chart in the perlop manpage.\n\n> It converts the fields in my input file like 097611/4 to\n> 097611\n> 097612\n> 097613\n> 097614\n>\n> But there are some of the fields like 09778/0, which should be converted to\n> 09778\n> 09779\n> 09770\n\nSo the 0 is a special case. Is that last one supposed to be 09770 or 09780?\n\nYou can check for 0 and handle it separately. If $end isn't 0, you get\nwhat you need from ($start..$end) . If it is 0, your list of suffixes\nwould be ($start..9, 0) instead. If you need 09780, you might need to\ngo with something like this:\n\n  my $range;\n  if ($end) {\n    @range = \"$stub$start\"..\"$stub$end\";\n  } else {\n    my $stub1 = $stub;\n    $stub1++; # magical autoincrement\n    @range = \"$stub$start\"..\"$stub1$end\";\n  }\n\nGood luck with it!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
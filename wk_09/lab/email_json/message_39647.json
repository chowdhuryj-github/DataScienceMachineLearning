{"category": "ham", "to_address": "\"Paul Lalli\" <mritty@gmail.com>", "from_address": "\"Sharan Basappa\" <sharan.basappa@gmail.com>", "subject": "Re: did I get greedy quantifiers wrong ?", "body": "Thanks a lot Paul ..\n\nFor this rule :\n$str = mississippi;\n$str =~ m/m(.*i)(.*pi)/;\n\nMy initial understanding was that .*i would match all the way till last char i.\nThis would indeed be true if .*i was not followed by .*pi.\nDo you agree ?\n\n\nOn 31 May 2007 06:11:45 -0700, Paul Lalli  wrote:\n> On May 31, 6:02 am, sharan.basa...@gmail.com (Sharan Basappa) wrote:\n> > I seem to be having some conceptual problem with greedy quantifiers ..\n> > My understanding is that it matches as much as follows while still\n> > allowing rest of the\n> > regex to match.\n>\n> 90% correct.  The other 10% is that the match starts left-to-right.\n> It will start with the first part of the string that can match, and\n> match as much of *that* as possible.  It will not search the rest of\n> the string to see if a longer match is possible later.  For example:\n>\n> $string = 'abbabbbbba';\n> $string =~ /(b*)/;\n> In this case, $1 will be set to 'bb', because that is the *first*\n> longest string it could find, even though if it had continued, it\n> would have been able to find 'bbbbb' later.\n>\n>\n> > But look at the following example :\n> > $str = mississippi;\n> > $str =~ m/m(.*i)(.*pi)/;\n> > print \"one is $1 \\n\";\n> > print \"two is $2 \\n\";\n> >\n> > $str = mississippi;\n> > $str =~ m/m(.*i?)(.*pi)/;\n>\n> This doesn't mean what you think it means.  This tells Perl that the\n> second token - (.*i?) can match as much of anything as it can,\n> followed by 0 or 1 i's.  That ? does not apply to the .* unless you\n> put it right after the *.  Compare and contrast with:\n> (.*?i), which means to match as little of anything as possible,\n> followed by exactly one i.\n>\n> > print \"one is $1 \\n\";\n> > print \"two is $2 \\n\";\n> >\n> > In the first code snippet, I expected first regex (.*i) to match till\n> > ississip\n>\n> Right there is a problem.  Your token is (.*i).  That is, the last\n> character of this token must be an i.  It can't end with a p.  That\n> doesn't match.  The .* matches as much as it can until the last 'i',\n> then saves the 'i' for the i in the token.\n>\n> > and leave pi for (.*pi) regex.\n> >\n> > But what I get as the output of this script is :\n> >\n> > one is ississi\n> > two is ppi\n> > one is ississip\n> > two is pi\n> >\n> > Why is that perl is leaving ppi to second regex while it can continue\n> > till first p\n>\n> It can't.  The token ends in an i.  'i' must be the last thing that\n> (.*i) matches.\n>\n> Paul Lalli\n>\n>\n> --\n> To unsubscribe, e-mail: beginners-unsubscribe@perl.org\n> For additional commands, e-mail: beginners-help@perl.org\n> http://learn.perl.org/\n>\n>\n>\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
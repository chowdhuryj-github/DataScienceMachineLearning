{"category": "ham", "to_address": "Allison Randal <allison@perl.org>", "from_address": "Bob Rogers <rogers-perl6@rgrjr.dyndns.org>", "subject": "Re: modifying classes after they're instantiated", "body": "   From: Allison Randal \n   Date: Wed, 11 Apr 2007 01:12:57 -0700\n\n   Alek Storm wrote:\n   > On 4/11/07, Bob Rogers  wrote:\n   >> Surely you are not suggesting that any random \"add_method\" should\n   >> require creating a new class?  Did you mean \"add_attribute\" (or\n   >> whatever)?\n\n   I did mean that, but only if the class has already been instantiated. \n   ('add_method' can add an additional multi, for example, so it can modify \n   existing behavior.)\n\nHmm.  If a Lisp implementation ever worked this way, FWIW, it would be\nconsidered buggy.  It would also make developing Lisp code harder than\nnecessary, as it is normal to start development of a class by defining\nit interactively, creating a few instances, adding methods, calling\nthem, adding more methods, making more instances, and so on, all within\nthe same session.  Lisp uses expect that newly-defined methods will work\nimmediately for old instances of those classes.\n\n   Come to think of it, I also do the same sort of thing in Perl 5:  At\nsome time during the execution of my program, I load a file that adds\nmethods to another class defined elsewhere (though the class may not\nactually have instances at that point).  It's not terribly clean in Perl\n5, 'tis true, but it can't be that rare.\n\n   But now that I've brought up Lisp, I should clarify my position.  I'm\nstill not sure how I would go about implementing ANSI-compliant Lisp\nobjects for Parrot.  As a result, I have stayed mostly silent on objects\nbecause (a) I don't know what I want yet, and (b) I assume I will have\nto do a lot of PMC subclassing anyway, so that would allow me to\noverride whatever doesn't work for me.  In any case, Lisp only uses\nmultimethods -- the first arg to add-method (and remove-method) is a\ngeneric function, not a class -- so I don't expect to need add_method\nanyway.\n\n   So I mention Lisp behavior not because I think Parrot ought to behave\nthat way, but as a way of explaining why this surprises me.\n\n   >> The remove_* operations could stay, they would just\n   >> throw errors on instantiated classes.\n\n   They could, but how often are people going to add a bunch of attributes \n   and methods and then remove them immediately before they ever \n   instantiate the class? . . .\n\nWhen the class is cloned, the 'instantiated' bit should be cleared,\nbecause there are as yet no instances of the cloned class.  So then\nremove_* would be useful on the clone.  True?\n\n   > Not all languages want to clone their classes on modification.  These\n   > languages would use their own class PMCs that don't clone themselves.\n\n   They might not clone their classes from the user perspective, but \n   internally it's the only truly safe way to modify a class that already \n   has objects instantiated (especially when you're talking about remove \n   operations). Otherwise, you have objects referencing attributes that \n   don't exist any longer in the class, or methods referencing attributes \n   that were never initialized in the object. The closest they can come is \n   the option 1) I listed.\n\nNote that Lisp uses a form of option 1, where an old instance is updated\nto the new class structure at some time before its slots (attributes)\nare next accessed [1].  I understand there are ways of making this\nupdate relatively cheap, without slowing down other method dispatch, but\nI'm afraid I'm not familiar with them.  In any case, it need not be all\nthat cheap, because it's not really needed in production code.\n\n   > If one of their classes is passed to and cloned by a different HLL,\n   > their class system will be screwed up/inconsistent.  I'm not sure how\n   > requiring HLLs to deal with explicit cloning would be simpler than\n   > having it abstracted away.  This system is much more flexible.\n\nThe normal use case for this class-changing API, it seems to me, is to\nredefine an HLL class definition incrementally by recompiling it.\nHaving one HLL mutate the class of another HLL seems relatively arcane.\nAre you suggesting that this is a bad idea simply because it can be\nabused in this manner?\n\n   Despite being arcane, and assuming the operation makes sense at all,\nI would argue that this scenario still ought to work.  If the basic\nParrot classes support mutation, then even an HLL that normally defines\ninflexible classes ought to inherit that mutability, unless it does\nsomething explicit to disable it.  In which case, it ought to disable\nthe \"clone\" op as well.\n\n   The point about abstraction is a good one. It can also be satisfied by \n   the 'clone' method/vtable. If a class has a different way of handling \n   modifications, it can return a modified version of itself instead of \n   returning a new clone (in those cases where the cloning operation was \n   flagged as a modification of an existing class).\n\nWould the code that does the class mutation need to do anything\ndifferent with the result in the \"clone\" vs. \"no clone\" case?  I.e. in\nterms of mutating it further, or doing something to finalize the\nchanges?\n\n   What if the mutated class has subclasses?  I imagine they would need\nto be cloned (automatically or not) as well?\n\n   >> Error recovery would also be easier for explicit cloning; what happens\n   >> if one of the class-mutating methods throws an error?\n   > \n   > I'm afraid you lost me.  How would this be different?  Could you\n   > provide some more information?\n\n   Essentially, what if you call 'add_method', it automatically clones the \n   class, and the automatic cloning fails for some reason? Then you get a \n   mysterious exception about \"failed to clone class\", leaving the average \n   user wondering why it was trying to clone a class in the first place.\n\n   Allison\n\nHere's another example:  Suppose you change a class definition in such a\nway that several attributes are deleted, and a few more are added.  If\nthat looks like an single operation at the HLL level, even though it\ntakes a slew of Parrot ops, then you want to be sure that the class\nmanipulation succeeds completely before replacing the original class\ndefinition as the one that find_class should return.\n\n\t\t\t\t\t-- Bob\n\n[1]  http://www.lispworks.com/documentation/HyperSpec/Body/04_cf.htm\n\n"}
{"category": "ham", "to_address": "Ed Plese <ed@edplese.com>", "from_address": "Alison Winters <alisonw@sgi.com>", "subject": "Re: [PATCH] Shadow Copy Improvements", "body": "Could someone take a look at this patch, metze perhaps?  I've been\ntesting with this patch on SGI's XVM snapshot and Ed is pretty happy\nwith it on ZFS.  I really think it adds a lot of value to the current\nsnapshot module.\n\nAlison\n\n\nEd Plese wrote:\n> Attached is a set of 3 patches that add fixes and improvements to the\n> existing shadow_copy VFS module.  I had previously sent a patch for a new\n> shadow_copy_zfs module with customizations specific to ZFS on Solaris but\n> these patches instead add generic improvements that should work with most\n> snapshot methods.\n> \n> I'd like give a big thanks to Alison Winters for contributing many of the\n> ideas for this patch as well as code and testing.\n> \n> The defaults for all of the new smb.conf parameters are set to values\n> that preserve backwards compatibility with the current module.\n> \n> The patches are:\n> \n> 1-dirent-fix.patch\n>   This fixes the module to work on systems that define struct dirent with\n>   d_name[1].  Solaris is an example of such a system and it causes the\n>   share to appear to be completely empty.\n> \n> 2-sort.patch\n>   With the existing shadow_copy module the shadow copies are displayed in\n>   the Windows GUI in the order the server obtains them from readdir(3).\n>   On some systems and filesystems readdir(3) does not return files in any\n>   particular order which leads to the list in the GUI being unsorted and\n>   difficult to use.  This patch allows the list to be sorted based on\n>   a \"sort\" parameter specified for the module.  Allowed values are \"asc\"\n>   or \"desc\".  When not specified the current unsorted behavior is maintained.\n> \n> 3-paths.patch\n>   This patch allows for various components of the snapshot paths to be\n>   easily customized.  Currently this must be done by creating scripts that\n>   will create the appropriate symbolic links every time a snapshot is taken\n>   and consequently clean up all of the symbolic links whenever a snapshot\n>   is deleted.  With this patch the path components are specified in the\n>   smb.conf file using the new parameters \"path\", \"subpath\", \"format\", and\n>   \"localtime\".  The defaults for all of the new parameters maintain the\n>   current behavior of the module.\n> \n>   path - Specifies the path to the directory that contains the snapshots.\n> \n>   format - This is the format of the snapshot names in str[fp]time notation\n>       except that $ characters are used in place of % characters.\n> \n>   subpath - The subdirectory under the snapshot that contains all of the\n>       files for this shadow copy.\n> \n>   localtime (boolean) - Treat the snapshot names as being in localtime\n>       instead of the default of GMT.\n> \n>   These probably aren't the clearest explanations of the parameters but the\n>   examples below should help to clear up any confusion.\n> \n> Some limitations include:\n> \n> * shadow copy does not work correctly when mapping a drive to a\n>   subdirectory of a share\n> * snapshot names are limited to expressions that can be expressed with the\n>   str[fp]time(3) functions and variable substitutions in smb.conf\n> \n> Example uses:\n> \n> Use with @GMT- directories or symbolic links in the share:\n> \n> [homes]\n>    public = no\n>    writable = yes\n>    printable = no\n>    vfs object = shadow_copy\n> \n> \n> A single large filesystem mounted at /home that contains all of the home\n> directories.  The snapshots reside in /snapshots/home.\n> \n> [homes]\n>    path = /home/%U\n>    public = no\n>    writable = yes\n>    printable = no\n>    vfs object = shadow_copy\n>    shadow_copy: path = /snapshots/home\n>    shadow_copy: subpath = %U\n>    shadow_copy: format = $Y.$m.$d-$H.$M.$S\n>    shadow_copy: sort = desc\n>    shadow_copy: localtime = yes\n> \n> \n> A separate ZFS filesystem for each home directory.\n> \n> [homes]\n>    path = /home/%U\n>    public = no\n>    writable = yes\n>    printable = no\n>    vfs object = shadow_copy\n>    shadow_copy: path = /home/%U/.zfs/snapshot\n>    shadow_copy: format = $Y.$m.$d-$H.$M.$S\n>    shadow_copy: sort = desc\n>    shadow_copy: localtime = yes\n> \n> \n> Comments and feedback are welcome!\n> \n> Thanks,\n> \n> Ed Plese\n> \n> \n> ------------------------------------------------------------------------\n> \n> === modified file 'source/modules/vfs_shadow_copy.c'\n> --- source/modules/vfs_shadow_copy.c\t2006-12-21 13:52:11 +0000\n> +++ source/modules/vfs_shadow_copy.c\t2007-04-16 01:45:15 +0000\n> @@ -58,8 +58,8 @@\n>  \n>  typedef struct {\n>  \tint pos;\n> -\tint num;\n> -\tSMB_STRUCT_DIRENT *dirs;\n> +\tint length;\n> +\tunsigned char *dirs;\n>  } shadow_copy_Dir;\n>  \n>  static BOOL shadow_copy_match_name(const char *name)\n> @@ -106,13 +106,14 @@\n>  \n>  \t\tDEBUG(10,(\"shadow_copy_opendir: not hide [%s]\\n\",d->d_name));\n>  \n> -\t\tdirp->dirs = SMB_REALLOC_ARRAY(dirp->dirs,SMB_STRUCT_DIRENT, dirp->num+1);\n> +\t\tdirp->dirs = SMB_REALLOC(dirp->dirs, dirp->length + d->d_reclen);\n>  \t\tif (!dirp->dirs) {\n>  \t\t\tDEBUG(0,(\"shadow_copy_opendir: Out of memory\\n\"));\n>  \t\t\tbreak;\n>  \t\t}\n>  \n> -\t\tdirp->dirs[dirp->num++] = *d;\n> +\t\tmemcpy(dirp->dirs + dirp->length, d, d->d_reclen);\n> +\t\tdirp->length += d->d_reclen;\n>  \t}\n>  \n>  \tSMB_VFS_NEXT_CLOSEDIR(handle,p);\n> @@ -121,10 +122,13 @@\n>  \n>  static SMB_STRUCT_DIRENT *shadow_copy_readdir(vfs_handle_struct *handle, SMB_STRUCT_DIR *_dirp)\n>  {\n> +\tSMB_STRUCT_DIRENT *d;\n>  \tshadow_copy_Dir *dirp = (shadow_copy_Dir *)_dirp;\n>  \n> -\tif (dirp->pos < dirp->num) {\n> -\t\treturn &(dirp->dirs[dirp->pos++]);\n> +\tif (dirp->pos < dirp->length) {\n> +\t\td = (SMB_STRUCT_DIRENT *)(dirp->dirs + dirp->pos);\n> +\t\tdirp->pos += d->d_reclen;\n> +\t\treturn d;\n>  \t}\n>  \n>  \treturn NULL;\n> @@ -134,7 +138,7 @@\n>  {\n>  \tshadow_copy_Dir *dirp = (shadow_copy_Dir *)_dirp;\n>  \n> -\tif (offset < dirp->num) {\n> +\tif (offset < dirp->length) {\n>  \t\tdirp->pos = offset ;\n>  \t}\n>  }\n> \n> \n> \n> ------------------------------------------------------------------------\n> \n> === modified file 'source/modules/vfs_shadow_copy.c'\n> --- source/modules/vfs_shadow_copy.c\t2007-04-16 01:45:15 +0000\n> +++ source/modules/vfs_shadow_copy.c\t2007-04-26 15:45:09 +0000\n> @@ -56,12 +56,50 @@\n>  #define SHADOW_COPY_PREFIX \"@GMT-\"\n>  #define SHADOW_COPY_SAMPLE \"@GMT-2004.02.18-15.44.00\"\n>  \n> +#define SHADOW_COPY_DEFAULT_SORT \"\"\n> +\n>  typedef struct {\n>  \tint pos;\n>  \tint length;\n>  \tunsigned char *dirs;\n>  } shadow_copy_Dir;\n>  \n> +static int shadow_copy_label_cmp_asc(const void *x, const void *y)\n> +{\n> +\treturn strncmp((char *)x, (char *)y, sizeof(SHADOW_COPY_LABEL));\n> +}\n> +\n> +static int shadow_copy_label_cmp_desc(const void *x, const void *y)\n> +{\n> +\treturn -strncmp((char *)x, (char *)y, sizeof(SHADOW_COPY_LABEL));\n> +}\n> +\n> +static void shadow_copy_sort_data(vfs_handle_struct *handle, SHADOW_COPY_DATA *shadow_copy_data)\n> +{\n> +\tconst char *tmp_str = NULL;\n> +\n> +\tif (shadow_copy_data && shadow_copy_data->num_volumes > 0 &&\n> +\t\tshadow_copy_data->labels) {\n> +\n> +\t\ttmp_str = lp_parm_const_string(SNUM(handle->conn), \"shadow_copy\", \"sort\",SHADOW_COPY_DEFAULT_SORT);\n> +\n> +\t\tif (strcmp(tmp_str, \"asc\") == 0) {\n> +\t\t\tqsort(shadow_copy_data->labels,\n> +\t\t\t\tshadow_copy_data->num_volumes,\n> +\t\t\t\tsizeof(SHADOW_COPY_LABEL),\n> +\t\t\t\tshadow_copy_label_cmp_asc);\n> +\n> +\t\t} else if (strcmp(tmp_str, \"desc\") == 0) {\n> +\t\t\tqsort(shadow_copy_data->labels,\n> +\t\t\t\tshadow_copy_data->num_volumes,\n> +\t\t\t\tsizeof(SHADOW_COPY_LABEL),\n> +\t\t\t\tshadow_copy_label_cmp_desc);\n> +\t\t}\n> +\t}\n> +\n> +\treturn;\n> +}\n> +\n>  static BOOL shadow_copy_match_name(const char *name)\n>  {\n>  \tif (strncmp(SHADOW_COPY_PREFIX,name, sizeof(SHADOW_COPY_PREFIX)-1)==0 &&\n> @@ -213,6 +251,8 @@\n>  \t\tshadow_copy_data->labels = tlabels;\n>  \t}\n>  \n> +\tshadow_copy_sort_data(handle, shadow_copy_data);\n> +\n>  \tSMB_VFS_NEXT_CLOSEDIR(handle,p);\n>  \treturn 0;\n>  }\n> \n> \n> \n> ------------------------------------------------------------------------\n> \n> === modified file 'source/modules/vfs_shadow_copy.c'\n> --- source/modules/vfs_shadow_copy.c\t2007-04-26 15:45:09 +0000\n> +++ source/modules/vfs_shadow_copy.c\t2007-04-26 15:46:05 +0000\n> @@ -46,8 +46,52 @@\n>  \n>      Note: Files must differ to be displayed via Windows Explorer!\n>  \t  Directories are always displayed...    \n> +\n> +    In addition it is possible to specify additional parameters\n> +\tthat eliminate the need to utilize the @GMT- directories\n> +\tor symbolic links.\n> +\n> +    path\n> +      Specifies the path to the directory that contains the\n> +      snapshots.\n> +\n> +    format\n> +      Specifies the format of the snapshot names in str[fp]time\n> +      notation except that $ characters are used in place of %\n> +      characters.\n> +\n> +    subpath\n> +      Specifies the subdirectory under the snapshot that contains\n> +      all of the files for this shadow copy.\n> +\n> +    localtime (boolean)\n> +      Treat the snapshot names as being in localtime instead of\n> +      the default of GMT.\n> +\n> +    sort\n> +      Sorts the shadow copies, specified as \"asc\" or \"desc\".\n> +      The default is to leave them unsorted.\n> +\n> +    Below is example usage for a single large filesystem mounted\n> +    at /home that contains all of the home directories.  The\n> +    snapshots reside in /snapshots/home.\n> +\n> +    [homes]\n> +       path = /home/%U\n> +       public = no\n> +       writable = yes\n> +       printable = no\n> +       vfs object = shadow_copy\n> +       shadow_copy: path = /snapshots/home\n> +       shadow_copy: subpath = %U\n> +       shadow_copy: format = $Y.$m.$d-$H.$M.$S\n> +       shadow_copy: sort = desc\n> +       shadow_copy: localtime = yes\n> +\n>  */\n>  \n> +extern userdom_struct current_user_info;\n> +\n>  static int vfs_shadow_copy_debug_level = DBGC_VFS;\n>  \n>  #undef DBGC_CLASS\n> @@ -56,6 +100,11 @@\n>  #define SHADOW_COPY_PREFIX \"@GMT-\"\n>  #define SHADOW_COPY_SAMPLE \"@GMT-2004.02.18-15.44.00\"\n>  \n> +#define SHADOW_COPY_GMT_FORMAT \"@GMT-%Y.%m.%d-%H.%M.%S\"\n> +#define SHADOW_COPY_DEFAULT_FORMAT \"@GMT-$Y.$m.$d-$H.$M.$S\"\n> +#define SHADOW_COPY_DEFAULT_PATH \".\"\n> +#define SHADOW_COPY_DEFAULT_SUBPATH \".\"\n> +#define SHADOW_COPY_DEFAULT_LOCALTIME (False)\n>  #define SHADOW_COPY_DEFAULT_SORT \"\"\n>  \n>  typedef struct {\n> @@ -110,13 +159,146 @@\n>  \treturn False;\n>  }\n>  \n> +static BOOL shadow_copy_snapshot_to_gmt(vfs_handle_struct *handle, const char *name, char *converted, int converted_length)\n> +{\n> +\tchar *cstr = NULL;\n> +\tstruct tm timestamp;\n> +\ttime_t timestamp_t;\n> +\n> +\tchar *fmt = alloc_sub_basic(get_current_username(), current_user_info.domain,\n> +\t\tlp_parm_const_string(SNUM(handle->conn),\n> +\t\t\t\"shadow_copy\", \"format\", SHADOW_COPY_DEFAULT_FORMAT));\n> +\tchar *tmp;\n> +\n> +\tif (fmt == NULL) {\n> +\t\tDEBUG(0, (\"shadow_copy_snapshot_to_gmt: alloc_sub_basic failed for format\\n\"));\n> +\t\treturn False;\n> +\t}\n> +\n> +\t/* replace $ in the parameter with % */\n> +\tfor (tmp = fmt; *tmp != '\\0'; tmp++) {\n> +\t\tif (*tmp == '$') {\n> +\t\t\t*tmp = '%';\n> +\t\t}\n> +\t}\n> +\n> +\tmemset(&timestamp, 0, sizeof(timestamp));\n> +\tcstr = strptime(name, fmt, &timestamp);\n> +\n> +\tif (cstr == NULL) {\n> +\t\tDEBUG(10, (\"shadow_copy_snapshot_to_gmt: no match %s: %s\\n\", fmt, name));\n> +\t\tSAFE_FREE(fmt);\n> +\t\treturn False;\n> +\t}\n> +\n> +\tDEBUG(10, (\"shadow_copy_snapshot_to_gmt: match %s: %s\\n\", fmt, name));\n> +\tif (lp_parm_bool(SNUM(handle->conn), \"shadow_copy\", \"localtime\", SHADOW_COPY_DEFAULT_LOCALTIME)) {\n> +\t\ttimestamp.tm_isdst = -1;\n> +\t\ttimestamp_t = mktime(&timestamp);\n> +\t\tgmtime_r(&timestamp_t, &timestamp);\n> +\t}\n> +\tstrftime(converted, converted_length, SHADOW_COPY_GMT_FORMAT, &timestamp);\n> +\tSAFE_FREE(fmt);\n> +\treturn True;\n> +}\n> +\n> +static BOOL shadow_copy_file_to_snapshot_path(vfs_handle_struct *handle, const char *path, char *converted, int converted_length)\n> +{\n> +\t/* all conversions start with the initial portion of the path matching\n> +\t * @GMT-xxxxxxx\n> +\t *\t\n> +\t * take the full string and pass it along to strptime */\n> +\n> +\tchar *cstr = NULL;\n> +\tstruct tm timestamp;\n> +\ttime_t timestamp_t;\n> +\tchar snapname[MAXPATHLEN];\n> +\tchar *snappath = NULL;\n> +\tchar *subpath = NULL;\n> +\n> +\tchar *fmt = alloc_sub_basic(get_current_username(), current_user_info.domain,\n> +\t\tlp_parm_const_string(SNUM(handle->conn),\n> +\t\t\t\"shadow_copy\", \"format\", SHADOW_COPY_DEFAULT_FORMAT));\n> +\tchar *tmp;\n> +\n> +\tif (fmt == NULL) {\n> +\t\tDEBUG(0, (\"shadow_copy_file_to_snapshot_path: alloc_sub_basic failed for format\\n\"));\n> +\t\treturn False;\n> +\t}\n> +\n> +\t/* replace $ in the parameter with % */\n> +\tfor (tmp = fmt; *tmp != '\\0'; tmp++) {\n> +\t\tif (*tmp == '$') {\n> +\t\t\t*tmp = '%';\n> +\t\t}\n> +\t}\n> +\n> +\tmemset(&timestamp, 0, sizeof(timestamp));\n> +\tcstr = strptime(path, SHADOW_COPY_GMT_FORMAT, &timestamp);\n> +\n> +\tif (cstr == NULL) {\n> +\t\t/* string doesn't match the required SHADOW_COPY_GMT_FORMAT so just\n> +\t\t * return the original path */\n> +\n> +\t\tstrncpy(converted, path, converted_length);\n> +\t\tSAFE_FREE(fmt);\n> +\t\treturn False;\n> +\t}\n> +\n> +\t/* cstr is the remaining portion of the path after the @GMT-xxx */\n> +\n> +\tif (lp_parm_bool(SNUM(handle->conn), \"shadow_copy\", \"localtime\", SHADOW_COPY_DEFAULT_LOCALTIME)) {\n> +\t\ttimestamp_t = timegm(&timestamp);\n> +\t\tlocaltime_r(&timestamp_t, &timestamp);\n> +\t}\n> +\tstrftime(snapname, MAXPATHLEN, fmt, &timestamp);\n> +\n> +\tsnappath = alloc_sub_basic(get_current_username(), current_user_info.domain,\n> +\t\tlp_parm_const_string(SNUM(handle->conn),\n> +\t\t\t\"shadow_copy\", \"path\", SHADOW_COPY_DEFAULT_PATH));\n> +\tif (snappath == NULL) {\n> +\t\tDEBUG(0, (\"shadow_copy_file_to_snapshot_path: alloc_sub_basic failed for path\\n\"));\n> +\t\tSAFE_FREE(fmt);\n> +\t\treturn False;\n> +\t}\n> +\n> +\tsubpath = alloc_sub_basic(get_current_username(), current_user_info.domain,\n> +\t\tlp_parm_const_string(SNUM(handle->conn),\n> +\t\t\t\"shadow_copy\", \"subpath\", SHADOW_COPY_DEFAULT_SUBPATH));\n> +\tif (subpath == NULL) {\n> +\t\tDEBUG(0, (\"shadow_copy_file_to_snapshot_path: alloc_sub_basic failed for subpath\\n\"));\n> +\t\tSAFE_FREE(fmt);\n> +\t\tSAFE_FREE(snappath);\n> +\t\treturn False;\n> +\t}\n> +\n> +\t/* path/snap/subpath/filepath */\n> +\tsnprintf(converted, converted_length, \"%s/%s/%s/%s\",\n> +\t\tsnappath,\n> +\t\tsnapname,\n> +\t\tsubpath,\n> +\t\tcstr);\n> +\n> +\tSAFE_FREE(fmt);\n> +\tSAFE_FREE(snappath);\n> +\tSAFE_FREE(subpath);\n> +\treturn True;\n> +}\n> +\n>  static SMB_STRUCT_DIR *shadow_copy_opendir(vfs_handle_struct *handle, const char *fname, const char *mask, uint32 attr)\n>  {\n>  \tshadow_copy_Dir *dirp;\n> -\tSMB_STRUCT_DIR *p = SMB_VFS_NEXT_OPENDIR(handle,fname,mask,attr);\n> +\tSMB_STRUCT_DIR *p = NULL;\n> +\t\n> +\tchar newpath[MAXPATHLEN];\n> +\tshadow_copy_file_to_snapshot_path(handle, fname, newpath, MAXPATHLEN);\n> +\n> +\tDEBUG(10,(\"shadow_copy_opendir: [%s] -> [%s]\\n\",fname,newpath));\n> +\t\n> +\tp = SMB_VFS_NEXT_OPENDIR(handle,newpath,mask,attr);\n>  \n>  \tif (!p) {\n> -\t\tDEBUG(0,(\"shadow_copy_opendir: SMB_VFS_NEXT_OPENDIR() failed for [%s]\\n\",fname));\n> +\t\tDEBUG(0,(\"shadow_copy_opendir: SMB_VFS_NEXT_OPENDIR() failed for [%s]\\n\",newpath));\n>  \t\treturn NULL;\n>  \t}\n>  \n> @@ -203,15 +385,49 @@\n>  \treturn 0;\t\n>  }\n>  \n> +static int shadow_copy_stat(vfs_handle_struct *handle, const char *fname, SMB_STRUCT_STAT *sbuf)\n> +{\n> +\tchar newpath[MAXPATHLEN];\n> +\n> +\tshadow_copy_file_to_snapshot_path(handle, fname, newpath, MAXPATHLEN);\n> +\tDEBUG(10,(\"shadow_copy_stat: [%s] -> [%s]\\n\",fname,newpath));\n> +\n> +\treturn SMB_VFS_NEXT_STAT(handle, newpath, sbuf);\n> +}\n> +\n> +static int shadow_copy_open(vfs_handle_struct *handle, const char *fname, files_struct *fsp, int flags, mode_t mode)\n> +{\n> +\tchar newpath[MAXPATHLEN];\n> +\n> +\tshadow_copy_file_to_snapshot_path(handle, fname, newpath, MAXPATHLEN);\n> +\tDEBUG(10,(\"shadow_copy_open: [%s] -> [%s]\\n\",fname,newpath));\n> +\n> +\treturn SMB_VFS_NEXT_OPEN(handle, newpath, fsp, flags, mode);\n> +}\n> +\n>  static int shadow_copy_get_shadow_copy_data(vfs_handle_struct *handle, files_struct *fsp, SHADOW_COPY_DATA *shadow_copy_data, BOOL labels)\n>  {\n> -\tSMB_STRUCT_DIR *p = SMB_VFS_NEXT_OPENDIR(handle,fsp->conn->connectpath,NULL,0);\n> +\tSMB_STRUCT_DIR *p = NULL;\n> +\tchar snapname[MAXPATHLEN];\n> +\tchar *path = alloc_sub_basic(get_current_username(), current_user_info.domain,\n> +\t\tlp_parm_const_string(SNUM(handle->conn),\n> +\t\t\t\"shadow_copy\", \"path\", fsp->conn->connectpath));\n> +\n> +\tif (path == NULL) {\n> +\t\tDEBUG(0, (\"shadow_copy_get_shadow_copy_data: alloc_sub_basic failed for path\\n\"));\n> +\t\treturn -1;\n> +\t}\n> +\n> +\tDEBUG(10,(\"shadow_copy_get_shadow_copy_data: [%s]\\n\",path));\n> +\n> +\tp = SMB_VFS_NEXT_OPENDIR(handle,path,NULL,0);\n>  \n>  \tshadow_copy_data->num_volumes = 0;\n>  \tshadow_copy_data->labels = NULL;\n>  \n>  \tif (!p) {\n> -\t\tDEBUG(0,(\"shadow_copy_get_shadow_copy_data: SMB_VFS_NEXT_OPENDIR() failed for [%s]\\n\",fsp->conn->connectpath));\n> +\t\tDEBUG(0,(\"shadow_copy_get_shadow_copy_data: SMB_VFS_NEXT_OPENDIR() failed for [%s]\\n\",path));\n> +\t\tSAFE_FREE(path);\n>  \t\treturn -1;\n>  \t}\n>  \n> @@ -225,8 +441,8 @@\n>  \t\t}\n>  \n>  \t\t/* */\n> -\t\tif (!shadow_copy_match_name(d->d_name)) {\n> -\t\t\tDEBUG(10,(\"shadow_copy_get_shadow_copy_data: ignore [%s]\\n\",d->d_name));\n> +\t\tif (!shadow_copy_snapshot_to_gmt(handle, d->d_name, snapname, MAXPATHLEN)) {\n> +\t\t\tDEBUG(6,(\"shadow_copy_get_shadow_copy_data: ignore [%s]\\n\",d->d_name));\n>  \t\t\tcontinue;\n>  \t\t}\n>  \n> @@ -243,10 +459,11 @@\n>  \t\tif (tlabels == NULL) {\n>  \t\t\tDEBUG(0,(\"shadow_copy_get_shadow_copy_data: Out of memory\\n\"));\n>  \t\t\tSMB_VFS_NEXT_CLOSEDIR(handle,p);\n> +\t\t\tSAFE_FREE(path);\n>  \t\t\treturn -1;\n>  \t\t}\n>  \n> -\t\tsnprintf(tlabels[shadow_copy_data->num_volumes++], sizeof(*tlabels), \"%s\",d->d_name);\n> +\t\tsnprintf(tlabels[shadow_copy_data->num_volumes++], sizeof(*tlabels), \"%s\",snapname);\n>  \n>  \t\tshadow_copy_data->labels = tlabels;\n>  \t}\n> @@ -254,6 +471,7 @@\n>  \tshadow_copy_sort_data(handle, shadow_copy_data);\n>  \n>  \tSMB_VFS_NEXT_CLOSEDIR(handle,p);\n> +\tSAFE_FREE(path);\n>  \treturn 0;\n>  }\n>  \n> @@ -267,6 +485,9 @@\n>  \t{SMB_VFS_OP(shadow_copy_rewinddir),\t\tSMB_VFS_OP_REWINDDIR,\t\tSMB_VFS_LAYER_TRANSPARENT},\n>  \t{SMB_VFS_OP(shadow_copy_closedir),\t\tSMB_VFS_OP_CLOSEDIR,\t\tSMB_VFS_LAYER_TRANSPARENT},\n>  \n> +\t{SMB_VFS_OP(shadow_copy_stat),\t\tSMB_VFS_OP_STAT,\t\tSMB_VFS_LAYER_TRANSPARENT},\n> +\t{SMB_VFS_OP(shadow_copy_open),\t\tSMB_VFS_OP_OPEN,\t\tSMB_VFS_LAYER_TRANSPARENT},\n> +\n>  \t{SMB_VFS_OP(shadow_copy_get_shadow_copy_data),\tSMB_VFS_OP_GET_SHADOW_COPY_DATA,SMB_VFS_LAYER_OPAQUE},\n>  \n>  \t{SMB_VFS_OP(NULL),\t\t\t\tSMB_VFS_OP_NOOP,\t\tSMB_VFS_LAYER_NOOP}\n> \n\n"}
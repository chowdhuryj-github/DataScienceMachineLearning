{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14385 - doc/trunk/design/syn", "body": "Author: larry\nDate: Fri Apr 27 08:46:01 2007\nNew Revision: 14385\n\nModified:\n   doc/trunk/design/syn/S05.pod\n\nLog:\nCorrection noted by bsb++\n\n\nModified: doc/trunk/design/syn/S05.pod\n==============================================================================\n--- doc/trunk/design/syn/S05.pod\t(original)\n+++ doc/trunk/design/syn/S05.pod\tFri Apr 27 08:46:01 2007\n@@ -14,9 +14,9 @@\n    Maintainer: Patrick Michaud  and\n                Larry Wall \n    Date: 24 Jun 2002\n-   Last Modified: 17 Apr 2007\n+   Last Modified: 27 Apr 2007\n    Number: 5\n-   Version: 57\n+   Version: 58\n \n This document summarizes Apocalypse 5, which is about the new regex\n syntax.  We now try to call them I rather than \"regular\n@@ -375,6 +375,8 @@\n match at all possible character positions (including overlapping)\n and return all matches in a list context, or a disjunction of matches\n in a scalar context.  The first match at any position is returned.\n+The matches are guaranteed to be returned in left-to-right order with\n+respect to the starting positions.\n \n      $str = \"abracadabra\";\n \n@@ -384,13 +386,20 @@\n \n =item *\n \n-With the new C<:ex> (C<:exhaustive>) modifier, the current regex will match\n-every possible way (including overlapping) and return all matches in a list\n-context, or a disjunction of matches in a scalar context.\n+With the new C<:ex> (C<:exhaustive>) modifier, the current regex will\n+match every possible way (including overlapping) and return all matches\n+in a list context, or a disjunction of matches in a scalar context.\n+The matches are guaranteed to be returned in left-to-right order with\n+respect to the starting positions.  The order within each starting\n+position is not guaranteed and may depend on the nature of both the\n+pattern and the matching engine.  (Conjecture: or we could enforce\n+backtracking engine semantics.  Or we could guarantee no order at all\n+unless the pattern starts with \"::\" or some such to suppress DFAish\n+solutions.)\n \n      $str = \"abracadabra\";\n \n-     if $str ~~ m:exhaustive/ a (.*) a / {\n+     if $str ~~ m:exhaustive/ a (.*?) a / {\n          say \"@()\";    # br brac bracad bracadabr c cad cadabr d dabr br\n      }\n \n\n"}
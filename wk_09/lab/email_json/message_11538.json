{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 169: - fixed a problem with packets to ourselves. The packets\n\twere being in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 169\nrevision-id: tridge@samba.org-20070420075837-29a520d0d03b3196\nparent: tridge@samba.org-20070419215034-109370d61422c5cb\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Fri 2007-04-20 17:58:37 +1000\nmessage:\n  - fixed a problem with packets to ourselves. The packets were being\n    processed immediately, but the input routines indirectly assumed\n    they were being called as a new event (for example, a calling\n    routine might queue the packet, then afterwards modify the ltdb\n    record). The solution was to make self packets queue via a zero\n    timeout.\n  \n  - fixed unlinking of the socket in a exit in the lockwait code. Needed\n    an _exit instead of exit so atexit() doesn't trigger\n  \n  - print latency of lockwait delays\nmodified:\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_lockwait.c         ctdb_lockwait.c-20070416214118-n1aeonljj3vpdd9q-1\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-04-19 06:27:56 +0000\n+++ b/common/ctdb.c\t2007-04-20 07:58:37 +0000\n@@ -331,6 +331,44 @@\n \tDEBUG(3,(\"ctdb_connect_wait: got all %d nodes\\n\", expected));\n }\n \n+struct queue_next {\n+\tstruct ctdb_context *ctdb;\n+\tstruct ctdb_req_header *hdr;\n+};\n+\n+\n+/*\n+  trigered when a deferred packet is due\n+ */\n+static void queue_next_trigger(struct event_context *ev, struct timed_event *te, \n+\t\t\t       struct timeval t, void *private_data)\n+{\n+\tstruct queue_next *q = talloc_get_type(private_data, struct queue_next);\n+\tctdb_recv_pkt(q->ctdb, (uint8_t *)q->hdr, q->hdr->length);\n+\ttalloc_free(q);\n+}\t\n+\n+/*\n+  defer a packet, so it is processed on the next event loop\n+  this is used for sending packets to ourselves\n+ */\n+static void ctdb_defer_packet(struct ctdb_context *ctdb, struct ctdb_req_header *hdr)\n+{\n+\tstruct queue_next *q;\n+\tq = talloc(ctdb, struct queue_next);\n+\tif (q == NULL) {\n+\t\tDEBUG(0,(__location__ \" Failed to allocate deferred packet\\n\"));\n+\t\treturn;\n+\t}\n+\tq->ctdb = ctdb;\n+\tq->hdr = talloc_memdup(ctdb, hdr, hdr->length);\n+\tif (q->hdr == NULL) {\n+\t\tDEBUG(0,(\"Error copying deferred packet to self\\n\"));\n+\t\treturn;\n+\t}\n+\tevent_add_timed(ctdb->ev, q, timeval_zero(), queue_next_trigger, q);\n+}\n+\n /*\n   queue a packet or die\n */\n@@ -338,7 +376,9 @@\n {\n \tstruct ctdb_node *node;\n \tnode = ctdb->nodes[hdr->destnode];\n-\tif (ctdb->methods->queue_pkt(node, (uint8_t *)hdr, hdr->length) != 0) {\n+\tif (hdr->destnode == ctdb->vnn && !(ctdb->flags & CTDB_FLAG_SELF_CONNECT)) {\n+\t\tctdb_defer_packet(ctdb, hdr);\n+\t} else if (ctdb->methods->queue_pkt(node, (uint8_t *)hdr, hdr->length) != 0) {\n \t\tctdb_fatal(ctdb, \"Unable to queue packet\\n\");\n \t}\n }\n\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-04-19 07:43:27 +0000\n+++ b/common/ctdb_call.c\t2007-04-20 07:58:37 +0000\n@@ -222,17 +222,12 @@\n \tmemcpy(&r->data[0], key->dptr, key->dsize);\n \tmemcpy(&r->data[key->dsize], data->dptr, data->dsize);\n \n-\tif (r->hdr.destnode == ctdb->vnn) {\n-\t\t/* we are the lmaster - don't send to ourselves */\n-\t\tctdb_recv_pkt(ctdb, (uint8_t *)&r->hdr, r->hdr.length);\n-\t\treturn;\n-\t} else {\n-\t\tctdb_queue_packet(ctdb, &r->hdr);\n-\n-\t\t/* update the ltdb to record the new dmaster */\n-\t\theader->dmaster = r->hdr.destnode;\n-\t\tctdb_ltdb_store(ctdb_db, *key, header, *data);\n-\t}\n+\t/* XXX - probably not necessary when lmaster==dmaster\n+\t   update the ltdb to record the new dmaster */\n+\theader->dmaster = r->hdr.destnode;\n+\tctdb_ltdb_store(ctdb_db, *key, header, *data);\n+\t\n+\tctdb_queue_packet(ctdb, &r->hdr);\n \n \ttalloc_free(r);\n }\n@@ -280,7 +275,8 @@\n \t}\n \t\n \t/* its a protocol error if the sending node is not the current dmaster */\n-\tif (header.dmaster != hdr->srcnode) {\n+\tif (header.dmaster != hdr->srcnode && \n+\t    hdr->srcnode != ctdb_lmaster(ctdb_db->ctdb, &key)) {\n \t\tctdb_fatal(ctdb, \"dmaster request from non-master\");\n \t\treturn;\n \t}\n@@ -313,13 +309,7 @@\n \tr->datalen       = data.dsize;\n \tmemcpy(&r->data[0], data.dptr, data.dsize);\n \n-\tif (r->hdr.destnode == r->hdr.srcnode) {\n-\t\t/* inject the packet back into the input queue */\n-\t\ttalloc_steal(ctdb, r);\n-\t\tctdb_recv_pkt(ctdb, (uint8_t *)&r->hdr, r->hdr.length);\n-\t} else {\n-\t\tctdb_queue_packet(ctdb, &r->hdr);\n-\t}\n+\tctdb_queue_packet(ctdb, &r->hdr);\n \n \ttalloc_free(tmp_ctx);\n }\n\n=== modified file 'common/ctdb_lockwait.c'\n--- a/common/ctdb_lockwait.c\t2007-04-17 01:26:59 +0000\n+++ b/common/ctdb_lockwait.c\t2007-04-20 07:58:37 +0000\n@@ -34,6 +34,7 @@\n \tpid_t child;\n \tvoid *private_data;\n \tvoid (*callback)(void *);\n+\tstruct timeval t;\n };\n \n static void lockwait_handler(struct event_context *ev, struct fd_event *fde, \n@@ -46,6 +47,7 @@\n \tpid_t child = h->child;\n \ttalloc_set_destructor(h, NULL);\n \tclose(h->fd[0]);\n+\tDEBUG(3,(__location__ \" lockwait took %.6f seconds\\n\", timeval_elapsed(&h->t)));\n \ttalloc_free(h);\t\n \tcallback(p);\n \twaitpid(child, NULL, 0);\n@@ -106,7 +108,7 @@\n \t\t * Do we need a tdb_reopen here?\n \t\t */\n \t\ttdb_chainlock(ctdb_db->ltdb->tdb, key);\n-\t\texit(0);\n+\t\t_exit(0);\n \t}\n \n \tclose(result->fd[1]);\n@@ -120,5 +122,7 @@\n \t\treturn NULL;\n \t}\n \n+\tresult->t = timeval_current();\n+\n \treturn result;\n }\n\n"}
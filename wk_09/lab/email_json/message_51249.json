{"category": "ham", "to_address": "\"Speakup is a screen review system for Linux.\" <speakup@braille.uwo.ca>", "from_address": "\"Spie Sutherland\" <spie@proficio.ca>", "subject": "Re: Speakup in userspace", "body": "Samuel said:\nWhat we want is stealing some keypresses, but not all of\nthem.  The way to achieve this with input is currently to grab the\nphysical device, and re-emulate the keypresses we don't want in a uinput\ndevice, which is quite tedious.\n\nFair enough. But it would seem that the components that make up a \nspecialized system like this need to be decoupled rather than monolithic,\nfor many reasons, one being allowance for alternative modalities. What \nwould be very useful I think, would be if those \"stolen\" keypresses could\nland in a  /dev/input event queue. This decouples the input device from \nwhat is done what those stolen keypresses. It would also allow for some\nother modality, not PC keyboard, to generate those same events by \nsome other means. Consider someone who cannot type for whatever\nreason, who needs an alternative interface other than the keyboard.\n\nThe Input Driver may be tedious but it's uniform and modular. If we are \ntalking about potential user space versus kernel space, then it would make \nsome sense to dissect the overall functionality into layers and separate \nthem, then figure out what needs to remain in the kernel, ideally as \nsomewhat \"atomic\" functionality, probably as several drivers instead of \none, then think about how in user space an application might use those. \nThe approach of putting it all in the kernel has quite a few detriments, \nprobably the largest being the need for constant maintenance as the kernel \nchanges. One small example, although it may be tedious to steal key\npresses and then re-implement them, once that is done as a separate \ndriver on its own, then very little should change from kernel to kernel \nversion. One the other end of things, console output, there is even \ngreater need for layering and atomicity of function, since what used \nto be a serial port is functionally the same now but the protocols and \nhardware to implement it (usb serial) is completely different. \n\nIt might be a good idea to think in terms of what I would call \nvertical protoype if we want to explore user space versus kernel.\nWhat I mean by that is rather than thinking of how the entire new \ndesign would work, take a small cross-section of the whole and \ntry re-designing a simple example that traverses from input to output. \nIn commercial, in-house, or contract software this approach is \nessential (vertical prototype) to ensure that the architecture is \nsound before attempting to re-design the whole mess. \n\nThe need to steal keypresses is not new or unique. It makes a lot\nof sense to pay close attention to the re-architecture of linux input\nmethod and console projects. Even if it's tedious or we don't like \nhow some things are done, throwing it out and going direct to \nhardware digs a hole that makes it hardware specific to x86 and\nmost likely a never ending cycle of maintenance so it doesn't \nbreak as the kernel evolves. \n\nThinking about the whole process in abstraction somewhat like\nthe model-view-controller design pattern would make sense.\nStealing the keypresses should be independent and atomically\nabstracted from what those keypresses do.\n\n  -- Spie\n\n_______________________________________________\nSpeakup mailing list\nSpeakup@braille.uwo.ca\nhttp://speech.braille.uwo.ca/mailman/listinfo/speakup\n\n"}
{"category": "ham", "to_address": "Dan Williams <dcbw@redhat.com>", "from_address": "Don Hopkins <dhopkins@DonHopkins.com>", "subject": "[sugar] Efficient general purpose tile engine,\n\tand a cellular automata machine", "body": "\n\n\n\n\n\n\nI'm developing a general purpose tile engine that can be used for\ncellular automata, and other tile based games, including all of\nSimCity's needs: the close-up\nmap editor that's fully zoomable to any scale, with cursor and sprite\noverlays, and the overall map view, with transparent\noverlays to show stuff like population density, traffic, etc. \n\nThanks to all the helpful advice I've received, I've re-written my tile\nengine to use \"nativeTarget = ctx.get_target()\" to get the native 565\nxlib surface from the cairo context associated with the gtk widget, and\nthen use \"tilesSurface =\nnativeTarget.create_similar(cairo.CONTEXT_COLOR, tilesWidth,\ntilesHeight)\" to create a 565 xlib surface for the tiles in the server.\nThe I copied the tiles there to convert them from 888 to 565. So then\nit can copy them quickly onto the screen or an offscreen 565 xlib\nsurface, where I can draw on top of them efficiently with Cairo, to\nimplement efficient offscreen composition and overlays! \n\nThe tile engine is designed to provide an efficient 565 critical path\nto the screen, support scaling the tiles to any integral number of\npixels, and it has a fast path for unscaled tiles. If the scale is 1:1,\nit just copies the entire tile collection into an xlib 565 surface in\nthe server, to convert them all at once up front. If the scale is not\n1:1, then it creates a temporary 888 single tile sized surface to clip\nout each tile, then clips and copies it into the 565 tile surface (a\nsingle surface that contains all tiles) in the server. That way the\ntiles are cleanly sliced apart so there is no possibility of bleeding\nbetween adjacent tiles when they're scaled (and resampled). [Maybe I'm\njust being paranoid. If it turns out there is no bleeding problem then\nI can simplify the code. But I'm afraid that if you just scale and\nresample all the tiles together they might bleed into each other along\nthe edges.] \n\nThe tile engine also supports an alternative efficient pixel based\nrenderer for single pixel sized tiles (which uses a surface as a color\nmap, like the tile map but each tile is 1x1). The API is a bit\ndifferent because instead of passing in a cairo context to draw with,\nyou pass in a 24 bit image surface that it draws into, which you can\nthen draw onto the screen yourself by scaling and clipping it however\nnecessary. (Of course that does require Cairo or the X server to\nresample it, but at least it minimizes the size of the image it has to\nconvert.) It could easily support 32 bit rgba images, too, so colormaps\ncould contain transparency to produce translucent overlays with opaque\nbands (to make iso contour maps for population density and other\noverlays). \n\nSince the colormaps and tiles are cairo surfaces, it's easy to process\nand render dynamic colormaps and tiles! \n\nQuestion: How to I tell Cairo to use FILTER_FAST instead of\nFILTER_BEST? The set_filter method is supported by the cairo pattern\nobject, but not the surface or the context. How to I wrangle a surface\ninto a pattern, or use a pattern instead of a surface, or whatever I\nhave to do to switch to fast nearest neighbor interpolation mode when\nscaling a surface? \n\nIt supports both pixels based color maps as well as bigger tile sets,\nbecause I want to be able to zoom into any scale, and have it still\nlook nice and run fast. That way you can supply an \"iconified\" pixel\nbased color map for use at small scales, as well a nice looking tiles\nthat will be used at closer zooms. The higher level Python part of the\ntile engine lets you specify a minimum and maximum scale between which\nto cross-fade between the tiles and the pixels, so you can have your\ncake and eat it too. When you're zoomed way out, you see the pixels\nscaled to the exact zoom, softly interpolated with smooth solid colors.\nAs you zoom in and it gets big enough to use the tiles, they fade in\nunderneath the pixels with more detail, with the pixel colors overlayed\ntransparently on top of the tiles. It looks really cool with the smooth\ninterpolation, like the detailed tiles have colored LEDs that light up\nthe cell area. \n\nI made a demo application that uses my cellular automata machine engine\n(currently it runs the von Neumann 29 state cellular automata, but it\nsupports lots of other rules). The initial configuration is an\n\"autoinitializing exclusive or gate\" which I like because it has lots\nof pretty blinking lights. I've started writing a\npanning/zooming/cursor/tile/editing user interface. \n\nI've put up a tar file with the latest code drop:\n\nhttp://www.DonHopkins.com/home/cam.tgz\n\nThe way to build and run it is:\n\nUntar the \"cam\" directory into your \"sugar-jhbuild/source\" directory. \nGo into the directory \"sugar-jhbuild/source/cam\". \nEdit the file autogen-sugar.sh to contain the absolute path to your\nsugar-jhbuild directory. \nRun the script \"./autogen-sugar.sh\" to configure the project. \nBuild and install the project with \"make install\".\nGo into the directory \"sugar-jhbuild/source/cam/cam/test\". \nRun the script \"python test.py\". \nA small window will open up.\nClick in the window to set the input focus. \nPress the left mouse button and drag to pan the cells. \nPress \"i\" to zoom in, \"o\" to zoom out, and \"r\" to reset the zoom. \nOnce you zoom out with \"o\" a few notches you will see the pixel overlay\nfading in, and after enough zooming out it will be solid scaled pixels.\n\nYou can zoom into the tiles with \"i\". There is no limit on the zoom but\nthe X server will barf after a while if you keep zooming. \nPress the \"d\" key to toggle debug inset mode, which insets the view by\na bit and draws a red rectangle where the clip of the view would be, so\nyou can see how it optimizes the cells it draws. \nIt only draws exactly the cells it needs, into an offscreen buffer,\nthen composes the outside background and the cursor on top of that in\nanother buffer, then copies that to the screen. \n\nHere are some pictures at various zooms, showing the cross fading and\nthe debug inset mode:\n\nhttp://www.DonHopkins.com/home/cam-1.png\nhttp://www.DonHopkins.com/home/cam-2.png\nhttp://www.DonHopkins.com/home/cam-3.png\nhttp://www.DonHopkins.com/home/cam-4.png\nhttp://www.DonHopkins.com/home/cam-5.png\n\n\u00a0\u00a0\u00a0 -Don\n\nThanks a lot for all the advice, which I have tried to follow!\n\n\nRight.  Make sure the whole critical path is 16-bit 565.\n  \n\n\n\n\nDrawing a single rectangle, (if pixel aligned---that is, just using\ninteger coordinates and an identity transformation), has lots of\nfast-path treatment in cairo, so please take advantage of it. You can\ndo that with either:\n\n\tcairo_rectangle\n\tcairo_clip\n\nto setup the clipping and then cairo_paint to do the painting, or\njust:\n\n\tcairo_rectangle\n\tcairo_fill\n\nto draw the part you want. Either way you should be hitting the same\npath in cairo to ask the X server to do very efficient things.\n\n    \n\n\n\n\nOK, so that's giving you image surfaces, and that's causing the slow\nconversion when drawing to X. So the best would be to do that just\nonce, (get your data uploaded into an xlib surface, and then draw from\nthere).\n    \n\n\nCorrect; about the only thing you can do here is use create_similar() on\nthe xlib _window_ surface, draw your 24bpp image surface to that, and\ncache the 565 xlib surface for all further drawing.  Note that you will\n_not_ get alpha because the surface is 565.\n\n  \n\n\n\n\nFor a cairo context you can call cairo_get_target, (probably\ncontext.get_target in python), to get the surface it's targeting. So\nthat should give you the surface you need from which you can call\ncreate_similar. And for the case of a gdk drawable you can call\ngdk_cairo_create, and then cairo_get_target. (I do think it's a little\nannoying that GTK+ doesn't have a direct way to create a cairo surface\nfrom a GDK drawable, but the gdk_cairo_create;cairo_get_target\napproach works fine---even if its not quite obvious).\n    \n\n\n\n\n\nAgain, ensure that _any_ surfaces you use in your critical paths are\n565.  If anything is not 565, you'll be subject to Xlib having to smash\nan 888 pixmap down to 565, and that's not very fast, even with MMX.\n  \n\n\n\n\nAnyway, I hope that all works out well for you. And I'm looking\nforward to hearing what kinds of performance improvements you get from\nusing cairo xlib surfaces of the desired depth.\n\n-Carl\n    \n\n\n\n\n\n"}
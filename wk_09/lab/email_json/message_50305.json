{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 549: added code to kill registered clients on a IP release in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 549\nrevision-id: tridge@samba.org-20070618175406-aecnwij4nc2n4b1z\nparent: tridge@samba.org-20070617171508-dshksshlnzdh2qfs\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-06-19 03:54:06 +1000\nmessage:\n  added code to kill registered clients on a IP release\nmodified:\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n  server/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n  server/ctdb_server.c           ctdb.c-20061127094323-t50f58d65iaao5of-2\n  server/ctdb_traverse.c         ctdb_traverse.c-20070503021550-ztfs5rwx8jfm8qqx-1\n  takeover/ctdb_takeover.c       ctdb_takeover.c-20070525071636-a5n1ihghjtppy08r-2\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-06-17 13:31:44 +0000\n+++ b/include/ctdb_private.h\t2007-06-18 17:54:06 +0000\n@@ -101,6 +101,7 @@\n \tint fd;\n \tstruct ctdb_queue *queue;\n \tuint32_t client_id;\n+\tpid_t pid;\n \tstruct ctdb_tcp_list *tcp_list;\n };\n \n@@ -267,7 +268,6 @@\n \tTALLOC_CTX *last_ctx;\n };\n \n-\n /* main state of the ctdb daemon */\n struct ctdb_context {\n \tstruct event_context *ev;\n@@ -306,6 +306,7 @@\n \tstruct ctdb_call_state *pending_calls;\n \tstruct ctdb_takeover takeover;\n \tstruct ctdb_tcp_list *tcp_list;\n+\tstruct ctdb_client_ip *client_ip_list;\n };\n \n struct ctdb_db_context {\n@@ -926,7 +927,7 @@\n \n int ctdb_start_recoverd(struct ctdb_context *ctdb);\n \n-uint32_t ctdb_get_num_enabled_nodes(struct ctdb_context *ctdb);\n+uint32_t ctdb_get_num_active_nodes(struct ctdb_context *ctdb);\n \n void ctdb_stop_monitoring(struct ctdb_context *ctdb);\n void ctdb_start_monitoring(struct ctdb_context *ctdb);\n\n=== modified file 'server/ctdb_daemon.c'\n--- a/server/ctdb_daemon.c\t2007-06-12 09:44:54 +0000\n+++ b/server/ctdb_daemon.c\t2007-06-18 17:54:06 +0000\n@@ -211,6 +211,14 @@\n \t\tDEBUG(2,(__location__ \" Registered message handler for srvid=%llu\\n\", \n \t\t\t (unsigned long long)srvid));\n \t}\n+\n+\t/* this is a hack for Samba - we now know the pid of the Samba client */\n+\tif ((srvid & 0xFFFFFFFF) == srvid &&\n+\t    kill(srvid, 0) == 0) {\n+\t\tclient->pid = srvid;\n+\t\tDEBUG(0,(__location__ \" Registered PID %u for client %u\\n\",\n+\t\t\t (unsigned)client->pid, client_id));\n+\t}\n \treturn res;\n }\n \n\n=== modified file 'server/ctdb_server.c'\n--- a/server/ctdb_server.c\t2007-06-09 11:58:50 +0000\n+++ b/server/ctdb_server.c\t2007-06-18 17:54:06 +0000\n@@ -193,15 +193,15 @@\n \n \n /*\n-  return the number of enabled nodes\n+  return the number of active nodes\n */\n-uint32_t ctdb_get_num_enabled_nodes(struct ctdb_context *ctdb)\n+uint32_t ctdb_get_num_active_nodes(struct ctdb_context *ctdb)\n {\n \tint i;\n \tuint32_t count=0;\n \tfor (i=0;ivnn_map->size;i++) {\n \t\tstruct ctdb_node *node = ctdb->nodes[ctdb->vnn_map->map[i]];\n-\t\tif (!(node->flags & (NODE_FLAGS_INACTIVE|NODE_FLAGS_DISABLED))) {\n+\t\tif (!(node->flags & NODE_FLAGS_INACTIVE)) {\n \t\t\tcount++;\n \t\t}\n \t}\n\n=== modified file 'server/ctdb_traverse.c'\n--- a/server/ctdb_traverse.c\t2007-06-09 11:58:50 +0000\n+++ b/server/ctdb_traverse.c\t2007-06-18 17:54:06 +0000\n@@ -373,7 +373,7 @@\n \n \tif (key.dsize == 0 && data.dsize == 0) {\n \t\tstate->null_count++;\n-\t\tif (state->null_count != ctdb_get_num_enabled_nodes(ctdb)) {\n+\t\tif (state->null_count != ctdb_get_num_active_nodes(ctdb)) {\n \t\t\treturn 0;\n \t\t}\n \t}\n\n=== modified file 'takeover/ctdb_takeover.c'\n--- a/takeover/ctdb_takeover.c\t2007-06-09 23:54:27 +0000\n+++ b/takeover/ctdb_takeover.c\t2007-06-18 17:54:06 +0000\n@@ -51,6 +51,16 @@\n };\n \n \n+/*\n+  list of clients to kill on IP release\n+ */\n+struct ctdb_client_ip {\n+\tstruct ctdb_client_ip *prev, *next;\n+\tstruct ctdb_context *ctdb;\n+\tstruct sockaddr_in ip;\n+\tuint32_t client_id;\n+};\n+\n \n /*\n   send a gratuitous arp\n@@ -211,6 +221,27 @@\n \treturn 0;\n }\n \n+/*\n+  kill any clients that are registered with a IP that is being released\n+ */\n+static void release_kill_clients(struct ctdb_context *ctdb, struct sockaddr_in *sin)\n+{\n+\tstruct ctdb_client_ip *ip;\n+\n+\tfor (ip=ctdb->client_ip_list; ip; ip=ip->next) {\n+\t\tif (ip->ip.sin_addr.s_addr == sin->sin_addr.s_addr) {\n+\t\t\tstruct ctdb_client *client = ctdb_reqid_find(ctdb, \n+\t\t\t\t\t\t\t\t     ip->client_id, \n+\t\t\t\t\t\t\t\t     struct ctdb_client);\n+\t\t\tif (client->pid != 0) {\n+\t\t\t\tDEBUG(0,(__location__ \" Killing client pid %u for IP %s on client_id %u\\n\",\n+\t\t\t\t\t (unsigned)client->pid, inet_ntoa(sin->sin_addr),\n+\t\t\t\t\t      ip->client_id));\n+\t\t\t\tkill(client->pid, SIGKILL);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n \n /*\n   called when releaseip event finishes\n@@ -234,6 +265,10 @@\n \n \tctdb_daemon_send_message(ctdb, ctdb->vnn, CTDB_SRVID_RELEASE_IP, data);\n \n+\t/* kill clients that have registered with this IP */\n+\trelease_kill_clients(ctdb, state->sin);\n+\t\n+\n \t/* tell other nodes about any tcp connections we were holding with this IP */\n \tfor (tcp=ctdb->tcp_list;tcp;tcp=tcp->next) {\n \t\tif (tcp->vnn == ctdb->vnn && \n@@ -528,6 +563,15 @@\n \n \n /*\n+  destroy a ctdb_client_ip structure\n+ */\n+static int ctdb_client_ip_destructor(struct ctdb_client_ip *ip)\n+{\n+\tDLIST_REMOVE(ip->ctdb->client_ip_list, ip);\n+\treturn 0;\n+}\n+\n+/*\n   called by a client to inform us of a TCP connection that it is managing\n   that should tickled with an ACK when IP takeover is done\n  */\n@@ -540,6 +584,16 @@\n \tstruct ctdb_control_tcp_vnn t;\n \tint ret;\n \tTDB_DATA data;\n+\tstruct ctdb_client_ip *ip;\n+\n+\tip = talloc(client, struct ctdb_client_ip);\n+\tCTDB_NO_MEMORY(ctdb, ip);\n+\n+\tip->ctdb = ctdb;\n+\tip->ip = p->dest;\n+\tip->client_id = client_id;\n+\ttalloc_set_destructor(ip, ctdb_client_ip_destructor);\n+\tDLIST_ADD(ctdb->client_ip_list, ip);\n \n \ttcp = talloc(client, struct ctdb_tcp_list);\n \tCTDB_NO_MEMORY(ctdb, tcp);\n\n"}
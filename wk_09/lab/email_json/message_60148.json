{"category": "ham", "to_address": "perl6 language <perl6-language@perl.org>", "from_address": "Mark Overmeer <mark@overmeer.net>", "subject": "Documenting Perl6", "body": "\n=begin INTRO\n\nMongers,\n\nI must say, I am a bit disappointed that the discussions about the future\nof documentation in Perl has died.  Or was everyone fully occupied\nby YAPC::NA?  I spent last week with my family on a stormy island,\nwithout sufficient internet access, so was unable to stirr things up\nagain, but maybe this email will bring the focus back.\n\nDamian challenged me by asking what I think how Perl6's documentation\nshould be done.  When I think about documentation, I do not (immediately)\nthink about some mark-up language; that is just a minor component.\nMy focus is on the whole process: from writer to reader.  Although Damain\nsays to have studied OODoc, this most import features of that system\nwere ignored: simplifying the documentation process, improving the\ndocumentation quality.\n\nEach time I re-read the list below, there are things I wish to change\nor add: it is neither complete nor final.  But I cannot wait longer to\npost it.  It's not my wish to extend this into a detailed requirements\ndocument, just to set a focus of discussion.  Maybe someone wants to\ncomment on it?\n\n               MarkOv\n\n=end INTRO\n\n======== Documentation of code (i.e. Perl6)\n\nIn this text, we try to determine the environment for the optimal\ndocumentation system for Perl6, but applicable to any other programming\nlanguage.\n\nEveryone will have his/her own weights on different aspects, and you\nmay even totally not agree with some of the listed remarks: it is open\nto discussion.  Some of the wishes contradict an other as well.\n\n=== Goal\n\nThe sole goal: the best documentation for Perl6\n\nIt is very important to keep in mind that documentation is made for\nsome target community to be read.  Write-only texts are useless.\n\n=== Target communities\n\nDocumentation is added to code, to provide additional information about\nthe code to inform some target community.  There are different target\ncommunities possible for the same piece of code, which should all be\nserved as good as possible.\n\nTraditionally, you see\n    1) code comments, for maintainers of the software\n    2) manual-pages, for everyone else\n\nBut more specific user groups can be defined:\n    1) code comments, for maintainers\n    2) developer manuals (the complete interface)\n    3) user manuals (distribution external interfaces)\n    4) selective look-up (for perldoc -f or IDE)\n\n=== Fundamentals\n\nThere are a few fundaments for good documentation:\n  - it must be written\n  - it must be correct\n  - it must be consistent in structure\n  - it must be consistent in content\n  - it must be accessible (find back/pleasant to read)\n\n[Writing]\nThe best way to get people into writing documentation, is to make it as\nsimple as possible.  This means:\n - reduce the need to read man-pages or books to be able to create it,\n - reduce the amount of text to be typed,\n - avoid the need for additional tools to be installed,\n - reduce the need for configuration.\nAll for the sake of laziness.  The less time people need to manage their\ndocumentation environment, the more time they have to write quality texts.\n\n[Writing]\nTo ease the burden of writing docs, documentation generating tools\nshould use as much information from the code as is useful for the\ntarget community.  Replication between code and docs make changes\na double effort.  Manual replicated of text between files (like the\ninclusion of the license text in each file) during programming is an\navoidable burden.\n\n[Writing]\nEach documentation fragment belongs to some part of the implementation.\nThis may be a distribution, a file, a class or grammar or package,\na method, rule or sub, a positional or named parameter, and so on.\nThis relation comes natural (because of the mixture of code and doc),\nor enforced (via some reference syntax).\n\n[Writing]\nThe documentation fragments need some markup.  Many mark-up languages\nexist, which do have more or less the same features.  Two of those are\nPOD and PDD S26.  Within one distribution, it is useful to use the\nsame kind of markup syntax.  Document generators should only get a\nminimal abstract interface to collect the results of the markup\nparser, for instance a  $markup->produceHtml($fragment, ...)\n\n[Writing]\nThe markup language used should be capable of addressing the things\nthat a document writer wishes to express, not on what certain output\nback-end can handle (those can always ignore things they cannot handle)\n\n[Correctness]\nThe documentation and the related code must be cross checkable, on\nmatters they overlap.  Better to avoid replication, in which case\nthere is no overlap to be checked.\n\n[Correctness]\nThe user should be stimulated to write in a good style.  One of the\nways to achieve this, is to avoid the need to write the same sentence\nover and over again.  For instance: \"This method returns a boolean,\nto indicate success\" is a sentence to avoid.  (Template based) auto-\ngeneration could be used introduce abbreviations for often used\nconstructs.\n\n[Correctness]\nProduced manuals should by default be checked for the completeness (like\nPod::Coverage), correctness in syntax (like Pod::Checker), and the\nused references.  If possible, spell-checking (like Pod::Spell) should\nbe invoked automatically.\n\n[Structure]\nThere is a set of components we will always find in (UNIX) manual pages:\nthe one-line purpose (name), the synopsis, extended description, the subs\nand methods, the \"see also\", authors, and license.  The order and location\nof these documentation fragments, and their exact names are arbitrary.\nOnly the back-end can decide how, whether, and in which order these\ncomponents appear.\n\n[Structure]\nThe doc-writers should have general information about which documentation\ncomponents are minimally needed by the back-ends, for instance the\nname and the license.  A short-list of chapter names suffices.\n\n[Structure]\nThe documentation generating back-ends shall have the same idea about the\nstructure and meaning of the contributed documentation.  The back-ends\nonly generate end-user texts, without any need for interpretation of the\ndoc fragments.  Only this way, systems like search.cpan.org can be of\nvalue.\n\n[Content]\nOn the documentation writer's side, there usually is a serious problem:\nwriters do not know enough about the readers: their level of education,\ntheir actual interests, and the media they use to read the documentation.\nThis results in inconsistent documentation between distributions.\nFor instance, some people put internal interfaces into the manual-pages,\nwhere other do not want to bother the readers hence include them as\ncomments.  In Perl6, we have scoped subs and private methods, so it\nis much clearer whether a component is available to everyone or not.\nWe may produce different manual pages.\n\n[Content]\nIff the used markup-language permits the author to specify the commands\nwhich change the back-end's output (in the anarchistic tradition of Perl),\ntherewith endangering the consistency in output style or frustrating the\nautomatic processing of the content by other back-ends, then there must\nbe a simple way for the back-ends to protect themselves.  There should\nbe a standard way to remove this cruft from the documentation fragments.\n\n[Accessible]\nThe back-end, which produces the document the user will read, can be\ntraditional UNIX manual-pages, HTML web-pages, a printed book, whatever.\nOf course, you want to produce documents which fit as good as possible\nto the possibilities which a certain output medium gives.  POD(5) can\nbe used to produce web-pages, but the features to link between document\nelements are far below the levels we are used to for HTML web-pages.\nIt should be very simple to create anchors and references to very\nspecific locations in the text, like a single option description.\nPreferably without the need to define destination anchor points: the\ndocumentation where you point to can be in a different package, not\nunder your control.\n\n[Accessible]\nDocumentation fragments are usually written in coding order.\nThe programmer's activities are often quite chaotic: functions and\nmethods are written in the order that the programmer needs them.\nRelated components are often close together in the file, but there is\nno role for manual-order during this development process.  What is the\noptimal order for the user to consume the fragments?  A very workable\nsolution is to group the items (for instance, constructors, accessors,\n...) into text sections, and within those groups use alphabetic sorting.\nEach section may need some introductory text and examples.\nTo make doc fragments groupable is a requirement, and back-ends will\nwork-out how that grouping is used.\n\n=== Generation documentation\n\nThe documentation generation process could look schematically\nsomething like this:\n\n for each file in the MANIFEST\n    parse Perl into its AST\n    extract doc and code info from AST into doc-tree\n\n for each doc-fragment in doc-tree\n    do spell-check\n\n preform consistency, structural checks on doc-tree\n collect inheritance information into doc-tree\n\n for each package, class, grammar, pod in doc-tree\n    call generator back-end(s)\n    syntax check produced man-pages\n\n"}
{"category": "ham", "to_address": "\"perl6 language\" <perl6-language@perl.org>", "from_address": "\"Jasmine Pues\" <jasminep@gmail.com>", "subject": "Re: Documenting Perl6", "body": "This may be unnecessary, but if anyone needs help with stylistic parts\nof the documentation (I can cross-check for accuracy) for a target\naudience (i.e., is it documentation for beginners, or those already\nfamiliar with Perl5? Is it aimed toward other programmers who are\nswitching languages or using Perl exclusively, or is it aimed toward\nthose with minimal experience who are used to markup languages and\nperhaps introductory C or something?)\n\nJust thought I'd volunteer for the effort, if needed.\n\n-Jasmine\n\nOn 02/07/07, Mark Overmeer  wrote:\n>\n> =begin INTRO\n>\n> Mongers,\n>\n> I must say, I am a bit disappointed that the discussions about the future\n> of documentation in Perl has died.  Or was everyone fully occupied\n> by YAPC::NA?  I spent last week with my family on a stormy island,\n> without sufficient internet access, so was unable to stirr things up\n> again, but maybe this email will bring the focus back.\n>\n> Damian challenged me by asking what I think how Perl6's documentation\n> should be done.  When I think about documentation, I do not (immediately)\n> think about some mark-up language; that is just a minor component.\n> My focus is on the whole process: from writer to reader.  Although Damain\n> says to have studied OODoc, this most import features of that system\n> were ignored: simplifying the documentation process, improving the\n> documentation quality.\n>\n> Each time I re-read the list below, there are things I wish to change\n> or add: it is neither complete nor final.  But I cannot wait longer to\n> post it.  It's not my wish to extend this into a detailed requirements\n> document, just to set a focus of discussion.  Maybe someone wants to\n> comment on it?\n>\n>                MarkOv\n>\n> =end INTRO\n>\n> ======== Documentation of code (i.e. Perl6)\n>\n> In this text, we try to determine the environment for the optimal\n> documentation system for Perl6, but applicable to any other programming\n> language.\n>\n> Everyone will have his/her own weights on different aspects, and you\n> may even totally not agree with some of the listed remarks: it is open\n> to discussion.  Some of the wishes contradict an other as well.\n>\n> === Goal\n>\n> The sole goal: the best documentation for Perl6\n>\n> It is very important to keep in mind that documentation is made for\n> some target community to be read.  Write-only texts are useless.\n>\n> === Target communities\n>\n> Documentation is added to code, to provide additional information about\n> the code to inform some target community.  There are different target\n> communities possible for the same piece of code, which should all be\n> served as good as possible.\n>\n> Traditionally, you see\n>     1) code comments, for maintainers of the software\n>     2) manual-pages, for everyone else\n>\n> But more specific user groups can be defined:\n>     1) code comments, for maintainers\n>     2) developer manuals (the complete interface)\n>     3) user manuals (distribution external interfaces)\n>     4) selective look-up (for perldoc -f or IDE)\n>\n> === Fundamentals\n>\n> There are a few fundaments for good documentation:\n>   - it must be written\n>   - it must be correct\n>   - it must be consistent in structure\n>   - it must be consistent in content\n>   - it must be accessible (find back/pleasant to read)\n>\n> [Writing]\n> The best way to get people into writing documentation, is to make it as\n> simple as possible.  This means:\n>  - reduce the need to read man-pages or books to be able to create it,\n>  - reduce the amount of text to be typed,\n>  - avoid the need for additional tools to be installed,\n>  - reduce the need for configuration.\n> All for the sake of laziness.  The less time people need to manage their\n> documentation environment, the more time they have to write quality texts.\n>\n> [Writing]\n> To ease the burden of writing docs, documentation generating tools\n> should use as much information from the code as is useful for the\n> target community.  Replication between code and docs make changes\n> a double effort.  Manual replicated of text between files (like the\n> inclusion of the license text in each file) during programming is an\n> avoidable burden.\n>\n> [Writing]\n> Each documentation fragment belongs to some part of the implementation.\n> This may be a distribution, a file, a class or grammar or package,\n> a method, rule or sub, a positional or named parameter, and so on.\n> This relation comes natural (because of the mixture of code and doc),\n> or enforced (via some reference syntax).\n>\n> [Writing]\n> The documentation fragments need some markup.  Many mark-up languages\n> exist, which do have more or less the same features.  Two of those are\n> POD and PDD S26.  Within one distribution, it is useful to use the\n> same kind of markup syntax.  Document generators should only get a\n> minimal abstract interface to collect the results of the markup\n> parser, for instance a  $markup->produceHtml($fragment, ...)\n>\n> [Writing]\n> The markup language used should be capable of addressing the things\n> that a document writer wishes to express, not on what certain output\n> back-end can handle (those can always ignore things they cannot handle)\n>\n> [Correctness]\n> The documentation and the related code must be cross checkable, on\n> matters they overlap.  Better to avoid replication, in which case\n> there is no overlap to be checked.\n>\n> [Correctness]\n> The user should be stimulated to write in a good style.  One of the\n> ways to achieve this, is to avoid the need to write the same sentence\n> over and over again.  For instance: \"This method returns a boolean,\n> to indicate success\" is a sentence to avoid.  (Template based) auto-\n> generation could be used introduce abbreviations for often used\n> constructs.\n>\n> [Correctness]\n> Produced manuals should by default be checked for the completeness (like\n> Pod::Coverage), correctness in syntax (like Pod::Checker), and the\n> used references.  If possible, spell-checking (like Pod::Spell) should\n> be invoked automatically.\n>\n> [Structure]\n> There is a set of components we will always find in (UNIX) manual pages:\n> the one-line purpose (name), the synopsis, extended description, the subs\n> and methods, the \"see also\", authors, and license.  The order and location\n> of these documentation fragments, and their exact names are arbitrary.\n> Only the back-end can decide how, whether, and in which order these\n> components appear.\n>\n> [Structure]\n> The doc-writers should have general information about which documentation\n> components are minimally needed by the back-ends, for instance the\n> name and the license.  A short-list of chapter names suffices.\n>\n> [Structure]\n> The documentation generating back-ends shall have the same idea about the\n> structure and meaning of the contributed documentation.  The back-ends\n> only generate end-user texts, without any need for interpretation of the\n> doc fragments.  Only this way, systems like search.cpan.org can be of\n> value.\n>\n> [Content]\n> On the documentation writer's side, there usually is a serious problem:\n> writers do not know enough about the readers: their level of education,\n> their actual interests, and the media they use to read the documentation.\n> This results in inconsistent documentation between distributions.\n> For instance, some people put internal interfaces into the manual-pages,\n> where other do not want to bother the readers hence include them as\n> comments.  In Perl6, we have scoped subs and private methods, so it\n> is much clearer whether a component is available to everyone or not.\n> We may produce different manual pages.\n>\n> [Content]\n> Iff the used markup-language permits the author to specify the commands\n> which change the back-end's output (in the anarchistic tradition of Perl),\n> therewith endangering the consistency in output style or frustrating the\n> automatic processing of the content by other back-ends, then there must\n> be a simple way for the back-ends to protect themselves.  There should\n> be a standard way to remove this cruft from the documentation fragments.\n>\n> [Accessible]\n> The back-end, which produces the document the user will read, can be\n> traditional UNIX manual-pages, HTML web-pages, a printed book, whatever.\n> Of course, you want to produce documents which fit as good as possible\n> to the possibilities which a certain output medium gives.  POD(5) can\n> be used to produce web-pages, but the features to link between document\n> elements are far below the levels we are used to for HTML web-pages.\n> It should be very simple to create anchors and references to very\n> specific locations in the text, like a single option description.\n> Preferably without the need to define destination anchor points: the\n> documentation where you point to can be in a different package, not\n> under your control.\n>\n> [Accessible]\n> Documentation fragments are usually written in coding order.\n> The programmer's activities are often quite chaotic: functions and\n> methods are written in the order that the programmer needs them.\n> Related components are often close together in the file, but there is\n> no role for manual-order during this development process.  What is the\n> optimal order for the user to consume the fragments?  A very workable\n> solution is to group the items (for instance, constructors, accessors,\n> ...) into text sections, and within those groups use alphabetic sorting.\n> Each section may need some introductory text and examples.\n> To make doc fragments groupable is a requirement, and back-ends will\n> work-out how that grouping is used.\n>\n> === Generation documentation\n>\n> The documentation generation process could look schematically\n> something like this:\n>\n>  for each file in the MANIFEST\n>     parse Perl into its AST\n>     extract doc and code info from AST into doc-tree\n>\n>  for each doc-fragment in doc-tree\n>     do spell-check\n>\n>  preform consistency, structural checks on doc-tree\n>  collect inheritance information into doc-tree\n>\n>  for each package, class, grammar, pod in doc-tree\n>     call generator back-end(s)\n>     syntax check produced man-pages\n>\n\n\n-- \n\"Don't presume to lecture me about good and evil. I've been there,\nyou've just seen a map.\"\n-Orson Scott Card\n\n--\nhttp://www.spreadfirefox.com\n\n"}
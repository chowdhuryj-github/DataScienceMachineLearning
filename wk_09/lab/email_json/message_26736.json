{"category": "ham", "to_address": "Nicholas Clark <nick@ccl4.org>", "from_address": "Joshua Isom <jrisom@gmail.com>", "subject": "Re: [svn:parrot] r18381 - trunk/include/parrot", "body": "\nOn May 9, 2007, at 4:01 PM, Nicholas Clark wrote:\n\n> On Wed, May 09, 2007 at 01:06:49PM -0700, chromatic wrote:\n>> On Wednesday 09 May 2007 12:53:57 Nicholas Clark wrote:\n>>\n>>> On Tue, May 01, 2007 at 04:41:22PM -0700, particle@cvs.perl.org \n>>> wrote:\n>>>> +\n>>>> +#define STRING_IS_NULL(s) ((s) == NULL)\n>>>> +#define STRING_IS_EMPTY(s) !(int)(s)->strlen\n>\n>> Does !(int)(s)->strlen really scan as quickly and easily as \n>> STRING_IS_EMPTY?\n>\n> Mmm, yes, thinking about it more...\n> What's that int cast doing there?\n>\n> Smells like a bug. Either (s)->strlen is going to be zero, in which \n> case\n> ! of it is true, or it's going to be in the range INT_MIN to INT_MAX, \n> in\n> which case it's not true, or it's going to be outside that range, in \n> which\n> case the cast is undefined behaviour. (because it's signed)\n>\n\nCasting to an int is definitely a bug.  Since on amd64, int is 32 bits \nand INTVAL is 64 bits(and void* is 64 bits), I've become cautious of \nany int in the code.  But I do find it a tad odd that strlen can be \nnegative, and I wonder what affect setting it to a negative number \nwould have on other parts of the system(besides unknown behavior).  \nUsing a macro for anything using casts is probably a decent thing \nbecause of false assumptions about how a compiler chooses the size of a \ntype.  Should maybe add a cage ticket about using things like \"int\" and \n\"short\" in source files(or anything other than config.h).  It'd \nhopefully prevent such issues(the sizeof(int) != sizeof(void*) caused a \ncrash with pccmethods until a refactoring recently) from occuring, at \nthe cost of commonly used(or assumed) methods for treating data.\n\n> I've not checked, and I'm not sure if it's going to be easy to do so, \n> but\n> I assume that the cast was moved into the macro as part of refactoring,\n> and has been in the code for some time.\n>\n> So, !s->strlen does scan as quickly and easily.\n>\n\nTo some, but it isn't as easy to just literally read.  \"Not s's strlen\" \nis a lot different than \"STRING_IS_EMTPY\".  Since the code will be read \noften, and often by people not familiar with parrot's internals, it \nmakes sense to make it easily readable.  It takes me a second to read \n!s->strlen, but half a second to read STRING_IS_EMTPY.\n\n> s == NULL is also more tersely written as !s, which, I feel, is also \n> clearer\n> to regular C programmers.\n\nEh, if we have one, may as well have the other, although this one seems \nsimple enough.\n\n> I've also intentionally left the parentheses off, as once you aren't \n> using\n> macros, you can choose not to use them on simple expressions.\n>\n>>> Arguably one of the mistakes of Perl 5 was to use too many macros, \n>>> which\n>>> unintentionally contributes to obfuscating the code.\n>>\n>> It's not as if *these* are SvPVNL and SvPVZ, or was that SVpvNL or \n>> SvPv\n>> or....?\n>\n> Yes. Those ones. But after about 5 years I started to see the patterns \n> in them.\n>\n> Clearly 5 years isn't a rapid learning curve.\n>\n\nAnd one of the major reasons I don't want to even look at the perl5 \nsource to find the code I'm wanting.  Plus the documentation of the \ncode isn't great last I saw(like where's the definition of what SvPVNL \nis?).  Parrot does have a couple flaws for finding struct definitions, \namong other things.  It took me a couple minutes(and many greps) to \nfind that STRING is defined in pobj.h as parrot_string_t.  Then again, \nthe macros in question aren't in any string related file but in \ninterpreter.h(although that one was quicker).\n\n> Nicholas Clark\n>\n\n"}
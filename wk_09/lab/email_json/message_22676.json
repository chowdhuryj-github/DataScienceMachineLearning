{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [perl #42865] [BUG] There's no way to set a vtable function with\n a Sub at runtime", "body": "Alek Storm wrote:\n> I'm almost done with the PDD15 implementation of vtable overriding.  It \n> adds\n> the 'add_vtable_method' PCCMETHOD to Class, but also adds methods to the\n> vtable in 'add_method', if they have the :vtable pragma set, like the old\n> object system.  I kept this capability for compatibility, but I'd love to\n> remove it, along with the :vtable pragma.  I'm very against adding a new\n> opcode, since this is exactly what PCCMETHODs, and, eventually, PMC roles\n> are designed for, though the sentiment is the same.\n\nTake a step back and explain your motivations for adding \n'add_vtable_method'?\n\nThe :vtable pragma is necessary for defining a .sub as an overridden \nvtable function in PIR code. If you had a replacement in mind, run it by \nthe list and we'll discuss it, but we can't just eliminate the feature.\n\n> How PMCs interact with vtable methods in PIR is dependent on the object\n> system used.  The default (PDD15) object system utilizes vtable overriding,\n> but other object systems have different semantics.  This means, while PIR\n> code can wrap PMCs in their own object system, we can't make all PMCs\n> object-aware. \n\nWhy would other object systems not use vtable overriding? Vtable \noverriding is a Parrot feature, it's the way high-level classes \nimplement their interactions with the virtual machine at a low level. \nDifferent object systems having different semantics doesn't change the \nfact that they implement those semantics using a combination of vtable \nfunctions and methods.\n\n> If you want to override vtable methods for built-in PMCs \n> such\n> as Integer, you need to implement PMC subclassing for PDD15 ;)\n\nWhich is part of the spec.\n\nAllison\n\n"}
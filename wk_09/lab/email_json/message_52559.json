{"category": "ham", "to_address": "beginners perl <beginners@perl.org>", "from_address": "Tom Allison <tom@tacocat.net>", "subject": "still working with utf8", "body": "OK, I sorted out what the deal is with charsets, Encode, utf8 and  \nother goodies.\n\nNow I have something I'm just not sure exactly how it is supposet to  \noperate.\n\nI have a string:\n=?iso-2022-jp?B?Rlc6IBskQjxkJDckNSRHJE8kSiQvJEYzWiQ3JF8kPyQkGyhC?=\nThat is a MIME::Base64 encoded string of iso-2022-jp characters.\n\nAfter I decode_base64 them and decode($text,'iso-2022-jp',utf8') them  \nI can print out something that looks exactly like japanese characters.\n\nBut you can't match /(\\w+) on them.  It's apparently one \"word\"  \nwithout spaces in it.\nUm... I don't know Japanese.  But I guess this string of spaghetti  \n(to me) is actually a language where one character as represented in  \na unicode terminal is actually one 'word' according to the perl  \ndefinition of a word...\n\nIn english, this would pick apart words in a sense that is simple for  \nme and many on this list to understand.\n\nI guess my question is, for CJK languages, should I expect the notion  \nof using a regex like \\w+ to pick up entire strings of text instead  \nof discrete words like latin based languages?\n\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
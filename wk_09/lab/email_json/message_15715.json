{"category": "ham", "to_address": "\"Jonathan Worthington\" <jonathan@jnthn.net>", "from_address": "\"jerry gay\" <jerry.gay@gmail.com>", "subject": "Re: [perl #42620] PGE 'Out of memory' panics.", "body": "On 4/25/07, Jonathan Worthington  wrote:\n> Andy Spieherty wrote:\n> > 2.  Garbage collection really slows the program down (I observed factors of 10 difference in speed with and without -G), and I have a vague unsupported suspicion that the slowdown grows faster than linearly with the allocated memory.\n> >\n> I remember tracing through a load of this code for about an hour. I was\n> none the wiser afterwards, but I was trying to work out arenas and\n> allocation stuff and so on.\n>\n> Basically, if you run the program without -G and then break it, it will\n> usually break inside the GC routine. What I do remember is that it was\n> looping through some kinda memory pool, or arena, or whatever. However,\n> the thing it was looping through was *huge* (like, from 0 to a six\n> figure number) and I think it maybe was an n^2 algorithm, which\n> amplified the effect further.\n>\n> Recent mentions of a lack of memory pool compaction kinda resonates with\n> what I analyzed; I always meant to return to look a bit more, but never\n> had time to dig deeper. I think re-discovering where it's spending so\n> much time during GC would be a good start, though. And just randomly\n> breaking into the program did it for me, usually first time.\n>\nyep, in src/gc/dod.c, i end up inside Parrot_dod_sweep()\ncur_arena->used is 137910 at present, which is where i broke in at test 177.\n\nthere's a loop that looks like:\n\n        for (i = nm = 0; i < cur_arena->used; i++) {\n            if (PObj_on_free_list_TEST(b))\n                ; /* if it's on free list, do nothing */\n            else if (PObj_live_TEST(b)) {\n                total_used++;\n                PObj_live_CLEAR(b);\n                PObj_get_FLAGS(b) &= ~PObj_custom_GC_FLAG;\n            }\n            else {\n                /* it must be dead */\n\ni set a breakpoint at\n                total_used++;\n\nthe first time this line is executed is when i = 134459 -- that's the\nfirst live object. that seems odd. when i get up around 137700, just\nabout every object is live.\n\nand that is just for one arena. counting through the chain of\ncur_arena->prev, it seems there are ten arenas. i'm in over my head\nhere--but it seems to me that both this chain of arenas and the size\nof each is much bigger than i imagine it should be.\n~jerry\n\n"}
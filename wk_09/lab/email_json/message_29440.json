{"category": "ham", "to_address": "sugar@laptop.org", "from_address": "Simon McVittie <simon.mcvittie@collabora.co.uk>", "subject": "Re: [sugar] Obtaining Buddy objects as contacts are encountered", "body": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nSummarizing some more issues discussed offline and in #sugar.\n\nThe difficult case for me at the moment is when a new person, who we don't know\nanything about, turns up in our (public) Tubes channel and joins a tube.\n\nProtocol constraints:\n=====================\n\nIn the XMPP implementation, they are deemed to have joined the\nchannel when they join the chat-room on the server (when we first\nreceive a presence message for them that came through the room), and they are\ndeemed to have joined the Tube when we first receive a presence message\nfor them that indicates that they are in the Tube.\n\nThe only identifying information we have in the presence message is their\nJID, e.g. 87654321f00d1234deadbeef@conference.olpc.collabora.co.uk on the\ntest server. This is presented in the Telepathy API as the contact's \"handle\",\nwhich is a small integer used as an abstraction for all protocols' ideas of\nunique identifiers.\n\nThe PS currently constructs JIDs by taking the hex SHA-1 of the public key,\nbut it appears this is intended to be an internal implementation detail\nonly, so we shouldn't rely on this (and neuralis doesn't want SHA-1 to\nbe used for anything cryptographically significant, which is fair enough).\nBecause this generates very unfriendly JIDs, we can't use the JID as a\nfall-back or a unique ID in the user interface like we would on the desktop\n(seeing a contact called bob.smith@example.com is useful, seeing a contact\ncalled 87654321f00d1234deadbeef is unhelpful).\n\nTo find out the buddy's public key and real name (their immutable\nidentity) and their colour, avatar and nickname (their mutable\nidentity) we have to query the server, which takes network round-trips,\nwhich might be slow and should be done asynchronously.\n\nOn the mesh contacts are again identified by Telepathy handles; this\ntime the handles represent mesh-specific unique IDs (nickname + \"@\" + IP\naddress, I think). The protocol hasn't been fully designed yet, but I expect it\nto be \"fast\" (round-trip-free) to retrieve the name, nick, colour and server\nJID, and probably \"slow\" to retrieve the public key and avatar, which are both\nlarger.\n\nThe message flow inside the Tube is a D-Bus connection, in which\nparticipants are identified by unique bus name (in our case these are\nrandomly generated). The Telepathy API provides a mapping between\nTelepathy handles and unique names. As soon as someone has a unique\nname, they are a full participant in the tube and can send and receive\nD-Bus messages.\n\nBecause we trust the server and (in future) have an encrypted and\nauthenticated connection to it, there is no additional encryption -\nunencrypted Base64 messages flow through the server.\n\nOn the mesh the problem is probably easier - because there's no trusted\nserver, setting up a secure connection requires key negotiation in any\ncase.\n\nRequirements:\n=============\n\nBuddy objects\n- -------------\nTo avoid forcing activity authors to deal with Telepathy handles\ndirectly, we want to provide a map between unique bus names and Buddy\nobjects, so the activity author can just deal with those.\n\nOrdering\n- --------\nTo allow the network protocol to be relatively simple, we want the\norder of D-Bus messages in the tube to be guaranteed in the same way it is on\na normal, daemon-based bus - namely, that everyone sees broadcast\nmessages (signals) arriving in the same order, and that all the messages\ncoming from a particular peer can be received in the same order they're\nsent in.\n\nKey as unique ID\n- ----------------\nDan requires that the Buddy be uniquely identified by\nits public key and no Buddy object may be created until the public key is\nknown. This is part of the current PS architecture.\n\nNo undetected eavesdropping\n- ---------------------------\n(A softer requirement)\n\nUsers should be able to tell when someone can receive their messages\n(and preferably who that someone is, but failing that it's useful to be able\nto tell that some as-yet unknown person has joined). Consider the\ncase where Alice invites Bob to join the channel without Chris' knowledge,\nand Chris says something Bob wasn't meant to see having not realised Bob has\nalready joined.\n\nPossible solutions\n==================\n\nAdvantages/disadvantages marked +/-. Having thought these over, I quite\nlike \"Newcomer broadcasts key\", which isn't a solution I'd thought of\nbefore writing this email, so I've put that one first.\n\nNewcomer broadcasts key\n- -----------------------\nWhen the new contact joins, they broadcast their key. Everyone else\nobserves it and uses it to create a Buddy object if necessary. Until the\nkey broadcast has been done, one of the other solutions (block the tube?\ndrop their messages? buddy is None?) is used. Optionally, they could\ninclude their colour, nick and other small, useful things in the key\nbroadcast.\n\nThis could either be done inside each Tube (this would prevent activities\nfrom using an existing D-Bus protocol completely unchanged inside a\nTube), in a special-purpose Tube (service name org.laptop.Tubes.BuddyInfo\nor something - I'd prefer this option), or in the Tubes channel outside\nany Tube (this would require a Telepathy spec extension).\n\n+ in Salut the \"key broadcast\" might be synthesized by the CM since it\n  must already have the key in order to create the channel/tube\n+ could be used as a basis for encrypted tubes in a future Telepathy\n  spec version? (an advantage for the community rather than for OLPC, really)\n- - unnecessary broadcast if everyone in the channel already has the\n  newcomer's key (n people joining a channel only cause O(n) traffic\n  though, and the key isn't huge)\n- - they can eavesdrop undetected until their identity is found, unless\n  the action taken until the broadcast prevents this\n\nDrop ordering\n- -------------\nDrop the Ordering requirement. When a new contact joins\na tube, defer processsing all their messages until their identity can be\ndiscovered.\n\n- - writing robust protocols becomes hard\n- - eavesdropping possible\n- - it's hard to include the new contact in the UI as an \"anonymous\" grey XO\n  or something\n\nBlocked tube\n- ------------\nWhen a new contact joins a tube (or possibly a tubes channel),\nyou stop processing all tube messages in that tube/channel (by\ndetaching its fd from the main loop) until finding out the contact's identity\nhas either succeeded or failed (if it fails, they can be shown in the UI\nas some sort of anonymous buddy - this would happen if an ordinary XMPP\nclient joined, for instance).\n\n+ conceptually very simple\n+ the new contact can't eavesdrop on messages, if the blocking is\n  channel-wide\n- - suspending processing for the tube or channel may not be easy or even\n  possible in all bindings (this can of course be fixed by writing code)\n- - easy DoS in public channels - just join and don't reply to\n  identity-finding messages\n\nAck required\n- ------------\nWhen a new contact joins a tube/channel, all messages from\nthem in that tube/all tubes in the channel are dropped until all existing\ncontacts in the tube/channel have acknowledged them. Existing contacts will\nonly acknowledge the new contact when finding their identity has either failed\nor succeeded.\n\n+ conceptually quite simple\n- - the unID'd client can eavesdrop in the meantime\n- - n people joining an empty channel cause O(n^2) broadcast messages and\n  O(n^3) traffic\n\nbuddy is None\n- -------------\nWhen a new contact joins a tube/channel, their buddy\nobject is None until their identity can be discovered. It's up to the\nactivity how to deal with this - it could defer messages, implement an\nactivity-specific protocol with acknowledgements required, or whatever.\nThe application author knows what protocol they're implementing, so\nknows whether deferring messages is safe.\n\n+ trivial to implement in the PS\n+ UI immediately shows that *someone*'s joined\n- - moves the burden onto application authors, and there are more of them\n  than PS authors\n\nJID as unique ID\n- ----------------\nDrop the \"key as unique ID\" requirement. Look up Buddy objects by JID -\nthen we can immediately know whether to create a new Buddy object and\nuse an existing one.\n\n+ A good fit for what's going on at the protocol level, so easy to\n  implement\n+ Matches the behaviour expected from non-OLPC clients, so will be\n  familiar to desktop IM developers\n- - Major conceptual change to the Presence Service may break things\n- - You still don't have their public key until some later point\n\nComments? Questions? Complaints? Additional requirements I haven't\naddressed or should think about?\n\n\tSimon\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.6 (GNU/Linux)\nComment: OpenPGP key: http://www.pseudorandom.co.uk/2003/contact/ or pgp.net\n\niD8DBQFGSG1cWSc8zVUw7HYRAkolAKDehUQVxj//YeNvl1qrV0CjHglTjACdFEIG\neKop+mO4VieiQnte1liL5Y0=\n=h3rw\n-----END PGP SIGNATURE-----\n_______________________________________________\nSugar mailing list\nSugar@laptop.org\nhttp://mailman.laptop.org/mailman/listinfo/sugar\n\n"}
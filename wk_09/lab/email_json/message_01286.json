{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 80: merge tcp changes from ronnie in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 80\nrevision-id: tridge@samba.org-20070410044813-b5c4d10a223f32dd\nparent: tridge@samba.org-20070410044632-78db5388490c3d40\nparent: ronniesahlberg@gmail.com-20070410031715-9ec894cesu1zghs4\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-04-10 14:48:13 +1000\nmessage:\n  merge tcp changes from ronnie\nmodified:\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  tcp/ctdb_tcp.h                 ctdb_tcp.h-20061127103747-l8xeniwiapbydehq-3\n  tcp/tcp_io.c                   tcp_io.c-20061128004937-x70q1cu5xzg5g2tm-3\n    ------------------------------------------------------------\n    merged: ronniesahlberg@gmail.com-20070410031715-9ec894cesu1zghs4\n    parent: ronniesahlberg@gmail.com-20070410023925-skzpy7ls4t4z5lzp\n    committer: Ronnie sahlberg \n    branch nick: ctdb\n    timestamp: Tue 2007-04-10 13:17:15 +1000\n    message:\n      change the tcp code to call ctdb_read_pdu() instead of doing the partial read thing explicitely\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-04-10 02:39:25 +0000\n+++ b/common/ctdb.c\t2007-04-10 03:17:15 +0000\n@@ -340,8 +340,6 @@\n \n int ctdb_start(struct ctdb_context *ctdb)\n {\n-\tint res;\n-\n \tif (ctdb->flags&CTDB_FLAG_DAEMON_MODE) {\n \t\treturn ctdbd_start(ctdb);\n \t}\n\n=== modified file 'tcp/ctdb_tcp.h'\n--- a/tcp/ctdb_tcp.h\t2006-12-19 01:07:07 +0000\n+++ b/tcp/ctdb_tcp.h\t2007-04-10 03:17:15 +0000\n@@ -25,22 +25,12 @@\n };\n \n /*\n-  incoming packet structure - only used when we get a partial packet\n-  on read\n-*/\n-struct ctdb_tcp_partial {\n-\tuint8_t *data;\n-\tuint32_t length;\n-};\n-\n-\n-/*\n   state associated with an incoming connection\n */\n struct ctdb_incoming {\n \tstruct ctdb_context *ctdb;\n \tint fd;\n-\tstruct ctdb_tcp_partial partial;\n+\tstruct ctdb_partial partial;\n };\n \n /*\n\n=== modified file 'tcp/tcp_io.c'\n--- a/tcp/tcp_io.c\t2007-02-07 02:26:07 +0000\n+++ b/tcp/tcp_io.c\t2007-04-10 03:17:15 +0000\n@@ -98,6 +98,38 @@\n }\n \n \n+\n+static void tcp_read_cb(uint8_t *data, int cnt, void *args)\n+{\n+\tstruct ctdb_incoming *in = talloc_get_type(args, struct ctdb_incoming);\n+\tstruct ctdb_req_header *hdr;\n+\n+\tif (cnt < sizeof(*hdr)) {\n+\t\tctdb_set_error(in->ctdb, \"Bad packet length %d\\n\", cnt);\n+\t\treturn;\n+\t}\n+\thdr = (struct ctdb_req_header *)data;\n+\tif (cnt != hdr->length) {\n+\t\tctdb_set_error(in->ctdb, \"Bad header length %d expected %d\\n\", \n+\t\t\t       hdr->length, cnt);\n+\t\treturn;\n+\t}\n+\n+\tif (hdr->ctdb_magic != CTDB_MAGIC) {\n+\t\tctdb_set_error(in->ctdb, \"Non CTDB packet rejected\\n\");\n+\t\treturn;\n+\t}\n+\n+\tif (hdr->ctdb_version != CTDB_VERSION) {\n+\t\tctdb_set_error(in->ctdb, \"Bad CTDB version 0x%x rejected\\n\", hdr->ctdb_version);\n+\t\treturn;\n+\t}\n+\n+\t/* most common case - we got a whole packet in one go\n+\t   tell the ctdb layer above that we have a packet */\n+\tin->ctdb->upcalls->recv_pkt(in->ctdb, data, cnt);\n+}\n+\n /*\n   called when an incoming connection is readable\n */\n@@ -105,85 +137,8 @@\n \t\t\t    uint16_t flags, void *private)\n {\n \tstruct ctdb_incoming *in = talloc_get_type(private, struct ctdb_incoming);\n-\tint num_ready = 0;\n-\tssize_t nread;\n-\tuint8_t *data, *data_base;\n-\n-\tif (ioctl(in->fd, FIONREAD, &num_ready) != 0 ||\n-\t    num_ready == 0) {\n-\t\t/* we've lost the link from another node. We don't\n-\t\t   notify the upper layers, as we only want to trigger\n-\t\t   a full node reorganisation when a send fails - that\n-\t\t   allows nodes to restart without penalty as long as\n-\t\t   the network is idle */\n-\t\ttalloc_free(in);\n-\t\treturn;\n-\t}\n-\n-\tin->partial.data = talloc_realloc_size(in, in->partial.data, \n-\t\t\t\t\t       num_ready + in->partial.length);\n-\tif (in->partial.data == NULL) {\n-\t\t/* not much we can do except drop the socket */\n-\t\ttalloc_free(in);\n-\t\treturn;\n-\t}\n-\n-\tnread = read(in->fd, in->partial.data+in->partial.length, num_ready);\n-\tif (nread <= 0) {\n-\t\t/* the connection must be dead */\n-\t\ttalloc_free(in);\n-\t\treturn;\n-\t}\n-\n-\tdata = in->partial.data;\n-\tnread += in->partial.length;\n-\n-\tin->partial.data = NULL;\n-\tin->partial.length = 0;\n-\n-\tif (nread >= 4 && *(uint32_t *)data == nread) {\n-\t\t/* most common case - we got a whole packet in one go\n-\t\t   tell the ctdb layer above that we have a packet */\n-\t\tin->ctdb->upcalls->recv_pkt(in->ctdb, data, nread);\n-\t\treturn;\n-\t}\n-\n-\tdata_base = data;\n-\n-\twhile (nread >= 4 && *(uint32_t *)data <= nread) {\n-\t\t/* we have at least one packet */\n-\t\tuint8_t *d2;\n-\t\tuint32_t len;\n-\t\tlen = *(uint32_t *)data;\n-\t\td2 = talloc_memdup(in, data, len);\n-\t\tif (d2 == NULL) {\n-\t\t\t/* sigh */\n-\t\t\ttalloc_free(in);\n-\t\t\treturn;\n-\t\t}\n-\t\tin->ctdb->upcalls->recv_pkt(in->ctdb, d2, len);\n-\t\tdata += len;\n-\t\tnread -= len;\t\t\n-\t}\n-\n-\tif (nread > 0) {\n-\t\t/* we have only part of a packet */\n-\t\tif (data_base == data) {\n-\t\t\tin->partial.data = data;\n-\t\t\tin->partial.length = nread;\n-\t\t} else {\n-\t\t\tin->partial.data = talloc_memdup(in, data, nread);\n-\t\t\tif (in->partial.data == NULL) {\n-\t\t\t\ttalloc_free(in);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tin->partial.length = nread;\n-\t\t\ttalloc_free(data_base);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\ttalloc_free(data_base);\n+\n+\tctdb_read_pdu(in->fd, in, &in->partial, tcp_read_cb, in);\n }\n \n /*\n\n"}
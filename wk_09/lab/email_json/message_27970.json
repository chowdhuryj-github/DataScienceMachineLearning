{"category": "ham", "to_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: yet another regex", "body": "On 5/11/07, Tom Phoenix  wrote:\n> On 5/11/07, Steve Finkelstein  wrote:\n>\n> > sflinux themes # echo 500 | perl -ple 's|(\\d)|length(9 x $1)|eg;'\n> > 500\n>\n> > essentially, (\\d) should match just the '5' in 500. that puts $1 == the\n> > literal 5. so you take length(9 x 5) which is nine repeated 5 times, and\n> > the length of that is 5. That replaces the 5 with a ... 5?\n> >\n> > Is my logic correct on this?\n>\n> I think you've got it, except it doesn't stop with the 5. Unless I'm\n> missing something, that substitution means the same thing as this\n> simpler one:\n>\n>     s#(\\d)#$1#g\n>\n> Unless the value of $1 is useful, it's hard to see what good this\n> does. It replaces each digit with itself. As side effects it affects\n> all the match variables, and it stringifies its target.\n>\n> Did you find that piece of code somewhere? Do you know what its author\n> was trying to do?\n>\n> --Tom Phoenix\n> Stonehenge Perl Training\n\nBeyond obfuscation, I can only think of one reason to write something\nlike that: un-tainting.  But even then it is bad regex for that since\nit doesn't validate anything.\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
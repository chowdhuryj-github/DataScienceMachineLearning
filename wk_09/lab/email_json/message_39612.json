{"category": "ham", "to_address": "beginners@perl.org, perl-beginners@moderators.isc.org", "from_address": "Paul Lalli <mritty@gmail.com>", "subject": "Re: Passing arguments to subroutine", "body": "On May 31, 4:27 am, almatir...@gmail.com (Alma) wrote:\n> I need to pass the result of prepare statement as an argument to the\n> subroutine.\n>\n> sub abc()\n\nThe () there very specifically say \"This subroutine takes no\narguments\".\n\n\n> {\n>         my $self= shift;\n>         my($id,$title) = @_;\n\n... and yet you're retrieving arguments from the subroutine.\n\n>         my $sth1= $databasehandle->prepare(\"select file_path from xyz\n> where id='$id' and title like '$title'\");\n>         my $res = $sth1->execute();\n>\n>         my @row = $sth1->fetchrow_array;\n>         print @row;\n>\n>         &deleteposter_file(@row);\n\nThe & there specifically says to ignore the prototype (ie, how many\narguments the subroutine says it needs).  So first you tell your\nsubroutines \"don't take any arguments\", and then you tell them \"ignore\nwhat I just told you.\"  Stop doing that.\n\n\n> }\n>\n> #-----------------Deletes from the File system\n>\n> sub delete_file()\n\nWhere the heck did this subroutine come from?  The subroutine you\ncalled above is called deleteposter_file.  And you're again telling it\nit takes no arguments, even though you passed arguments to it.\n\n> {\n>         my $self = shift;\n\nWhat?  You're not calling this subroutine as a method.  Why are you\nthinking it has an object reference as the first argument?\n\n>         my $file_path = @_;\n\nThis sets $file_path equal to the number of arguments left in @_\n(after you shifted off $self).  It does not set $file_path equal to\nthe first element of @_.  For that, you want either:\nmy ($file_path) = @_;\nor\nmy $file_path = shift;\nor\nmy $file_path = $_[0];\n\n> # extract the file name\n> #       my @parts = split('\\/',$file_path);\n> #       my $file =$parts[$#parts];\n> #       #unlink($file);\n\nWhy are you commenting this out?  Why are you not checking for\nerrors?  Why are you not printing $file to see what it is?\n\nunlink $file or die \"Cannot unlink '$file': $!\";\n\n> #       if( -e \"file\" ) {\n\n\"file\" is not the same thing as $file.\n\neven if you change it to $file, you're looking for $file in the\ncurrent directory, even though you just determined it may not be\nlocated in that directory, because you were originally passed a full\npath.\n\n> #       system(\"rm $file_path\");\n>\n>         unlink($file_path);\n\nagain,\nunlink $file_path or die \"Cannot unlink '$file_path': $!\";\n>\n> }\n>\n> abc is calling delete_file() . where it need to delete the file stored\n> at the location mentioned in file_path.\n>\n> Its not giving me an error\n\nYou didn't ask it to.  system calls don't report errors unless you\ncheck for an error and print the error out yourself.\n\nPaul Lalli\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
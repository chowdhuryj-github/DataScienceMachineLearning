{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: [svn:perl6-synopsis] r14376 - doc/trunk/design/syn", "body": "On Tue, Apr 17, 2007 at 07:34:38PM -0400, Joe Gottman wrote:\n: larry@cvs.perl.org wrote:\n: >+\n: >+The value of the conditional expression may be optionally bound to\n: >+a closure parameter:\n: >+\n: >+    if    testa() -> $a { say $a }\n: >+    elsif testb() -> $b { say $b }\n: >+    else          -> $b { say $b }\n: >  \n: I'd prefer it if the result of a test in an if or elsif were usable in \n: all subsequent elsif or else statements in the same if .. elsif .. else \n: clause, so you could do something like\n: \n:   if testa() -> $a {say \"$a  is true\"}\n:   elsif testb() -> $b say {\"$a is false and $b is true\"}\n:   else                      say {\"Neither $a nor $b is true\"}\n\nSorry, that sort of P5ish chicanery with implicitly propagated scopes\nviolates the simplified rules of scoping in P6.  If you really want\nthat, you'll have to say:\n\n    if my $a = testa()    { say \"$a  is true\"}\n    elsif my $b = testb() { say \"$a is false and $b is true\"}\n    else                  { say \"Neither $a nor $b is true\"}\n\nand live with the fact that $a and $b are also visible after the construct.\n\nLarry\n\n"}
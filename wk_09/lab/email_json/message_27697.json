{"category": "ham", "to_address": "sugar@laptop.org", "from_address": "Simon McVittie <simon.mcvittie@collabora.co.uk>", "subject": "Re: [sugar] Obtaining Buddy objects as contacts are encountered", "body": "Excerpted from #sugar:\n\n15:33 < smcv> dcbw: hmm, do we support buddies changing colour/nick/avatar at \n              will?\n15:33 < dcbw> smcv: yes, we do\n15:33 < smcv> dcbw: if so, any spoofing protection is essentially worthless \n              since they can freely change how they appear in the UI\n15:33 < dcbw> smcv: I'm not sure if sugar supports the name change in the mesh \n              view correctly\n15:33 < dcbw> smcv: keys cannot be changed\n15:34 < dcbw> smcv: the only unique ID of a person is thekey\n15:34 < smcv> yeah, but children aren't expected to be able to look at a \n              contact's key :-P\n15:34 < dcbw> smcv: no, the UI needs to deal with continuity management; if I \n              try to chat with 'john' but it's a different 'john' than I talked \n              to yesterday, then the child needs to know\n15:34 < dcbw> smcv: there are definitely some UI issues here that need to be \n              sorted out\n15:35 < smcv> consider: alice knows bob and charlie. bob isn't online at the \n              moment. charlie changes his nick and color to match bob's and \n              talks to alice\n15:35 < smcv> as far as alice can see in the UI, he's bob\n15:35 < dcbw> smcv: in which case, the key is the same, and the user gets \n              notified that this 'bob' isn't actually the 'bob' you might think \n              it is\n15:36 < dcbw> smcv: same thing with jabber; I'm sure you can have two people \n              named \"bill\" but htey have different jids\n15:36 < dcbw> smcv: you as the user need to know the difference\n15:36 < smcv> dcbw: is that notification also meant to be triggered when bob \n              changes his nick to robert?\n15:36 < dcbw> smcv: we may also allow you to set a real name or something for \n              the buddy that gets used no matter what the buddy's nick changes \n              to\n15:36 < smcv> dcbw: on jabber, typically one of them would be called \n              bill@jabber.org and the other william@gmail.com\n15:36 < smcv> or whatever\n15:37 < smcv> it's rather harder to compare 128-bit hex strings\n15:37 < smcv> (I assume we're doing our best not to expose the JIDs in the UI \n              at all, in fact)\n15:37 < dcbw> smcv: correct\n15:38 < smcv> dcbw: \"allow\" -> they won't\n15:38 < smcv> surely?\n15:39 < smcv> at least not until they've been bitten by friends impersonating \n              other friends a couple of times and someone knowledgeable has \n              explained how that helps\n\nIt seems to me that there are two directions for anti-spoofing:\n\n* Has this buddy changed their identity recently?\n* Does this buddy have an identity confusingly similar to one of my\n  other buddies?\n\nFor the first, when a buddy has changed their colour and/or nick recently, we\ncould highlight their XO somehow, with a mouseover popup showing other recent\ncolours and nicks they've had. This would be easy to do, and catches the case\nof one of your buddies trying to impersonate another - at the very least, you\ncan see that \"Bob\" was called Charlie until recently, and get suspicious.\n\nFor the second, you'd have to use some sort of heuristic to detect \"are\nthey trying to trick me?\" and have a ssh-style \"warning: something dodgy\nis going on here\". As we know from ssh and web browsers, making a UI for\nthis that non-crypto-literate users will understand is rather tricky.\nHowever, this is what we'd have to deal with for the case of someone you\nhaven't met yet trying to impersonate someone you have (suppose that instead\nof impersonating Bob himself, Charlie asks his cousin Dave, who\nAlice doesn't know, to do the impersonating).\n\nThinking about it, another possibility would be:\n\n* when someone tries to change their nick or colour, don't change it\n  anywhere in the GUI until the user has accepted the change\n* have some visual indication that you haven't met someone before\n  (for the \"cousin Dave\" case)\n\nIn any case, to be able to recover from mistakes you will have to\nbe able to find out something unique and unspoofable about a contact.\nThis could be done by asking them to send you a message when you next\nsee them in person, if it's someone you ever meet in person, or by\nasking them a question the real person would know the answer to, but\nwhen we have this whole key-based security thing, it'd be nice if it\ncould actually help us! Possible things:\n\n* When the OLPC is first registered, have the server sign the child's\n  \"official\" identity (e.g. full name). (The reason it has to be signed\n  is so the child's mesh identity can include it - then at least anyone who's\n  on the same server can verify it while not currently connected, if\n  they've previously stored the server's key)\n\n* Display the fingerprint (probably not all of it, since we're not\n  dealing with the NSA here :-) in a friendlier form - perhaps a pattern\n  of coloured squares and/or a bubblebabble string.\n\nTo see how well the latter idea works, I tried encoding my three Sugar\ntest profiles' fingerprints.\n\nRaw fingerprint as calculated by Sugar\n(Python: from sha import sha; sha('AAAAB3...=').hexdigest())\ndefault: 0f8b0e297ff44f30bb0affcebcb329a0604192ae\nlogin 2: d4a2e234698124054073b713bcc751af304338d4\nlogin 3: 20495ffc251a2d57ff1824cabe5c1f44c8e39d99\nNot very friendly.\n\nBubbleBabble (ftp://ftp.ietf.org/ietf-mail-archive/secsh/2001-08.mail)\nwith script http://projects.collabora.co.uk/~smcv/bubblebabble.py\nwhole fingerprint of default:\nxefom-rofed-nyzyz-gifef-bivub-pizys-vizur-fepap-bomug-cygip-vyxox\nor just the first 8 bytes: xefom-rofed-nyzyz-gifef-baxex\nFirst 8 bytes for my 3 keys:\nxefom-rofed-nyzyz-gifef-baxex\nxuhap-dumef-gipym-cynib-haxox\nxemag-nolyz-sonoc-pareh-laxex\nIt's better, but not great.\n\nColour squares:\nIf we have, say, a 4x4 grid with 2 bits per \"pixel\" per R/G/B channel (to make\ncolours nicely distinct) that's 4x4x6 = 96 bits of information.\nTaking the first 12 bytes of each of my keys I get:\nhttp://projects.collabora.co.uk/~smcv/fingerprints.png\n(with script http://projects.collabora.co.uk/~smcv/squares.py)\n_______________________________________________\nSugar mailing list\nSugar@laptop.org\nhttp://mailman.laptop.org/mailman/listinfo/sugar\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r23204 - in branches: SAMBA_3_0/source/include\n\tSAMBA_3_0/source/lib SAMBA_3_0/source/locking\n\tSAMBA_3_0/source/smbd SAMBA_3_0/source/utils\n\tSAMBA_3_0_26/source/include SAMBA_3_0_26/source/lib\n\tSAMBA_3_0_26/source/locking SAMBA_3_0_26/source/smbd\n\tSAMBA_3_0_26/source/utils", "body": "Author: vlendec\nDate: 2007-05-29 14:49:19 +0000 (Tue, 29 May 2007)\nNew Revision: 23204\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23204\n\nLog:\nAdd MSG_SMB_BRL_VALIDATE. Tridge, this is a bit different from your bzr\nbranch, please check if it fulfils your needs.\n\nTwo changes: The validation is not done inside the brlock.c traverse_fn,\nit's done as a separate routine. \n\nSecondly, this patch does not call the checker routines in smbcontrol\ndirectly but depends on a running smbd.\n\n\nModified:\n   branches/SAMBA_3_0/source/include/messages.h\n   branches/SAMBA_3_0/source/lib/messages.c\n   branches/SAMBA_3_0/source/locking/brlock.c\n   branches/SAMBA_3_0/source/smbd/server.c\n   branches/SAMBA_3_0/source/utils/smbcontrol.c\n   branches/SAMBA_3_0_26/source/include/messages.h\n   branches/SAMBA_3_0_26/source/lib/messages.c\n   branches/SAMBA_3_0_26/source/locking/brlock.c\n   branches/SAMBA_3_0_26/source/smbd/server.c\n   branches/SAMBA_3_0_26/source/utils/smbcontrol.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/include/messages.h\n===================================================================\n--- branches/SAMBA_3_0/source/include/messages.h\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0/source/include/messages.h\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -83,6 +83,11 @@\n  * Samba4 compatibility\n  */\n #define MSG_PVFS_NOTIFY\t\t\t0x0310\n+/*\n+ * cluster reconfigure events\n+ */\n+#define MSG_SMB_BRL_VALIDATE\t\t0x0311\n+#define MSG_SMB_RELEASE_IP\t\t0x0312\n \n /* winbind messages */\n #define MSG_WINBIND_FINISHED\t\t0x0401\n\nModified: branches/SAMBA_3_0/source/lib/messages.c\n===================================================================\n--- branches/SAMBA_3_0/source/lib/messages.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0/source/lib/messages.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -199,7 +199,7 @@\n \tstatus = messaging_tdb_init(ctx, ctx, &ctx->local);\n \n \tif (!NT_STATUS_IS_OK(status)) {\n-\t\tDEBUG(0, (\"message_init failed: %s\\n\", nt_errstr(status)));\n+\t\tDEBUG(0, (\"messaging_tdb_init failed: %s\\n\", nt_errstr(status)));\n \t\tTALLOC_FREE(ctx);\n \t}\n \n\nModified: branches/SAMBA_3_0/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -1686,3 +1686,109 @@\n {\n \treturn brl_get_locks_internal(mem_ctx, fsp, True);\n }\n+\n+struct brl_revalidate_state {\n+\tssize_t array_size;\n+\tuint32 num_pids;\n+\tstruct server_id *pids;\n+};\n+\n+/*\n+ * Collect PIDs of all processes with pending entries\n+ */\n+\n+static void brl_revalidate_collect(struct file_id id, struct server_id pid,\n+\t\t\t\t   enum brl_type lock_type,\n+\t\t\t\t   enum brl_flavour lock_flav,\n+\t\t\t\t   br_off start, br_off size,\n+\t\t\t\t   void *private_data)\n+{\n+\tstruct brl_revalidate_state *state =\n+\t\t(struct brl_revalidate_state *)private_data;\n+\n+\tif (!IS_PENDING_LOCK(lock_type)) {\n+\t\treturn;\n+\t}\n+\n+\tadd_to_large_array(state, sizeof(pid), (void *)&pid,\n+\t\t\t   &state->pids, &state->num_pids,\n+\t\t\t   &state->array_size);\n+}\n+\n+/*\n+ * qsort callback to sort the processes\n+ */\n+\n+static int compare_procids(const void *p1, const void *p2)\n+{\n+\tconst struct server_id *i1 = (struct server_id *)i1;\n+\tconst struct server_id *i2 = (struct server_id *)i2;\n+\n+\tif (i1->pid < i2->pid) return -1;\n+\tif (i2->pid > i2->pid) return 1;\n+\treturn 0;\n+}\n+\n+/*\n+ * Send a MSG_SMB_UNLOCK message to all processes with pending byte range\n+ * locks so that they retry. Mainly used in the cluster code after a node has\n+ * died.\n+ *\n+ * Done in two steps to avoid double-sends: First we collect all entries in an\n+ * array, then qsort that array and only send to non-dupes.\n+ */\n+\n+static void brl_revalidate(struct messaging_context *msg_ctx,\n+\t\t\t   void *private_data,\n+\t\t\t   uint32_t msg_type,\n+\t\t\t   struct server_id server_id,\n+\t\t\t   DATA_BLOB *data)\n+{\n+\tstruct brl_revalidate_state *state;\n+\tuint32 i;\n+\tstruct server_id last_pid;\n+\n+\tif (!(state = TALLOC_ZERO_P(NULL, struct brl_revalidate_state))) {\n+\t\tDEBUG(0, (\"talloc failed\\n\"));\n+\t\treturn;\n+\t}\n+\n+\tbrl_forall(brl_revalidate_collect, state);\n+\n+\tif (state->array_size == -1) {\n+\t\tDEBUG(0, (\"talloc failed\\n\"));\n+\t\tgoto done;\n+\t}\n+\n+\tif (state->num_pids == 0) {\n+\t\tgoto done;\n+\t}\n+\n+\tqsort(state->pids, state->num_pids, sizeof(state->pids[0]),\n+\t      compare_procids);\n+\n+\tZERO_STRUCT(last_pid);\n+\n+\tfor (i=0; inum_pids; i++) {\n+\t\tif (procid_equal(&last_pid, &state->pids[i])) {\n+\t\t\t/*\n+\t\t\t * We've seen that one already\n+\t\t\t */\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tmessaging_send(msg_ctx, state->pids[i], MSG_SMB_UNLOCK,\n+\t\t\t       &data_blob_null);\n+\t\tlast_pid = state->pids[i];\n+\t}\n+\n+ done:\n+\tTALLOC_FREE(state);\n+\treturn;\n+}\n+\n+void brl_register_msgs(struct messaging_context *msg_ctx)\n+{\n+\tmessaging_register(msg_ctx, NULL, MSG_SMB_BRL_VALIDATE,\n+\t\t\t   brl_revalidate);\n+}\n\nModified: branches/SAMBA_3_0/source/smbd/server.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/server.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0/source/smbd/server.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -375,6 +375,7 @@\n \t\t\t   MSG_SMB_CONF_UPDATED, smb_conf_updated); \n \tmessaging_register(smbd_messaging_context(), NULL,\n \t\t\t   MSG_SMB_STAT_CACHE_DELETE, smb_stat_cache_delete);\n+\tbrl_register_msgs(smbd_messaging_context());\n \n #ifdef DEVELOPER\n \tmessaging_register(smbd_messaging_context(), NULL,\n@@ -991,6 +992,7 @@\n \t}\n \n \t/* Setup all the TDB's - including CLEAR_IF_FIRST tdb's. */\n+\n \tif (smbd_messaging_context() == NULL)\n \t\texit(1);\n \n\nModified: branches/SAMBA_3_0/source/utils/smbcontrol.c\n===================================================================\n--- branches/SAMBA_3_0/source/utils/smbcontrol.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0/source/utils/smbcontrol.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -698,6 +698,34 @@\n \t\t\t    strlen(argv[1]) + 1);\n }\n \n+/* force a blocking lock retry */\n+\n+static BOOL do_lockretry(struct messaging_context *msg_ctx,\n+\t\t\t const struct server_id pid,\n+\t\t\t const int argc, const char **argv)\n+{\n+\tif (argc != 1) {\n+\t\tfprintf(stderr, \"Usage: smbcontrol  lockretry\\n\");\n+\t\treturn False;\n+\t}\n+\n+\treturn send_message(msg_ctx, pid, MSG_SMB_UNLOCK, NULL, 0);\n+}\n+\n+/* force a validation of all brl entries, including re-sends. */\n+\n+static BOOL do_brl_revalidate(struct messaging_context *msg_ctx,\n+\t\t\t      const struct server_id pid,\n+\t\t\t      const int argc, const char **argv)\n+{\n+\tif (argc != 1) {\n+\t\tfprintf(stderr, \"Usage: smbcontrol  brl-revalidate\\n\");\n+\t\treturn False;\n+\t}\n+\n+\treturn send_message(msg_ctx, pid, MSG_SMB_BRL_VALIDATE, NULL, 0);\n+}\n+\n /* Force a SAM synchronisation */\n \n static BOOL do_samsync(struct messaging_context *msg_ctx,\n@@ -1037,6 +1065,8 @@\n \t{ \"debuglevel\", do_debuglevel, \"Display current debuglevels\" },\n \t{ \"printnotify\", do_printnotify, \"Send a print notify message\" },\n \t{ \"close-share\", do_closeshare, \"Forcibly disconnect a share\" },\n+\t{ \"lockretry\", do_lockretry, \"Force a blocking lock retry\" },\n+\t{ \"brl-revalidate\", do_brl_revalidate, \"Revalidate all brl entries\" },\n         { \"samsync\", do_samsync, \"Initiate SAM synchronisation\" },\n         { \"samrepl\", do_samrepl, \"Initiate SAM replication\" },\n \t{ \"pool-usage\", do_poolusage, \"Display talloc memory usage\" },\n\nModified: branches/SAMBA_3_0_26/source/include/messages.h\n===================================================================\n--- branches/SAMBA_3_0_26/source/include/messages.h\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0_26/source/include/messages.h\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -83,6 +83,11 @@\n  * Samba4 compatibility\n  */\n #define MSG_PVFS_NOTIFY\t\t\t0x0310\n+/*\n+ * cluster reconfigure events\n+ */\n+#define MSG_SMB_BRL_VALIDATE\t\t0x0311\n+#define MSG_SMB_RELEASE_IP\t\t0x0312\n \n /* winbind messages */\n #define MSG_WINBIND_FINISHED\t\t0x0401\n\nModified: branches/SAMBA_3_0_26/source/lib/messages.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/messages.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0_26/source/lib/messages.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -199,7 +199,7 @@\n \tstatus = messaging_tdb_init(ctx, ctx, &ctx->local);\n \n \tif (!NT_STATUS_IS_OK(status)) {\n-\t\tDEBUG(0, (\"message_init failed: %s\\n\", nt_errstr(status)));\n+\t\tDEBUG(0, (\"messaging_tdb_init failed: %s\\n\", nt_errstr(status)));\n \t\tTALLOC_FREE(ctx);\n \t}\n \n\nModified: branches/SAMBA_3_0_26/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -1686,3 +1686,109 @@\n {\n \treturn brl_get_locks_internal(mem_ctx, fsp, True);\n }\n+\n+struct brl_revalidate_state {\n+\tssize_t array_size;\n+\tuint32 num_pids;\n+\tstruct server_id *pids;\n+};\n+\n+/*\n+ * Collect PIDs of all processes with pending entries\n+ */\n+\n+static void brl_revalidate_collect(struct file_id id, struct server_id pid,\n+\t\t\t\t   enum brl_type lock_type,\n+\t\t\t\t   enum brl_flavour lock_flav,\n+\t\t\t\t   br_off start, br_off size,\n+\t\t\t\t   void *private_data)\n+{\n+\tstruct brl_revalidate_state *state =\n+\t\t(struct brl_revalidate_state *)private_data;\n+\n+\tif (!IS_PENDING_LOCK(lock_type)) {\n+\t\treturn;\n+\t}\n+\n+\tadd_to_large_array(state, sizeof(pid), (void *)&pid,\n+\t\t\t   &state->pids, &state->num_pids,\n+\t\t\t   &state->array_size);\n+}\n+\n+/*\n+ * qsort callback to sort the processes\n+ */\n+\n+static int compare_procids(const void *p1, const void *p2)\n+{\n+\tconst struct server_id *i1 = (struct server_id *)i1;\n+\tconst struct server_id *i2 = (struct server_id *)i2;\n+\n+\tif (i1->pid < i2->pid) return -1;\n+\tif (i2->pid > i2->pid) return 1;\n+\treturn 0;\n+}\n+\n+/*\n+ * Send a MSG_SMB_UNLOCK message to all processes with pending byte range\n+ * locks so that they retry. Mainly used in the cluster code after a node has\n+ * died.\n+ *\n+ * Done in two steps to avoid double-sends: First we collect all entries in an\n+ * array, then qsort that array and only send to non-dupes.\n+ */\n+\n+static void brl_revalidate(struct messaging_context *msg_ctx,\n+\t\t\t   void *private_data,\n+\t\t\t   uint32_t msg_type,\n+\t\t\t   struct server_id server_id,\n+\t\t\t   DATA_BLOB *data)\n+{\n+\tstruct brl_revalidate_state *state;\n+\tuint32 i;\n+\tstruct server_id last_pid;\n+\n+\tif (!(state = TALLOC_ZERO_P(NULL, struct brl_revalidate_state))) {\n+\t\tDEBUG(0, (\"talloc failed\\n\"));\n+\t\treturn;\n+\t}\n+\n+\tbrl_forall(brl_revalidate_collect, state);\n+\n+\tif (state->array_size == -1) {\n+\t\tDEBUG(0, (\"talloc failed\\n\"));\n+\t\tgoto done;\n+\t}\n+\n+\tif (state->num_pids == 0) {\n+\t\tgoto done;\n+\t}\n+\n+\tqsort(state->pids, state->num_pids, sizeof(state->pids[0]),\n+\t      compare_procids);\n+\n+\tZERO_STRUCT(last_pid);\n+\n+\tfor (i=0; inum_pids; i++) {\n+\t\tif (procid_equal(&last_pid, &state->pids[i])) {\n+\t\t\t/*\n+\t\t\t * We've seen that one already\n+\t\t\t */\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tmessaging_send(msg_ctx, state->pids[i], MSG_SMB_UNLOCK,\n+\t\t\t       &data_blob_null);\n+\t\tlast_pid = state->pids[i];\n+\t}\n+\n+ done:\n+\tTALLOC_FREE(state);\n+\treturn;\n+}\n+\n+void brl_register_msgs(struct messaging_context *msg_ctx)\n+{\n+\tmessaging_register(msg_ctx, NULL, MSG_SMB_BRL_VALIDATE,\n+\t\t\t   brl_revalidate);\n+}\n\nModified: branches/SAMBA_3_0_26/source/smbd/server.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/smbd/server.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0_26/source/smbd/server.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -471,6 +471,7 @@\n \t\t\t   MSG_SMB_CONF_UPDATED, smb_conf_updated); \n \tmessaging_register(smbd_messaging_context(), NULL,\n \t\t\t   MSG_SMB_STAT_CACHE_DELETE, smb_stat_cache_delete);\n+\tbrl_register_msgs(smbd_messaging_context());\n \n #ifdef DEVELOPER\n \tmessaging_register(smbd_messaging_context(), NULL,\n@@ -1039,6 +1040,7 @@\n \t\tpidfile_create(\"smbd\");\n \n \t/* Setup all the TDB's - including CLEAR_IF_FIRST tdb's. */\n+\n \tif (smbd_messaging_context() == NULL)\n \t\texit(1);\n \n\nModified: branches/SAMBA_3_0_26/source/utils/smbcontrol.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/utils/smbcontrol.c\t2007-05-29 14:48:37 UTC (rev 23203)\n+++ branches/SAMBA_3_0_26/source/utils/smbcontrol.c\t2007-05-29 14:49:19 UTC (rev 23204)\n@@ -698,6 +698,34 @@\n \t\t\t    strlen(argv[1]) + 1);\n }\n \n+/* force a blocking lock retry */\n+\n+static BOOL do_lockretry(struct messaging_context *msg_ctx,\n+\t\t\t const struct server_id pid,\n+\t\t\t const int argc, const char **argv)\n+{\n+\tif (argc != 1) {\n+\t\tfprintf(stderr, \"Usage: smbcontrol  lockretry\\n\");\n+\t\treturn False;\n+\t}\n+\n+\treturn send_message(msg_ctx, pid, MSG_SMB_UNLOCK, NULL, 0);\n+}\n+\n+/* force a validation of all brl entries, including re-sends. */\n+\n+static BOOL do_brl_revalidate(struct messaging_context *msg_ctx,\n+\t\t\t      const struct server_id pid,\n+\t\t\t      const int argc, const char **argv)\n+{\n+\tif (argc != 1) {\n+\t\tfprintf(stderr, \"Usage: smbcontrol  brl-revalidate\\n\");\n+\t\treturn False;\n+\t}\n+\n+\treturn send_message(msg_ctx, pid, MSG_SMB_BRL_VALIDATE, NULL, 0);\n+}\n+\n /* Force a SAM synchronisation */\n \n static BOOL do_samsync(struct messaging_context *msg_ctx,\n@@ -1037,6 +1065,8 @@\n \t{ \"debuglevel\", do_debuglevel, \"Display current debuglevels\" },\n \t{ \"printnotify\", do_printnotify, \"Send a print notify message\" },\n \t{ \"close-share\", do_closeshare, \"Forcibly disconnect a share\" },\n+\t{ \"lockretry\", do_lockretry, \"Force a blocking lock retry\" },\n+\t{ \"brl-revalidate\", do_brl_revalidate, \"Revalidate all brl entries\" },\n         { \"samsync\", do_samsync, \"Initiate SAM synchronisation\" },\n         { \"samrepl\", do_samrepl, \"Initiate SAM replication\" },\n \t{ \"pool-usage\", do_poolusage, \"Display talloc memory usage\" },\n\n"}
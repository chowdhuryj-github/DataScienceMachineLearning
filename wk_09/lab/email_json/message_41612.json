{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Jonathan Worthington <jonathan@jnthn.net>", "subject": "Analysing a GC problem", "body": "Hi,\n\nAt the moment, under Win32, virtually all of the Perl 6 test suite fails \nunless run with -G (disabling garbage collection). The problem for at \nleast one of them is that the free list appears to be corrupted.\n\nFirst, a few notes on the free list. Parrot allocates large chunks of \nmemory, called pools, and then allocates objects out of these pools \nitself. All garbage collectible objects start out with the same two things:\n\ntypedef struct pobj_t {\n    UnionVal u;\n    Parrot_UInt flags;\n} pobj_t;\n\nThe UnionVal contains a range of things, but is at least the size of two \nintegers or two pointers. Normally this is used to store some of the \ndata for the object itself. However, after the object is freed, the \nfirst pointer-sized chunk of the UnionVal is used for another thing: to \nstore a linked list of free objects. When we want a new object, unless \nthe free list is empty (and thus NULL), we take the object on the front \nand set the free list to whatever that referred to as the next thing on \nthe free list, like this:\n\n    if (!pool->free_list)\n        (*pool->more_objects)(interp, pool);\n    ptr = pool->free_list;\n    pool->free_list = *(void **)ptr;\n\nThe segfault was occuring on the third line of this, namely because ptr \nwas coming back as 0xFFFFFFFF. After some messing around, I realized \nthat if I changed the code to read:\n\n    if (!pool->free_list)\n        (*pool->more_objects)(interp, pool);\n    ptr = pool->free_list;\n    if (*(void **)ptr == 0xFFFFFFFF) {\n        PMC *check = (PMC*)ptr;\n        return NULL;\n    }\n    pool->free_list = *(void **)ptr;\n\nAnd set a breakpoint on the \"return NULL;\", then I'd get some better \nidea of what ptr actually was. Turns out it is a PMC - a Key PMC in \nfact. And if you look in the Key PMC, you see a comment like:\n\nPMC_int_val(-1) means end of iteration.\n\nPMC_int_val is the same memory location as the free list pointer would \nbe, -1 is 0xFFFFFFFF and...well, you can see where this is going. So \nsomehow this Key PMC is not getting marked live, when it is still being \nused, right?\n\nWell, maybe. Next I looked at the flags of this PMC.\n\n00000100 00010000 00000110 00000011\n\nWe'd expect that:\n\nb_PObj_on_free_list_FLAG = 1 << 19,\n\nWould be set, but it ain't. So the PMC is on the free list, but hasn't \ngot the \"I'm on the free list\" flag. Thus it was, in theory, never \nactually placed onto the free list. Changing the test condition from \nearlier to:\n\n    if (!PObj_on_free_list_TEST((PObj*)ptr)) {\n        PMC *check = (PMC*)ptr;\n        return NULL;\n    }\n\nAnd setting the breakpoint gave check as the Key PMC, just like before. \n From which I infer that perhaps it's not a Key PMC that is not being \nmarked, but something else that keeps a Key PMC referenced from the \nfirst pointer in the UnionVal  Perhaps an iterator; from Iterator.pmc's \nmark routine:\n\n        /* the KEY */\n        if (PMC_struct_val(SELF))\n             pobject_lives(INTERP, (PObj *) PMC_struct_val(SELF));\n\nOr perhaps not, that's all I have time for today. But this post is for \nthose of you who wonder how one goes about tracing GC problems - I have \nbeen asked before and just wanted to make things a little less \nmysterious. Hope this helps. Or that it spurs someone else to continue \nthe hunt for this bug, which would be rather nice to nail.\n\nHappy hacking,\n\nJonathan\n\n"}
{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: S12: can(), signatures and casting", "body": "Larry Wall wrote:> Maybe we need to allow the & indirection on method names too:>>     if $obj.&fribble:(Str --> BadPoet) {\n-snip-\n> Note that we already define &foo:(Int, Str) to return a list of candidates> if there's more than one, so extending this from the multi dispatcher> to the single dispatcher just seem like a SMOS (small matter of syntax).\nOne corollary of this is that querying an object for its availablemethods should probably give you a list of coderefs instead of methodnames.\nWhat threw me initially was that I wasn't used to thinking of acoderef as a test for existence - in particular, I couldn't see howthe method's name could be specified using such a syntax.\nAnother question: what about\n  $obj.?fribble:(Str --> BadPoet)  $obj.*fribble:(Str --> BadPoet)  $obj.+fribble:(Str --> BadPoet)\nAs I understand it, placing a ? or * between an object and a methodresults in the method only being called if it exists (although I'm notclear on what happens if it doesn't); placing a * or + between theobject and method calls every version of the method that applies.Couldn't you just cap one of the former two with a '&' to prevent theresulting methods from actually running?\n  &$obj.?fribble:(Str --> BadPoet)  &$obj.*fribble:(Str --> BadPoet)  &$obj.+fribble:(Str --> BadPoet)\nOr would you have to hyperize the '&' in the latter cases?\n  &$obj.fribble:(Str --> BadPoet) # dies if fribble doesn't work as advertised;  &$obj.?fribble:(Str --> BadPoet) # returns undef instead.  &\u00ab$obj.*fribble:(Str --> BadPoet) # returns a list of all fribbles;  &\u00ab$obj.+fribble:(Str --> BadPoet) # as above, but fails on an empty list.\nRegardless, I agree: can '.can()'.\n-- Jonathan \"Dataweaver\" Lang\n\n"}
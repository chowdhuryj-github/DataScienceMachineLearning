{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r22327 - in branches/SAMBA_3_0/source: libsmb smbd", "body": "Author: jra\nDate: 2007-04-18 00:34:10 +0000 (Wed, 18 Apr 2007)\nNew Revision: 22327\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22327\n\nLog:\nFinish the gss-spnego part of the seal code. Now\nfor testing....\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/libsmb/clifsinfo.c\n   branches/SAMBA_3_0/source/libsmb/errormap.c\n   branches/SAMBA_3_0/source/smbd/seal.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/libsmb/clifsinfo.c\n===================================================================\n--- branches/SAMBA_3_0/source/libsmb/clifsinfo.c\t2007-04-18 00:12:39 UTC (rev 22326)\n+++ branches/SAMBA_3_0/source/libsmb/clifsinfo.c\t2007-04-18 00:34:10 UTC (rev 22327)\n@@ -2,6 +2,7 @@\n    Unix SMB/CIFS implementation.\n    FS info functions\n    Copyright (C) Stefan (metze) Metzmacher\t2003\n+   Copyright (C) Jeremy Allison 2007.\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -355,6 +356,22 @@\n }\n \n /******************************************************************************\n+ Make a client state struct.\n+******************************************************************************/\n+\n+static struct smb_trans_enc_state *make_cli_enc_state(enum smb_trans_enc_type smb_enc_type)\n+{\n+\tstruct smb_trans_enc_state *es = NULL;\n+\tes = SMB_MALLOC_P(struct smb_trans_enc_state);\n+\tif (!es) {\n+\t\treturn NULL;\n+\t}\n+\tZERO_STRUCTP(es);\n+\tes->smb_enc_type = smb_enc_type;\n+\treturn es;\n+}\n+\n+/******************************************************************************\n  Start a raw ntlmssp encryption.\n ******************************************************************************/\n \n@@ -367,14 +384,11 @@\n \tDATA_BLOB blob_out = data_blob(NULL, 0);\n \tDATA_BLOB param_out = data_blob(NULL, 0);\n \tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n-\tstruct smb_trans_enc_state *es = NULL;\n+\tstruct smb_trans_enc_state *es = make_cli_enc_state(SMB_TRANS_ENC_NTLM);\n \n-\tes = SMB_MALLOC_P(struct smb_trans_enc_state);\n \tif (!es) {\n \t\treturn NT_STATUS_NO_MEMORY;\n \t}\n-\tZERO_STRUCTP(es);\n-\tes->smb_enc_type = SMB_TRANS_ENC_NTLM;\n \tstatus = ntlmssp_client_start(&es->s.ntlmssp_state);\n \tif (!NT_STATUS_IS_OK(status)) {\n \t\tgoto fail;\n@@ -423,3 +437,166 @@\n \tcommon_free_encryption_state(&es);\n \treturn status;\n }\n+\n+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)\n+\n+#ifndef SMB_GSS_REQUIRED_FLAGS\n+#define SMB_GSS_REQUIRED_FLAGS (GSS_C_CONF_FLAG|GSS_C_INTEG_FLAG|GSS_C_MUTUAL_FLAG|GSS_C_REPLAY_FLAG|GSS_C_SEQUENCE_FLAG)\n+#endif\n+\n+/******************************************************************************\n+ Get client gss blob to send to a server.\n+******************************************************************************/\n+\n+static NTSTATUS make_cli_gss_blob(struct smb_trans_enc_state *es,\n+\t\t\t\tconst char *service,\n+\t\t\t\tconst char *host,\n+\t\t\t\tNTSTATUS status_in,\n+\t\t\t\tDATA_BLOB spnego_blob_in,\n+\t\t\t\tDATA_BLOB *p_blob_out)\n+{\n+\tconst char *krb_mechs[] = {OID_KERBEROS5_OLD, OID_KERBEROS5, NULL};\n+\tOM_uint32 ret;\n+\tOM_uint32 min;\n+\tgss_name_t srv_name;\n+\tgss_buffer_desc input_name;\n+\tgss_buffer_desc *p_tok_in;\n+\tgss_buffer_desc tok_out, tok_in;\n+\tDATA_BLOB blob_out = data_blob(NULL, 0);\n+\tDATA_BLOB blob_in = data_blob(NULL, 0);\n+\tchar *host_princ_s = NULL;\n+\tOM_uint32 ret_flags = 0;\n+\tNTSTATUS status = NT_STATUS_OK;\n+\n+\tmemset(&tok_out, '\\0', sizeof(tok_out));\n+\n+\t/* Get a ticket for the service@host */\n+\tasprintf(&host_princ_s, \"%s@%s\", service, host);\n+\tif (host_princ_s == NULL) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tinput_name.value = host_princ_s;\n+\tinput_name.length = strlen(host_princ_s) + 1;\n+\n+\tret = gss_import_name(&min,\n+\t\t\t\t&input_name,\n+\t\t\t\tGSS_C_NT_HOSTBASED_SERVICE,\n+\t\t\t\t&srv_name);\n+\n+\tif (ret != GSS_S_COMPLETE) {\n+\t\tSAFE_FREE(host_princ_s);\n+\t\treturn map_nt_error_from_gss(ret, min);\n+\t}\n+\n+\tif (spnego_blob_in.length == 0) {\n+\t\tp_tok_in = GSS_C_NO_BUFFER;\n+\t} else {\n+\t\t/* Remove the SPNEGO wrapper */\n+\t\tif (!spnego_parse_auth_response(spnego_blob_in, status_in, OID_KERBEROS5, &blob_in)) {\n+\t\t\tstatus = NT_STATUS_UNSUCCESSFUL;\n+\t\t\tgoto fail;\n+\t\t}\n+\t\ttok_in.value = blob_in.data;\n+\t\ttok_in.length = blob_in.length;\n+\t\tp_tok_in = &tok_in;\n+\t}\n+\n+\tret = gss_init_sec_context(&min,\n+\t\t\t\tGSS_C_NO_CREDENTIAL, /* Use our default cred. */\n+\t\t\t\t&es->s.gss_state->gss_ctx,\n+\t\t\t\tsrv_name,\n+\t\t\t\tGSS_C_NO_OID, /* default OID. */\n+\t\t\t\tGSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG | GSS_C_SEQUENCE_FLAG,\n+\t\t\t\tGSS_C_INDEFINITE,\t/* requested ticket lifetime. */\n+\t\t\t\tNULL,   /* no channel bindings */\n+\t\t\t\tp_tok_in,\n+\t\t\t\tNULL,   /* ignore mech type */\n+\t\t\t\t&tok_out,\n+\t\t\t\t&ret_flags,\n+\t\t\t\tNULL);  /* ignore time_rec */\n+\n+\tstatus = map_nt_error_from_gss(ret, min);\n+\tif (!NT_STATUS_IS_OK(status) && !NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\tgoto fail;\n+\t}\n+\n+\tif ((ret_flags & SMB_GSS_REQUIRED_FLAGS) != SMB_GSS_REQUIRED_FLAGS) {\n+\t\tstatus = NT_STATUS_ACCESS_DENIED;\n+\t}\n+\n+\tblob_out = data_blob(tok_out.value, tok_out.length);\n+\n+\t/* Wrap in an SPNEGO wrapper */\n+\t*p_blob_out = gen_negTokenTarg(krb_mechs, blob_out);\n+\n+  fail:\n+\n+\tdata_blob_free(&blob_out);\n+\tdata_blob_free(&blob_in);\n+\tSAFE_FREE(host_princ_s);\n+\tgss_release_name(&min, &srv_name);\n+\tif (tok_out.value) {\n+\t\tgss_release_buffer(&min, &tok_out);\n+\t}\n+\treturn status;\n+}\n+\n+/******************************************************************************\n+ Start a SPNEGO gssapi encryption context.\n+******************************************************************************/\n+\n+NTSTATUS cli_gss_smb_encryption_start(struct cli_state *cli)\n+{\n+\tDATA_BLOB blob_recv = data_blob(NULL, 0);\n+\tDATA_BLOB blob_send = data_blob(NULL, 0);\n+\tDATA_BLOB param_out = data_blob(NULL, 0);\n+\tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n+\tfstring fqdn;\n+\tconst char *servicename;\n+\tstruct smb_trans_enc_state *es = make_cli_enc_state(SMB_TRANS_ENC_GSS);\n+\n+\tif (!es) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tname_to_fqdn(fqdn, cli->desthost);\n+\tstrlower_m(fqdn);\n+\n+\tservicename = \"cifs\";\n+\tstatus = make_cli_gss_blob(es, servicename, fqdn, NT_STATUS_OK, blob_recv, &blob_send);\n+\tif (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\tservicename = \"host\";\n+\t\tstatus = make_cli_gss_blob(es, servicename, fqdn, NT_STATUS_OK, blob_recv, &blob_send);\n+\t\tif (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n+\t\t\tgoto fail;\n+\t\t}\n+\t}\n+\n+\tdo {\n+\t\tdata_blob_free(&blob_recv);\n+\t\tstatus = enc_blob_send_receive(cli, &blob_send, &blob_recv, &param_out);\n+\t\tif (param_out.length == 2) {\n+\t\t\tes->enc_ctx_num = SVAL(param_out.data, 0);\n+\t\t}\n+\t\tdata_blob_free(&blob_send);\n+\t\tstatus = make_cli_gss_blob(es, servicename, fqdn, status, blob_recv, &blob_send);\n+\t} while (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED));\n+\tdata_blob_free(&blob_recv);\n+\n+\tif (NT_STATUS_IS_OK(status)) {\n+\t\t/* Replace the old state, if any. */\n+\t\tif (cli->trans_enc_state) {\n+\t\t\tcommon_free_encryption_state(&cli->trans_enc_state);\n+\t\t}\n+\t\tcli->trans_enc_state = es;\n+\t\tcli->trans_enc_state->enc_on = True;\n+\t\tes = NULL;\n+\t}\n+\n+  fail:\n+\n+\tcommon_free_encryption_state(&es);\n+\treturn status;\n+}\n+#endif\n\nModified: branches/SAMBA_3_0/source/libsmb/errormap.c\n===================================================================\n--- branches/SAMBA_3_0/source/libsmb/errormap.c\t2007-04-18 00:12:39 UTC (rev 22326)\n+++ branches/SAMBA_3_0/source/libsmb/errormap.c\t2007-04-18 00:34:10 UTC (rev 22327)\n@@ -1652,6 +1652,10 @@\n \t\treturn NT_STATUS_OK;\n \t}\n \n+\tif (gss_maj == GSS_S_CONTINUE_NEEDED) {\n+\t\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n+\t}\n+\n \tif (gss_maj == GSS_S_FAILURE) {\n \t\treturn map_nt_error_from_unix((int)minor);\n \t}\n\nModified: branches/SAMBA_3_0/source/smbd/seal.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/seal.c\t2007-04-18 00:12:39 UTC (rev 22326)\n+++ branches/SAMBA_3_0/source/smbd/seal.c\t2007-04-18 00:34:10 UTC (rev 22327)\n@@ -333,9 +333,12 @@\n \tOM_uint32 flags = 0;\n \tgss_buffer_desc in_buf, out_buf;\n \tstruct smb_tran_enc_state_gss *gss_state;\n+\tDATA_BLOB auth_reply = data_blob(NULL,0);\n+\tDATA_BLOB response = data_blob(NULL,0);\n+\tNTSTATUS status;\n \n \tif (!partial_srv_trans_enc_ctx) {\n-\t\tNTSTATUS status = make_srv_encryption_context(SMB_TRANS_ENC_GSS, &partial_srv_trans_enc_ctx);\n+\t\tstatus = make_srv_encryption_context(SMB_TRANS_ENC_GSS, &partial_srv_trans_enc_ctx);\n \t\tif (!NT_STATUS_IS_OK(status)) {\n \t\t\treturn status;\n \t\t}\n@@ -361,8 +364,9 @@\n \t\t\t\tNULL,\t\t/* Ingore time. */\n \t\t\t\tNULL);\t\t/* Ignore delegated creds. */\n \n+\tstatus = gss_err_to_ntstatus(ret, min);\n \tif (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {\n-\t\treturn gss_err_to_ntstatus(ret, min);\n+\t\treturn status;\n \t}\n \n \t/* Ensure we've got sign+seal available. */\n@@ -376,20 +380,18 @@\n \t\t}\n \t}\n \n-\tSAFE_FREE(*ppdata);\n-\t*ppdata = memdup(out_buf.value, out_buf.length);\n-\tif (!*ppdata) {\n-\t\tgss_release_buffer(&min, &out_buf);\n-\t\treturn NT_STATUS_NO_MEMORY;\n-\t}\n-\t*p_data_size = out_buf.length;\n+\tauth_reply = data_blob(out_buf.value, out_buf.length);\n \tgss_release_buffer(&min, &out_buf);\n \n-\tif (ret != GSS_S_CONTINUE_NEEDED) {\n-\t\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n-\t} else {\n-\t\treturn NT_STATUS_OK;\n-\t}\n+\t/* Wrap in SPNEGO. */\n+\tresponse = spnego_gen_auth_response(&auth_reply, status, OID_KERBEROS5);\n+\tdata_blob_free(&auth_reply);\n+\n+\tSAFE_FREE(*ppdata);\n+\t*ppdata = response.data;\n+\t*p_data_size = response.length;\n+\n+\treturn status;\n }\n #endif\n \n\n"}
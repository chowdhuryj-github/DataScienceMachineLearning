{"category": "ham", "to_address": "Tom Phoenix <tom@stonehenge.com>", "from_address": "Tom Allison <tom@tacocat.net>", "subject": "Re: character encoding & regex", "body": "\nOn Jun 16, 2007, at 6:05 PM, Tom Phoenix wrote:\n\n>\n> On 6/16/07, Tom Allison  wrote:\n>\n>> I'm trying to do some regular expression on strings in email. They  \n>> could be\n>> encoded to something.  But I can't tell because I don't have a  \n>> utf8 unicode\n>> xterm window that will show me anything.  At best I get ?????a??   \n>> and other\n>> trash like that.  I think this is typical for ascii text  \n>> renderings of two-bit\n>> characters.\n>\n> But, I think what you're saying is, you want to be able to tell\n> whether today's ?????a?? is the same mystery word that looked like\n> ?????a?? in yesterday's mail, right? That is, you still won't know\n> what it is, but at least you'll be able to say you saw it again.\n\nThis is exactly what I'm trying to do.  I just want to know if I've  \nseen the same string previously.\n\n>\n>> I found something that SpamAssassin uses to convert all this \"goo\"  \n>> into a\n>> repeatable set of characters (which is all I'm really after) by  \n>> running\n>> something that looks like this:\n>>\n>> sub _quote_bytea {\n>>      my ($str) = @_;\n>>      my $buf = \"\";\n>>      foreach my $char (split(//,$str)) {\n>>          my $oct = sprintf (\"%lo\", ord($char));\n>>          if (length( $oct ) < 2 ) { $oct = '0' . $oct; }\n>>          if (length( $oct ) < 3 ) { $oct = '0' . $oct; }\n>>          $buf .= '\\\\\\\\\\\\\\\\' . $oct;\n>>      }\n>>      return $buf;\n>> }\n>\n> So that's somebody else's code, not yours? Does that code have any\n> comments that explain what it's doing? What does \"_quote_bytea\" mean?\n>\nSpamAssassin.  But they have very few comments and not many of them  \nare very clear.\n>\n\n> But it sounds to me as if you don't want that particular string; you\n> want any function that gives you a lossless, repeatable coding of your\n> input string, but unlike the input string, the desired result is\n> composed only of printable characters. Yes? And presumably,\n> compactness and readability are also desirable features of the encoded\n> string.\n>\n>  # Encode everything except the \"normal\" ASCII\n>  # characters. Normal includes newline and space, but no other\n>  # inkless characters. Normal does not include backslash.\n>  ###UNPORTABLE### Newline character is machine-dependent\n>  $str =~ s{([^\\n\\x20-\\x5b\\x5d-\\x7e])}{ sprintf \"\\\\{%x}\", ord($1) }seg;\n>\n> By now, I'm sure I must have sufficiently misunderstood either the\n> task or Perl's abilities to accomplish it, so I'll leave it at this.\n> Hope this helps!\n\n\nThis is about it.\nNow I'm not familiar with the \\x20.. notations but this gives me  \nsomething to play with.\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
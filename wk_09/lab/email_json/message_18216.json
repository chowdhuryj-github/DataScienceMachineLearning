{"category": "ham", "to_address": "matt@diephouse.com", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [perl #42776] [BUG] is isa ok?", "body": "Matt Diephouse wrote:\n> \n> It looks like the PMC variant is correct in this case, because Object\n> isn't actually a class. There's a class flag for PMCs that sets\n> whether or not they are a class and Object doesn't have this set.\n> \n> When you call the PMC variant of isa, it calls Parrot_object_isa, and\n> that has this code:\n> \n>    /* if this is not a class */\n>    if (!PObj_is_class_TEST(pmc)) {\n>        pmc = VTABLE_get_class(interp, pmc);\n>    }\n> \n> So since Object isn't a class, it calls the get_class vtable and gets\n> the Class pmc. It then tests the object to see if it's a Class, which\n> it obviously isn't.\n\nYou should always get the same answer from the 'isa' opcode, whether you \npass in a string or a PMC. In this case, object.pmc should override the \n'isa' vtable method to delegate the lookup to the object's class. \n(ParrotObject.pmc inherits an overridden 'isa' from ParrotClass.pmc.)\n\nUltimately, both variants of the 'isa' opcode should call the vtable \n'isa' (preserving encapsulation, allowing vtable overriding, etc.) This \nmeans the vtable isa needs to be able to handle keyed lookup. (Unless we \nreverse the decision of RT#39045.)\n\nAn object should never report that it 'isa' Object, it should only \nreport an 'isa' relationship to the classes it inherited from. \n(Different HLLs will have different notional hierarchies, and we don't \nwant Parrot's low-level implementation details to be visible in the mix.)\n\nAllison\n\n"}
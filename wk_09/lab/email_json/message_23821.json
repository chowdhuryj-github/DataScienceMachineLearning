{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r22688 - in branches: SAMBA_3_0/source/include\n\tSAMBA_3_0/source/locking SAMBA_3_0_26/source/include\n\tSAMBA_3_0_26/source/locking", "body": "Author: vlendec\nDate: 2007-05-05 20:43:06 +0000 (Sat, 05 May 2007)\nNew Revision: 22688\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22688\n\nLog:\nChange lock_data in struct byte_range_lock from void * to struct lock_struct *\n\nModified:\n   branches/SAMBA_3_0/source/include/locking.h\n   branches/SAMBA_3_0/source/locking/brlock.c\n   branches/SAMBA_3_0_26/source/include/locking.h\n   branches/SAMBA_3_0_26/source/locking/brlock.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/include/locking.h\n===================================================================\n--- branches/SAMBA_3_0/source/include/locking.h\t2007-05-05 20:41:21 UTC (rev 22687)\n+++ branches/SAMBA_3_0/source/include/locking.h\t2007-05-05 20:43:06 UTC (rev 22688)\n@@ -57,7 +57,7 @@\n \tBOOL modified;\n \tBOOL read_only;\n \tstruct lock_key key;\n-\tvoid *lock_data;\n+\tstruct lock_struct *lock_data;\n };\n \n #define BRLOCK_FN_CAST() \\\n\nModified: branches/SAMBA_3_0/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-05 20:41:21 UTC (rev 22687)\n+++ branches/SAMBA_3_0/source/locking/brlock.c\t2007-05-05 20:43:06 UTC (rev 22688)\n@@ -317,7 +317,7 @@\n {\n \tunsigned int i;\n \tfiles_struct *fsp = br_lck->fsp;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \n \tfor (i=0; i < br_lck->num_locks; i++) {\n \t\t/* Do any Windows or POSIX locks conflict ? */\n@@ -362,7 +362,7 @@\n \n \tmemcpy(&locks[br_lck->num_locks], plock, sizeof(struct lock_struct));\n \tbr_lck->num_locks += 1;\n-\tbr_lck->lock_data = (void *)locks;\n+\tbr_lck->lock_data = locks;\n \tbr_lck->modified = True;\n \n \treturn NT_STATUS_OK;\n@@ -588,7 +588,7 @@\n \t\t\tconst struct lock_struct *plock)\n {\n \tunsigned int i, count;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct lock_struct *tp;\n \tBOOL lock_was_added = False;\n \tBOOL signal_pending_read = False;\n@@ -686,7 +686,7 @@\n \t}\n \tbr_lck->num_locks = count;\n \tSAFE_FREE(br_lck->lock_data);\n-\tbr_lck->lock_data = (void *)tp;\n+\tbr_lck->lock_data = tp;\n \tlocks = tp;\n \tbr_lck->modified = True;\n \n@@ -770,7 +770,7 @@\n static BOOL brl_unlock_windows(struct byte_range_lock *br_lck, const struct lock_struct *plock)\n {\n \tunsigned int i, j;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tenum brl_type deleted_lock_type = READ_LOCK; /* shut the compiler up.... */\n \n #if ZERO_ZERO\n@@ -873,7 +873,7 @@\n {\n \tunsigned int i, j, count;\n \tstruct lock_struct *tp;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tBOOL overlap_found = False;\n \n \t/* No zero-zero locks for POSIX. */\n@@ -1006,7 +1006,7 @@\n \tbr_lck->num_locks = count;\n \tSAFE_FREE(br_lck->lock_data);\n \tlocks = tp;\n-\tbr_lck->lock_data = (void *)tp;\n+\tbr_lck->lock_data = tp;\n \tbr_lck->modified = True;\n \n \t/* Send unlock messages to any pending waiters that overlap. */\n@@ -1078,7 +1078,7 @@\n \tBOOL ret = True;\n \tunsigned int i;\n \tstruct lock_struct lock;\n-\tconst struct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tconst struct lock_struct *locks = br_lck->lock_data;\n \tfiles_struct *fsp = br_lck->fsp;\n \n \tlock.context.smbpid = smbpid;\n@@ -1135,7 +1135,7 @@\n {\n \tunsigned int i;\n \tstruct lock_struct lock;\n-\tconst struct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tconst struct lock_struct *locks = br_lck->lock_data;\n \tfiles_struct *fsp = br_lck->fsp;\n \n \tlock.context.smbpid = *psmbpid;\n@@ -1201,7 +1201,7 @@\n \t\tenum brl_flavour lock_flav)\n {\n \tunsigned int i;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct lock_context context;\n \n \tcontext.smbpid = smbpid;\n@@ -1251,7 +1251,7 @@\n \tint fnum = fsp->fnum;\n \tunsigned int i, j, dcount=0;\n \tint num_deleted_windows_locks = 0;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct process_id pid = procid_self();\n \tBOOL unlock_individually = False;\n \n@@ -1586,7 +1586,7 @@\n \ttalloc_set_destructor(br_lck, byte_range_lock_destructor);\n \n \tdata = tdb_fetch(tdb, key);\n-\tbr_lck->lock_data = (void *)data.dptr;\n+\tbr_lck->lock_data = (struct lock_struct *)data.dptr;\n \tbr_lck->num_locks = data.dsize / sizeof(struct lock_struct);\n \n \tif (!fsp->lockdb_clean) {\n@@ -1595,29 +1595,20 @@\n \t\t/* Go through and ensure all entries exist - remove any that don't. */\n \t\t/* Makes the lockdb self cleaning at low cost. */\n \n-\t\tstruct lock_struct *locks =\n-\t\t\t(struct lock_struct *)br_lck->lock_data;\n-\n-\t\tif (!validate_lock_entries(&br_lck->num_locks, &locks)) {\n+\t\tif (!validate_lock_entries(&br_lck->num_locks,\n+\t\t\t\t\t   &br_lck->lock_data)) {\n \t\t\tSAFE_FREE(br_lck->lock_data);\n \t\t\tTALLOC_FREE(br_lck);\n \t\t\treturn NULL;\n \t\t}\n \n-\t\t/*\n-\t\t * validate_lock_entries might have changed locks. We can't\n-\t\t * use a direct pointer here because otherwise gcc warnes\n-\t\t * about strict aliasing rules being violated.\n-\t\t */\n-\t\tbr_lck->lock_data = locks;\n-\n \t\t/* Mark the lockdb as \"clean\" as seen from this open file. */\n \t\tfsp->lockdb_clean = True;\n \t}\n \n \tif (DEBUGLEVEL >= 10) {\n \t\tunsigned int i;\n-\t\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\t\tstruct lock_struct *locks = br_lck->lock_data;\n \t\tDEBUG(10,(\"brl_get_locks_internal: %u current locks on dev=%.0f, inode=%.0f\\n\",\n \t\t\tbr_lck->num_locks,\n \t\t\t(double)fsp->dev, (double)fsp->inode ));\n\nModified: branches/SAMBA_3_0_26/source/include/locking.h\n===================================================================\n--- branches/SAMBA_3_0_26/source/include/locking.h\t2007-05-05 20:41:21 UTC (rev 22687)\n+++ branches/SAMBA_3_0_26/source/include/locking.h\t2007-05-05 20:43:06 UTC (rev 22688)\n@@ -57,7 +57,7 @@\n \tBOOL modified;\n \tBOOL read_only;\n \tstruct lock_key key;\n-\tvoid *lock_data;\n+\tstruct lock_struct *lock_data;\n };\n \n #define BRLOCK_FN_CAST() \\\n\nModified: branches/SAMBA_3_0_26/source/locking/brlock.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-05 20:41:21 UTC (rev 22687)\n+++ branches/SAMBA_3_0_26/source/locking/brlock.c\t2007-05-05 20:43:06 UTC (rev 22688)\n@@ -317,7 +317,7 @@\n {\n \tunsigned int i;\n \tfiles_struct *fsp = br_lck->fsp;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \n \tfor (i=0; i < br_lck->num_locks; i++) {\n \t\t/* Do any Windows or POSIX locks conflict ? */\n@@ -362,7 +362,7 @@\n \n \tmemcpy(&locks[br_lck->num_locks], plock, sizeof(struct lock_struct));\n \tbr_lck->num_locks += 1;\n-\tbr_lck->lock_data = (void *)locks;\n+\tbr_lck->lock_data = locks;\n \tbr_lck->modified = True;\n \n \treturn NT_STATUS_OK;\n@@ -588,7 +588,7 @@\n \t\t\tconst struct lock_struct *plock)\n {\n \tunsigned int i, count;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct lock_struct *tp;\n \tBOOL lock_was_added = False;\n \tBOOL signal_pending_read = False;\n@@ -686,7 +686,7 @@\n \t}\n \tbr_lck->num_locks = count;\n \tSAFE_FREE(br_lck->lock_data);\n-\tbr_lck->lock_data = (void *)tp;\n+\tbr_lck->lock_data = tp;\n \tlocks = tp;\n \tbr_lck->modified = True;\n \n@@ -770,7 +770,7 @@\n static BOOL brl_unlock_windows(struct byte_range_lock *br_lck, const struct lock_struct *plock)\n {\n \tunsigned int i, j;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tenum brl_type deleted_lock_type = READ_LOCK; /* shut the compiler up.... */\n \n #if ZERO_ZERO\n@@ -873,7 +873,7 @@\n {\n \tunsigned int i, j, count;\n \tstruct lock_struct *tp;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tBOOL overlap_found = False;\n \n \t/* No zero-zero locks for POSIX. */\n@@ -1006,7 +1006,7 @@\n \tbr_lck->num_locks = count;\n \tSAFE_FREE(br_lck->lock_data);\n \tlocks = tp;\n-\tbr_lck->lock_data = (void *)tp;\n+\tbr_lck->lock_data = tp;\n \tbr_lck->modified = True;\n \n \t/* Send unlock messages to any pending waiters that overlap. */\n@@ -1078,7 +1078,7 @@\n \tBOOL ret = True;\n \tunsigned int i;\n \tstruct lock_struct lock;\n-\tconst struct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tconst struct lock_struct *locks = br_lck->lock_data;\n \tfiles_struct *fsp = br_lck->fsp;\n \n \tlock.context.smbpid = smbpid;\n@@ -1135,7 +1135,7 @@\n {\n \tunsigned int i;\n \tstruct lock_struct lock;\n-\tconst struct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tconst struct lock_struct *locks = br_lck->lock_data;\n \tfiles_struct *fsp = br_lck->fsp;\n \n \tlock.context.smbpid = *psmbpid;\n@@ -1201,7 +1201,7 @@\n \t\tenum brl_flavour lock_flav)\n {\n \tunsigned int i;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct lock_context context;\n \n \tcontext.smbpid = smbpid;\n@@ -1251,7 +1251,7 @@\n \tint fnum = fsp->fnum;\n \tunsigned int i, j, dcount=0;\n \tint num_deleted_windows_locks = 0;\n-\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\tstruct lock_struct *locks = br_lck->lock_data;\n \tstruct process_id pid = procid_self();\n \tBOOL unlock_individually = False;\n \n@@ -1586,7 +1586,7 @@\n \ttalloc_set_destructor(br_lck, byte_range_lock_destructor);\n \n \tdata = tdb_fetch(tdb, key);\n-\tbr_lck->lock_data = (void *)data.dptr;\n+\tbr_lck->lock_data = (struct lock_struct *)data.dptr;\n \tbr_lck->num_locks = data.dsize / sizeof(struct lock_struct);\n \n \tif (!fsp->lockdb_clean) {\n@@ -1595,29 +1595,20 @@\n \t\t/* Go through and ensure all entries exist - remove any that don't. */\n \t\t/* Makes the lockdb self cleaning at low cost. */\n \n-\t\tstruct lock_struct *locks =\n-\t\t\t(struct lock_struct *)br_lck->lock_data;\n-\n-\t\tif (!validate_lock_entries(&br_lck->num_locks, &locks)) {\n+\t\tif (!validate_lock_entries(&br_lck->num_locks,\n+\t\t\t\t\t   &br_lck->lock_data)) {\n \t\t\tSAFE_FREE(br_lck->lock_data);\n \t\t\tTALLOC_FREE(br_lck);\n \t\t\treturn NULL;\n \t\t}\n \n-\t\t/*\n-\t\t * validate_lock_entries might have changed locks. We can't\n-\t\t * use a direct pointer here because otherwise gcc warnes\n-\t\t * about strict aliasing rules being violated.\n-\t\t */\n-\t\tbr_lck->lock_data = locks;\n-\n \t\t/* Mark the lockdb as \"clean\" as seen from this open file. */\n \t\tfsp->lockdb_clean = True;\n \t}\n \n \tif (DEBUGLEVEL >= 10) {\n \t\tunsigned int i;\n-\t\tstruct lock_struct *locks = (struct lock_struct *)br_lck->lock_data;\n+\t\tstruct lock_struct *locks = br_lck->lock_data;\n \t\tDEBUG(10,(\"brl_get_locks_internal: %u current locks on dev=%.0f, inode=%.0f\\n\",\n \t\t\tbr_lck->num_locks,\n \t\t\t(double)fsp->dev, (double)fsp->inode ));\n\n"}
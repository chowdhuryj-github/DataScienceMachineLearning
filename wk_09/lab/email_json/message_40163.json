{"category": "ham", "to_address": "Perl Beginners <beginners@perl.org>", "from_address": "Mathew Snyder <theillien@yahoo.com>", "subject": "Re: Effective date grab", "body": "Yes,  a month from the first to the last day.  This is how I'm doing it right\nnow which seems to be a lot of code which should be able to be pruned:\n#Declare the variables we'll need\nmy $count = 1;\nmy $febDays;\nmy @days;\nmy %time;\nmy %months31 = (\n        \"01\" => undef,\n        \"03\" => undef,\n        \"05\" => undef,\n        \"07\" => undef,\n        \"08\" => undef,\n        \"10\" => undef,\n        \"12\" => undef,\n);\nmy %months30 = (\n        \"04\" => undef,\n        \"06\" => undef,\n        \"09\" => undef,\n        \"11\" => undef,\n);\nmy %months = (\n        \"01\" => \"Jan\",\n        \"02\" => \"Feb\",\n        \"03\" => \"Mar\",\n        \"04\" => \"Apr\",\n        \"05\" => \"May\",\n        \"06\" => \"Jun\",\n        \"07\" => \"Jul\",\n        \"08\" => \"Aug\",\n        \"09\" => \"Sept\",\n        \"10\" => \"Oct\",\n        \"11\" => \"Nov\",\n        \"12\" => \"Dec\",\n);\n\nmy @date; #  = (localtime)[4,5];\nmy $month = (sprintf '%02d', (localtime)[4]); #$date[0]);\nmy $year      = (localtime)[5] + 1900; #$date[1] + 1900;\n\n# If the value of the 'month' variable is '00' we are in January so need\n# to set the $month to 12 in order to get December's data.  Any other\n# value is spot on.  The reason being that  while (localtime) will produce\n# a value based  on a startpoint of '00', we are shifting this back one by\n# making '00' equal to '12' causing all other numbers to match up to their\n# respective month.\nif ($month == '00') {\n        $month = 12;\n        $year--;\n}\n\n# We need to determine if the current year is a leap year so we use the\n# right number of days for Feb.\nif (isleap($year)) {\n        $febDays = 29;\n}else{\n        $febDays = 28;\n}\n\n Determine if the month requested has 31, 30 or 28 days and build\n# our days array to match\nif (exists($months31{$month})){\n        while ($count <= 31) {\n                push @days, (sprintf '%02d', $count);\n                $count++;\n        }\n}elsif (exists($months30{$month})){\n        while ($count <= 30) {\n                push @days, (sprintf '%02d', $count);\n                $count++;\n        }\n}else{\n        while ($count <= $febDays) {\n                push @days, (sprintf '%02d', $count);\n                $count++;\n        }\n}\n\nThat's just a keister-load of code just to create an array of 28/29, 30 or 31 dates.\n\nMathew\nKeep up with me and what I'm up to: http://theillien.blogspot.com\n\n\nMathew Snyder wrote:\n> A while ago I had posted requesting help with a long block of code that would do\n> all kinds of stuff dealing with the date.  It turned out to not work despite\n> being technically, correct.  Instead of getting help with it, Mr. Phoenix\n> provided me with a block of code that did what I needed but much more concisely.\n>  And, more importantly, correctly.\n> \n> for (1 .. 7) {\n>   $time -= 24*60*60;\n>   my @date = (localtime($time))[3 .. 5];\n>   push @days, (sprintf '%02d', $date[0]);\n>   push @months,(sprintf '%02d',$date[1] + 1);\n>   push @years, $date[2] + 1900;\n>   push @searchDate, join \"-\", ($date[2] + 1900), (sprintf '%02d',$date[1] + 1),\n> (sprintf '%02d', $date[0]);\n> }\n> \n> This will give me a weeks worth of dates regardless of whether or not the month\n> flips over in the middle of the week.\n> \n> What I'd like to do now is modify this or figure out a similar block of code\n> that will do the same only for an entire month.  The thing I see being a problem\n> though is that some months have 30 days, some months have 31 days and February\n> has 28/29 days.  This makes it pretty much impossible to just do a for loop\n> utilizing (1..whatever).  How can I populate an array of an entire month's worth\n> of dates without worrying about how many days the month has?\n> \n> Mathew\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
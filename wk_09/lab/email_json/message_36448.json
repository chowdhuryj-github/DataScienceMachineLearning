{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "svn commit: samba r23152 - in\n\tbranches/SAMBA_4_0/source/torture/raw: .", "body": "Author: tridge\nDate: 2007-05-26 03:24:08 +0000 (Sat, 26 May 2007)\nNew Revision: 23152\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23152\n\nLog:\nfixed some async retry issues in openbench\n\nModified:\n   branches/SAMBA_4_0/source/torture/raw/openbench.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/torture/raw/openbench.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/openbench.c\t2007-05-26 01:26:09 UTC (rev 23151)\n+++ branches/SAMBA_4_0/source/torture/raw/openbench.c\t2007-05-26 03:24:08 UTC (rev 23152)\n@@ -39,15 +39,13 @@\n static int open_retries;\n static char **fnames;\n static int num_connected;\n+static struct timed_event *report_te;\n \n-enum open_stage {OPEN_INITIAL, OPEN_OPEN, OPEN_CLOSE};\n-\n struct benchopen_state {\n \tTALLOC_CTX *mem_ctx;\n \tstruct event_context *ev;\n \tstruct smbcli_state *cli;\n \tstruct smbcli_tree *tree;\n-\tenum open_stage stage;\n \tint client_num;\n \tint old_fnum;\n \tint fnum;\n@@ -68,7 +66,6 @@\n };\n \n static void next_open(struct benchopen_state *state);\n-static void next_operation(struct benchopen_state *state);\n static void reopen_connection(struct event_context *ev, struct timed_event *te, \n \t\t\t      struct timeval t, void *private_data);\n \n@@ -97,9 +94,9 @@\n \tDEBUG(0,(\"reconnect to %s finished (%u connected)\\n\", state->dest_host,\n \t\t num_connected));\n \n-\tstate->stage = OPEN_INITIAL;\n \tstate->fnum = -1;\n-\tnext_operation(state);\n+\tstate->old_fnum = -1;\n+\tnext_open(state);\n }\n \n \t\n@@ -152,7 +149,9 @@\n {\n \tstate->count++;\n \n-\tstate->file_num = (state->file_num+1) % (nprocs+1);\n+\tstate->file_num = (state->file_num+1) % (3*nprocs);\n+\n+\tDEBUG(2,(\"[%d] opening %u\\n\", state->client_num, state->file_num));\n \tstate->open_parms.ntcreatex.level = RAW_OPEN_NTCREATEX;\n \tstate->open_parms.ntcreatex.in.flags = 0;\n \tstate->open_parms.ntcreatex.in.root_fid = 0;\n@@ -174,6 +173,10 @@\n \n static void next_close(struct benchopen_state *state)\n {\n+\tDEBUG(2,(\"[%d] closing %d\\n\", state->client_num, state->old_fnum));\n+\tif (state->old_fnum == -1) {\n+\t\treturn;\n+\t}\n \tstate->close_parms.close.level = RAW_CLOSE_CLOSE;\n \tstate->close_parms.close.in.file.fnum = state->old_fnum;\n \tstate->close_parms.close.in.write_time = 0;\n@@ -181,6 +184,7 @@\n \tstate->req_close = smb_raw_close_send(state->tree, &state->close_parms);\n \tstate->req_close->async.fn = close_completed;\n \tstate->req_close->async.private = state;\n+\tstate->old_fnum = -1;\n }\n \n /*\n@@ -192,8 +196,6 @@\n \tTALLOC_CTX *tmp_ctx = talloc_new(state->mem_ctx);\n \tNTSTATUS status;\n \n-\tstate->old_fnum = state->fnum;\n-\n \tstatus = smb_raw_open_recv(req, tmp_ctx, &state->open_parms);\n \n \ttalloc_free(tmp_ctx);\n@@ -215,6 +217,7 @@\n \t}\n \n \tif (NT_STATUS_EQUAL(status, NT_STATUS_SHARING_VIOLATION)) {\n+\t\tDEBUG(2,(\"[%d] retrying open\\n\", state->client_num));\n \t\topen_retries++;\n \t\tstate->req_open = smb_raw_open_send(state->tree, &state->open_parms);\n \t\tstate->req_open->async.fn = open_completed;\n@@ -228,9 +231,17 @@\n \t\treturn;\n \t}\n \n+\tstate->old_fnum = state->fnum;\n \tstate->fnum = state->open_parms.ntcreatex.out.file.fnum;\n \n-\tnext_operation(state);\n+\tDEBUG(2,(\"[%d] open completed: fnum=%d old_fnum=%d\\n\", \n+\t\t state->client_num, state->fnum, state->old_fnum));\n+\n+\tif (state->old_fnum != -1) {\n+\t\tnext_close(state);\n+\t}\n+\n+\tnext_open(state);\n }\t\n \n /*\n@@ -263,27 +274,10 @@\n \t\treturn;\n \t}\n \n-\tnext_operation(state);\n+\tDEBUG(2,(\"[%d] close completed: fnum=%d old_fnum=%d\\n\", \n+\t\t state->client_num, state->fnum, state->old_fnum));\n }\t\n \n-static void next_operation(struct benchopen_state *state)\n-{\n-\tswitch (state->stage) {\n-\tcase OPEN_INITIAL:\n-\t\tnext_open(state);\n-\t\tstate->stage = OPEN_OPEN;\n-\t\tbreak;\n-\tcase OPEN_OPEN:\n-\t\tnext_open(state);\n-\t\tstate->stage = OPEN_CLOSE;\n-\t\tbreak;\n-\tcase OPEN_CLOSE:\n-\t\tnext_close(state);\n-\t\tstate->stage = OPEN_OPEN;\n-\t\tbreak;\n-\t}\n-}\n-\n static void echo_completion(struct smbcli_request *req)\n {\n \tstruct benchopen_state *state = talloc_get_type(req->async.private, \n@@ -312,7 +306,8 @@\n \t}\n \tprintf(\"\\r\");\n \tfflush(stdout);\n-\tevent_add_timed(ev, state, timeval_current_ofs(1, 0), report_rate, state);\n+\treport_te = event_add_timed(ev, state, timeval_current_ofs(1, 0), \n+\t\t\t\t    report_rate, state);\n \n \t/* send an echo on each interface to ensure it stays alive - this helps\n \t   with IP takeover */\n@@ -346,7 +341,7 @@\n \tstruct event_context *ev = event_context_find(mem_ctx);\n \tstruct benchopen_state *state;\n \tint total = 0, minops=0;\n-\tbool progress;\n+\tbool progress=False;\n \n \tprogress = torture_setting_bool(torture, \"progress\", true);\n \t\n@@ -379,8 +374,8 @@\n \t\tgoto failed;\n \t}\n \n-\tfnames = talloc_array(mem_ctx, char *, nprocs+1);\n-\tfor (i=0;ifile_num], \n \t\t\t\t\t    O_RDWR|O_CREAT, DENY_ALL);\n-\t\tstate[i].old_fnum = state[i].fnum;\n-\t\tstate[i].stage = OPEN_OPEN;\n-\t\tnext_operation(&state[i]);\n+\t\tstate[i].old_fnum = -1;\n+\t\tnext_open(&state[i]);\n \t}\n \n \ttv = timeval_current();\t\n \n \tif (progress) {\n-\t\tevent_add_timed(ev, state, timeval_current_ofs(1, 0), report_rate, state);\n+\t\treport_te = event_add_timed(ev, state, timeval_current_ofs(1, 0), \n+\t\t\t\t\t    report_rate, state);\n \t}\n \n \tprintf(\"Running for %d seconds\\n\", timelimit);\n@@ -410,6 +405,8 @@\n \t\t}\n \t}\n \n+\ttalloc_free(report_te);\n+\n \tprintf(\"%.2f ops/second (%d retries)\\n\", \n \t       total/timeval_elapsed(&tv), open_retries);\n \tminops = state[0].count;\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 152: validate dmaster on a client fetch request in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 152\nrevision-id: tridge@samba.org-20070418083902-70e42a254dc2a6f6\nparent: tridge@samba.org-20070418053541-815ac1776bf2937f\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Wed 2007-04-18 18:39:02 +1000\nmessage:\n  validate dmaster on a client fetch request\nmodified:\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n  common/ctdb_util.c             ctdb_util.c-20061128065342-to93h6eejj5kon81-3\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-04-18 05:35:41 +0000\n+++ b/common/ctdb_daemon.c\t2007-04-18 08:39:02 +0000\n@@ -244,6 +244,30 @@\n \t_exit(0);\n }\n \n+\n+/*\n+  send a fetch lock error reply to the client\n+ */\n+static void daemon_fetch_lock_error(struct ctdb_client *client,\n+\t\t\t\t    struct ctdb_req_fetch_lock *f)\n+{\n+\tstruct ctdb_reply_fetch_lock r;\n+\n+\tZERO_STRUCT(r);\n+\tr.hdr.length       = sizeof(r);\n+\tr.hdr.ctdb_magic   = CTDB_MAGIC;\n+\tr.hdr.ctdb_version = CTDB_VERSION;\n+\tr.hdr.operation    = CTDB_REPLY_FETCH_LOCK;\n+\tr.hdr.reqid        = f->hdr.reqid;\n+\tr.state            = -1;\n+\t\n+\t/*\n+\t * Ignore the result, there's not much we can do anyway.\n+\t */\n+\tctdb_queue_send(client->queue, (uint8_t *)&r.hdr,\n+\t\t\tr.hdr.length);\n+}\n+\n /*\n   called when the daemon gets a fetch lock request from a client\n  */\n@@ -257,21 +281,13 @@\n \n \tctdb_db = find_ctdb_db(client->ctdb, f->db_id);\n \tif (ctdb_db == NULL) {\n-\t\tstruct ctdb_reply_fetch_lock r;\n-\n-\t\tZERO_STRUCT(r);\n-\t\tr.hdr.length       = sizeof(r);\n-\t\tr.hdr.ctdb_magic   = CTDB_MAGIC;\n-\t\tr.hdr.ctdb_version = CTDB_VERSION;\n-\t\tr.hdr.operation    = CTDB_REPLY_FETCH_LOCK;\n-\t\tr.hdr.reqid        = f->hdr.reqid;\n-\t\tr.state            = -1;\n-\n-\t\t/*\n-\t\t * Ignore the result, there's not much we can do anyway.\n-\t\t */\n-\t\tctdb_queue_send(client->queue, (uint8_t *)&r.hdr,\n-\t\t\t\tr.hdr.length);\n+\t\tdaemon_fetch_lock_error(client, f);\n+\t\treturn;\n+\t}\n+\n+\tif (!ctdb_validate_vnn(client->ctdb, f->header.dmaster)) {\n+\t\tDEBUG(0,(__location__ \" Invalid dmaster %u\\n\", f->header.dmaster));\n+\t\tdaemon_fetch_lock_error(client, f);\n \t\treturn;\n \t}\n \n\n=== modified file 'common/ctdb_util.c'\n--- a/common/ctdb_util.c\t2007-04-17 12:13:06 +0000\n+++ b/common/ctdb_util.c\t2007-04-18 08:39:02 +0000\n@@ -102,3 +102,4 @@\n \n \treturn (1103515243 * value + 12345);  \n }\n+\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-04-18 05:35:41 +0000\n+++ b/include/ctdb_private.h\t2007-04-18 08:39:02 +0000\n@@ -50,6 +50,11 @@\n \tint port;\n };\n \n+/*\n+  check a vnn is valid\n+ */\n+#define ctdb_validate_vnn(ctdb, vnn) (((uint32_t)(vnn)) < (ctdb)->num_nodes)\n+\n \n /* called from the queue code when a packet comes in. Called with data==NULL\n    on error */\n\n"}
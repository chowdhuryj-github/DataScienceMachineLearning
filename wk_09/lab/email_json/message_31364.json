{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "svn commit: samba r22965 - in\n\tbranches/SAMBA_4_0/source/torture/raw: .", "body": "Author: tridge\nDate: 2007-05-17 03:42:28 +0000 (Thu, 17 May 2007)\nNew Revision: 22965\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22965\n\nLog:\n\nchanged RAW-LOCK-BENCH to remove the scheduling uncertainty. We should\nalways get balanced locking now\n\nModified:\n   branches/SAMBA_4_0/source/torture/raw/lockbench.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/torture/raw/lockbench.c\n===================================================================\n--- branches/SAMBA_4_0/source/torture/raw/lockbench.c\t2007-05-17 02:42:14 UTC (rev 22964)\n+++ branches/SAMBA_4_0/source/torture/raw/lockbench.c\t2007-05-17 03:42:28 UTC (rev 22965)\n@@ -32,13 +32,6 @@\n #include \"libcli/composite/composite.h\"\n #include \"libcli/smb_composite/smb_composite.h\"\n \n-#define CHECK_STATUS(status, correct) do { \\\n-\tif (!NT_STATUS_EQUAL(status, correct)) { \\\n-\t\tprintf(\"(%s) Incorrect status %s - should be %s\\n\", \\\n-\t\t       __location__, nt_errstr(status), nt_errstr(correct)); \\\n-\t\tgoto failed; \\\n-\t}} while (0)\n-\n #define BASEDIR \"\\\\benchlock\"\n #define FNAME BASEDIR \"\\\\lock.dat\"\n \n@@ -46,17 +39,19 @@\n static int lock_failed;\n static int num_connected;\n \n+enum lock_stage {LOCK_INITIAL, LOCK_LOCK, LOCK_UNLOCK};\n+\n struct benchlock_state {\n \tstruct event_context *ev;\n \tstruct smbcli_tree *tree;\n \tTALLOC_CTX *mem_ctx;\n \tint client_num;\n \tint fnum;\n-\tint offset;\n+\tenum lock_stage stage;\n+\tint lock_offset;\n+\tint unlock_offset;\n \tint count;\n \tint lastcount;\n-\tunion smb_lock io;\n-\tstruct smb_lock_entry lock[2];\n \tstruct smbcli_request *req;\n \tstruct smb_composite_connect reconnect;\n \n@@ -74,20 +69,47 @@\n */\n static void lock_send(struct benchlock_state *state)\n {\n-\tstate->io.lockx.in.file.fnum = state->fnum;\n-\tstate->io.lockx.in.ulock_cnt = 1;\n-\tstate->lock[0].pid = state->tree->session->pid;\n-\tstate->lock[1].pid = state->tree->session->pid;\n-\tstate->lock[0].offset = state->offset;\n-\tstate->lock[1].offset = (state->offset+1)%nprocs;\n-\tstate->req = smb_raw_lock_send(state->tree, &state->io);\n+\tunion smb_lock io;\n+\tstruct smb_lock_entry lock;\n+\n+\tswitch (state->stage) {\n+\tcase LOCK_INITIAL:\n+\t\tio.lockx.in.ulock_cnt = 0;\n+\t\tio.lockx.in.lock_cnt = 1;\n+\t\tstate->lock_offset = 0;\n+\t\tstate->unlock_offset = 0;\n+\t\tlock.offset = state->lock_offset;\n+\t\tbreak;\n+\tcase LOCK_LOCK:\n+\t\tio.lockx.in.ulock_cnt = 0;\n+\t\tio.lockx.in.lock_cnt = 1;\n+\t\tstate->lock_offset = (state->lock_offset+1)%(nprocs+1);\n+\t\tlock.offset = state->lock_offset;\n+\t\tbreak;\n+\tcase LOCK_UNLOCK:\n+\t\tio.lockx.in.ulock_cnt = 1;\n+\t\tio.lockx.in.lock_cnt = 0;\n+\t\tlock.offset = state->unlock_offset;\n+\t\tstate->unlock_offset = (state->unlock_offset+1)%(nprocs+1);\n+\t\tbreak;\n+\t}\n+\n+\tlock.count = 1;\n+\tlock.pid = state->tree->session->pid;\n+\n+\tio.lockx.level = RAW_LOCK_LOCKX;\n+\tio.lockx.in.mode = LOCKING_ANDX_LARGE_FILES;\n+\tio.lockx.in.timeout = 100000;\n+\tio.lockx.in.locks = &lock\n+\tio.lockx.in.file.fnum = state->fnum;\n+\n+\tstate->req = smb_raw_lock_send(state->tree, &io);\n \tif (state->req == NULL) {\n \t\tDEBUG(0,(\"Failed to setup lock\\n\"));\n \t\tlock_failed++;\n \t}\n \tstate->req->async.private = state;\n \tstate->req->async.fn      = lock_completion;\n-\tstate->offset = (state->offset+1)%nprocs;\n }\n \n static void reopen_connection(struct event_context *ev, struct timed_event *te, \n@@ -106,22 +128,13 @@\n \t\texit(1);\n \t}\n \n-\t/* reestablish one lock, preparing for the async lock loop */\n-\tstate->lock[0].offset = state->offset;\n-\tstate->io.lockx.in.ulock_cnt = 0;\n-\tstate->io.lockx.in.file.fnum = state->fnum;\n-\tstate->req = smb_raw_lock_send(state->tree, &state->io);\n-\tif (state->req == NULL) {\n-\t\tDEBUG(0,(\"Failed to setup lock\\n\"));\n-\t\tlock_failed++;\n-\t}\n-\tstate->req->async.private = state;\n-\tstate->req->async.fn      = lock_completion;\n-\n \tnum_connected++;\n \n \tDEBUG(0,(\"reconnect to %s finished (%u connected)\\n\", state->dest_host,\n \t\t num_connected));\n+\n+\tstate->stage = LOCK_INITIAL;\n+\tlock_send(state);\n }\n \n /*\n@@ -211,10 +224,23 @@\n \t\t\tDEBUG(0,(\"Lock failed - %s\\n\", nt_errstr(status)));\n \t\t\tlock_failed++;\n \t\t}\n-\t} else {\n-\t\tstate->count++;\n-\t\tlock_send(state);\n+\t\treturn;\n \t}\n+\n+\tswitch (state->stage) {\n+\tcase LOCK_INITIAL:\n+\t\tstate->stage = LOCK_LOCK;\n+\t\tbreak;\n+\tcase LOCK_LOCK:\n+\t\tstate->stage = LOCK_UNLOCK;\n+\t\tbreak;\n+\tcase LOCK_UNLOCK:\n+\t\tstate->stage = LOCK_LOCK;\n+\t\tbreak;\n+\t}\n+\n+\tstate->count++;\n+\tlock_send(state);\n }\n \n \n@@ -246,7 +272,6 @@\n \tstruct event_context *ev = event_context_find(mem_ctx);\n \tstruct benchlock_state *state;\n \tint total = 0, minops=0;\n-\tNTSTATUS status;\n \tstruct smbcli_state *cli;\n \tbool progress;\n \n@@ -290,24 +315,7 @@\n \t\t\tgoto failed;\n \t\t}\n \n-\t\tstate[i].io.lockx.level = RAW_LOCK_LOCKX;\n-\t\tstate[i].io.lockx.in.mode = LOCKING_ANDX_LARGE_FILES;\n-\t\tstate[i].io.lockx.in.timeout = 100000;\n-\t\tstate[i].io.lockx.in.ulock_cnt = 0;\n-\t\tstate[i].io.lockx.in.lock_cnt = 1;\n-\t\tstate[i].lock[0].count = 1;\n-\t\tstate[i].lock[1].count = 1;\n-\t\tstate[i].io.lockx.in.locks = &state[i].lock[0];\n-\n-\t\tstate[i].offset = i;\n-\t\tstate[i].io.lockx.in.file.fnum = state[i].fnum;\n-\t\tstate[i].lock[0].offset = state[i].offset;\n-\t\tstate[i].lock[0].pid    = state[i].tree->session->pid;\n-\t\tstatus = smb_raw_lock(state[i].tree, &state[i].io);\n-\t\tCHECK_STATUS(status, NT_STATUS_OK);\n-\t}\n-\n-\tfor (i=0;i<nprocs;i++) {\n+\t\tstate[i].stage = LOCK_INITIAL;\n \t\tlock_send(&state[i]);\n \t}\n \n\n"}
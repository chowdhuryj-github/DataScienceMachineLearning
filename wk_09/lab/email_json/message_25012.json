{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Robert Hicks <sigzero@gmail.com>", "subject": "Re: looping through a file", "body": "Chas Owens wrote:\n> On 5/7/07, Robert Hicks  wrote:\n> snip\n>> I think part of the problem is the 'shift'ing that I was doing. I am\n>> looking into that. Basically I was shift'ing the @log out of existence\n>> after the first pass.\n> snip\n> \n> That sounds like a viable candidate for the warning as well.\n> \n> \n> snip\n>> > Also, you should never use a straight string in a regex; it should\n>> > aways be quoted.\n>> >\n>> > $line = shift @log until $line =~ /\\Q$prime_id\\E/;\n>>\n>> What does that give you? I have never heard of that and have never had a\n>> problem the way I have shown. Just curious...\n> snip\n> \n> The \\Q turns off meta-characters until the \\E.  If your substr returns\n> \"foo.id\" then /$prime_id/ will match \"foolid\" as well as as \"foo.id\".\n> Worse yet if substr returns \"abc+de\" then /$prime_id/ won't match\n> against \"abc+de\" only \"abcde\", \"abccde\", etc.  And the worst is\n> unmatched open/close characters.  Try this\n> \n> perl -le '$smiley = \":)\"; print $1 if $smiley =~ /($smiley)/;'\n> \n> versus this\n> \n> perl -le '$smiley = \":)\"; print $1 if $smiley =~ /(\\Q$smiley\\E)/;'\n\nCool, thanks for the tidbit!\n\nRobert\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
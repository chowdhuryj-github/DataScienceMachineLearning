{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jerry@samba.org", "subject": "svn commit: samba r23101 - in branches/SAMBA_3_0_RELEASE/source:\n\tinclude locking smbd", "body": "Author: jerry\nDate: 2007-05-23 22:46:30 +0000 (Wed, 23 May 2007)\nNew Revision: 23101\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23101\n\nLog:\ngrab remainder of rename fixes\nModified:\n   branches/SAMBA_3_0_RELEASE/source/include/smb.h\n   branches/SAMBA_3_0_RELEASE/source/locking/locking.c\n   branches/SAMBA_3_0_RELEASE/source/smbd/open.c\n   branches/SAMBA_3_0_RELEASE/source/smbd/reply.c\n   branches/SAMBA_3_0_RELEASE/source/smbd/trans2.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_RELEASE/source/include/smb.h\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/include/smb.h\t2007-05-23 21:32:10 UTC (rev 23100)\n+++ branches/SAMBA_3_0_RELEASE/source/include/smb.h\t2007-05-23 22:46:30 UTC (rev 23101)\n@@ -748,6 +748,7 @@\n };\n \n #define SHARE_MODE_FLAG_POSIX_OPEN\t0x1\n+#define SHARE_MODE_ALLOW_INITIAL_DELETE_ON_CLOSE      0x2\n \n /* struct returned by get_share_modes */\n struct share_mode_entry {\n@@ -765,7 +766,7 @@\n \tSMB_INO_T inode;\n \tunsigned long share_file_id;\n \tuint32 uid;\t\t/* uid of file opener. */\n-\tuint16 flags;\t\t/* POSIX_OPEN only defined so far... */\n+\tuint16 flags;\t\t/* See SHARE_MODE_XX above. */\n };\n \n /* oplock break message definition - linearization of share_mode_entry.\n\nModified: branches/SAMBA_3_0_RELEASE/source/locking/locking.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/locking/locking.c\t2007-05-23 21:32:10 UTC (rev 23100)\n+++ branches/SAMBA_3_0_RELEASE/source/locking/locking.c\t2007-05-23 22:46:30 UTC (rev 23101)\n@@ -993,10 +993,13 @@\n }\n \n void set_share_mode(struct share_mode_lock *lck, files_struct *fsp,\n-\t\t\tuid_t uid, uint16 mid, uint16 op_type)\n+\t\t\tuid_t uid, uint16 mid, uint16 op_type, BOOL initial_delete_on_close_allowed)\n {\n \tstruct share_mode_entry entry;\n \tfill_share_mode_entry(&entry, fsp, uid, mid, op_type);\n+\tif (initial_delete_on_close_allowed) {\n+\t\tentry.flags |= SHARE_MODE_ALLOW_INITIAL_DELETE_ON_CLOSE;\n+\t}\n \tadd_share_mode_entry(lck, &entry);\n }\n \n@@ -1196,6 +1199,22 @@\n \treturn NT_STATUS_OK;\n }\n \n+/****************************************************************************\n+ Do we have an open file handle that created this entry ?\n+****************************************************************************/\n+\n+BOOL can_set_initial_delete_on_close(const struct share_mode_lock *lck)\n+{\n+\tint i;\n+\n+\tfor (i=0; inum_share_modes; i++) {\n+\t\tif (lck->share_modes[i].flags & SHARE_MODE_ALLOW_INITIAL_DELETE_ON_CLOSE) {\n+\t\t\treturn True;\n+\t\t}\n+\t}\n+\treturn False;\n+}\n+\n /*************************************************************************\n  Return a talloced copy of a UNIX_USER_TOKEN. NULL on fail.\n  (Should this be in locking.c.... ?).\n@@ -1296,6 +1315,31 @@\n \treturn True;\n }\n \n+/****************************************************************************\n+ Sets the allow initial delete on close flag for this share mode.\n+****************************************************************************/\n+\n+BOOL set_allow_initial_delete_on_close(struct share_mode_lock *lck, files_struct *fsp, BOOL delete_on_close)\n+{\n+\tstruct share_mode_entry entry, *e;\n+\n+\t/* Don't care about the pid owner being correct here - just a search. */\n+\tfill_share_mode_entry(&entry, fsp, (uid_t)-1, 0, NO_OPLOCK);\n+\n+\te = find_share_mode_entry(lck, &entry);\n+\tif (e == NULL) {\n+\t\treturn False;\n+\t}\n+\n+\tif (delete_on_close) {\n+\t\te->flags |= SHARE_MODE_ALLOW_INITIAL_DELETE_ON_CLOSE;\n+\t} else {\n+\t\te->flags &= ~SHARE_MODE_ALLOW_INITIAL_DELETE_ON_CLOSE;\n+\t}\n+\tlck->modified = True;\n+\treturn True;\n+}\n+\n struct forall_state {\n \tvoid (*fn)(const struct share_mode_entry *entry,\n \t\t   const char *sharepath,\n\nModified: branches/SAMBA_3_0_RELEASE/source/smbd/open.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/smbd/open.c\t2007-05-23 21:32:10 UTC (rev 23100)\n+++ branches/SAMBA_3_0_RELEASE/source/smbd/open.c\t2007-05-23 22:46:30 UTC (rev 23101)\n@@ -47,7 +47,12 @@\n \tNTSTATUS status = NT_STATUS_OK;\n \n #ifdef O_NOFOLLOW\n-\tif (!lp_symlinks(SNUM(conn))) {\n+\t/* \n+\t * Never follow symlinks on a POSIX client. The\n+\t * client should be doing this.\n+\t */\n+\n+\tif (fsp->posix_open || !lp_symlinks(SNUM(conn))) {\n \t\tflags |= O_NOFOLLOW;\n \t}\n #endif\n@@ -1120,6 +1125,7 @@\n \tBOOL file_existed = VALID_STAT(*psbuf);\n \tBOOL def_acl = False;\n \tBOOL posix_open = False;\n+\tBOOL new_file_created = False;\n \tSMB_DEV_T dev = 0;\n \tSMB_INO_T inode = 0;\n \tNTSTATUS fsp_open = NT_STATUS_ACCESS_DENIED;\n@@ -1760,28 +1766,31 @@\n \t\t\tfsp->oplock_type = NO_OPLOCK;\n \t\t}\n \t}\n-\tset_share_mode(lck, fsp, current_user.ut.uid, 0, fsp->oplock_type);\n \n-\tif (info == FILE_WAS_OVERWRITTEN || info == FILE_WAS_CREATED ||\n-\t    info == FILE_WAS_SUPERSEDED) {\n+\tif (info == FILE_WAS_OVERWRITTEN || info == FILE_WAS_CREATED || info == FILE_WAS_SUPERSEDED) {\n+\t\tnew_file_created = True;\n+\t}\n \n-\t\t/* Handle strange delete on close create semantics. */\n-\t\tif (create_options & FILE_DELETE_ON_CLOSE) {\n-\t\t\tstatus = can_set_delete_on_close(fsp, True, new_dos_attributes);\n+\tset_share_mode(lck, fsp, current_user.ut.uid, 0, fsp->oplock_type, new_file_created);\n \n-\t\t\tif (!NT_STATUS_IS_OK(status)) {\n-\t\t\t\t/* Remember to delete the mode we just added. */\n-\t\t\t\tdel_share_mode(lck, fsp);\n-\t\t\t\tTALLOC_FREE(lck);\n-\t\t\t\tfd_close(conn,fsp);\n-\t\t\t\tfile_free(fsp);\n-\t\t\t\treturn status;\n-\t\t\t}\n-\t\t\t/* Note that here we set the *inital* delete on close flag,\n-\t\t\t   not the regular one. The magic gets handled in close. */\n-\t\t\tfsp->initial_delete_on_close = True;\n+\t/* Handle strange delete on close create semantics. */\n+\tif ((create_options & FILE_DELETE_ON_CLOSE) && can_set_initial_delete_on_close(lck)) {\n+\t\tstatus = can_set_delete_on_close(fsp, True, new_dos_attributes);\n+\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\t/* Remember to delete the mode we just added. */\n+\t\t\tdel_share_mode(lck, fsp);\n+\t\t\tTALLOC_FREE(lck);\n+\t\t\tfd_close(conn,fsp);\n+\t\t\tfile_free(fsp);\n+\t\t\treturn status;\n \t\t}\n+\t\t/* Note that here we set the *inital* delete on close flag,\n+\t\t   not the regular one. The magic gets handled in close. */\n+\t\tfsp->initial_delete_on_close = True;\n+\t}\n \t\n+\tif (new_file_created) {\n \t\t/* Files should be initially set as archive */\n \t\tif (lp_map_archive(SNUM(conn)) ||\n \t\t    lp_store_dos_attributes(SNUM(conn))) {\n@@ -2139,7 +2148,7 @@\n \t\treturn status;\n \t}\n \n-\tset_share_mode(lck, fsp, current_user.ut.uid, 0, NO_OPLOCK);\n+\tset_share_mode(lck, fsp, current_user.ut.uid, 0, NO_OPLOCK, True);\n \n \t/* For directories the delete on close bit at open time seems\n \t   always to be honored on close... See test 19 in Samba4 BASE-DELETE. */\n\nModified: branches/SAMBA_3_0_RELEASE/source/smbd/reply.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/smbd/reply.c\t2007-05-23 21:32:10 UTC (rev 23100)\n+++ branches/SAMBA_3_0_RELEASE/source/smbd/reply.c\t2007-05-23 22:46:30 UTC (rev 23101)\n@@ -1790,7 +1790,7 @@\n  Check if a user is allowed to rename a file.\n ********************************************************************/\n \n-static NTSTATUS can_rename(connection_struct *conn, char *fname, uint16 dirtype, SMB_STRUCT_STAT *pst)\n+static NTSTATUS can_rename(connection_struct *conn, char *fname, uint16 dirtype, SMB_STRUCT_STAT *pst, BOOL self_open)\n {\n \tfiles_struct *fsp;\n \tuint32 fmode;\n@@ -1811,7 +1811,10 @@\n \n \tstatus = open_file_ntcreate(conn, fname, pst,\n \t\t\t\tDELETE_ACCESS,\n-\t\t\t\tFILE_SHARE_READ|FILE_SHARE_WRITE,\n+\t\t\t\t/* If we're checking our fsp don't deny for delete. */\n+\t\t\t\tself_open ?\n+\t\t\t\t\tFILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE :\n+\t\t\t\t\tFILE_SHARE_READ|FILE_SHARE_WRITE,\n \t\t\t\tFILE_OPEN,\n \t\t\t\t0,\n \t\t\t\tFILE_ATTRIBUTE_NORMAL,\n@@ -4192,7 +4195,9 @@\n \tZERO_STRUCT(sbuf);\n \n \tstatus = unix_convert(conn, newname, False, newname_last_component, &sbuf);\n-\tif (!NT_STATUS_IS_OK(status)) {\n+\t/* We expect this to be NT_STATUS_OBJECT_PATH_NOT_FOUND */\n+\tif (!NT_STATUS_EQUAL(NT_STATUS_OBJECT_PATH_NOT_FOUND, status)) {\n+\t\treturn NT_STATUS_OBJECT_NAME_COLLISION;\n \t\treturn status;\n \t}\n \n@@ -4260,9 +4265,20 @@\n \t\treturn NT_STATUS_OBJECT_NAME_COLLISION;\n \t}\n \n-\tstatus = can_rename(conn,fsp->fsp_name,attrs,&sbuf);\n+\t/* Ensure we have a valid stat struct for the source. */\n+\tif (fsp->fh->fd != -1) {\n+\t\tif (SMB_VFS_FSTAT(fsp,fsp->fh->fd,&sbuf) == -1) {\n+\t\t\treturn map_nt_error_from_unix(errno);\n+\t\t}\n+\t} else {\n+\t\tif (SMB_VFS_STAT(conn,fsp->fsp_name,&sbuf) == -1) {\n+\t\t\treturn map_nt_error_from_unix(errno);\n+\t\t}\n+\t}\n \n-\tif (dest_exists && !NT_STATUS_IS_OK(status)) {\n+\tstatus = can_rename(conn,fsp->fsp_name,attrs,&sbuf,True);\n+\n+\tif (!NT_STATUS_IS_OK(status)) {\n \t\tDEBUG(3,(\"rename_internals_fsp: Error %s rename %s -> %s\\n\",\n \t\t\tnt_errstr(status), fsp->fsp_name,newname));\n \t\tif (NT_STATUS_EQUAL(status,NT_STATUS_SHARING_VIOLATION))\n@@ -4277,9 +4293,33 @@\n \tlck = get_share_mode_lock(NULL, fsp->dev, fsp->inode, NULL, NULL);\n \n \tif(SMB_VFS_RENAME(conn,fsp->fsp_name, newname) == 0) {\n+\t\tuint32 create_options = fsp->fh->private_options;\n+\n \t\tDEBUG(3,(\"rename_internals_fsp: succeeded doing rename on %s -> %s\\n\",\n \t\t\tfsp->fsp_name,newname));\n+\n \t\trename_open_files(conn, lck, fsp->dev, fsp->inode, newname);\n+\n+\t\t/*\n+\t\t * A rename acts as a new file create w.r.t. allowing an initial delete\n+\t\t * on close, probably because in Windows there is a new handle to the\n+\t\t * new file. If initial delete on close was requested but not\n+\t\t * originally set, we need to set it here. This is probably not 100% correct,\n+\t\t * but will work for the CIFSFS client which in non-posix mode\n+\t\t * depends on these semantics. JRA.\n+\t\t */\n+\n+\t\tset_allow_initial_delete_on_close(lck, fsp, True);\n+\n+\t\tif (create_options & FILE_DELETE_ON_CLOSE) {\n+\t\t\tstatus = can_set_delete_on_close(fsp, True, 0);\n+\n+\t\t\tif (NT_STATUS_IS_OK(status)) {\n+\t\t\t\t/* Note that here we set the *inital* delete on close flag,\n+\t\t\t\t * not the regular one. The magic gets handled in close. */\n+\t\t\t\tfsp->initial_delete_on_close = True;\n+\t\t\t}\n+\t\t}\n \t\tTALLOC_FREE(lck);\n \t\treturn NT_STATUS_OK;\t\n \t}\n@@ -4530,7 +4570,7 @@\n \t\t\treturn status;\n \t\t}\n \n-\t\tstatus = can_rename(conn,directory,attrs,&sbuf1);\n+\t\tstatus = can_rename(conn,directory,attrs,&sbuf1,False);\n \n \t\tif (!NT_STATUS_IS_OK(status)) {\n \t\t\tDEBUG(3,(\"rename_internals: Error %s rename %s -> \"\n@@ -4658,7 +4698,7 @@\n \t\t\t\t  fname, nt_errstr(status)));\n \t\t\tcontinue;\n \t\t}\n-\t\tstatus = can_rename(conn,fname,attrs,&sbuf1);\n+\t\tstatus = can_rename(conn,fname,attrs,&sbuf1,False);\n \t\tif (!NT_STATUS_IS_OK(status)) {\n \t\t\tDEBUG(6, (\"rename %s refused\\n\", fname));\n \t\t\tcontinue;\n\nModified: branches/SAMBA_3_0_RELEASE/source/smbd/trans2.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/smbd/trans2.c\t2007-05-23 21:32:10 UTC (rev 23100)\n+++ branches/SAMBA_3_0_RELEASE/source/smbd/trans2.c\t2007-05-23 22:46:30 UTC (rev 23101)\n@@ -4507,10 +4507,11 @@\n \tpstrcpy(base_name, fname);\n \tp = strrchr_m(base_name, '/');\n \tif (p) {\n-\t\t*p = '\\0';\n+\t\tp[1] = '\\0';\n+\t} else {\n+\t\tpstrcpy(base_name, \"./\");\n \t}\n \t/* Append the new name. */\n-\tpstrcat(base_name, \"/\");\n \tpstrcat(base_name, newname);\n \n \tif (fsp) {\n@@ -5632,9 +5633,17 @@\n \t\t\t * to do this call. JRA.\n \t\t\t */\n \t\t\tpstrcpy(fname, fsp->fsp_name);\n-\t\t\tif (SMB_VFS_STAT(conn,fname,&sbuf) != 0) {\n-\t\t\t\tDEBUG(3,(\"call_trans2setfilepathinfo: fileinfo of %s failed (%s)\\n\",fname,strerror(errno)));\n-\t\t\t\treturn UNIXERROR(ERRDOS,ERRbadpath);\n+\t\t\tif (INFO_LEVEL_IS_UNIX(info_level)) {\n+\t\t\t\t/* Always do lstat for UNIX calls. */\n+\t\t\t\tif (SMB_VFS_LSTAT(conn,fname,&sbuf)) {\n+\t\t\t\t\tDEBUG(3,(\"call_trans2setfilepathinfo: SMB_VFS_LSTAT of %s failed (%s)\\n\",fname,strerror(errno)));\n+\t\t\t\t\treturn UNIXERROR(ERRDOS,ERRbadpath);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (SMB_VFS_STAT(conn,fname,&sbuf) != 0) {\n+\t\t\t\t\tDEBUG(3,(\"call_trans2setfilepathinfo: fileinfo of %s failed (%s)\\n\",fname,strerror(errno)));\n+\t\t\t\t\treturn UNIXERROR(ERRDOS,ERRbadpath);\n+\t\t\t\t}\n \t\t\t}\n \t\t} else if (fsp && fsp->print_file) {\n \t\t\t/*\n@@ -5693,14 +5702,18 @@\n \t\t\treturn ERROR_NT(status);\n \t\t}\n \n-\t\t/*\n-\t\t * For CIFS UNIX extensions the target name may not exist.\n-\t\t */\n+\t\tif (INFO_LEVEL_IS_UNIX(info_level)) {\n+\t\t\t/*\n+\t\t\t * For CIFS UNIX extensions the target name may not exist.\n+\t\t\t */\n \n-\t\tif(!VALID_STAT(sbuf) && !INFO_LEVEL_IS_UNIX(info_level)) {\n-\t\t\tDEBUG(3,(\"call_trans2setfilepathinfo: stat of %s failed (%s)\\n\", fname, strerror(errno)));\n+\t\t\t/* Always do lstat for UNIX calls. */\n+\t\t\tSMB_VFS_LSTAT(conn,fname,&sbuf);\n+\n+\t\t} else if (!VALID_STAT(sbuf) && SMB_VFS_STAT(conn,fname,&sbuf)) {\n+\t\t\tDEBUG(3,(\"call_trans2setfilepathinfo: SMB_VFS_STAT of %s failed (%s)\\n\",fname,strerror(errno)));\n \t\t\treturn UNIXERROR(ERRDOS,ERRbadpath);\n-\t\t}    \n+\t\t}\n \t}\n \n \tif (!CAN_WRITE(conn)) {\n\n"}
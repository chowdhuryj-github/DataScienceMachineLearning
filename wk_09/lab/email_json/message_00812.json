{"category": "ham", "to_address": "\"Muenchen, Robert A (Bob)\" <muenchen@utk.edu>", "from_address": "Marc Schwartz <marc_schwartz@comcast.net>", "subject": "Re: [R] do.call vs. lapply for lists", "body": "On Mon, 2007-04-09 at 12:45 -0400, Muenchen, Robert A (Bob) wrote:\n> Hi All,\n> \n> I'm trying to understand the difference between do.call and lapply for\n> applying a function to a list. Below is one of the variations of\n> programs (by Marc Schwartz) discussed here recently to select the first\n> and last n observations per group.\n> \n> I've looked in several books, the R FAQ and searched the archives, but I\n> can't find enough to figure out why lapply doesn't do what do.call does\n> in this case. The help files & newsletter descriptions of do.call sound\n> like it would do the same thing, but I'm sure that's due to my lack of\n> understanding about their specific terminology. I would appreciate it if\n> you could take a moment to enlighten me. \n> \n> Thanks,\n> Bob\n> \n> mydata <- data.frame(\n>   id      = c('001','001','001','002','003','003'),\n>   math    = c(80,75,70,65,65,70),\n>   reading = c(65,70,88,NA,90,NA)\n> )\n> mydata\n> \n> mylast <- lapply( split(mydata,mydata$id), tail, n=1)\n> mylast\n> class(mylast) #It's a list, so lapply will so *something* with it.\n> \n> #This gets the desired result:\n> do.call(\"rbind\", mylast)\n> \n> #This doesn't do the same thing, which confuses me:\n> lapply(mylast,rbind)\n> \n> #...and data.frame won't fix it as I've seen it do in other\n> circumstances:\n> data.frame( lapply(mylast,rbind) )\n\nBob,\n\nA key difference is that do.call() operates (in the above example) as if\nthe actual call was:\n\n> rbind(mylast[[1]], mylast[[2]], mylast[[3]])\n   id math reading\n3 001   70      88\n4 002   65      NA\n6 003   70      NA\n\nIn other words, do.call() takes the quoted function and passes the list\nobject as if it was a list of individual arguments. So rbind() is only\ncalled once.\n\nIn this case, rbind() internally handles all of the factor level issues,\netc. to enable a single common data frame to be created from the three\nindependent data frames contained in 'mylast':\n\n> str(mylast)\nList of 3\n $ 001:'data.frame':    1 obs. of  3 variables:\n  ..$ id     : Factor w/ 3 levels \"001\",\"002\",\"003\": 1\n  ..$ math   : num 70\n  ..$ reading: num 88\n $ 002:'data.frame':    1 obs. of  3 variables:\n  ..$ id     : Factor w/ 3 levels \"001\",\"002\",\"003\": 2\n  ..$ math   : num 65\n  ..$ reading: num NA\n $ 003:'data.frame':    1 obs. of  3 variables:\n  ..$ id     : Factor w/ 3 levels \"001\",\"002\",\"003\": 3\n  ..$ math   : num 70\n  ..$ reading: num NA\n\n\nOn the other hand, lapply() (as above) calls rbind() _separately_ for\neach component of mylast.  It therefore acts as if the following series\nof three separate calls were made:\n\n\n> rbind(mylast[[1]])\n   id math reading\n3 001   70      88\n\n> rbind(mylast[[2]])\n   id math reading\n4 002   65      NA\n\n> rbind(mylast[[3]])\n   id math reading\n6 003   70      NA\n\n\nOf course, the result of lapply() is that the above are combined into a\nsingle R list object and returned:\n\n> lapply(mylast, rbind)\n$`001`\n   id math reading\n3 001   70      88\n\n$`002`\n   id math reading\n4 002   65      NA\n\n$`003`\n   id math reading\n6 003   70      NA\n\n\nIt is a subtle, but of course critical, difference in how the internal\nfunction is called and how the arguments are passed.\n\nDoes that help?\n\nRegards,\n\nMarc Schwartz\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
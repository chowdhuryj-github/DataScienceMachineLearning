{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: Default filehandles, or topicalizing filehandles, or something", "body": "On Tue, May 01, 2007 at 09:26:38AM -0700, Jonathan Lang wrote:\n: On 5/1/07, brian d foy  wrote:\n: >I was thinking about default filehandles yesterday. select() doesn't\n: >seem to be around except as an \"Unfiled\" function in S16.\n: >\n: >Then, as I was looking at\n: >\n: >   .say( \"Hello World\" );\n: \n: At various times, I have seen something to the effect of each of the\n: following being bandied about:\n: \n:  $*OUT.say( \"Hello World\" );\n:  \"Hello World\".say;\n: \n: That is, both filehandles and strings have 'say' methods that do\n: essentially the same thing, but using subtly different syntax.  How\n: would I use &(\"Hello World\".say) to write to filehandle $FH?  My gut\n: reaction would be to use an adverb for the purpose:\n: \n:  \"Hello World\".say :to($FH);\n: \n: This would also work for the sub version:\n: \n:  say :to($FH) \"Hello World\";\n\nDon't need a named arg, since we can simply be polymorphic on strings vs\nfilehandles, which thankfully do not overlap semantically:\n\n    \"Hello World\".say($FH)\n    $FH.say(\"Hello World\")\n\n: With this in mind, you probably could create a localized alias for\n: 'say', if you wanted to:\n: \n:  {\n:    my &say := &OUTER::say.assuming(:to($FH));\n:    say \"Hello World\"; # same as 'say \"Hello World\" :to($FH);'\n:  }\n: \n: The catch with this is that you'd have to do this for each output\n: routine separately.\n\nYou don't always want lexical scoping for this sort of thing; you\noften want dynamic scoping instead.\n\n: How about this: Do the output routines default to the global\n: filehandles directly, or do they default to lexical bindings of them?\n: That is, does 'say' output to $*OUT in the absence of an explicit\n: filehandle, or does it output to $OUT (with the latter normally being\n: bound to $*OUT)?  If the latter, you should be able to redirect all of\n: your output in the rest of the current scope by saying:\n: \n:  $OUT := $*ERR;\n: \n: I can understand not being able to rebind the global filehandles.\n: After all: once they're rebound, how would you ever find what they\n: were originally bound to?\n\nThe plan introduced in A06 was to leave $*('IN'|'OUT'|'ERR') bound\nto stdin, stdout, and stderr (which can still be dickered with on\nthe POSIXy level, of course), and instead emulate p5's select(FH)\nusing a global variable $*DEFOUT for the default handle of print\n(and now say as well).\n\nI note that $*DEFOUT didn't make it into any of the synopses (though it\ndid make it to pugs/t/builtins/io/say_and_print.t, oddly), so I've just\nadded it to pugs/docs/Spec/IO.pod, the proto-synopsis on IO.\n\nAnyway, you should (eventually) just be able to say\n\n    {\n\ttemp $*DEFOUT := $MYFH;\n\tfoo();\n    }\n\nto redirect the default output of foo() and then restore at the end of the\ndynamic scope.  That's an improvement over dancing the select twostep.\n\nLarry\n\n"}
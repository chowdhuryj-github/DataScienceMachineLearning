{"category": "ham", "to_address": "\"Jonathan Lang\" <dataweaver@gmail.com>, p6l <perl6-language@perl.org>", "from_address": "\"Mark J. Reed\" <markjreed@mail.com>", "subject": "Re: Generalizing ?? !!", "body": "Ok, let me take a step back and see what's being suggested.\n\nit certainly seems like a case can be made for a binary operator, say\n??, that returns its rhs if the lhs is true, undef otherwise,\nanalogous to the shell's ${var+val} construct.\n\nAt first glance it appears that the desired ternary behavior could be\nachieved by  chaining such an operator with //:\n\nA ?? B // C\n\nBut that fails if B happens to be undef. And it seems to me that\nanything you do to the chaining rules to fix that case is going to be\npretty confusing in general.\n\nSo I prefer keeping a single construct, but perhaps the else-part\ncould be optional?\n\n\nOn 6/11/07, Jonathan Lang  wrote:\n> Audrey Tang wrote:\n> > Jonathan Lang wrote:\n> > > A variation of chaining associativity gets\n> > > used, with the \"chaining rule\" being '$v1 op1 $v2 // $v1 op2 $v3'\n> > > instead of '$v1 op1 $v2 && $v2 op2 $v3', as is the case for comparison\n> > > chaining.\n> >\n> > But wouldn't that make:\n> >\n> >    True ?? undef !! Moose;\n> >\n> > evaluate to Moose, instead of undef as we wanted?\n>\n> Nope; because of the short-circuiting behavior:\n>\n>     True ?? undef !! Moose\n> ->\n>     True ?? undef // True !! Moose\n>\n> The condition evaluates to True, causing the ?? to evaluate its RHS\n> and then short-circuit the rest of the expression.  The fact that the\n> RHS evaluates to undef is irrelevant.\n>\n> In a sense, ?? and !! would invert the usual short-circuiting\n> behavior: with normal short-circuiting operators (&& and ||), the RHS\n> is evaluated if and only if the operator does not short-circuit; with\n> ?? and !!, the RHS would be evaluated if and only if the operator\n> _does_ short-circuit.\n>\n> NeonGraal wrote:\n> > Surely if you defined !! to return \"undef but true\" and both operators\n> > to be left associative then it all works.\n> >\n> >  1==0 ?? \"True\" !! \"False\" -> (undef) !! \"False\" which seems right to\n> > me.\n> >\n> >  1==1 !! \"False\" ?? \"True\" -> (undef but true) ?? \"True\" also good.\n>\n> ...except that '1==1 !! \"False\"' would return 'undef but true' on a\n> failure.  I'm sure that a rationale could be provided for doing this;\n> but it's a potentially surprising result which could get you in\n> trouble.  Best to keep to a simple 'undef' result on a failure.\n>\n> Hakim: I'm not familiar with Haskell, so I can't follow your code as\n> well as I need to to provide an informed response.\n>\n> Juerd Waalboer wrote:\n> > Zev Benjamin wrote:\n> > > ?? and !! could always return some kind of result object that boolizes\n> > > to true or false.\n> >\n> > Can we *please* keep simple things simple?\n>\n> Agreed.  I'm in favor of this proposal to the extent that it breaks a\n> simple trinary operator down into equally simple binary operators\n> (with the trinary form continuing to exist as an emergent property of\n> the interaction of the binaries); if those binary operators become\n> more complex than the trinary form, or if you lose the ability to\n> recover the trinary form from them, there's no point in pursuing this\n> proposal.\n>\n> --\n> Jonathan \"Dataweaver\" Lang\n>\n\n\n-- \nMark J. Reed \n"}
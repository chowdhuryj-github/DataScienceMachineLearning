{"category": "ham", "to_address": "Andrew Morton <akpm@linux-foundation.org>", "from_address": "Nick Piggin <npiggin@suse.de>", "subject": "[patch 39/44] cifs convert to new aops", "body": "Convert to new aops, and fix security hole where page is set uptodate\nbefore contents are uptodate.\n\nCc: sfrench@samba.org\nCc: samba-technical@lists.samba.org\nCc: Linux Filesystems \nSigned-off-by: Nick Piggin \n\n fs/cifs/file.c |   89 ++++++++++++++++++++++++++++++++-------------------------\n 1 file changed, 51 insertions(+), 38 deletions(-)\n\nIndex: linux-2.6/fs/cifs/file.c\n===================================================================\n--- linux-2.6.orig/fs/cifs/file.c\n+++ linux-2.6/fs/cifs/file.c\n@@ -103,7 +103,7 @@ static inline int cifs_open_inode_helper\n \n \t/* want handles we can use to read with first\n \t   in the list so we do not have to walk the\n-\t   list to search for one in prepare_write */\n+\t   list to search for one in write_begin */\n \tif ((file->f_flags & O_ACCMODE) == O_WRONLY) {\n \t\tlist_add_tail(&pCifsFile->flist, \n \t\t\t      &pCifsInode->openFileList);\n@@ -1358,40 +1358,37 @@ static int cifs_writepage(struct page* p\n \treturn rc;\n }\n \n-static int cifs_commit_write(struct file *file, struct page *page,\n-\tunsigned offset, unsigned to)\n+static int cifs_write_end(struct file *file, struct address_space *mapping,\n+\t\t\tloff_t pos, unsigned len, unsigned copied,\n+\t\t\tstruct page *page, void *fsdata)\n {\n \tint xid;\n \tint rc = 0;\n-\tstruct inode *inode = page->mapping->host;\n-\tloff_t position = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;\n+\tstruct inode *inode = mapping->host;\n+\tloff_t position = pos + copied;\n \tchar *page_data;\n \n \txid = GetXid();\n-\tcFYI(1, (\"commit write for page %p up to position %lld for %d\", \n-\t\t page, position, to));\n+\tcFYI(1, (\"write end for page %p at pos %lld, copied %d\",\n+\t\t page, pos, copied));\n \tspin_lock(&inode->i_lock);\n \tif (position > inode->i_size) {\n \t\ti_size_write(inode, position);\n \t}\n \tspin_unlock(&inode->i_lock);\n+\tif (!PageUptodate(page) && copied == PAGE_CACHE_SIZE)\n+\t\tSetPageUptodate(page);\n+\n \tif (!PageUptodate(page)) {\n-\t\tposition =  ((loff_t)page->index << PAGE_CACHE_SHIFT) + offset;\n-\t\t/* can not rely on (or let) writepage write this data */\n-\t\tif (to < offset) {\n-\t\t\tcFYI(1, (\"Illegal offsets, can not copy from %d to %d\",\n-\t\t\t\toffset, to));\n-\t\t\tFreeXid(xid);\n-\t\t\treturn rc;\n-\t\t}\n+\t\tunsigned long offset = pos & (PAGE_CACHE_SIZE - 1);\n+\n \t\t/* this is probably better than directly calling\n \t\t   partialpage_write since in this function the file handle is\n \t\t   known which we might as well\tleverage */\n \t\t/* BB check if anything else missing out of ppw\n \t\t   such as updating last write time */\n \t\tpage_data = kmap(page);\n-\t\trc = cifs_write(file, page_data + offset, to-offset,\n-\t\t\t\t&position);\n+\t\trc = cifs_write(file, page_data + offset, copied, &pos);\n \t\tif (rc > 0)\n \t\t\trc = 0;\n \t\t/* else if (rc < 0) should we set writebehind rc? */\n@@ -1399,9 +1396,12 @@ static int cifs_commit_write(struct file\n \t} else {\t\n \t\tset_page_dirty(page);\n \t}\n-\n \tFreeXid(xid);\n-\treturn rc;\n+\n+\tunlock_page(page);\n+\tpage_cache_release(page);\n+\n+\treturn rc < 0 ? rc : copied;\n }\n \n int cifs_fsync(struct file *file, struct dentry *dentry, int datasync)\n@@ -1928,34 +1928,47 @@ int is_size_safe_to_change(struct cifsIn\n \t\treturn 1;\n }\n \n-static int cifs_prepare_write(struct file *file, struct page *page,\n-\tunsigned from, unsigned to)\n+static int cifs_write_begin(struct file *file, struct address_space *mapping,\n+\t\t\tloff_t pos, unsigned len, unsigned flags,\n+\t\t\tstruct page **pagep, void **fsdata)\n {\n \tint rc = 0;\n \tloff_t i_size;\n \tloff_t offset;\n+\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n+\tstruct page *page;\n+\n+\tpage = __grab_cache_page(mapping, index);\n+\tif (!page)\n+\t\treturn -ENOMEM;\n+\t*pagep = page;\n \n-\tcFYI(1, (\"prepare write for page %p from %d to %d\",page,from,to));\n+\tcFYI(1, (\"write begin for page %p at pos %lld, length %d\",\n+\t\t page, pos, len));\n \tif (PageUptodate(page))\n \t\treturn 0;\n \n-\t/* If we are writing a full page it will be up to date,\n-\t   no need to read from the server */\n-\tif ((to == PAGE_CACHE_SIZE) && (from == 0)) {\n-\t\tSetPageUptodate(page);\n+\t/* If we are writing a full page it will become up to date,\n+\t   no need to read from the server (although we may encounter a\n+\t   short copy, so write_end has to handle this) */\n+\tif (len == PAGE_CACHE_SIZE)\n \t\treturn 0;\n-\t}\n \n-\toffset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n-\ti_size = i_size_read(page->mapping->host);\n+\toffset = index << PAGE_CACHE_SHIFT;\n+\ti_size = i_size_read(mapping->host);\n+\n+\tif (offset >= i_size) {\n+\t\tvoid *kaddr;\n+\t\tunsigned from, to;\n \n-\tif ((offset >= i_size) ||\n-\t    ((from == 0) && (offset + to) >= i_size)) {\n \t\t/*\n \t\t * We don't need to read data beyond the end of the file.\n \t\t * zero it, and set the page uptodate\n \t\t */\n-\t\tvoid *kaddr = kmap_atomic(page, KM_USER0);\n+\t\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n+\t\tto = from + len;\n+\n+\t\tkaddr = kmap_atomic(page, KM_USER0);\n \n \t\tif (from)\n \t\t\tmemset(kaddr, 0, from);\n@@ -1971,12 +1984,12 @@ static int cifs_prepare_write(struct fil\n \t\t/* we could try using another file handle if there is one -\n \t\t   but how would we lock it to prevent close of that handle\n \t\t   racing with this read? In any case\n-\t\t   this will be written out by commit_write so is fine */\n+\t\t   this will be written out by write_end so is fine */\n \t}\n \n \t/* we do not need to pass errors back \n \t   e.g. if we do not have read access to the file \n-\t   because cifs_commit_write will do the right thing.  -- shaggy */\n+\t   because cifs_write_end will do the right thing.  -- shaggy */\n \n \treturn 0;\n }\n@@ -1986,8 +1999,8 @@ const struct address_space_operations ci\n \t.readpages = cifs_readpages,\n \t.writepage = cifs_writepage,\n \t.writepages = cifs_writepages,\n-\t.prepare_write = cifs_prepare_write,\n-\t.commit_write = cifs_commit_write,\n+\t.write_begin = cifs_write_begin,\n+\t.write_end = cifs_write_end,\n \t.set_page_dirty = __set_page_dirty_nobuffers,\n \t/* .sync_page = cifs_sync_page, */\n \t/* .direct_IO = */\n@@ -2002,8 +2015,8 @@ const struct address_space_operations ci\n \t.readpage = cifs_readpage,\n \t.writepage = cifs_writepage,\n \t.writepages = cifs_writepages,\n-\t.prepare_write = cifs_prepare_write,\n-\t.commit_write = cifs_commit_write,\n+\t.write_begin = cifs_write_begin,\n+\t.write_end = cifs_write_end,\n \t.set_page_dirty = __set_page_dirty_nobuffers,\n \t/* .sync_page = cifs_sync_page, */\n \t/* .direct_IO = */\n\n-- \n\n"}
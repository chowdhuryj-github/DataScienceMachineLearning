{"category": "ham", "to_address": "James Keenan via RT <parrotbug-followup@parrotcode.org>", "from_address": "Andy Spieherty <spiehera@lafayette.edu>", "subject": "Re: [perl #42412] Configure.pl things =no is true ", "body": "On Fri, 4 May 2007, James Keenan via RT wrote:\n\n> On Thu May 03 21:02:21 2007, allison  at perl.org wrote:\n> > Andy Spieherty wrote:\n> > > On Tue, 1 May 2007, James Keenan via RT wrote:\n> > > \n> > >> On Tue Apr 10 01:45:31 2007, jrisom  at gmail.com wrote:\n> > >>> Configure should act as though writing --foo=no is false instead of \n> > >>> true.  Tonight I tried using --execcapable=no to get around a compile \n> > >>> failure, but then realized that it would probably treat \"no\" as a true \n> > >>> value.\n> > \n> > I'm okay with having a plain English representation for \"false value\", \n> > as long as we have exactly one. Pick 'no', 'none', 'false', or whatever \n> > but we won't try to support every possible value a user might type in to \n> > mean false. Whatever we pick will mean false everywhere, on every \n> > option. And we have to be careful to make sure it's not a value that \n> > someone might want to use as a string value.\n\nIt may be sensible to distinguish boolean and string variables to avoid\nthat problem.\n\n> The more you multiply variant ways of providing values to options,\n> -- the more code you have to write,\n> -- the more code someone has to maintain,\n> -- the more tests someone has to write to verify the validity of the code and ensure high \n> coverage by the tests, and\n> -- the more documentation someone has to write to explain the code.\n\nYes.  I think we're all on the same page here.  There are currently\nmultiple ways to say \"no\":\n\n>       --nomanicheck\n>       --cgoto=0\n>       --without-gdbm\n>       --icu-config=none\n> \n> This means that for undocumented things, like -execcapable, the user has\n> to guess.\n\nI'm recommending replacing them with a single way to say \"no\".  Whether\nthat single way is spelled -Ufoo, --unset-foo, --disable-foo, --no-foo,\nor --foo=0 is a Configure human-interface design decision (and then an\nimplementation detail), but supporting a single way is less work in the\nend than the current 4 ways.\n\n> For at least the third of those tasks, that someone, currently, is me.  \n\nBelieve me -- I am truly very sympathetic to that problem.\n\n> I'm hoping to recruit additional people to help maintain Parrot's Perl 5 configuration and \n> build tools, and I made some progress in this regard at Hackathon Toronto.  Still, almost all \n> of Configure.pl's options are completely untouched by the test suite.  Code coverage for the \n> config/*/*.pm hierarchy is generally only around 25%.  Why multiply features for which, if \n> we're following best practices, we ought to write tests when we don't have the people to write \n> those tests?\n\nI'm advocating *reducing* the number of options -- replacing the\nhand-maintained hodge-podge of current options by a more generic scheme.\nThen, within that generic scheme, I expect it will likely be no big\ndeal to internally treat --set-foo=\"no\" as equivalent to --set-foo=0 or\n--unset-foo (at least for boolean variables).\n\nIn perl5's Configure, there are over a thousand variables that can\nbe set by command-line options.  Presumably parrot will end up with a\nsimilar number.  Attempting to write tests for them all would be madness.\n\n-- \n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n"}
{"category": "ham", "to_address": "\"Ken Foskey\" <foskey@optushome.com.au>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: Iterate through a hashref using XML::Simple (real post)", "body": "On 6/15/07, Ken Foskey  wrote:\n> On Fri, 2007-06-15 at 14:08 -0700, gimme_this_gimme_that@yahoo.com\n> wrote:\n> > Sweet Chas!\n> >\n> > My two cents is to check out XML::Twig at http://www.xmltwig.org/ .\n> >\n> > It's easy to get a grip on and well suited to reading attributes as\n> > well as elements in elements.\n>\n> Looks interesting,  would this reasonably handle 70,000 statements\n> containing LOTS of details in them?   I need to process this statement\n> by statement but it would totally blow memory.\n>\n> --\n> Ken Foskey\n> FOSS developer\n\nYes, so long as you only need to deal with a part of it at a time you\ncan flush the parts that you are done with from memory.  I have used\nXML::Twig to deal with files in the gigabyte range.\n\nfrom perldoc XML::Twig\n       Processing an XML document chunk by chunk\n\n       One of the strengths of XML::Twig is that it let you work with files\n       that do not fit in memory (BTW storing an XML document in memory as a\n       tree is quite memory-expensive, the expansion factor being often around\n       10).\n\n       To do this you can define handlers, that will be called once a specific\n       element has been completely parsed. In these handlers you can access\n       the element and process it as you see fit, using the navigation and the\n       cut-n-paste methods, plus lots of convenient ones like \"prefix \".  Once\n       the element is completely processed you can then \"flush \" it, which\n       will output it and free the memory. You can also \"purge \" it if you\n       don't need to output it (if you are just extracting some data from the\n       document for example). The handler will be called again once the next\n       relevant element has been parsed.\n\n         my $t= XML::Twig->new( twig_handlers =>\n                                 { section => \\&section,\n                                   para   => sub { $_->set_tag( 'p');\n                                 },\n                              );\n         $t->parsefile( 'doc.xml');\n         $t->flush; # don't forget to flush one last time in the end or anything\n                    # after the last  tag will not be output\n\n         # the handler is called once a section is completely parsed, ie when\n         # the end tag for section is found, it receives the twig itself and\n         # the element (including all its sub-elements) as arguments\n         sub section\n           { my( $t, $section)= @_;      # arguments for all twig_handlers\n             $section->set_tag( 'div');  # change the tag name.4, my favourite m\nethod...\n             # let's use the attribute nb as a prefix to the title\n             my $title= $section->first_child( 'title'); # find the title\n             my $nb= $title->{'att'}->{'nb'}; # get the attribute\n             $title->prefix( \"$nb - \");  # easy isn't it?\n             $section->flush;            # outputs the section and frees memory\n           }\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
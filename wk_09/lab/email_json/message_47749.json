{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "\"Gavin Kelly\" <gavinpaulkelly@gmail.com>", "subject": "Re: [R] pretty report", "body": "At 5:01 PM -0400 6/12/07, Weiwei Shi wrote:\n>Dear Listers:\n>\n>I have a couple of data frames to report and each corresponds to\n>different condtions, e.g. conditions=c(10, 15, 20, 25). In this\n>examples, four data frames need to be exported in a \"pretty\" report.\n>\n>I knew Perl has some module for exporting data to Excel and after\n>googling, I found R does not.\n\nWeiwei,\n\nIf you (or the users who are opening your reports) are going to using\na version of excel that supports the new Office XML formats, you can\nwrite multi-sheeted workbooks as below: simply give spreadsheetML a\nnamed list of dataframes.  You can add attributes to the components to\nadd things such as comments, subheadings that span multiple columns,\nhyperlinks and named data-ranges.\n\nIf you can't guarantee that the opener won't have a modern Excel (I\ndon't believe Mac versions are yet at this stage), then you will need\nto have a windows box to open the file, and save as 'proper' excel.\nBelow is a visual basic macro I have set up in a watched directory to\ndo this on the fly.  I use the program \"filenotify\" to watch the\ndirectory.\n\nIf any of the package developers want to incorporate this function,\nthen please do get in touch.  It's probably not worth a package of\nit's own, but I think the ability to have multi-sheeted excel books,\nwith the extra bits of formatting mentioned above might be useful.\nI'ts fairly straightforward to add extra styling (colours, typefaces,\netc).\n\nRegards - Gavin\n\n###  The R function, and a demo\nspreadsheetML <- function(dat, fname, style=NULL) {\n  if (is.data.frame(dat))\n    dat <- list(Sheet1=dat)\n  if (is.null(names(dat)))\n    names(dat) <- paste(\"Sheet\",1:length(dat), sep=\"\")\n  names(dat)[names(dat)==\"\"] <- paste(\"Sheet\",1:length(dat),\nsep=\"\")[names(dat)==\"\"]\n  x <- xmlOutputDOM(\"Workbook\", nameSpace=\"ss\",\n                    nsURI=list(\n                      o=\"urn:schemas-microsoft-com:office:office\",\n                      x=\"urn:schemas-microsoft-com:office:excel\",\n                      ss=\"urn:schemas-microsoft-com:office:spreadsheet\",\n                      html=\"http://www.w3.org/TR/REC-html40\"))\n  if (!is.null(style))\n    x$addNode(style)\n### Annotate any named Ranges\n  if (any(!is.null(lapply(dat, attr, \"range\")))) {\n    x$addTag(\"Names\", close=FALSE)\n    for (sheet in names(dat)) {\n      rngs <- attr(dat[[sheet]],\"range\")\n      offset <- ifelse(is.null(attr(dat[[sheet]],\"subhead\")), 1, 2)\n      for (i in names(rngs)) {\n        refersTo <- sprintf(\"=%s!R%iC%i:R%iC%i\",\n                            sheet,\n                            rngs[[i]]$rowStart+offset,\n                            rngs[[i]]$colStart,\n                            rngs[[i]]$rowEnd+offset,\n                            rngs[[i]]$colEnd)\n        x$addTag(\"NamedRange\", attrs=c(\"ss:Name\"=i,\n                                 \"ss:RefersTo\"=refersTo))\n      }\n    }\n    x$closeTag() #Names\n  }\n  for (sheet in 1:length(dat)) {\n    ## For each dataframe, construct a worksheet\n    x$addTag(\"Worksheet\", attrs=c(\"ss:Name\"=names(dat)[[sheet]]), close=FALSE)\n    x$addTag(\"Table\",close=FALSE)\n    x$addTag(\"Row\", close=FALSE)\n    ## If there's a subheader, expand it, and remove entries from\nrelevant header\n    headRow <- colnames(dat[[sheet]])\n    if (!is.null(subhead <- attr(dat[[sheet]],\"subhead\"))) {\n      subHeadRow <- rep(\"\", length(headRow))\n      for (i in names(subhead)) {\n        start <- match(i, headRow)\n        subHeadRow[start:(start+length(subhead[[i]])-1)] <-\n          subhead[[i]]\n        headRow[(start+1):(start+length(subhead[[i]])-1)] <- \"\"\n      }\n    }\n    ## Create Header Row, with comments\n    for (i in headRow) {\n      x$addTag(\"Cell\", close=FALSE)\n      x$addTag(\"Data\",i , attrs=c(\"ss:Type\"=\"String\"))\n      if (!is.null(comment <- attr(dat[[sheet]],\"xlComment\")[[i]])) {\n        if (is.character(comment)) {\n          x$addTag(\"Comment\", attrs=c(\"ss:Author\"=\"BaBS\"), close=FALSE)\n          x$addTag(\"Data\", comment)\n          x$closeTag() #Comment\n        }\n      }\n      x$closeTag() # Header entry\n    }\n    x$closeTag() # Header Row\n    ## Create Sub-Header row, with comments\n    if (!is.null(subhead)) {\n      x$addTag(\"Row\", close=FALSE)\n      for (i in 1:length(subHeadRow)) {\n        x$addTag(\"Cell\", close=FALSE)\n        x$addTag(\"Data\",subHeadRow[i] , attrs=c(\"ss:Type\"=\"String\"))\n        if (is.list(comment <- attr(dat[[sheet]],\"xlComment\")[[headRow[i]]])) {\n          if (!is.null(comment <- comment[[subHeadRow[i]]])) {\n            x$addTag(\"Comment\", attrs=c(\"ss:Author\"=\"BaBS\"), close=FALSE)\n            x$addTag(\"Data\", comment)\n            x$closeTag() #Comment\n          }\n        }\n        x$closeTag()\n      }\n      x$closeTag() # subHeader Row\n    }\n    coltypes <- rep(\"String\", ncol(dat[[sheet]]))\n    coltypes[sapply(dat[[sheet]], is.numeric)] <- \"Number\"\n    href <- attributes(dat[[sheet]])$href\n    ## Enter the data row-wise\n    for (i in 1:nrow(dat[[sheet]])) {\n      x$addTag(\"Row\", close=FALSE)\n      for (j in 1:ncol(dat[[sheet]])) {\n        ## Go through the row, expanding any hyperlinks\n        cellAttr <- NULL\n        if (!is.na(ind <- match(colnames(dat[[sheet]])[j], names(href))))\n          cellAttr <- c(\"ss:Href\"=gsub(\" \", dat[[sheet]][i,j], href[ind]))\n        x$addTag(\"Cell\", attrs=cellAttr, close=FALSE)\n        x$addTag(\"Data\", as.character(dat[[sheet]][i,j]),\nattrs=c(\"ss:Type\"=coltypes[j]))\n        x$closeTag()\n      }\n      x$closeTag() # data row\n    }\n    x$closeTag() # table\n    x$closeTag() # Worksheet\n  }\n  x$closeTag() # Workbook\n  con = file(fname, \"w\")\n  saveXML(x$value(), file=con, prefix=\"\\n\\n\")\n  close(con)\n  x$reset()\n}\n\n### Example Usage\nlibrary(XML)\ndat <- list(a=data.frame(A=1:10, B=LETTERS[1:10], b=letters[1:10]),\n            b=data.frame(a=1:10, b=factor(LETTERS[1:2])))\nattr(dat$a, \"range\") <- list(data=list(rowStart=1,\n                               rowEnd=nrow(dat$a),\n                               colStart=1,\n                               colEnd=ncol(dat$a)))\nattr(dat$a, \"subhead\") <- list(B=c(\"Upper\",\"Lower\"))\nattr(dat$a, \"xlComment\") <- list(A=\"Hello\",\n                               B=list(Upper=\"World\"))\nattr(dat$b, \"href\") <- list(a=\"http://www.google.co.uk/search?q= \")\n#save as .xml if using the vba script\nspreadsheetML(dat, \"tmp.xls\")\n\n###  Prototype script to saveas xml to xls\nDim appExcel\nDim strSource\nDim wbSource\nDim ArgObj\nSet ArgObj = WScript.Arguments\nDim objRegExpr\nSet objRegExpr = New regexp\n\nobjRegExpr.Pattern = \".*\\.xml$\"\nobjRegExpr.Global = True\nobjRegExpr.IgnoreCase = True\nstrSource = ArgObj(0)\n\nif (objRegExpr.Test(strSource)) Then\n  Set appExcel = CreateObject(\"Excel.Application\")\n  appExcel.DisplayAlerts = False\n  Set wbSource = appExcel.Workbooks.Open(strSource)\n  wbSource.SaveAs \"c:\\converted\\tmp.xls\", 1\n  wbSource.Close False\n  Set wbSource = Nothing\n  appExcel.Quit\n  Set appExcel = Nothing\nEnd If\n\n\n-- \nGavin Kelly\nSenior Statistician, Bioinformatics & Biostatistics Group\nCancer Research UK\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
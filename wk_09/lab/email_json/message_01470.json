{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Michael Adam <ma@sernet.de>", "subject": "Rev 5345: auth/auth_util2.c renamed to auth/token_util.c in\n\tVolker's checkin in\n\thttp://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/", "body": "At http://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/\n\n------------------------------------------------------------\nrevno: 5345\nrevision-id: ma@sernet.de-20070410105002-8ca543eecefafbc4\nparent: ma@sernet.de-20070410103722-a2ae212eac5cc568\ncommitter: Michael Adam \nbranch nick: SAMBA_3_0-registry.bzr\ntimestamp: Tue 2007-04-10 12:50:02 +0200\nmessage:\n  auth/auth_util2.c renamed to auth/token_util.c in Volker's checkin\nremoved:\n  source/auth/auth_util2.c       auth_util2.c-20070228112535-wzq0qzh7l78m6o3o-1\n=== removed file 'source/auth/auth_util2.c'\n--- a/source/auth/auth_util2.c\t2007-02-28 11:58:58 +0000\n+++ b/source/auth/auth_util2.c\t1970-01-01 00:00:00 +0000\n@@ -1,459 +0,0 @@\n-/* \n- *  Unix SMB/CIFS implementation.\n- *  Authentication utility functions\n- *  Copyright (C) Andrew Tridgell 1992-1998\n- *  Copyright (C) Andrew Bartlett 2001\n- *  Copyright (C) Jeremy Allison 2000-2001\n- *  Copyright (C) Rafal Szczesniak 2002\n- *  Copyright (C) Volker Lendecke 2006\n- *  Copyright (C) Michael Adam 2007\n- *\n- *  This program is free software; you can redistribute it and/or modify\n- *  it under the terms of the GNU General Public License as published by\n- *  the Free Software Foundation; either version 2 of the License, or\n- *  (at your option) any later version.\n- *  \n- *  This program is distributed in the hope that it will be useful,\n- *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- *  GNU General Public License for more details.\n- *  \n- *  You should have received a copy of the GNU General Public License\n- *  along with this program; if not, write to the Free Software\n- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n- */\n-\n-/* functions moved from auth/auth_util.c to minimize linker deps */\n-\n-#include \"includes.h\"\n-\n-/****************************************************************************\n- Duplicate a SID token.\n-****************************************************************************/\n-\n-NT_USER_TOKEN *dup_nt_token(TALLOC_CTX *mem_ctx, const NT_USER_TOKEN *ptoken)\n-{\n-\tNT_USER_TOKEN *token;\n-\n-\tif (!ptoken)\n-\t\treturn NULL;\n-\n-\ttoken = TALLOC_P(mem_ctx, NT_USER_TOKEN);\n-\tif (token == NULL) {\n-\t\tDEBUG(0, (\"talloc failed\\n\"));\n-\t\treturn NULL;\n-\t}\n-\n-\tZERO_STRUCTP(token);\n-\n-\tif (ptoken->user_sids && ptoken->num_sids) {\n-\t\ttoken->user_sids = (DOM_SID *)talloc_memdup(\n-\t\t\ttoken, ptoken->user_sids, sizeof(DOM_SID) * ptoken->num_sids );\n-\n-\t\tif (token->user_sids == NULL) {\n-\t\t\tDEBUG(0, (\"talloc_memdup failed\\n\"));\n-\t\t\tTALLOC_FREE(token);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\ttoken->num_sids = ptoken->num_sids;\n-\t}\n-\t\n-\t/* copy the privileges; don't consider failure to be critical here */\n-\t\n-\tif ( !se_priv_copy( &token->privileges, &ptoken->privileges ) ) {\n-\t\tDEBUG(0,(\"dup_nt_token: Failure to copy SE_PRIV!.  \"\n-\t\t\t \"Continuing with 0 privileges assigned.\\n\"));\n-\t}\n-\n-\treturn token;\n-}\n-\n-/****************************************************************************\n- Check for a SID in an NT_USER_TOKEN\n-****************************************************************************/\n-\n-BOOL nt_token_check_sid ( const DOM_SID *sid, const NT_USER_TOKEN *token )\n-{\n-\tint i;\n-\t\n-\tif ( !sid || !token )\n-\t\treturn False;\n-\t\n-\tfor ( i=0; inum_sids; i++ ) {\n-\t\tif ( sid_equal( sid, &token->user_sids[i] ) )\n-\t\t\treturn True;\n-\t}\n-\n-\treturn False;\n-}\n-\n-BOOL nt_token_check_domain_rid( NT_USER_TOKEN *token, uint32 rid ) \n-{\n-\tDOM_SID domain_sid;\n-\n-\t/* if we are a domain member, the get the domain SID, else for \n-\t   a DC or standalone server, use our own SID */\n-\n-\tif ( lp_server_role() == ROLE_DOMAIN_MEMBER ) {\n-\t\tif ( !secrets_fetch_domain_sid( lp_workgroup(),\n-\t\t\t\t\t\t&domain_sid ) ) {\n-\t\t\tDEBUG(1,(\"nt_token_check_domain_rid: Cannot lookup \"\n-\t\t\t\t \"SID for domain [%s]\\n\", lp_workgroup()));\n-\t\t\treturn False;\n-\t\t}\n-\t} \n-\telse\n-\t\tsid_copy( &domain_sid, get_global_sam_sid() );\n-\n-\tsid_append_rid( &domain_sid, rid );\n-\t\n-\treturn nt_token_check_sid( &domain_sid, token );\\\n-}\n-\n-/******************************************************************************\n- Create a token for the root user to be used internally by smbd.\n- This is similar to running under the context of the LOCAL_SYSTEM account\n- in Windows.  This is a read-only token.  Do not modify it or free() it.\n- Create a copy if your need to change it.\n-******************************************************************************/\n-\n-NT_USER_TOKEN *get_root_nt_token( void )\n-{\n-\tstatic NT_USER_TOKEN *token = NULL;\n-\tDOM_SID u_sid, g_sid;\n-\tstruct passwd *pw;\n-\t\n-\tif ( token )\n-\t\treturn token;\n-\n-\tif ( !(pw = sys_getpwnam( \"root\" )) ) {\n-\t\tDEBUG(0,(\"get_root_nt_token: getpwnam\\\"root\\\") failed!\\n\"));\n-\t\treturn NULL;\n-\t}\n-\t\n-\t/* get the user and primary group SIDs; although the \n-\t   BUILTIN\\Administrators SId is really the one that matters here */\n-\t   \n-\tuid_to_sid(&u_sid, pw->pw_uid);\n-\tgid_to_sid(&g_sid, pw->pw_gid);\n-\n-\ttoken = create_local_nt_token(NULL, &u_sid, False,\n-\t\t\t\t      1, &global_sid_Builtin_Administrators);\n-\treturn token;\n-}\n-\n-\n-/*\n- * Add alias SIDs from memberships within the partially created token SID list\n- */\n-\n-static NTSTATUS add_aliases(const DOM_SID *domain_sid,\n-\t\t\t    struct nt_user_token *token)\n-{\n-\tuint32 *aliases;\n-\tsize_t i, num_aliases;\n-\tNTSTATUS status;\n-\tTALLOC_CTX *tmp_ctx;\n-\n-\tif (!(tmp_ctx = talloc_init(\"add_aliases\"))) {\n-\t\treturn NT_STATUS_NO_MEMORY;\n-\t}\n-\n-\taliases = NULL;\n-\tnum_aliases = 0;\n-\n-\tstatus = pdb_enum_alias_memberships(tmp_ctx, domain_sid,\n-\t\t\t\t\t    token->user_sids,\n-\t\t\t\t\t    token->num_sids,\n-\t\t\t\t\t    &aliases, &num_aliases);\n-\n-\tif (!NT_STATUS_IS_OK(status)) {\n-\t\tDEBUG(10, (\"pdb_enum_alias_memberships failed: %s\\n\",\n-\t\t\t   nt_errstr(status)));\n-\t\tTALLOC_FREE(tmp_ctx);\n-\t\treturn status;\n-\t}\n-\n-\tfor (i=0; iuser_sids,\n-\t\t\t\t\t&token->num_sids)) {\n-\t\t\tDEBUG(0, (\"add_sid_to_array failed\\n\"));\n-\t\t\tTALLOC_FREE(tmp_ctx);\n-\t\t\treturn NT_STATUS_NO_MEMORY;\n-\t\t}\n-\t}\n-\n-\tTALLOC_FREE(tmp_ctx);\n-\treturn NT_STATUS_OK;\n-}\n-\n-/*******************************************************************\n-*******************************************************************/\n-\n-static NTSTATUS add_builtin_administrators( struct nt_user_token *token )\n-{\n-\tDOM_SID domadm;\n-\n-\t/* nothing to do if we aren't in a domain */\n-\t\n-\tif ( !(IS_DC || lp_server_role()==ROLE_DOMAIN_MEMBER) ) {\n-\t\treturn NT_STATUS_OK;\n-\t}\n-\t\n-\t/* Find the Domain Admins SID */\n-\t\n-\tif ( IS_DC ) {\n-\t\tsid_copy( &domadm, get_global_sam_sid() );\n-\t} else {\n-\t\tif ( !secrets_fetch_domain_sid( lp_workgroup(), &domadm ) )\n-\t\t\treturn NT_STATUS_CANT_ACCESS_DOMAIN_INFO;\n-\t}\n-\tsid_append_rid( &domadm, DOMAIN_GROUP_RID_ADMINS );\n-\t\n-\t/* Add Administrators if the user beloongs to Domain Admins */\n-\t\n-\tif ( nt_token_check_sid( &domadm, token ) ) {\n-\t\tif (!add_sid_to_array(token, &global_sid_Builtin_Administrators,\n-\t\t\t\t\t &token->user_sids, &token->num_sids)) {\n-\t\t\treturn NT_STATUS_NO_MEMORY;\n-\t\t}\n-\t}\n-\t\n-\treturn NT_STATUS_OK;\n-}\n-\n-/*******************************************************************\n-*******************************************************************/\n-\n-static NTSTATUS create_builtin_users( void )\n-{\n-\tNTSTATUS status;\n-\tDOM_SID dom_users;\n-\n-\tstatus = pdb_create_builtin_alias( BUILTIN_ALIAS_RID_USERS );\n-\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\tDEBUG(0,(\"create_builtin_users: Failed to create Users\\n\"));\n-\t\treturn status;\n-\t}\n-\t\n-\t/* add domain users */\n-\tif ((IS_DC || (lp_server_role() == ROLE_DOMAIN_MEMBER)) \n-\t\t&& secrets_fetch_domain_sid(lp_workgroup(), &dom_users))\n-\t{\n-\t\tsid_append_rid(&dom_users, DOMAIN_GROUP_RID_USERS );\n-\t\tstatus = pdb_add_aliasmem( &global_sid_Builtin_Users, &dom_users);\n-\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\tDEBUG(0,(\"create_builtin_administrators: Failed to add Domain Users to\"\n-\t\t\t\t\" Users\\n\"));\n-\t\t\treturn status;\n-\t\t}\n-\t}\n-\t\t\t\n-\treturn NT_STATUS_OK;\n-}\t\t\n-\n-/*******************************************************************\n-*******************************************************************/\n-\n-static NTSTATUS create_builtin_administrators( void )\n-{\n-\tNTSTATUS status;\n-\tDOM_SID dom_admins, root_sid;\n-\tfstring root_name;\n-\tenum lsa_SidType type;\t\t\n-\tTALLOC_CTX *ctx;\n-\tBOOL ret;\n-\n-\tstatus = pdb_create_builtin_alias( BUILTIN_ALIAS_RID_ADMINS );\n-\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\tDEBUG(0,(\"create_builtin_administrators: Failed to create Administrators\\n\"));\n-\t\treturn status;\n-\t}\n-\t\n-\t/* add domain admins */\n-\tif ((IS_DC || (lp_server_role() == ROLE_DOMAIN_MEMBER)) \n-\t\t&& secrets_fetch_domain_sid(lp_workgroup(), &dom_admins))\n-\t{\n-\t\tsid_append_rid(&dom_admins, DOMAIN_GROUP_RID_ADMINS);\n-\t\tstatus = pdb_add_aliasmem( &global_sid_Builtin_Administrators, &dom_admins );\n-\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\tDEBUG(0,(\"create_builtin_administrators: Failed to add Domain Admins\"\n-\t\t\t\t\" Administrators\\n\"));\n-\t\t\treturn status;\n-\t\t}\n-\t}\n-\t\t\t\n-\t/* add root */\n-\tif ( (ctx = talloc_init(\"create_builtin_administrators\")) == NULL ) {\n-\t\treturn NT_STATUS_NO_MEMORY;\n-\t}\n-\tfstr_sprintf( root_name, \"%s\\\\root\", get_global_sam_name() );\n-\tret = lookup_name( ctx, root_name, 0, NULL, NULL, &root_sid, &type );\n-\tTALLOC_FREE( ctx );\n-\n-\tif ( ret ) {\n-\t\tstatus = pdb_add_aliasmem( &global_sid_Builtin_Administrators, &root_sid );\n-\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\tDEBUG(0,(\"create_builtin_administrators: Failed to add root\"\n-\t\t\t\t\" Administrators\\n\"));\n-\t\t\treturn status;\n-\t\t}\n-\t}\n-\t\n-\treturn NT_STATUS_OK;\n-}\t\t\n-\n-\n-/*******************************************************************\n- Create a NT token for the user, expanding local aliases\n-*******************************************************************/\n-\n-/* static struct nt_user_token *create_local_nt_token(TALLOC_CTX *mem_ctx, */\n-struct nt_user_token *create_local_nt_token(TALLOC_CTX *mem_ctx,\n-\t\t\t\t\t\t   const DOM_SID *user_sid,\n-\t\t\t\t\t\t   BOOL is_guest,\n-\t\t\t\t\t\t   int num_groupsids,\n-\t\t\t\t\t\t   const DOM_SID *groupsids)\n-{\n-\tstruct nt_user_token *result = NULL;\n-\tint i;\n-\tNTSTATUS status;\n-\tgid_t gid;\n-\n-\tDEBUG(10, (\"Create local NT token for %s\\n\", sid_string_static(user_sid)));\n-\n-\tif (!(result = TALLOC_ZERO_P(mem_ctx, NT_USER_TOKEN))) {\n-\t\tDEBUG(0, (\"talloc failed\\n\"));\n-\t\treturn NULL;\n-\t}\n-\n-\t/* Add the user and primary group sid */\n-\n-\tif (!add_sid_to_array(result, user_sid,\n-\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\treturn NULL;\n-\t}\n-\n-\t/* For guest, num_groupsids may be zero. */\n-\tif (num_groupsids) {\n-\t\tif (!add_sid_to_array(result, &groupsids[0],\n-\t\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\t\treturn NULL;\n-\t\t}\n-\t}\n-\t\t\t \n-\t/* Add in BUILTIN sids */\n-\t\n-\tif (!add_sid_to_array(result, &global_sid_World,\n-\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\treturn NULL;\n-\t}\n-\tif (!add_sid_to_array(result, &global_sid_Network,\n-\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\treturn NULL;\n-\t}\n-\n-\tif (is_guest) {\n-\t\tif (!add_sid_to_array(result, &global_sid_Builtin_Guests,\n-\t\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\t\treturn NULL;\n-\t\t}\n-\t} else {\n-\t\tif (!add_sid_to_array(result, &global_sid_Authenticated_Users,\n-\t\t\t\t &result->user_sids, &result->num_sids)) {\n-\t\t\treturn NULL;\n-\t\t}\n-\t}\n-\t\n-\t/* Now the SIDs we got from authentication. These are the ones from\n-\t * the info3 struct or from the pdb_enum_group_memberships, depending\n-\t * on who authenticated the user.\n-\t * Note that we start the for loop at \"1\" here, we already added the\n-\t * first group sid as primary above. */\n-\n-\tfor (i=1; iuser_sids, &result->num_sids)) {\n-\t\t\treturn NULL;\n-\t\t}\n-\t}\n-\t\n-\t/* Deal with the BUILTIN\\Administrators group.  If the SID can\n-\t   be resolved then assume that the add_aliasmem( S-1-5-32 ) \n-\t   handled it. */\n-\n-\tif ( !sid_to_gid( &global_sid_Builtin_Administrators, &gid ) ) {\n-\t\t/* We can only create a mapping if winbind is running \n-\t\t   and the nested group functionality has been enabled */\n-\t\t   \n-\t\tif ( lp_winbind_nested_groups() && winbind_ping() ) {\n-\t\t\tbecome_root();\n-\t\t\tstatus = create_builtin_administrators( );\n-\t\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\t\tDEBUG(2,(\"create_local_nt_token: Failed to create BUILTIN\\\\Administrators group!\\n\"));\n-\t\t\t\t/* don't fail, just log the message */\n-\t\t\t}\n-\t\t\tunbecome_root();\n-\t\t}\n-\t\telse {\n-\t\t\tstatus = add_builtin_administrators( result );\n-\t\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\t\t/* just log a complaint but do not fail */\n-\t\t\t\tDEBUG(3,(\"create_local_nt_token: failed to check for local Administrators\"\n-\t\t\t\t\t\" membership (%s)\\n\", nt_errstr(status)));\n-\t\t\t}\t\t\t\n-\t\t}\t\t\n-\t}\n-\n-\t/* Deal with the BUILTIN\\Users group.  If the SID can\n-\t   be resolved then assume that the add_aliasmem( S-1-5-32 ) \n-\t   handled it. */\n-\n-\tif ( !sid_to_gid( &global_sid_Builtin_Users, &gid ) ) {\n-\t\t/* We can only create a mapping if winbind is running \n-\t\t   and the nested group functionality has been enabled */\n-\t\t   \n-\t\tif ( lp_winbind_nested_groups() && winbind_ping() ) {\n-\t\t\tbecome_root();\n-\t\t\tstatus = create_builtin_users( );\n-\t\t\tif ( !NT_STATUS_IS_OK(status) ) {\n-\t\t\t\tDEBUG(2,(\"create_local_nt_token: Failed to create BUILTIN\\\\Users group!\\n\"));\n-\t\t\t\t/* don't fail, just log the message */\n-\t\t\t}\n-\t\t\tunbecome_root();\n-\t\t}\n-\t}\n-\n-\t/* Deal with local groups */\n-\t\n-\tif (lp_winbind_nested_groups()) {\n-\n-\t\t/* Now add the aliases. First the one from our local SAM */\n-\n-\t\tstatus = add_aliases(get_global_sam_sid(), result);\n-\n-\t\tif (!NT_STATUS_IS_OK(status)) {\n-\t\t\tTALLOC_FREE(result);\n-\t\t\treturn NULL;\n-\t\t}\n-\n-\t\t/* Finally the builtin ones */\n-\n-\t\tstatus = add_aliases(&global_sid_Builtin, result);\n-\n-\t\tif (!NT_STATUS_IS_OK(status)) {\n-\t\t\tTALLOC_FREE(result);\n-\t\t\treturn NULL;\n-\t\t}\n-\t} \n-\n-\n-\tget_privileges_for_sids(&result->privileges, result->user_sids,\n-\t\t\t\tresult->num_sids);\n-\treturn result;\n-}\n-\n-/* END */\n\n"}
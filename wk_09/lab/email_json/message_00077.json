{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r22132 - in branches: SAMBA_3_0/source/modules\n\tSAMBA_3_0/source/smbd SAMBA_3_0_25/source/modules\n\tSAMBA_3_0_25/source/smbd", "body": "Author: jra\nDate: 2007-04-08 19:41:47 +0000 (Sun, 08 Apr 2007)\nNew Revision: 22132\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22132\n\nLog:\nI hate inefficiency. Don't call conv_str_size()\non every pread/sendfile call, initialize these\nvariables in an allocated struct at connection\ntime and just refer to them directly.\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/modules/vfs_readahead.c\n   branches/SAMBA_3_0/source/smbd/vfs.c\n   branches/SAMBA_3_0_25/source/modules/vfs_readahead.c\n   branches/SAMBA_3_0_25/source/smbd/vfs.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/modules/vfs_readahead.c\n===================================================================\n--- branches/SAMBA_3_0/source/modules/vfs_readahead.c\t2007-04-08 17:05:41 UTC (rev 22131)\n+++ branches/SAMBA_3_0/source/modules/vfs_readahead.c\t2007-04-08 19:41:47 UTC (rev 22132)\n@@ -22,36 +22,22 @@\n static BOOL didmsg;\n #endif\n \n+struct readahead_data {\n+\tSMB_OFF_T off_bound;\n+\tSMB_OFF_T len;\n+\tBOOL didmsg;\n+};\n+\n /* \n  * This module copes with Vista AIO read requests on Linux\n  * by detecting the initial 0x80000 boundary reads and causing\n  * the buffer cache to be filled in advance.\n  */\n \n-static unsigned long get_offset_boundary(struct vfs_handle_struct *handle)\n-{\n-\tSMB_OFF_T off_bound = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n-\t\t\t\t\t\t\"readahead\",\n-\t\t\t\t\t\t\"offset\",\n-\t\t\t\t\t\tNULL));\n-\tif (off_bound == 0) {\n-\t\toff_bound = 0x80000;\n-\t}\n-\treturn (unsigned long)off_bound;\n-}\n+/*******************************************************************\n+ sendfile wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n \n-static unsigned long get_offset_length(struct vfs_handle_struct *handle, unsigned long def_val)\n-{\n-\tSMB_OFF_T len = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n-\t\t\t\t\t\t\"readahead\",\n-\t\t\t\t\t\t\"length\",\n-\t\t\t\t\t\tNULL));\n-\tif (len == 0) {\n-\t\tlen = def_val;\n-\t}\n-\treturn (unsigned long)len;\n-}\n-\n static ssize_t readahead_sendfile(struct vfs_handle_struct *handle,\n \t\t\t\t\tint tofd,\n \t\t\t\t\tfiles_struct *fsp,\n@@ -60,27 +46,27 @@\n \t\t\t\t\tSMB_OFF_T offset,\n \t\t\t\t\tsize_t count)\n {\n-\tunsigned long off_bound = get_offset_boundary(handle);\n-\tif ( offset % off_bound == 0) {\n-\t\tunsigned long len = get_offset_length(handle, off_bound);\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n #if defined(HAVE_LINUX_READAHEAD)\n-\t\tint err = readahead(fromfd, offset, (size_t)len);\n+\t\tint err = readahead(fromfd, offset, (size_t)rhd->len);\n \t\tDEBUG(10,(\"readahead_sendfile: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fromfd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t        err ));\n #elif defined(HAVE_POSIX_FADVISE)\n-\t\tint err = posix_fadvise(fromfd, offset, (off_t)len, POSIX_FADV_WILLNEED);\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n \t\tDEBUG(10,(\"readahead_sendfile: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fromfd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\terr ));\n #else\n-\t\tif (!didmsg) {\n+\t\tif (!rhd->didmsg) {\n \t\t\tDEBUG(0,(\"readahead_sendfile: no readahead on this platform\\n\"));\n-\t\t\tdidmsg = True;\n+\t\t\trhd->didmsg = True;\n \t\t}\n #endif\n \t}\n@@ -93,6 +79,10 @@\n \t\t\t\t\tcount);\n }\n \n+/*******************************************************************\n+ pread wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n+\n static ssize_t readahead_pread(vfs_handle_struct *handle,\n \t\t\t\tfiles_struct *fsp,\n \t\t\t\tint fd,\n@@ -100,40 +90,97 @@\n \t\t\t\tsize_t count,\n \t\t\t\tSMB_OFF_T offset)\n {\n-\tunsigned long off_bound = get_offset_boundary(handle);\n-\tif ( offset % off_bound == 0) {\n-\t\tunsigned long len = get_offset_length(handle, off_bound);\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n #if defined(HAVE_LINUX_READAHEAD)\n-\t\tint err = readahead(fd, offset, (size_t)len);\n+\t\tint err = readahead(fd, offset, (size_t)rhd->len);\n \t\tDEBUG(10,(\"readahead_pread: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\terr ));\n #elif defined(HAVE_POSIX_FADVISE)\n-\t\tint err = posix_fadvise(fromfd, offset, (off_t)len, POSIX_FADV_WILLNEED);\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n \t\tDEBUG(10,(\"readahead_pread: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\t(err ));\n #else\n-\t\tif (!didmsg) {\n+\t\tif (!rhd->didmsg) {\n \t\t\tDEBUG(0,(\"readahead_pread: no readahead on this platform\\n\"));\n-\t\t\tdidmsg = True;\n+\t\t\trhd->didmsg = True;\n \t\t}\n #endif\n         }\n         return SMB_VFS_NEXT_PREAD(handle, fsp, fd, data, count, offset);\n }\n \n+/*******************************************************************\n+ Directly called from main smbd when freeing handle.\n+*******************************************************************/\n+\n+static void free_readahead_data(void **pptr)\n+{\n+\tSAFE_FREE(*pptr);\n+}\n+\n+/*******************************************************************\n+ Allocate the handle specific data so we don't call the expensive\n+ conv_str_size function for each sendfile/pread.\n+*******************************************************************/\n+\n+static int readahead_connect(struct vfs_handle_struct *handle,\n+\t\t\t\tconst char *service,\n+\t\t\t\tconst char *user)\n+{\n+\tstruct readahead_data *rhd = SMB_MALLOC_P(struct readahead_data);\n+\tif (!rhd) {\n+\t\tDEBUG(0,(\"readahead_connect: out of memory\\n\"));\n+\t\treturn -1;\n+\t}\n+\tZERO_STRUCTP(rhd);\n+\n+\trhd->didmsg = False;\n+\trhd->off_bound = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"offset\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->off_bound == 0) {\n+\t\trhd->off_bound = 0x80000;\n+\t}\n+\trhd->len = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"length\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->len == 0) {\n+\t\trhd->len = rhd->off_bound;\n+\t}\n+\n+\thandle->data = (void *)rhd;\n+\thandle->free_data = free_readahead_data;\n+\treturn 0;\n+}\n+\n+/*******************************************************************\n+ Functions we're replacing.\n+ We don't replace read as it isn't used from smbd to read file\n+ data.\n+*******************************************************************/\n+\n static vfs_op_tuple readahead_ops [] =\n {\n \t{SMB_VFS_OP(readahead_sendfile), SMB_VFS_OP_SENDFILE, SMB_VFS_LAYER_TRANSPARENT},\n \t{SMB_VFS_OP(readahead_pread), SMB_VFS_OP_PREAD, SMB_VFS_LAYER_TRANSPARENT},\n+        {SMB_VFS_OP(readahead_connect), SMB_VFS_OP_CONNECT,  SMB_VFS_LAYER_TRANSPARENT},\n \t{SMB_VFS_OP(NULL), SMB_VFS_OP_NOOP, SMB_VFS_LAYER_NOOP}\n };\n \n+/*******************************************************************\n+ Module initialization boilerplate.\n+*******************************************************************/\n+\n NTSTATUS vfs_readahead_init(void);\n NTSTATUS vfs_readahead_init(void)\n {\n\nModified: branches/SAMBA_3_0/source/smbd/vfs.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/vfs.c\t2007-04-08 17:05:41 UTC (rev 22131)\n+++ branches/SAMBA_3_0/source/smbd/vfs.c\t2007-04-08 19:41:47 UTC (rev 22132)\n@@ -174,7 +174,7 @@\n \t\tDEBUG(5, (\"Checking operation #%d (type %d, layer %d)\\n\", i, ops[i].type, ops[i].layer));\n \t\tif(ops[i].layer == SMB_VFS_LAYER_OPAQUE) {\n \t\t\t/* If this operation was already made opaque by different module, it\n-\t\t\t * will be overridded here.\n+\t\t\t * will be overridden here.\n \t\t\t */\n \t\t\tDEBUGADD(5, (\"Making operation type %d opaque [module %s]\\n\", ops[i].type, vfs_object));\n \t\t\tvfs_set_operation(&conn->vfs_opaque, ops[i].type, handle, ops[i].op);\n\nModified: branches/SAMBA_3_0_25/source/modules/vfs_readahead.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/modules/vfs_readahead.c\t2007-04-08 17:05:41 UTC (rev 22131)\n+++ branches/SAMBA_3_0_25/source/modules/vfs_readahead.c\t2007-04-08 19:41:47 UTC (rev 22132)\n@@ -22,36 +22,22 @@\n static BOOL didmsg;\n #endif\n \n+struct readahead_data {\n+\tSMB_OFF_T off_bound;\n+\tSMB_OFF_T len;\n+\tBOOL didmsg;\n+};\n+\n /* \n  * This module copes with Vista AIO read requests on Linux\n  * by detecting the initial 0x80000 boundary reads and causing\n  * the buffer cache to be filled in advance.\n  */\n \n-static unsigned long get_offset_boundary(struct vfs_handle_struct *handle)\n-{\n-\tSMB_OFF_T off_bound = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n-\t\t\t\t\t\t\"readahead\",\n-\t\t\t\t\t\t\"offset\",\n-\t\t\t\t\t\tNULL));\n-\tif (off_bound == 0) {\n-\t\toff_bound = 0x80000;\n-\t}\n-\treturn (unsigned long)off_bound;\n-}\n+/*******************************************************************\n+ sendfile wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n \n-static unsigned long get_offset_length(struct vfs_handle_struct *handle, unsigned long def_val)\n-{\n-\tSMB_OFF_T len = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n-\t\t\t\t\t\t\"readahead\",\n-\t\t\t\t\t\t\"length\",\n-\t\t\t\t\t\tNULL));\n-\tif (len == 0) {\n-\t\tlen = def_val;\n-\t}\n-\treturn (unsigned long)len;\n-}\n-\n static ssize_t readahead_sendfile(struct vfs_handle_struct *handle,\n \t\t\t\t\tint tofd,\n \t\t\t\t\tfiles_struct *fsp,\n@@ -60,27 +46,27 @@\n \t\t\t\t\tSMB_OFF_T offset,\n \t\t\t\t\tsize_t count)\n {\n-\tunsigned long off_bound = get_offset_boundary(handle);\n-\tif ( offset % off_bound == 0) {\n-\t\tunsigned long len = get_offset_length(handle, off_bound);\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n #if defined(HAVE_LINUX_READAHEAD)\n-\t\tint err = readahead(fromfd, offset, (size_t)len);\n+\t\tint err = readahead(fromfd, offset, (size_t)rhd->len);\n \t\tDEBUG(10,(\"readahead_sendfile: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fromfd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t        err ));\n #elif defined(HAVE_POSIX_FADVISE)\n-\t\tint err = posix_fadvise(fromfd, offset, (off_t)len, POSIX_FADV_WILLNEED);\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n \t\tDEBUG(10,(\"readahead_sendfile: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fromfd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\terr ));\n #else\n-\t\tif (!didmsg) {\n+\t\tif (!rhd->didmsg) {\n \t\t\tDEBUG(0,(\"readahead_sendfile: no readahead on this platform\\n\"));\n-\t\t\tdidmsg = True;\n+\t\t\trhd->didmsg = True;\n \t\t}\n #endif\n \t}\n@@ -93,6 +79,10 @@\n \t\t\t\t\tcount);\n }\n \n+/*******************************************************************\n+ pread wrapper that does readahead/posix_fadvise.\n+*******************************************************************/\n+\n static ssize_t readahead_pread(vfs_handle_struct *handle,\n \t\t\t\tfiles_struct *fsp,\n \t\t\t\tint fd,\n@@ -100,40 +90,97 @@\n \t\t\t\tsize_t count,\n \t\t\t\tSMB_OFF_T offset)\n {\n-\tunsigned long off_bound = get_offset_boundary(handle);\n-\tif ( offset % off_bound == 0) {\n-\t\tunsigned long len = get_offset_length(handle, off_bound);\n+\tstruct readahead_data *rhd = (struct readahead_data *)handle->data;\n+\n+\tif ( offset % rhd->off_bound == 0) {\n #if defined(HAVE_LINUX_READAHEAD)\n-\t\tint err = readahead(fd, offset, (size_t)len);\n+\t\tint err = readahead(fd, offset, (size_t)rhd->len);\n \t\tDEBUG(10,(\"readahead_pread: readahead on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\terr ));\n #elif defined(HAVE_POSIX_FADVISE)\n-\t\tint err = posix_fadvise(fromfd, offset, (off_t)len, POSIX_FADV_WILLNEED);\n+\t\tint err = posix_fadvise(fromfd, offset, (off_t)rhd->len, POSIX_FADV_WILLNEED);\n \t\tDEBUG(10,(\"readahead_pread: posix_fadvise on fd %u, offset %llu, len %u returned %d\\n\",\n \t\t\t(unsigned int)fd,\n \t\t\t(unsigned long long)offset,\n-\t\t\t(unsigned int)len,\n+\t\t\t(unsigned int)rhd->len,\n \t\t\t(err ));\n #else\n-\t\tif (!didmsg) {\n+\t\tif (!rhd->didmsg) {\n \t\t\tDEBUG(0,(\"readahead_pread: no readahead on this platform\\n\"));\n-\t\t\tdidmsg = True;\n+\t\t\trhd->didmsg = True;\n \t\t}\n #endif\n         }\n         return SMB_VFS_NEXT_PREAD(handle, fsp, fd, data, count, offset);\n }\n \n+/*******************************************************************\n+ Directly called from main smbd when freeing handle.\n+*******************************************************************/\n+\n+static void free_readahead_data(void **pptr)\n+{\n+\tSAFE_FREE(*pptr);\n+}\n+\n+/*******************************************************************\n+ Allocate the handle specific data so we don't call the expensive\n+ conv_str_size function for each sendfile/pread.\n+*******************************************************************/\n+\n+static int readahead_connect(struct vfs_handle_struct *handle,\n+\t\t\t\tconst char *service,\n+\t\t\t\tconst char *user)\n+{\n+\tstruct readahead_data *rhd = SMB_MALLOC_P(struct readahead_data);\n+\tif (!rhd) {\n+\t\tDEBUG(0,(\"readahead_connect: out of memory\\n\"));\n+\t\treturn -1;\n+\t}\n+\tZERO_STRUCTP(rhd);\n+\n+\trhd->didmsg = False;\n+\trhd->off_bound = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"offset\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->off_bound == 0) {\n+\t\trhd->off_bound = 0x80000;\n+\t}\n+\trhd->len = conv_str_size(lp_parm_const_string(SNUM(handle->conn),\n+\t\t\t\t\t\t\"readahead\",\n+\t\t\t\t\t\t\"length\",\n+\t\t\t\t\t\tNULL));\n+\tif (rhd->len == 0) {\n+\t\trhd->len = rhd->off_bound;\n+\t}\n+\n+\thandle->data = (void *)rhd;\n+\thandle->free_data = free_readahead_data;\n+\treturn 0;\n+}\n+\n+/*******************************************************************\n+ Functions we're replacing.\n+ We don't replace read as it isn't used from smbd to read file\n+ data.\n+*******************************************************************/\n+\n static vfs_op_tuple readahead_ops [] =\n {\n \t{SMB_VFS_OP(readahead_sendfile), SMB_VFS_OP_SENDFILE, SMB_VFS_LAYER_TRANSPARENT},\n \t{SMB_VFS_OP(readahead_pread), SMB_VFS_OP_PREAD, SMB_VFS_LAYER_TRANSPARENT},\n+        {SMB_VFS_OP(readahead_connect), SMB_VFS_OP_CONNECT,  SMB_VFS_LAYER_TRANSPARENT},\n \t{SMB_VFS_OP(NULL), SMB_VFS_OP_NOOP, SMB_VFS_LAYER_NOOP}\n };\n \n+/*******************************************************************\n+ Module initialization boilerplate.\n+*******************************************************************/\n+\n NTSTATUS vfs_readahead_init(void);\n NTSTATUS vfs_readahead_init(void)\n {\n\nModified: branches/SAMBA_3_0_25/source/smbd/vfs.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/smbd/vfs.c\t2007-04-08 17:05:41 UTC (rev 22131)\n+++ branches/SAMBA_3_0_25/source/smbd/vfs.c\t2007-04-08 19:41:47 UTC (rev 22132)\n@@ -174,7 +174,7 @@\n \t\tDEBUG(5, (\"Checking operation #%d (type %d, layer %d)\\n\", i, ops[i].type, ops[i].layer));\n \t\tif(ops[i].layer == SMB_VFS_LAYER_OPAQUE) {\n \t\t\t/* If this operation was already made opaque by different module, it\n-\t\t\t * will be overridded here.\n+\t\t\t * will be overridden here.\n \t\t\t */\n \t\t\tDEBUGADD(5, (\"Making operation type %d opaque [module %s]\\n\", ops[i].type, vfs_object));\n \t\t\tvfs_set_operation(&conn->vfs_opaque, ops[i].type, handle, ops[i].op);\n\n"}
{"category": "ham", "to_address": "nicolas bertin <nbertin@gsc.riken.jp>", "from_address": "Martin Morgan <mtmorgan@fhcrc.org>", "subject": "Re: [R] Error in clusterApply(): recursive default argument\n reference", "body": "Hi Nicolas --\n\nI think your code is assuming that all nodes have access to the same\nset of variables. One solution is to write in a more completely\n'functional' style\n\nparNullDistribIntersection <- function(g1, g2, perm=1000, cl=cl) {\n    n1 = nodes(g1)                      \n    parSapply(cl, 1:perm,\n              function(i, g1, g2, n1) {\n                  nodes(g1) <- sample(n1)\n                  numEdges(intersection(g1,g2))\n              },\n              g1, g2, n1)\n}              \n\nAnother possibility is to ensure that the relevant variables are\nexported to the cluster before parSapply. With both of these you'll\nwant to pay some attention to the costs of communicating the data to\nthe nodes, which could easily be overwhelming (Rmpi's version of\nparSapply is smarter at doing the data transfer -- log n time rather\nthan linear time, where n is the number of nodes -- and more flexible\nin distributing the work).\n\nHope that helps,\n\nMartin\n\n\nnicolas bertin  writes:\n\n> Hi,\n>\n> I want to compute a distribution of the intersection of a graph and\n> 'randomized' graphs induced by the permutations of node labels (to\n> preserve the graph topology).\n> Since I ll have many permutations to perform, I was thinking of using\n> the snow package and in particular \"parSapply\" to divide the work\n> between my 4 CPUs.\n> But I get the following error message :\n>\n> Error in clusterApply(cl, splitList(x, length(cl)), lapply, fun, ...) : \n>         recursive default argument reference\n>\n> What am i doing wrong ?\n>\n> Some details about my platform and R version :\n> -----------------------------------------------\n> $platform\n> [1] \"x86_64-redhat-linux-gnu\"\n> $version.string\n> [1] \"R version 2.4.1 (2006-12-18)\"\n>\n>\n> Below is the snippet of code generating the error message :\n> -----------------------------------------------------------\n> ### libraries ###\n> library(graph)\n> library(snow)\n>\n> ### functions ###\n> nullDistribIntersection <- function(g1, g2, perm=1000)\n> {\n>   n1 <- nodes(g1)\n>   sapply(1:perm,\n> \t  function(i)\n> \t  {\n>             nodes(g1) <- sample(n1)\n> \t    numEdges(intersection(g1,g2))\n> \t  }\n> \t )\n> }\n>\n>\n> parNullDistribIntersection <- function(g1, g2, perm=1000, cl=cl)\n> {\n>   n1 <- nodes(g1)\n>   parSapply(cl, 1:perm,\n> \t  function(i)\n> \t  {\n>             nodes(g1) <- sample(n1)\n> \t    numEdges(intersection(g1,g2))\n> \t  }\n> \t )\n> }\n>\n>\n> ## initialize the graph and the rand seed\n> set.seed(123)\n> g <- randomEGraph(LETTERS[1:15], edges = 100)\n>\n> ## compute a distribution of the intersection of the graph \n> ## and a 'randomized' graph induced by the permutations of\n> ## node labels (to preserve the graph topology)\n> cat(\"1CPU sys time:\",\n>     system.time(\n>                  dist <- nullDistribIntersection(g,g)\n>                ),\n>     \"\\n\"\n>     )\n>\n> cl <- makeCluster(c(\"localhost\", \"localhost\"), type = \"SOCK\")\n> cat(\"Cluster sys time:\",\n>     system.time(\n>                  dist <- parNullDistribIntersection(g,g)\n>                ),\n>     \"\\n\"\n>     )\n> ----------------------------------------------------------------\n>\n> Thanks in advance.\n>\n> Nicolas Bertin \n> GSC / RIKEN Yokohama\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n\n-- \nMartin Morgan\nBioconductor / Computational Biology\nhttp://bioconductor.org\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
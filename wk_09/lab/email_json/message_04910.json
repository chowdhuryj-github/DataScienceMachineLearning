{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r22209 - in branches: SAMBA_3_0/source/nsswitch\n\tSAMBA_3_0_25/source/nsswitch", "body": "Author: jra\nDate: 2007-04-13 22:29:50 +0000 (Fri, 13 Apr 2007)\nNew Revision: 22209\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22209\n\nLog:\nFix the storage of time_t -> make it 64 bits (use the\nsame load/store function as NTTIME). Add a version number\nstring to the winbindd cache so we can tell if it needs\nupgrading. THIS WILL DELETE ANY EXISTING winbindd_cache.tdb\non first startup regardless of offline auth status. Once\nthis is done we're in good shape though.\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/nsswitch/winbindd.c\n   branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\n   branches/SAMBA_3_0_25/source/nsswitch/winbindd.c\n   branches/SAMBA_3_0_25/source/nsswitch/winbindd_cache.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd.c\t2007-04-13 05:37:08 UTC (rev 22208)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd.c\t2007-04-13 22:29:50 UTC (rev 22209)\n@@ -1081,6 +1081,11 @@\n \t\texit(1);\n \t}\n \t\n+\t/* Initialize cache (ensure version is correct). */\n+\tif (!initialize_winbindd_cache()) {\n+\t\texit(1);\n+\t}\n+\n \t/* React on 'smbcontrol winbindd reload-config' in the same way\n \t   as to SIGHUP signal */\n \tmessage_register(MSG_SMB_CONF_UPDATED, msg_reload_services, NULL);\n\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\t2007-04-13 05:37:08 UTC (rev 22208)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd_cache.c\t2007-04-13 22:29:50 UTC (rev 22209)\n@@ -29,12 +29,53 @@\n #undef DBGC_CLASS\n #define DBGC_CLASS DBGC_WINBIND\n \n+#define WINBINDD_CACHE_VERSION 1\n+#define WINBINDD_CACHE_VERSION_KEYSTR \"WINBINDD_CACHE_VERSION\"\n+\n extern struct winbindd_methods reconnect_methods;\n extern BOOL opt_nocache;\n #ifdef HAVE_ADS\n extern struct winbindd_methods ads_methods;\n #endif\n \n+/*\n+ * JRA. KEEP THIS LIST UP TO DATE IF YOU ADD CACHE ENTRIES.\n+ * Here are the list of entry types that are *not* stored\n+ * as form struct cache_entry in the cache.\n+ */\n+\n+static const char *non_centry_keys[] = {\n+\t\"SEQNUM/\",\n+\t\"DR/\",\n+\t\"DE/\",\n+\t\"WINBINDD_OFFLINE\",\n+\tWINBINDD_CACHE_VERSION_KEYSTR,\n+\tNULL\n+};\n+\n+/************************************************************************\n+ Is this key a non-centry type ?\n+************************************************************************/\n+\n+static BOOL is_non_centry_key(TDB_DATA kbuf)\n+{\n+\tint i;\n+\n+\tif (kbuf.dptr == NULL || kbuf.dsize == 0) {\n+\t\treturn False;\n+\t}\n+\tfor (i = 0; non_centry_keys[i] != NULL; i++) {\n+\t\tsize_t namelen = strlen(non_centry_keys[i]);\n+\t\tif (kbuf.dsize <= namelen) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (strncmp(non_centry_keys[i], (const char *)kbuf.dptr, namelen) == 0) {\n+\t\t\treturn True;\n+\t\t}\n+\t}\n+\treturn False;\n+}\n+\n /* Global online/offline state - False when online. winbindd starts up online\n    and sets this to true if the first query fails and there's an entry in\n    the cache tdb telling us to stay offline. */\n@@ -237,18 +278,11 @@\n }\n \n /*\n-  pull a time_t from a cache entry \n+  pull a time_t from a cache entry. time_t stored portably as a 64-bit time.\n */\n static time_t centry_time(struct cache_entry *centry)\n {\n-\ttime_t ret;\n-\tif (centry_check_bytes(centry, sizeof(time_t))) {\n-\t\tsmb_panic_fn(\"centry_time\");\n-\t\treturn (time_t)-1;\n-\t}\n-\tret = IVAL(centry->data, centry->ofs); /* FIXME: correct ? */\n-\tcentry->ofs += sizeof(time_t);\n-\treturn ret;\n+\treturn (time_t)centry_nttime(centry);\n }\n \n /* pull a string from a cache entry, using the supplied\n@@ -719,13 +753,13 @@\n }\n \n /*\n-  push a time_t into a centry \n+  push a time_t into a centry - use a 64 bit size.\n+  NTTIME here is being used as a convenient 64-bit size.\n */\n static void centry_put_time(struct cache_entry *centry, time_t t)\n {\n-\tcentry_expand(centry, sizeof(time_t));\n-\tSIVAL(centry->data, centry->ofs, t); /* FIXME: is this correct ?? */\n-\tcentry->ofs += sizeof(time_t);\n+\tNTTIME nt = (NTTIME)t;\n+\treturn centry_put_nttime(centry, nt);\n }\n \n /*\n@@ -2164,6 +2198,61 @@\n \treturn True;\n }\n \n+/************************************************************************\n+ This is called by the parent to initialize the cache file.\n+ We don't need sophisticated locking here as we know we're the\n+ only opener.\n+************************************************************************/\n+\n+BOOL initialize_winbindd_cache(void)\n+{\n+\tBOOL cache_bad = True;\n+\tuint32 vers;\n+\n+\tif (!init_wcache()) {\n+\t\tDEBUG(0,(\"initialize_winbindd_cache: init_wcache failed.\\n\"));\n+\t\treturn False;\n+\t}\n+\n+\t/* Check version number. */\n+\tif (tdb_fetch_uint32(wcache->tdb, WINBINDD_CACHE_VERSION_KEYSTR, &vers) &&\n+\t\t\tvers == WINBINDD_CACHE_VERSION) {\n+\t\tcache_bad = False;\n+\t}\n+\n+\tif (cache_bad) {\n+\t\tDEBUG(0,(\"initialize_winbindd_cache: clearing cache \"\n+\t\t\t\"and re-creating with version number %d\\n\",\n+\t\t\tWINBINDD_CACHE_VERSION ));\n+\n+\t\ttdb_close(wcache->tdb);\n+\t\twcache->tdb = NULL;\n+\n+\t\tif (unlink(lock_path(\"winbindd_cache.tdb\")) == -1) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: unlink %s failed %s \",\n+\t\t\t\tlock_path(\"winbindd_cache.tdb\"),\n+\t\t\t\tstrerror(errno) ));\n+\t\t\treturn False;\n+\t\t}\n+\t\tif (!init_wcache()) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: re-initialization \"\n+\t\t\t\t\t\"init_wcache failed.\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\t/* Write the version. */\n+\t\tif (!tdb_store_uint32(wcache->tdb, WINBINDD_CACHE_VERSION_KEYSTR, WINBINDD_CACHE_VERSION)) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: version number store failed %s\\n\",\n+\t\t\t\ttdb_errorstr(wcache->tdb) ));\n+\t\t\treturn False;\n+\t\t}\n+\t}\n+\n+\ttdb_close(wcache->tdb);\n+\twcache->tdb = NULL;\n+\treturn True;\n+}\n+\n void cache_store_response(pid_t pid, struct winbindd_response *response)\n {\n \tfstring key_str;\n@@ -2360,12 +2449,21 @@\n \t\t\t\tsid, type);\n }\n \n-/* delete all centries that don't have NT_STATUS_OK set */\n+/*\n+ * The original idea that this cache only contains centries has\n+ * been blurred - now other stuff gets put in here. Ensure we\n+ * ignore these things on cleanup.\n+ */\n+\n static int traverse_fn_cleanup(TDB_CONTEXT *the_tdb, TDB_DATA kbuf, \n \t\t\t       TDB_DATA dbuf, void *state)\n {\n \tstruct cache_entry *centry;\n \n+\tif (is_non_centry_key(kbuf)) {\n+\t\treturn 0;\n+\t}\n+\n \tcentry = wcache_fetch_raw((char *)kbuf.dptr);\n \tif (!centry) {\n \t\treturn 0;\n\nModified: branches/SAMBA_3_0_25/source/nsswitch/winbindd.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/nsswitch/winbindd.c\t2007-04-13 05:37:08 UTC (rev 22208)\n+++ branches/SAMBA_3_0_25/source/nsswitch/winbindd.c\t2007-04-13 22:29:50 UTC (rev 22209)\n@@ -1065,6 +1065,11 @@\n \t\texit(1);\n \t}\n \t\n+\t/* Initialize cache (ensure version is correct). */\n+\tif (!initialize_winbindd_cache()) {\n+\t\texit(1);\n+\t}\n+\n \t/* React on 'smbcontrol winbindd reload-config' in the same way\n \t   as to SIGHUP signal */\n \tmessage_register(MSG_SMB_CONF_UPDATED, msg_reload_services, NULL);\n\nModified: branches/SAMBA_3_0_25/source/nsswitch/winbindd_cache.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/nsswitch/winbindd_cache.c\t2007-04-13 05:37:08 UTC (rev 22208)\n+++ branches/SAMBA_3_0_25/source/nsswitch/winbindd_cache.c\t2007-04-13 22:29:50 UTC (rev 22209)\n@@ -29,12 +29,53 @@\n #undef DBGC_CLASS\n #define DBGC_CLASS DBGC_WINBIND\n \n+#define WINBINDD_CACHE_VERSION 1\n+#define WINBINDD_CACHE_VERSION_KEYSTR \"WINBINDD_CACHE_VERSION\"\n+\n extern struct winbindd_methods reconnect_methods;\n extern BOOL opt_nocache;\n #ifdef HAVE_ADS\n extern struct winbindd_methods ads_methods;\n #endif\n \n+/*\n+ * JRA. KEEP THIS LIST UP TO DATE IF YOU ADD CACHE ENTRIES.\n+ * Here are the list of entry types that are *not* stored\n+ * as form struct cache_entry in the cache.\n+ */\n+\n+static const char *non_centry_keys[] = {\n+\t\"SEQNUM/\",\n+\t\"DR/\",\n+\t\"DE/\",\n+\t\"WINBINDD_OFFLINE\",\n+\tWINBINDD_CACHE_VERSION_KEYSTR,\n+\tNULL\n+};\n+\n+/************************************************************************\n+ Is this key a non-centry type ?\n+************************************************************************/\n+\n+static BOOL is_non_centry_key(TDB_DATA kbuf)\n+{\n+\tint i;\n+\n+\tif (kbuf.dptr == NULL || kbuf.dsize == 0) {\n+\t\treturn False;\n+\t}\n+\tfor (i = 0; non_centry_keys[i] != NULL; i++) {\n+\t\tsize_t namelen = strlen(non_centry_keys[i]);\n+\t\tif (kbuf.dsize <= namelen) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (strncmp(non_centry_keys[i], (const char *)kbuf.dptr, namelen) == 0) {\n+\t\t\treturn True;\n+\t\t}\n+\t}\n+\treturn False;\n+}\n+\n /* Global online/offline state - False when online. winbindd starts up online\n    and sets this to true if the first query fails and there's an entry in\n    the cache tdb telling us to stay offline. */\n@@ -227,19 +268,11 @@\n }\n \n /*\n-  pull a time_t from a cache entry \n+  pull a time_t from a cache entry. time_t stored portably as a 64-bit time.\n */\n static time_t centry_time(struct cache_entry *centry)\n {\n-\ttime_t ret;\n-\tif (centry->len - centry->ofs < sizeof(time_t)) {\n-\t\tDEBUG(0,(\"centry corruption? needed %u bytes, have %u\\n\", \n-\t\t\t (unsigned int)sizeof(time_t), (unsigned int)(centry->len - centry->ofs)));\n-\t\tsmb_panic(\"centry_time\");\n-\t}\n-\tret = IVAL(centry->data, centry->ofs); /* FIXME: correct ? */\n-\tcentry->ofs += sizeof(time_t);\n-\treturn ret;\n+\treturn (time_t)centry_nttime(centry);\n }\n \n /* pull a string from a cache entry, using the supplied\n@@ -713,13 +746,13 @@\n }\n \n /*\n-  push a time_t into a centry \n+  push a time_t into a centry - use a 64 bit size.\n+  NTTIME here is being used as a convenient 64-bit size.\n */\n static void centry_put_time(struct cache_entry *centry, time_t t)\n {\n-\tcentry_expand(centry, sizeof(time_t));\n-\tSIVAL(centry->data, centry->ofs, t); /* FIXME: is this correct ?? */\n-\tcentry->ofs += sizeof(time_t);\n+\tNTTIME nt = (NTTIME)t;\n+\treturn centry_put_nttime(centry, nt);\n }\n \n /*\n@@ -2119,7 +2152,7 @@\n \t}\n }\n \n-BOOL init_wcache(void)\n+static BOOL init_wcache(void)\n {\n \tif (wcache == NULL) {\n \t\twcache = SMB_XMALLOC_P(struct winbind_cache);\n@@ -2143,6 +2176,61 @@\n \treturn True;\n }\n \n+/************************************************************************\n+ This is called by the parent to initialize the cache file.\n+ We don't need sophisticated locking here as we know we're the\n+ only opener.\n+************************************************************************/\n+\n+BOOL initialize_winbindd_cache(void)\n+{\n+\tBOOL cache_bad = True;\n+\tuint32 vers;\n+\n+\tif (!init_wcache()) {\n+\t\tDEBUG(0,(\"initialize_winbindd_cache: init_wcache failed.\\n\"));\n+\t\treturn False;\n+\t}\n+\n+\t/* Check version number. */\n+\tif (tdb_fetch_uint32(wcache->tdb, WINBINDD_CACHE_VERSION_KEYSTR, &vers) &&\n+\t\t\tvers == WINBINDD_CACHE_VERSION) {\n+\t\tcache_bad = False;\n+\t}\n+\n+\tif (cache_bad) {\n+\t\tDEBUG(0,(\"initialize_winbindd_cache: clearing cache \"\n+\t\t\t\"and re-creating with version number %d\\n\",\n+\t\t\tWINBINDD_CACHE_VERSION ));\n+\n+\t\ttdb_close(wcache->tdb);\n+\t\twcache->tdb = NULL;\n+\n+\t\tif (unlink(lock_path(\"winbindd_cache.tdb\")) == -1) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: unlink %s failed %s \",\n+\t\t\t\tlock_path(\"winbindd_cache.tdb\"),\n+\t\t\t\tstrerror(errno) ));\n+\t\t\treturn False;\n+\t\t}\n+\t\tif (!init_wcache()) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: re-initialization \"\n+\t\t\t\t\t\"init_wcache failed.\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\t/* Write the version. */\n+\t\tif (!tdb_store_uint32(wcache->tdb, WINBINDD_CACHE_VERSION_KEYSTR, WINBINDD_CACHE_VERSION)) {\n+\t\t\tDEBUG(0,(\"initialize_winbindd_cache: version number store failed %s\\n\",\n+\t\t\t\ttdb_errorstr(wcache->tdb) ));\n+\t\t\treturn False;\n+\t\t}\n+\t}\n+\n+\ttdb_close(wcache->tdb);\n+\twcache->tdb = NULL;\n+\treturn True;\n+}\n+\n void cache_store_response(pid_t pid, struct winbindd_response *response)\n {\n \tfstring key_str;\n@@ -2340,11 +2428,21 @@\n }\n \n /* delete all centries that don't have NT_STATUS_OK set */\n+/*\n+ * The original idea that this cache only contains centries has\n+ * been blurred - now other stuff gets put in here. Ensure we\n+ * ignore these things on cleanup.\n+ */\n+\n static int traverse_fn_cleanup(TDB_CONTEXT *the_tdb, TDB_DATA kbuf, \n \t\t\t       TDB_DATA dbuf, void *state)\n {\n \tstruct cache_entry *centry;\n \n+\tif (is_non_centry_key(kbuf)) {\n+\t\treturn 0;\n+\t}\n+\n \tcentry = wcache_fetch_raw(kbuf.dptr);\n \tif (!centry) {\n \t\treturn 0;\n\n"}
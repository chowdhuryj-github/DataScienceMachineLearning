{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Steve Bertrand <iaccounts@ibctech.ca>", "subject": "Re: $1 $2 var confusion", "body": "John W. Krahn wrote:\n> Mumia W. wrote:\n>> That happens because the match variables ($1, $2, ...) are only changed\n>> when a regular expression matches; otherwise, they are left alone.\n>>\n>> In the first case, \"$2 !~ /domain\\.com/\" succeeds but does not capture\n>> anything, so the numbered match variables are unset.\n>>\n>> Your situation reinforces the rule that you should always test if the\n>> match succeeded before you attempt to use the match variables:\n>>\n>>     my $email = 'steveb@domain.com';\n>>     my @f = (undef, $email =~ /(.*)\\@(.*)/);\n> \n> Why did you put undef in there?  It serves no useful purpose other than making\n> the code harder to understand for beginners.\n\nWow...powerful statement.\n\nTo be honest, I got what I needed before I really payed attention to the\nabove part as per Rob and Tom's replies, but after re-reading, I agree.\n\nIn the above, do I assume correctly (without time to test for myself)\nthat 'undef' in this case undefines any instance of $1? (or $N for that\nmatter)?\n\n> \n>       my @f = $email =~ /(.*)\\@(.*)/;\n> \n> \n>>     (@f > 1) && ($f[2] =~ /domain\\.com/ ?\n>>         print \"$f[1]\\n\" : print \"var 2 is bad\\n\" );\n>>\n>> The test \"@f > 1\" is my way of testing if the match succeeded.\n> \n> The rvalue conditional operator should use the returned value:\n\nHonestly, I hate to say I'm a beginner, but relative to others here I\nwon't beg otherwise. Without having to spend time reading the ?: method\n(which I never use as of yet anyway), here is how I would do it now, so\nI would understand it, and so would my staff who are not programmers\nwhatsoever, and who may have to understand it lest I get hit by a bus. I\ninclude comments as I would if a non programmer would have to read it:\n\n# Get the username portion, and the domain portion that we\n# must verify from the input the user types in\n\nmy ($username, $domain) = split (/\\@/, $email);\n{... do verification}\n\n\nNow that I've started a controversy, can I ask if the following method\nis correct and accepted practice if I only care about the username portion?\n\nI use the following example often instead of split()ing, and then\nbreaking apart an array. Note this is a simple example, it's more handy\nfor me in circumstances where I may be fed an array with numerous slices:\n\nmy $username = (split (/\\@/, $email))[0];\n\nAgain, I have to say that the speed of the feedback was great today :)\nRob, I appreciate your input, and Tom, I don't know if you helped\nRandall write the books, but it's especially exciting to see yourself\nand the author of several books I own and have read active on the list.\n\nSteve\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
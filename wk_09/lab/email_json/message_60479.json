{"category": "ham", "to_address": "perl6 language <perl6-language@perl.org>", "from_address": "Richard Hainsworth <richard@rusrating.ru>", "subject": "Re: Documenting Perl6", "body": "Having read this posting, I find it VERY hard to understand exactly how \nDamian and Mark differ fundamentally. They both seem to be after the \nsame thing in the end.\n\nA rhetorical question of my own and an answer.\n\nQ) what is the real difference between comments and documentation?\n- Syntactically for the perl parser they are both white space.\n- Both are used to explain the code.\n\nA)  Documentation can be extracted from the body of the code by a \ndocumentation parser. Comments cant.\n- Documentation has to be written bearing in mind that it might be \ndivorced from the code, so where necessary the code has to be marked so \nthat it too will be included in the documentation. Comments dont get \nseparated from their context ever.\n- The final form of the documentation, viz a manual page or tutorial, \nand hence the structure, viz., headings / subheading, has to be \nconsidered when writing the software and adding the documentation. Hence \nthe layout instructions.\n- This suggests that comments and documentation differ only in the extra \ninformation needed by documentation when the text is separated from the \ncode. Comments are never separated from the code.\n- Comments are used to convert code to white space, for debugging, \ndevelopment etc.\n\nObservations)\n1) Programmers prefer to focus on the implementation. Focussing on how \nthe documentation will look when extracted can be distracting. And hence \nthis disincentivises writing documentation.\n2) When writing a useful tutorial or descriptive text, a different \nstructure is more often better in explaining the software than the \nstructure of the code. Moreover, it may not be apparent at the start of \nwriting what structure is better. Yet a program is substantially \ncontext-free - it matters little if functions with semantic closeness \nare grouped together.\n3) Different types of structure and level of documentation are \nappropriate for different purposes.\n4) What about links to other modules? When trying to understand some \ncode, I find references to unfamilar modules and I would like to be able \nto reference those. Yet currently, I must find the module and work \nthrough the documentation on that module separately, And if that module \nincludes another unfamiliar module, I have to recurse to another level.\n\nQuestions:\n1) Would it be possible to unify all comments and documentation into a \nsingle paradigm, such as a sort of bracketting convention with optional \nextra information for other tools to use, eg., layout information, \ngrouping information, context (viz., for a tutorial, or reference) \ninformation?\n2) Would it be possible for the brackets to have different 'opacities' \nfor the perl parser, so that code can be recognised both as code and as \ndocumentation with extra information? In this way, code would be \nincluded in some forms of documentation (eg., function signatures in \nreference manuals) just by placing \"transparent\" documentation brackets \naround them.\n3) Would it be possible for the brackets to have 'opacities' for the \nperl parser that can be set by the value of some variable, hence \ndebugging / tracing code could be switched on by setting that variable \nin the code?\n4) Is there a means for specifying the way documentation is reassembled, \neg., a means for defining for say a tutorial a different structure than \nthe linear structure of the documentation strings within the software?\n\nBig Questions:\na) Have I missed the conflict points completely?\nb) If no, do the questions above provide a means to resolve the \n\"philosophically different\" approaches to documentation?\nc) Am I wrong in thinking that implementing the suggestions in the \nquestions should not require a substantial redesign of perl6?\nd) If what I have suggested can already be done with Pod, could some \nexamples be shown.\n\nRichard\n\nMark Overmeer wrote:\n> =begin INTRO\n>\n> Mongers,\n>\n> I must say, I am a bit disappointed that the discussions about the future\n> of documentation in Perl has died.  Or was everyone fully occupied\n> by YAPC::NA?  I spent last week with my family on a stormy island,\n> without sufficient internet access, so was unable to stirr things up\n> again, but maybe this email will bring the focus back.\n>\n> Damian challenged me by asking what I think how Perl6's documentation\n> should be done.  When I think about documentation, I do not (immediately)\n> think about some mark-up language; that is just a minor component.\n> My focus is on the whole process: from writer to reader.  Although Damain\n> says to have studied OODoc, this most import features of that system\n> were ignored: simplifying the documentation process, improving the\n> documentation quality.\n>\n> Each time I re-read the list below, there are things I wish to change\n> or add: it is neither complete nor final.  But I cannot wait longer to\n> post it.  It's not my wish to extend this into a detailed requirements\n> document, just to set a focus of discussion.  Maybe someone wants to\n> comment on it?\n>\n>                MarkOv\n>\n> =end INTRO\n>\n> ======== Documentation of code (i.e. Perl6)\n>\n> In this text, we try to determine the environment for the optimal\n> documentation system for Perl6, but applicable to any other programming\n> language.\n>\n> Everyone will have his/her own weights on different aspects, and you\n> may even totally not agree with some of the listed remarks: it is open\n> to discussion.  Some of the wishes contradict an other as well.\n>\n> === Goal\n>\n> The sole goal: the best documentation for Perl6\n>\n> It is very important to keep in mind that documentation is made for\n> some target community to be read.  Write-only texts are useless.\n>\n> === Target communities\n>\n> Documentation is added to code, to provide additional information about\n> the code to inform some target community.  There are different target\n> communities possible for the same piece of code, which should all be\n> served as good as possible.\n>\n> Traditionally, you see\n>     1) code comments, for maintainers of the software\n>     2) manual-pages, for everyone else\n>\n> But more specific user groups can be defined:\n>     1) code comments, for maintainers\n>     2) developer manuals (the complete interface)\n>     3) user manuals (distribution external interfaces)\n>     4) selective look-up (for perldoc -f or IDE)\n>\n> === Fundamentals\n>\n> There are a few fundaments for good documentation:\n>   - it must be written\n>   - it must be correct\n>   - it must be consistent in structure\n>   - it must be consistent in content\n>   - it must be accessible (find back/pleasant to read)\n>\n> [Writing]\n> The best way to get people into writing documentation, is to make it as\n> simple as possible.  This means:\n>  - reduce the need to read man-pages or books to be able to create it,\n>  - reduce the amount of text to be typed,\n>  - avoid the need for additional tools to be installed,\n>  - reduce the need for configuration.\n> All for the sake of laziness.  The less time people need to manage their\n> documentation environment, the more time they have to write quality texts.\n>\n> [Writing]\n> To ease the burden of writing docs, documentation generating tools\n> should use as much information from the code as is useful for the\n> target community.  Replication between code and docs make changes\n> a double effort.  Manual replicated of text between files (like the\n> inclusion of the license text in each file) during programming is an\n> avoidable burden.\n>\n> [Writing]\n> Each documentation fragment belongs to some part of the implementation.\n> This may be a distribution, a file, a class or grammar or package,\n> a method, rule or sub, a positional or named parameter, and so on.\n> This relation comes natural (because of the mixture of code and doc),\n> or enforced (via some reference syntax).\n>\n> [Writing]\n> The documentation fragments need some markup.  Many mark-up languages\n> exist, which do have more or less the same features.  Two of those are\n> POD and PDD S26.  Within one distribution, it is useful to use the\n> same kind of markup syntax.  Document generators should only get a\n> minimal abstract interface to collect the results of the markup\n> parser, for instance a  $markup->produceHtml($fragment, ...)\n>\n> [Writing]\n> The markup language used should be capable of addressing the things\n> that a document writer wishes to express, not on what certain output\n> back-end can handle (those can always ignore things they cannot handle)\n>\n> [Correctness]\n> The documentation and the related code must be cross checkable, on\n> matters they overlap.  Better to avoid replication, in which case\n> there is no overlap to be checked.\n>\n> [Correctness]\n> The user should be stimulated to write in a good style.  One of the\n> ways to achieve this, is to avoid the need to write the same sentence\n> over and over again.  For instance: \"This method returns a boolean,\n> to indicate success\" is a sentence to avoid.  (Template based) auto-\n> generation could be used introduce abbreviations for often used\n> constructs.\n>\n> [Correctness]\n> Produced manuals should by default be checked for the completeness (like\n> Pod::Coverage), correctness in syntax (like Pod::Checker), and the\n> used references.  If possible, spell-checking (like Pod::Spell) should\n> be invoked automatically.\n>\n> [Structure]\n> There is a set of components we will always find in (UNIX) manual pages:\n> the one-line purpose (name), the synopsis, extended description, the subs\n> and methods, the \"see also\", authors, and license.  The order and location\n> of these documentation fragments, and their exact names are arbitrary.\n> Only the back-end can decide how, whether, and in which order these\n> components appear.\n>\n> [Structure]\n> The doc-writers should have general information about which documentation\n> components are minimally needed by the back-ends, for instance the\n> name and the license.  A short-list of chapter names suffices.\n>\n> [Structure]\n> The documentation generating back-ends shall have the same idea about the\n> structure and meaning of the contributed documentation.  The back-ends\n> only generate end-user texts, without any need for interpretation of the\n> doc fragments.  Only this way, systems like search.cpan.org can be of\n> value.\n>\n> [Content]\n> On the documentation writer's side, there usually is a serious problem:\n> writers do not know enough about the readers: their level of education,\n> their actual interests, and the media they use to read the documentation.\n> This results in inconsistent documentation between distributions.\n> For instance, some people put internal interfaces into the manual-pages,\n> where other do not want to bother the readers hence include them as\n> comments.  In Perl6, we have scoped subs and private methods, so it\n> is much clearer whether a component is available to everyone or not.\n> We may produce different manual pages.\n>\n> [Content]\n> Iff the used markup-language permits the author to specify the commands\n> which change the back-end's output (in the anarchistic tradition of Perl),\n> therewith endangering the consistency in output style or frustrating the\n> automatic processing of the content by other back-ends, then there must\n> be a simple way for the back-ends to protect themselves.  There should\n> be a standard way to remove this cruft from the documentation fragments.\n>\n> [Accessible]\n> The back-end, which produces the document the user will read, can be\n> traditional UNIX manual-pages, HTML web-pages, a printed book, whatever.\n> Of course, you want to produce documents which fit as good as possible\n> to the possibilities which a certain output medium gives.  POD(5) can\n> be used to produce web-pages, but the features to link between document\n> elements are far below the levels we are used to for HTML web-pages.\n> It should be very simple to create anchors and references to very\n> specific locations in the text, like a single option description.\n> Preferably without the need to define destination anchor points: the\n> documentation where you point to can be in a different package, not\n> under your control.\n>\n> [Accessible]\n> Documentation fragments are usually written in coding order.\n> The programmer's activities are often quite chaotic: functions and\n> methods are written in the order that the programmer needs them.\n> Related components are often close together in the file, but there is\n> no role for manual-order during this development process.  What is the\n> optimal order for the user to consume the fragments?  A very workable\n> solution is to group the items (for instance, constructors, accessors,\n> ...) into text sections, and within those groups use alphabetic sorting.\n> Each section may need some introductory text and examples.\n> To make doc fragments groupable is a requirement, and back-ends will\n> work-out how that grouping is used.\n>\n> === Generation documentation\n>\n> The documentation generation process could look schematically\n> something like this:\n>\n>  for each file in the MANIFEST\n>     parse Perl into its AST\n>     extract doc and code info from AST into doc-tree\n>\n>  for each doc-fragment in doc-tree\n>     do spell-check\n>\n>  preform consistency, structural checks on doc-tree\n>  collect inheritance information into doc-tree\n>\n>  for each package, class, grammar, pod in doc-tree\n>     call generator back-end(s)\n>     syntax check produced man-pages\n>   \n\n"}
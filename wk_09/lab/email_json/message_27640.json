{"category": "ham", "to_address": "Nicholas Clark <nick@ccl4.org>", "from_address": "Andy Spieherty <spiehera@lafayette.edu>", "subject": "Re: [svn:parrot] r18381 - trunk/include/parrot", "body": "On Thu, 10 May 2007, Nicholas Clark wrote:\n\n> But when I read STRING_IS_EMPTY() I stop and wonder \"right, how?\" and\n> stop to look up what it expands to. Which one does need to do, if one\n> is chasing down a bug. (Because with a bug, things *aren't* working as\n> at least one of the designer or implementor intended, which means\n> assumptions need to be checked. Maybe I'm odd)\n\nProbably, but you're not alone!  In perl5, I know I've made a lot of use \nof the .c.i Makefile rule.  In parrot, the equivalent exercise for me \nseems to be tracing all the indirections and structure casting.\n\n> So, personally, I find it easier with a comment on the struct by that\n> member, saying that an empty string has zero length.\n>\n> Mmm, looking at it right now:\n> \n> struct parrot_string_t {\n>     pobj_t obj;\n>     UINTVAL bufused;\n>     char *strstart;\n>     UINTVAL strlen;\n>     /*    parrot_string_representation_t representation;*/\n>     struct _encoding *encoding;\n>     struct _charset *charset;\n>     UINTVAL hashval; /* cached hash value computation; not yet used */\n> };\n> \n> \n> It makes me wonder what's the difference between bufused and strlen.\n\nbufused is in bytes; strlen is in \"characters\", determined by calling the \nstring's encoding->codepoints function:\n\n    ((ENCODING *)s->encoding)->codepoints(interp, s)\n\n-- \n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n"}
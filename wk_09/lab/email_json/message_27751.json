{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "mimir@samba.org", "subject": "svn commit: samba r22804 - in branches/SAMBA_4_0/source/libnet: .", "body": "Author: mimir\nDate: 2007-05-11 19:10:34 +0000 (Fri, 11 May 2007)\nNew Revision: 22804\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22804\n\nLog:\nconvert libnet_rpc_userinfo function to use \"continue\" functions\ninstead of a single handler.\n\n\nrafal\n\n\nModified:\n   branches/SAMBA_4_0/source/libnet/userinfo.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/libnet/userinfo.c\n===================================================================\n--- branches/SAMBA_4_0/source/libnet/userinfo.c\t2007-05-11 15:28:07 UTC (rev 22803)\n+++ branches/SAMBA_4_0/source/libnet/userinfo.c\t2007-05-11 19:10:34 UTC (rev 22804)\n@@ -31,14 +31,9 @@\n #include \"libnet/userinfo.h\"\n #include \"librpc/gen_ndr/ndr_samr_c.h\"\n \n-static void userinfo_handler(struct rpc_request *req);\n \n-enum userinfo_stage { USERINFO_LOOKUP, USERINFO_OPENUSER, USERINFO_GETUSER, USERINFO_CLOSEUSER };\n-\n struct userinfo_state {\n-\tenum userinfo_stage       stage;\n \tstruct dcerpc_pipe        *pipe;\n-\tstruct rpc_request        *req;\n \tstruct policy_handle      domain_handle;\n \tstruct policy_handle      user_handle;\n \tuint16_t                  level;\n@@ -53,23 +48,53 @@\n };\n \n \n+static void continue_userinfo_lookup(struct rpc_request *req);\n+static void continue_userinfo_openuser(struct rpc_request *req);\n+static void continue_userinfo_getuser(struct rpc_request *req);\n+static void continue_userinfo_closeuser(struct rpc_request *req);\n+\n+\n /**\n  * Stage 1 (optional): Look for a username in SAM server.\n  */\n-static NTSTATUS userinfo_lookup(struct composite_context *c,\n-\t\t\t\tstruct userinfo_state *s)\n+static void continue_userinfo_lookup(struct rpc_request *req)\n {\n+\tstruct composite_context *c;\n+\tstruct userinfo_state *s;\n+\tstruct rpc_request *openuser_req;\n+\tstruct monitor_msg msg;\n+\tstruct msg_rpc_lookup_name *msg_lookup;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct userinfo_state);\n+\n \t/* receive samr_Lookup reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \t\n \t/* there could be a problem with name resolving itself */\n-\tNT_STATUS_NOT_OK_RETURN(s->lookup.out.result);\n+\tif (!NT_STATUS_IS_OK(s->lookup.out.result)) {\n+\t\tcomposite_error(c, s->lookup.out.result);\n+\t\treturn;\n+\t}\n \n+\t/* issue a monitor message */\n+\tif (s->monitor_fn) {\n+\t\tmsg.type = rpc_lookup_name;\n+\t\tmsg_lookup = talloc(s, struct msg_rpc_lookup_name);\n+\t\tmsg_lookup->rid = s->lookup.out.rids.ids;\n+\t\tmsg_lookup->count = s->lookup.out.rids.count;\n+\t\tmsg.data = (void*)msg_lookup;\n+\t\tmsg.data_size = sizeof(*msg_lookup);\n+\t\t\n+\t\ts->monitor_fn(&msg);\n+\t}\n+\t\n+\n \t/* have we actually got name resolved\n \t   - we're looking for only one at the moment */\n \tif (s->lookup.out.rids.count == 0) {\n-\t\treturn NT_STATUS_NO_SUCH_USER;\n+\t\tcomposite_error(c, NT_STATUS_NO_SUCH_USER);\n \t}\n \n \t/* TODO: find proper status code for more than one rid found */\n@@ -81,168 +106,143 @@\n \ts->openuser.out.user_handle   = &s->user_handle;\n \n \t/* send request */\n-\ts->req = dcerpc_samr_OpenUser_send(s->pipe, c, &s->openuser);\n-\tif (s->req == NULL) goto failure;\n+\topenuser_req = dcerpc_samr_OpenUser_send(s->pipe, c, &s->openuser);\n+\tif (composite_nomem(openuser_req, c)) return;\n \n-\ts->req->async.callback = userinfo_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = USERINFO_OPENUSER;\n-\n-\treturn NT_STATUS_OK;\n-\n-failure:\n-\treturn NT_STATUS_UNSUCCESSFUL;\n+\tcomposite_continue_rpc(c, openuser_req, continue_userinfo_openuser, c);\n }\n \n \n /**\n  * Stage 2: Open user policy handle.\n  */\n-static NTSTATUS userinfo_openuser(struct composite_context *c,\n-\t\t\t\t  struct userinfo_state *s)\n+static void continue_userinfo_openuser(struct rpc_request *req)\n {\n+\tstruct composite_context *c;\n+\tstruct userinfo_state *s;\n+\tstruct rpc_request *queryuser_req;\n+\tstruct monitor_msg msg;\n+\tstruct msg_rpc_open_user *msg_open;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct userinfo_state);\n+\n \t/* receive samr_OpenUser reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n+\n+\tif (!NT_STATUS_IS_OK(s->queryuserinfo.out.result)) {\n+\t\tcomposite_error(c, s->queryuserinfo.out.result);\n+\t\treturn;\n+\t}\n+\n+\t/* issue a monitor message */\n+\tif (s->monitor_fn) {\n+\t\tmsg.type = rpc_open_user;\n+\t\tmsg_open = talloc(s, struct msg_rpc_open_user);\n+\t\tmsg_open->rid = s->openuser.in.rid;\n+\t\tmsg_open->access_mask = s->openuser.in.access_mask;\n+\t\tmsg.data = (void*)msg_open;\n+\t\tmsg.data_size = sizeof(*msg_open);\n+\t\t\n+\t\ts->monitor_fn(&msg);\n+\t}\n \t\n \t/* prepare parameters for QueryUserInfo call */\n \ts->queryuserinfo.in.user_handle = &s->user_handle;\n \ts->queryuserinfo.in.level       = s->level;\n \t\n \t/* queue rpc call, set event handling and new state */\n-\ts->req = dcerpc_samr_QueryUserInfo_send(s->pipe, c, &s->queryuserinfo);\n-\tif (s->req == NULL) goto failure;\n+\tqueryuser_req = dcerpc_samr_QueryUserInfo_send(s->pipe, c, &s->queryuserinfo);\n+\tif (composite_nomem(queryuser_req, c)) return;\n \t\n-\ts->req->async.callback = userinfo_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = USERINFO_GETUSER;\n-\t\n-\treturn NT_STATUS_OK;\n-\n-failure:\n-\treturn NT_STATUS_UNSUCCESSFUL;\n+\tcomposite_continue_rpc(c, queryuser_req, continue_userinfo_getuser, c);\n }\n \n \n /**\n  * Stage 3: Get requested user information.\n  */\n-static NTSTATUS userinfo_getuser(struct composite_context *c,\n-\t\t\t\t struct userinfo_state *s)\n+static void continue_userinfo_getuser(struct rpc_request *req)\n {\n+\tstruct composite_context *c;\n+\tstruct userinfo_state *s;\n+\tstruct rpc_request *close_req;\n+\tstruct monitor_msg msg;\n+\tstruct msg_rpc_query_user *msg_query;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct userinfo_state);\n+\n \t/* receive samr_QueryUserInfo reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \n \t/* check if queryuser itself went ok */\n-\tNT_STATUS_NOT_OK_RETURN(s->queryuserinfo.out.result);\n+\tif (!NT_STATUS_IS_OK(s->queryuserinfo.out.result)) {\n+\t\tcomposite_error(c, s->queryuserinfo.out.result);\n+\t\treturn;\n+\t}\n \n \ts->info = talloc_steal(s, s->queryuserinfo.out.info);\n+\n+\t/* issue a monitor message */\n+\tif (s->monitor_fn) {\n+\t\tmsg.type = rpc_query_user;\n+\t\tmsg_query = talloc(s, struct msg_rpc_query_user);\n+\t\tmsg_query->level = s->queryuserinfo.in.level;\n+\t\tmsg.data = (void*)msg_query;\n+\t\tmsg.data_size = sizeof(*msg_query);\n+\t\t\n+\t\ts->monitor_fn(&msg);\n+\t}\n \t\n \t/* prepare arguments for Close call */\n \ts->samrclose.in.handle  = &s->user_handle;\n \ts->samrclose.out.handle = &s->user_handle;\n \t\n \t/* queue rpc call, set event handling and new state */\n-\ts->req = dcerpc_samr_Close_send(s->pipe, c, &s->samrclose);\n+\tclose_req = dcerpc_samr_Close_send(s->pipe, c, &s->samrclose);\n+\tif (composite_nomem(close_req, c)) return;\n \t\n-\ts->req->async.callback = userinfo_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = USERINFO_CLOSEUSER;\n-\n-\treturn NT_STATUS_OK;\n+\tcomposite_continue_rpc(c, close_req, continue_userinfo_closeuser, c);\n }\n \n \n /**\n  * Stage 4: Close policy handle associated with opened user.\n  */\n-static NTSTATUS userinfo_closeuser(struct composite_context *c,\n-\t\t\t\t   struct userinfo_state *s)\n+static void continue_userinfo_closeuser(struct rpc_request *req)\n {\n-\t/* receive samr_Close reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n-\n-\tc->state = COMPOSITE_STATE_DONE;\n-\n-\treturn NT_STATUS_OK;\n-}\n-\n-\n-/**\n- * Event handler for asynchronous request. Handles transition through\n- * intermediate stages of the call.\n- *\n- * @param req rpc call context\n- */\n-static void userinfo_handler(struct rpc_request *req)\n-{\n-\tstruct composite_context *c = req->async.private;\n-\tstruct userinfo_state *s = talloc_get_type(c->private_data, struct userinfo_state);\n+\tstruct composite_context *c;\n+\tstruct userinfo_state *s;\n \tstruct monitor_msg msg;\n-\tstruct msg_rpc_lookup_name *msg_lookup;\n-\tstruct msg_rpc_open_user *msg_open;\n-\tstruct msg_rpc_query_user *msg_query;\n \tstruct msg_rpc_close_user *msg_close;\n-\t\n-\t/* Stages of the call */\n-\tswitch (s->stage) {\n-\tcase USERINFO_LOOKUP:\n-\t\tc->status = userinfo_lookup(c, s);\n \n-\t\tmsg.type = rpc_lookup_name;\n-\t\tmsg_lookup = talloc(s, struct msg_rpc_lookup_name);\n-\t\tmsg_lookup->rid = s->lookup.out.rids.ids;\n-\t\tmsg_lookup->count = s->lookup.out.rids.count;\n-\t\tmsg.data = (void*)msg_lookup;\n-\t\tmsg.data_size = sizeof(*msg_lookup);\n-\t\tbreak;\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct userinfo_state);\n \n-\tcase USERINFO_OPENUSER:\n-\t\tc->status = userinfo_openuser(c, s);\n+\t/* receive samr_Close reply */\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \n-\t\tmsg.type = rpc_open_user;\n-\t\tmsg_open = talloc(s, struct msg_rpc_open_user);\n-\t\tmsg_open->rid = s->openuser.in.rid;\n-\t\tmsg_open->access_mask = s->openuser.in.access_mask;\n-\t\tmsg.data = (void*)msg_open;\n-\t\tmsg.data_size = sizeof(*msg_open);\n-\t\tbreak;\n+\tif (!NT_STATUS_IS_OK(s->samrclose.out.result)) {\n+\t\tcomposite_error(c, s->samrclose.out.result);\n+\t\treturn;\n+\t}\n \n-\tcase USERINFO_GETUSER:\n-\t\tc->status = userinfo_getuser(c, s);\n-\n-\t\tmsg.type = rpc_query_user;\n-\t\tmsg_query = talloc(s, struct msg_rpc_query_user);\n-\t\tmsg_query->level = s->queryuserinfo.in.level;\n-\t\tmsg.data = (void*)msg_query;\n-\t\tmsg.data_size = sizeof(*msg_query);\n-\t\tbreak;\n-\t\t\n-\tcase USERINFO_CLOSEUSER:\n-\t\tc->status = userinfo_closeuser(c, s);\n-\n+\t/* issue a monitor message */\n+\tif (s->monitor_fn) {\n \t\tmsg.type = rpc_close_user;\n \t\tmsg_close = talloc(s, struct msg_rpc_close_user);\n \t\tmsg_close->rid = s->openuser.in.rid;\n \t\tmsg.data = (void*)msg_close;\n \t\tmsg.data_size = sizeof(*msg_close);\n-\t\tbreak;\n-\t}\n \n-\tif (!NT_STATUS_IS_OK(c->status)) {\n-\t\tc->state = COMPOSITE_STATE_ERROR;\n-\t}\n-\t\n-\tif (s->monitor_fn) {\n \t\ts->monitor_fn(&msg);\n \t}\n \n-\tif (c->state >= COMPOSITE_STATE_DONE &&\n-\t    c->async.fn) {\n-\t\tc->async.fn(c);\n-\t}\n+\tcomposite_done(c);\n }\n \n \n@@ -259,6 +259,7 @@\n \tstruct composite_context *c;\n \tstruct userinfo_state *s;\n \tstruct dom_sid *sid;\n+\tstruct rpc_request *openuser_req, *lookup_req;\n \n \tif (!p || !io) return NULL;\n \t\n@@ -285,11 +286,11 @@\n \t\ts->openuser.out.user_handle   = &s->user_handle;\n \t\t\n \t\t/* send request */\n-\t\ts->req = dcerpc_samr_OpenUser_send(p, c, &s->openuser);\n-\t\tif (composite_nomem(s->req, c)) return c;\n-\t\t\n-\t\ts->stage = USERINFO_OPENUSER;\n+\t\topenuser_req = dcerpc_samr_OpenUser_send(p, c, &s->openuser);\n+\t\tif (composite_nomem(openuser_req, c)) return c;\n \n+\t\tcomposite_continue_rpc(c, openuser_req, continue_userinfo_openuser, c);\n+\n \t} else {\n \t\t/* preparing parameters to send rpc request */\n \t\ts->lookup.in.domain_handle    = &s->domain_handle;\n@@ -300,16 +301,12 @@\n \t\ts->lookup.in.names[0].string  = talloc_strdup(s, io->in.username);\n \t\t\n \t\t/* send request */\n-\t\ts->req = dcerpc_samr_LookupNames_send(p, c, &s->lookup);\n-\t\tif (composite_nomem(s->req, c)) return c;\n+\t\tlookup_req = dcerpc_samr_LookupNames_send(p, c, &s->lookup);\n+\t\tif (composite_nomem(lookup_req, c)) return c;\n \t\t\n-\t\ts->stage = USERINFO_LOOKUP;\n+\t\tcomposite_continue_rpc(c, lookup_req, continue_userinfo_lookup, c);\n \t}\n \n-\t/* callback handler */\n-\ts->req->async.callback = userinfo_handler;\n-\ts->req->async.private = c;\n-\n \treturn c;\n }\n \n\n"}
{"category": "ham", "to_address": "ted.harding@manchester.ac.uk, r-help@stat.math.ethz.ch", "from_address": "\"Alberto Monteiro\" <albmont@centroin.com.br>", "subject": "Re: [R] convergence", "body": "\nTed Harding wrote:\n> \n> There are various ways round this, but a 'for' loop with\n> a fixed number of iterations is not usully one of them!\n> \n> The simplest is to use while(). A possibly strategy is\n> \n>   Y.old <- initial.Y\n>   while(TRUE){\n>     Y <- compute.Y(Y.old, ...)\n>     if(abs(Y - Y.old) < small.number) break\n>     Y.old <- Y\n>   }\n> \n> This will loop indefinitely until the convergence criterion\n> \n>   abs(Y - Y.old) < small.number\n> \n> is met, and then stop.\n> \nI guess some precaution must be taken to prevent that the loop\nruns forever.\n\nThose algorithms that must optimize something, but run the risk \nof running forever, sound like the \"chess playing\" engine: we\nknow that a deterministic solution exists (there is a finite number\nof chess positions), but it's not practical to check all of them.\n\nI read somewhere that computer loop problems are treated as if\nthe computer was \"playing chess\" agains Murphy: it tries hard to\nsolve the problem, but sometimes he must give up a path and backtrack\nto a less optimum but faster solution.\n\nDo I make any sense?\n\nAlberto Monteiro\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
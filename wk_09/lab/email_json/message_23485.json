{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 256: added tdb_chainlock_mark() call,\n\twhich can be used to mark a chain locked without actually locking\n\tit. This will be used to guarantee forward progress in the\n\tctdb non-blocking lockwait code in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 256\nrevision-id: tridge@samba.org-20070505071433-i3i06lprinozpxhe\nparent: tridge@samba.org-20070505040946-iji1cxsyb8ail7bk\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sat 2007-05-05 17:14:33 +1000\nmessage:\n  added tdb_chainlock_mark() call, which can be used to mark a chain locked without actually locking it. This will be used to guarantee forward progress in the ctdb non-blocking lockwait code\nmodified:\n  lib/tdb/common/lock.c          lock.c-20070220022425-m1wibgjq7n5hahs6-7\n  lib/tdb/include/tdb.h          tdb.h-20070125040949-7t3f5zdl1q4z9hyv-101\n=== modified file 'lib/tdb/common/lock.c'\n--- a/lib/tdb/common/lock.c\t2007-04-16 13:03:36 +0000\n+++ b/lib/tdb/common/lock.c\t2007-05-05 07:14:33 +0000\n@@ -28,6 +28,8 @@\n \n #include \"tdb_private.h\"\n \n+#define TDB_MARK_LOCK 0x80000000\n+\n /* a byte range locking function - return 0 on success\n    this functions locks/unlocks 1 byte at the specified offset.\n \n@@ -109,6 +111,9 @@\n {\n \tstruct tdb_lock_type *new_lck;\n \tint i;\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n+\n+\tltype &= ~TDB_MARK_LOCK;\n \n \t/* a global lock allows us to avoid per chain locks */\n \tif (tdb->global_lock.count && \n@@ -158,7 +163,8 @@\n \n \t/* Since fcntl locks don't nest, we do a lock for the first one,\n \t   and simply bump the count for future ones */\n-\tif (tdb->methods->tdb_brlock(tdb,FREELIST_TOP+4*list,ltype, op,\n+\tif (!mark_lock &&\n+\t    tdb->methods->tdb_brlock(tdb,FREELIST_TOP+4*list, ltype, op,\n \t\t\t\t     0, 1)) {\n \t\treturn -1;\n \t}\n@@ -200,6 +206,9 @@\n \tint ret = -1;\n \tint i;\n \tstruct tdb_lock_type *lck = NULL;\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n+\n+\tltype &= ~TDB_MARK_LOCK;\n \n \t/* a global lock allows us to avoid per chain locks */\n \tif (tdb->global_lock.count && \n@@ -244,8 +253,12 @@\n \t * anyway.\n \t */\n \n-\tret = tdb->methods->tdb_brlock(tdb, FREELIST_TOP+4*list, F_UNLCK,\n-\t\t\t\t       F_SETLKW, 0, 1);\n+\tif (mark_lock) {\n+\t\tret = 0;\n+\t} else {\n+\t\tret = tdb->methods->tdb_brlock(tdb, FREELIST_TOP+4*list, F_UNLCK,\n+\t\t\t\t\t       F_SETLKW, 0, 1);\n+\t}\n \ttdb->num_locks--;\n \n \t/*\n@@ -376,6 +389,18 @@\n \treturn tdb_lock_nonblock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK);\n }\n \n+/* mark a chain as locked without actually locking it. Warning! use with great caution! */\n+int tdb_chainlock_mark(struct tdb_context *tdb, TDB_DATA key)\n+{\n+\treturn tdb_lock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK | TDB_MARK_LOCK);\n+}\n+\n+/* unmark a chain as locked without actually locking it. Warning! use with great caution! */\n+int tdb_chainlock_unmark(struct tdb_context *tdb, TDB_DATA key)\n+{\n+\treturn tdb_unlock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK | TDB_MARK_LOCK);\n+}\n+\n int tdb_chainunlock(struct tdb_context *tdb, TDB_DATA key)\n {\n \treturn tdb_unlock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK);\n\n=== modified file 'lib/tdb/include/tdb.h'\n--- a/lib/tdb/include/tdb.h\t2007-05-04 12:18:00 +0000\n+++ b/lib/tdb/include/tdb.h\t2007-05-05 07:14:33 +0000\n@@ -140,6 +140,8 @@\n int tdb_chainunlock(struct tdb_context *tdb, TDB_DATA key);\n int tdb_chainlock_read(struct tdb_context *tdb, TDB_DATA key);\n int tdb_chainunlock_read(struct tdb_context *tdb, TDB_DATA key);\n+int tdb_chainlock_mark(struct tdb_context *tdb, TDB_DATA key);\n+int tdb_chainlock_unmark(struct tdb_context *tdb, TDB_DATA key);\n \n /* Debug functions. Not used in production. */\n void tdb_dump_all(struct tdb_context *tdb);\n\n"}
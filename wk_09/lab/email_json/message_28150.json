{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 290: the retry client code is no longer needed now that we use\n\ta freeze on recovery in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 290\nrevision-id: tridge@samba.org-20070512095555-59wxjjrspw50l8s9\nparent: tridge@samba.org-20070512095518-py0kxx2oypiqunse\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sat 2007-05-12 19:55:55 +1000\nmessage:\n  the retry client code is no longer needed now that we use a freeze on recovery\nmodified:\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-05-12 08:08:50 +0000\n+++ b/common/ctdb_daemon.c\t2007-05-12 09:55:55 +0000\n@@ -334,31 +334,10 @@\n }\n \n \n-struct ctdb_client_retry {\n-\tstruct ctdb_client *client;\n-\tstruct ctdb_req_call *call;\n-};\n-\n static void daemon_request_call_from_client(struct ctdb_client *client, \n \t\t\t\t\t    struct ctdb_req_call *c);\n \n /*\n-  triggered after a one second delay, retrying a client packet\n-  that was deferred because of the daemon being in recovery mode\n- */\n-static void retry_client_packet(struct event_context *ev, struct timed_event *te, \n-\t\t\t\tstruct timeval t, void *private_data)\n-{\n-\tstruct ctdb_client_retry *retry = talloc_get_type(private_data, struct ctdb_client_retry);\n-\n-\tdaemon_request_call_from_client(retry->client, retry->call);\n-\n-\ttalloc_free(retry);\n-}\n-\n-\n-\n-/*\n   this is called when the ctdb daemon received a ctdb request call\n   from a local client over the unix domain socket\n  */\n@@ -374,29 +353,6 @@\n \tint ret;\n \tstruct ctdb_context *ctdb = client->ctdb;\n \n-\tif (ctdb->recovery_mode != CTDB_RECOVERY_NORMAL) {\n-\t\tstruct ctdb_client_retry *retry;\n-\t\t\n-\t\tDEBUG(0,(__location__ \" ctdb call %u from client\"\n-\t\t\t \" while we are in recovery mode. Deferring it\\n\", \n-\t\t\t c->hdr.reqid)); \n-\n-\t\t/* hang the event and the structure off client */\n-\t\tretry = talloc(client, struct ctdb_client_retry);\n-\t\tCTDB_NO_MEMORY_VOID(ctdb, retry);\n-\t\tretry->client = client;\n-\t\tretry->call   = c;\n-\t\t\n-\t\t/* this ensures that after the retry happens we\n-\t\t   eventually free this request */\n-\t\ttalloc_steal(retry, c);\n-\t\t\n-\t\tevent_add_timed(ctdb->ev, retry, timeval_current_ofs(1,0), retry_client_packet, retry);\n-\t\treturn;\n-\t}\n-\n-\n-\n \tctdb->status.total_calls++;\n \tctdb->status.pending_calls++;\n \n\n"}
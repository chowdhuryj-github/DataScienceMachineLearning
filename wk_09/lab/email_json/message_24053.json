{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "pancake <pancake@youterm.com>", "subject": "Re: mmx/sse copy functions (was: Puzzling structure in\n <parrot/stacks.h>)", "body": "I think that the right way to handle paddings for memory alignment\nis using the pack(1) pragma directive to make everything fit on 1\nbyte and ensure by code that what we do is correct (instead of\nrelaying this task to the compiler).\n\nOf course..if any compiler does not supports this directive we\nshould not use it.\n\nHere's a example:\n\n$ cat foo.c\n#pragma pack(1)\nstruct { char foo; int bar; } str;\nmain() { printf(\"%d\\n\", sizeof(str)); }\n\n$ gcc foo.c\n$ ./a.out\n5\n\nWe can pack to 4 or so...some compilers (aka gcc) returns some\nnasty sizes when measuring..(not necessary aligned to 4).\n\n--pancake\n\nOn Thu, 26 Apr 2007 22:44:05 +0200\nLeopold Toetsch  wrote:\n\n> Am Donnerstag, 26. April 2007 21:44 schrieb Andy Spieherty:\n> > Does anyone understand the 'dummy' element in\n> > include/parrot/stacks.h?  Here is the relevant snippet:\n> >\n> >     typedef struct Stack_Chunk {\n> >         pobj_t obj;\n> >         int size;\n> >         const char * name;\n> >         struct Stack_Chunk *prev;\n> >     #if ! DISABLE_GC_DEBUG && defined(I386)\n> >         void * dummy;   /* force 8 byte align for mmx and sse moves */\n> >     #endif\n> >         union { /* force appropriate alignment of 'data' */\n> >             void *data;\n> >     #ifndef I386\n> >             double d_dummy;         /* align double values on stack */\n> >     #endif\n> >         } u;\n> >     } Stack_Chunk_t;\n> >\n> > (I assume that mmx and sse are some sort of i386-specific instructions.)\n> \n> Indeed.\n> \n> > Specifically, I'm wondering about two things:\n> >\n> > 1.  Is the comment backwards?  If I count correctly, including the\n> >     void *dummy means that u.data will *NOT* be aligned on an 8-byte\n> >     boundary.  Is that the actual intent?  (Of course, compilers are\n> >     free to add in extra padding inside structures, and it may end up\n> >     aligned with some compilers but not aligned with others.)\n> \n> At some earlier time in parrot history, there was a (32 bit, pointer-sized) \n> 'version' [1] structure item in pobj_t, which was active \n> with !DISABLE_GC_DEBUG. The dummy was needed for i386 (when x86_64 didn't \n> even exist) to align the data pointer at an 8-byte boundary.\n> \n> The assembly coded mmx/sse copy subroutines were active at that time and did \n> introduce a nice speedup.\n> These copy functions were used to copy register frames at - hmmm ancient - \n> times before parrot got more than 32 registers.\n> \n> As the past tense is indicating, above dummy is totally obsolete and the copy \n> functions[2] are unused. The latter could be removed too, but might be a \n> nice-to-have, when something faster than memcpy(3) is wanted or needed, \n> albeit only on restricted (but common) platforms and for aligned memory only. \n> Some recent CPUs do have special instructions for copying unaligned memory \n> reegions too.\n> \n> leo\n> \n> [1] it was renamed later to a similar name and was removed thereafter:\n>     $ svn log include/parrot/pobj.h | grep version\n> \n> [2] see also these (and related) in the parrot tree\n>     $ find . -type f | egrep '_mmx|_sse' | grep -v svn\n>     $ find . -type f | xargs grep mmx # ...\n> \n\n\n  --pancake\n\n"}
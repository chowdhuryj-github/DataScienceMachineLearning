{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "Prasenjit Kapat <kapatp@gmail.com>", "subject": "[R] use loop or use apply?", "body": "Hi,\n\nI have two matrices, A (axd) and B (bxd). I want to get another matrix C (axb) \nsuch that, C[i,j] is the Euclidean distance between the ith row of A and jth \nrow of B. In general, I can say that C[i,j] = some.function (A[i,], B[j,]). \nWhat is the best method for doing so? (assume a < b)\n\nI have been doing some exploration myself: Consider the following function: \nget.f, in which, 'method=1' is the rudimentary double for loop; 'method=2' \navoids one loop by constructing a bigger matrix, but doesn't use \napply(); 'method=3' avoids both the loops by using apply() and constructing \nbigger matrices; 'method=4' avoids constructing bigger matrices by using \napply() twice.\n\nget.f <- function (A, B, method=2) {\n\tif (method == 1){\n\t\ta <- nrow(A); b <- nrow(B);\n\t\tC <- matrix(NA, nrow=a, ncol=b);\n\t\tfor (i in 1:a) \n\t\t\tfor (j in 1:b) \n\t\t\t\tC[i,j] <- sum((A[i,]-B[j,])^2)\n\t} else if (method == 2 ) {\n\t\ta <- nrow(A); b <- nrow(B); d <- ncol(A);\n\t\tC <- matrix(NA, nrow=a, ncol=b);\n\t\tfor (i in 1:a) \n\t\t\tC[i,] <- rowSums((matrix(A[i,], nrow=b, ncol=d, byrow=TRUE) - B) ^ 2)\n\t} else if (method == 3) {\n\t\t\tC <- t(apply(A, MARGIN=1, FUN=\"FUN1\", BB=B)); # transpose is needed\n\t} else if (method == 4) {\n\t\t\tC <- t(apply(A, MARGIN=1, FUN=\"FUN2\", BB=B))\n\t}\n}\n\nFUN1 <- function(aa, BB)\n  return(rowSums(\n\t\t(matrix(aa, nrow=nrow(BB), ncol=ncol(BB), byrow=TRUE) - BB)^2)\n  )\n\nFUN2 <- function(aa, BB)\n\treturn(apply(BB, MARGIN=1, FUN=\"FUN3\", aa=aa))\n\nFUN3 <- function(bb,aa) return(sum((aa-bb)^2))\n\n### With these methods and the following intitializations,\n\na <- 100; b <- 1000; d <- 100; n.loop <- 20;\n\nA <- matrix(rnorm(a*d), ncol=d)\nB <- matrix(rnorm(b*d), ncol=d)\n\nall.times <- matrix(0,nrow=5,ncol=4)\nrownames(all.times) <- rownames(as.matrix(system.time(NULL)))\n\nfor (i in 1:4)  \n\tfor (j in 1:n.loop)\n\t\tall.times[,i] <- all.times[,i] + \n\t\t\t\tas.matrix(system.time(C <- get.f(A=A, B=B, method=i)))\n\nall.times <- all.times / n.loop\nprint(all.times)\n\n               [,1]    [,2]    [,3]    [,4]\nuser.self   4.0554 1.50010 1.50130 4.51285\nsys.self     0.0370 0.02420 0.01800 0.04260\nelapsed    4.2705 1.58865 1.59475 6.07535\nuser.child 0.0000 0.00000 0.00000 0.00000\nsys.child   0.0000 0.00000 0.00000 0.00000\n\n'method=2' stands out be the best and 'method=1' (for loops) beats 'method=4' \n(two apply()s)... Is that expected?\n\nIs it possible to improve over 'method=2'?\n\nThanks\nPK\n\nPS: The mail text seems fine in my composer, I hope, it looks decent in your \nreader.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
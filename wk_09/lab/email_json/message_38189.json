{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jerry@samba.org", "subject": "svn commit: samba r23190 - in branches/SAMBA_3_0_26/source: auth\n\tinclude lib smbd", "body": "Author: jerry\nDate: 2007-05-29 12:53:42 +0000 (Tue, 29 May 2007)\nNew Revision: 23190\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23190\n\nLog:\nsvn merge ../SAMBA_3_0 -r22019:22026\n\nThis is abartlet's talloc changes to the samu struct stored \nin the server info state.\n\n\nModified:\n   branches/SAMBA_3_0_26/source/auth/auth_sam.c\n   branches/SAMBA_3_0_26/source/auth/auth_util.c\n   branches/SAMBA_3_0_26/source/include/smb.h\n   branches/SAMBA_3_0_26/source/lib/util_pw.c\n   branches/SAMBA_3_0_26/source/smbd/password.c\n   branches/SAMBA_3_0_26/source/smbd/session.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/auth/auth_sam.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/auth/auth_sam.c\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/auth/auth_sam.c\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -263,10 +263,10 @@\n \t\treturn NT_STATUS_UNSUCCESSFUL;\n \t}\n \n-\t/* Can't use the talloc version here, because the returned struct gets\n-\t   kept on the server_info */\n+\t/* the returned struct gets kept on the server_info, by means\n+\t   of a steal further down */\n \n-\tif ( !(sampass = samu_new( NULL )) ) {\n+\tif ( !(sampass = samu_new( mem_ctx )) ) {\n \t\treturn NT_STATUS_NO_MEMORY;\n \t}\n \n\nModified: branches/SAMBA_3_0_26/source/auth/auth_util.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/auth/auth_util.c\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/auth/auth_util.c\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -561,19 +561,23 @@\n \tDOM_SID unix_group_sid;\n \t\n \n-\tif ( !(pwd = getpwnam_alloc(NULL, pdb_get_username(sampass))) ) {\n+\tif ( !(result = make_server_info(NULL)) ) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tif ( !(pwd = getpwnam_alloc(result, pdb_get_username(sampass))) ) {\n \t\tDEBUG(1, (\"User %s in passdb, but getpwnam() fails!\\n\",\n \t\t\t  pdb_get_username(sampass)));\n+\t\tTALLOC_FREE(result);\n \t\treturn NT_STATUS_NO_SUCH_USER;\n \t}\n \n-\tif ( !(result = make_server_info(NULL)) ) {\n-\t\tTALLOC_FREE(pwd);\n-\t\treturn NT_STATUS_NO_MEMORY;\n-\t}\n-\n \tresult->sam_account = sampass;\n-\tresult->unix_name = talloc_strdup(result, pwd->pw_name);\n+\t/* Ensure thaat the sampass will be freed with the result */\n+\ttalloc_steal(result, sampass);\n+\tresult->unix_name = pwd->pw_name;\n+\t/* Ensure that we keep pwd->pw_name, because we will free pwd below */\n+\ttalloc_steal(result, pwd->pw_name);\n \tresult->gid = pwd->pw_gid;\n \tresult->uid = pwd->pw_uid;\n \t\n\nModified: branches/SAMBA_3_0_26/source/include/smb.h\n===================================================================\n--- branches/SAMBA_3_0_26/source/include/smb.h\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/include/smb.h\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -1757,9 +1757,9 @@\n \tgid_t gid; /* gid of a validated user */\n \n \tuserdom_struct user;\n-\tchar *homedir;\n-\tchar *unix_homedir;\n-\tchar *logon_script;\n+\tconst char *homedir;\n+\tconst char *unix_homedir;\n+\tconst char *logon_script;\n \t\n \tBOOL guest;\n \n\nModified: branches/SAMBA_3_0_26/source/lib/util_pw.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/util_pw.c\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/lib/util_pw.c\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -74,7 +74,7 @@\n \t\tif ((pwnam_cache[i] != NULL) && \n \t\t    (strcmp(name, pwnam_cache[i]->pw_name) == 0)) {\n \t\t\tDEBUG(10, (\"Got %s from pwnam_cache\\n\", name));\n-\t\t\treturn (struct passwd *)talloc_reference(mem_ctx, pwnam_cache[i]);\n+\t\t\treturn tcopy_passwd(mem_ctx, pwnam_cache[i]);\n \t\t}\n \t}\n \n@@ -98,15 +98,15 @@\n \t\ti = rand() % PWNAMCACHE_SIZE;\n \n \tif (pwnam_cache[i] != NULL) {\n-\t\tTALLOC_FREE(pwnam_cache[i]);\n+\t\t/* Remove this old cache entry, from the cache.  We\n+\t\t * use talloc_unlink here because we want to be very\n+\t\t * clear which referece we are removing */\n+\t\ttalloc_unlink(pwnam_cache, pwnam_cache[i]);\n \t}\n \n \tpwnam_cache[i] = tcopy_passwd(pwnam_cache, temp);\n-\tif (pwnam_cache[i]!= NULL && mem_ctx != NULL) {\n-\t\treturn (struct passwd *)talloc_reference(mem_ctx, pwnam_cache[i]);\n-\t}\n \n-\treturn tcopy_passwd(NULL, pwnam_cache[i]);\n+\treturn tcopy_passwd(mem_ctx, temp);\n }\n \n struct passwd *getpwuid_alloc(TALLOC_CTX *mem_ctx, uid_t uid) \n\nModified: branches/SAMBA_3_0_26/source/smbd/password.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/smbd/password.c\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/smbd/password.c\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -92,15 +92,8 @@\n \tif (vuser == NULL)\n \t\treturn;\n \t\n-\tSAFE_FREE(vuser->homedir);\n-\tSAFE_FREE(vuser->unix_homedir);\n-\tSAFE_FREE(vuser->logon_script);\n-\t\n \tsession_yield(vuser);\n-\tSAFE_FREE(vuser->session_keystr);\n \n-\tTALLOC_FREE(vuser->server_info);\n-\n \tdata_blob_free(&vuser->session_key);\n \n \tDLIST_REMOVE(validated_users, vuser);\n@@ -109,10 +102,7 @@\n \t   from the vuid 'owner' of connections */\n \tconn_clear_vuid_cache(vuid);\n \n-\tSAFE_FREE(vuser->groups);\n-\tTALLOC_FREE(vuser->nt_user_token);\n-\n-\tSAFE_FREE(vuser);\n+\tTALLOC_FREE(vuser);\n \tnum_validated_vuids--;\n }\n \n@@ -153,7 +143,7 @@\n \t\t  DATA_BLOB session_key, DATA_BLOB response_blob,\n \t\t  const char *smb_name)\n {\n-\tuser_struct *vuser = NULL;\n+\tuser_struct *vuser;\n \n \t/* Paranoia check. */\n \tif(lp_security() == SEC_SHARE) {\n@@ -166,14 +156,12 @@\n \t\treturn UID_FIELD_INVALID;\n \t}\n \n-\tif((vuser = SMB_MALLOC_P(user_struct)) == NULL) {\n-\t\tDEBUG(0,(\"Failed to malloc users struct!\\n\"));\n+\tif((vuser = talloc_zero(NULL, user_struct)) == NULL) {\n+\t\tDEBUG(0,(\"Failed to talloc users struct!\\n\"));\n \t\tdata_blob_free(&session_key);\n \t\treturn UID_FIELD_INVALID;\n \t}\n \n-\tZERO_STRUCTP(vuser);\n-\n \t/* Allocate a free vuid. Yes this is a linear search... :-) */\n \twhile( get_valid_user_struct(next_vuid) != NULL ) {\n \t\tnext_vuid++;\n@@ -203,6 +191,11 @@\n \t\treturn vuser->vuid;\n \t}\n \n+\t/* use this to keep tabs on all our info from the authentication */\n+\tvuser->server_info = server_info;\n+\t/* Ensure that the server_info will dissapear with the vuser it is now attached to */\n+\ttalloc_steal(vuser, vuser->server_info);\n+\n \t/* the next functions should be done by a SID mapping system (SMS) as\n \t * the new real sam db won't have reference to unix uids or gids\n \t */\n@@ -212,14 +205,13 @@\n \t\n \tvuser->n_groups = server_info->n_groups;\n \tif (vuser->n_groups) {\n-\t\tif (!(vuser->groups = (gid_t *)memdup(server_info->groups,\n-\t\t\t\t\t\t      sizeof(gid_t) *\n-\t\t\t\t\t\t      vuser->n_groups))) {\n-\t\t\tDEBUG(0,(\"register_vuid: failed to memdup \"\n+\t\tif (!(vuser->groups = (gid_t *)talloc_memdup(vuser, server_info->groups,\n+\t\t\t\t\t\t\t     sizeof(gid_t) *\n+\t\t\t\t\t\t\t     vuser->n_groups))) {\n+\t\t\tDEBUG(0,(\"register_vuid: failed to talloc_memdup \"\n \t\t\t\t \"vuser->groups\\n\"));\n \t\t\tdata_blob_free(&session_key);\n-\t\t\tfree(vuser);\n-\t\t\tTALLOC_FREE(server_info);\n+\t\t\tTALLOC_FREE(vuser);\n \t\t\treturn UID_FIELD_INVALID;\n \t\t}\n \t}\n@@ -247,24 +239,26 @@\n \t\t\tconst char *unix_homedir =\n \t\t\t\tpdb_get_unix_homedir(server_info->sam_account);\n \t\t\tif (unix_homedir) {\n-\t\t\t\tvuser->unix_homedir =\n-\t\t\t\t\tsmb_xstrdup(unix_homedir);\n+\t\t\t\tvuser->unix_homedir = unix_homedir;\n \t\t\t}\n \t\t} else {\n \t\t\tstruct passwd *passwd =\n-\t\t\t\tgetpwnam_alloc(NULL, vuser->user.unix_name);\n+\t\t\t\tgetpwnam_alloc(vuser, vuser->user.unix_name);\n \t\t\tif (passwd) {\n-\t\t\t\tvuser->unix_homedir =\n-\t\t\t\t\tsmb_xstrdup(passwd->pw_dir);\n+\t\t\t\tvuser->unix_homedir = passwd->pw_dir;\n+\t\t\t\t/* Ensure that the unix_homedir now\n+\t\t\t\t * belongs to vuser, so it goes away\n+\t\t\t\t * with it, not with passwd below: */\n+\t\t\t\ttalloc_steal(vuser, vuser->unix_homedir);\n \t\t\t\tTALLOC_FREE(passwd);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (homedir) {\n-\t\t\tvuser->homedir = smb_xstrdup(homedir);\n+\t\t\tvuser->homedir = homedir;\n \t\t}\n \t\tif (logon_script) {\n-\t\t\tvuser->logon_script = smb_xstrdup(logon_script);\n+\t\t\tvuser->logon_script = logon_script;\n \t\t}\n \t}\n \n@@ -280,23 +274,15 @@\n \t\t  vuser->user.full_name));\t\n \n  \tif (server_info->ptok) {\n-\t\tvuser->nt_user_token = dup_nt_token(NULL, server_info->ptok);\n+\t\tvuser->nt_user_token = dup_nt_token(vuser, server_info->ptok);\n \t} else {\n \t\tDEBUG(1, (\"server_info does not contain a user_token - \"\n \t\t\t  \"cannot continue\\n\"));\n-\t\tTALLOC_FREE(server_info);\n+\t\tTALLOC_FREE(vuser);\n \t\tdata_blob_free(&session_key);\n-\t\tSAFE_FREE(vuser->homedir);\n-\t\tSAFE_FREE(vuser->unix_homedir);\n-\t\tSAFE_FREE(vuser->logon_script);\n-\n-\t\tSAFE_FREE(vuser);\n \t\treturn UID_FIELD_INVALID;\n \t}\n \n-\t/* use this to keep tabs on all our info from the authentication */\n-\tvuser->server_info = server_info;\n-\n \tDEBUG(3,(\"UNIX uid %d is UNIX user %s, and will be vuid %u\\n\",\n \t\t (int)vuser->uid,vuser->user.unix_name, vuser->vuid));\n \n\nModified: branches/SAMBA_3_0_26/source/smbd/session.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/smbd/session.c\t2007-05-29 12:18:41 UTC (rev 23189)\n+++ branches/SAMBA_3_0_26/source/smbd/session.c\t2007-05-29 12:53:42 UTC (rev 23190)\n@@ -205,9 +205,9 @@\n \t\t\t       sessionid.id_str, sessionid.id_num);\n \t}\n \n-\tvuser->session_keystr = SMB_STRDUP(keystr);\n+\tvuser->session_keystr = talloc_strdup(vuser, keystr);\n \tif (!vuser->session_keystr) {\n-\t\tDEBUG(0, (\"session_claim:  strdup() failed for session_keystr\\n\"));\n+\t\tDEBUG(0, (\"session_claim:  talloc_strdup() failed for session_keystr\\n\"));\n \t\treturn False;\n \t}\n \treturn True;\n\n"}
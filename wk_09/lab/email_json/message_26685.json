{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "allison@cvs.develooper.com", "subject": "[svn:parrot-pdd] r18492 - trunk/docs/pdds/draft", "body": "Author: allison\nDate: Wed May  9 22:57:21 2007\nNew Revision: 18492\n\nModified:\n   trunk/docs/pdds/draft/pdd17_pmc.pod\n\nLog:\n[pdd] The new combined PMC PDD, a work in progress.\n\n\nModified: trunk/docs/pdds/draft/pdd17_pmc.pod\n==============================================================================\n--- trunk/docs/pdds/draft/pdd17_pmc.pod\t(original)\n+++ trunk/docs/pdds/draft/pdd17_pmc.pod\tWed May  9 22:57:21 2007\n@@ -1,26 +1,34 @@\n-# Copyright (C) 2001-2006, The Perl Foundation.\n+# Copyright (C) 2001-2007, The Perl Foundation.\n # $Id$\n \n =head1 NAME\n \n-docs/pdds/pdd17_basic_types.pod - Parrot's Core PMC types\n+docs/pdds/pdd17_pmc.pod - Parrot Magic Cookies\n \n-{{ NOTE: could use a better name to differentiate it from PDD 04\n-datatypes. Possibly pdd17_core_pmcs.pod. }}\n+=head1 VERSION\n+\n+$Revision$\n \n =head1 ABSTRACT\n \n-This PDD documents the core Parrot PMC types and their behavior.\n+This PDD describes the internal structure and behavior of the Parrot Magic\n+Cookie (PMC) data type. \n \n-=head1 VERSION\n-\n-$Revision$\n \n =head1 DESCRIPTION\n \n-Parrot has a number of core PMC types that all programs can guarantee will be\n-available to them. (With the possible exception of Parrot programs executing on\n-an embedded device or other restricted environment)\n+PMCs implement all internal data types more complex than a simple integer,\n+float, or string, and also the data types of high-level languages.  Nothing\n+outside the core of Parrot (in fact, nothing outside the data type's vtable\n+routines) should infer anything about a PMC (hence the Magic part).\n+\n+This does mean, though, that you need to either know\n+what functions are available and what they do, or have some method of finding\n+out. \n+\n+It's faster if you know which vtable entry does what, so that's the method\n+parrot uses.\n+\n \n =head1 QUESTIONS\n \n@@ -50,11 +58,977 @@\n the limitation. This runs back to Leo's proposal to make PMCs a little more\n flexible, so we wouldn't have to hold all PMCs to the same 8 bits\n \n+=head1 DESCRIPTION\n+\n+=over 4\n+\n+=item - High-level objects can subclass low-level PMCs\n+\n =back\n \n =head1 IMPLEMENTATION\n \n-=head2 Scalar types\n+=head2 Internal structure\n+\n+All PMCs have the form:\n+\n+    struct PMC {\n+        pobj_t obj;\n+        VTABLE *vtable;\n+ #if ! PMC_DATA_IN_EXT\n+        DPOINTER *data;\n+ #endif\n+        struct PMC_EXT *pmc_ext;\n+    };\n+\n+where C is a pointer to an C structure:\n+\n+    typedef struct pobj_t {\n+        UnionVal u;\n+        Parrot_UInt flags;\n+ #if ! DISABLE_GC_DEBUG\n+        UINTVAL _pobj_version;\n+ #endif\n+    } pobj_t;\n+\n+and where:\n+\n+    typedef union UnionVal {\n+        struct {\n+            void * _bufstart;\n+            size_t _buflen;\n+        } _b;\n+        struct {\n+            DPOINTER* _struct_val;\n+            PMC* _pmc_val;\n+        } _ptrs;\n+        INTVAL _int_val;\n+        FLOATVAL _num_val;\n+        struct parrot_string_t * _string_val;\n+    } UnionVal;\n+\n+C holds data associated with the PMC. This can be in the form of an  integer\n+value, a floating-point value, a string value, or a pointer  to other data.\n+C may be empty, since the PMC structure also provides a more general data\n+pointer, but is useful for PMCs which hold only a single piece of data (e.g.\n+C).\n+\n+C holds a set of flags associated with the PMC; these are documented  in\n+F, and are generally only used within the Parrot \n+internals.\n+\n+C<_pobj_version> is only used for debugging Parrot's garbage collector. It is\n+documented elsewhere (well, it will be once we get around to doing that...).\n+\n+C holds a pointer to the B associated with the PMC. This points\n+to a set of functions, with interfaces described in\n+F that implement the basic behaviour of the PMC\n+(i.e. how it behaves under addition, subtraction, cloning etc.)\n+\n+C (if present) holds a pointer to any additional data associated  with\n+the PMC. This may be NULL.\n+\n+C points to an extended PMC structure. This has the form:\n+\n+    struct PMC_EXT {\n+ #if PMC_DATA_IN_EXT\n+        DPOINTER *data;\n+ #endif\n+        PMC *_metadata;\n+        struct _Sync *_synchronize;\n+        PMC *_next_for_GC;\n+    };\n+\n+C is a generic data pointer, as described above.\n+\n+C<_metadata> holds internal PMC metadata. The specification for this has not\n+yet been finalized.\n+\n+C<_synchronize> is for access synchronization between shared PMCs.\n+\n+C<_next_for_GC> determines the next PMC in the 'used' list during dead object \n+detection in the GC.\n+\n+PMCs are not required to have a C structure (i.e. C can be\n+null).\n+\n+PMCs are used to implement the basic data types of the high level languages\n+running on top of Parrot. For instance, a Perl 5 C will map onto one (or\n+more) types of PMC, while particular Python datatypes will map onto different\n+types of PMC.\n+\n+=head2 Vtable Functions\n+\n+Vtables decouple the interface and implementation of various object functions. \n+The actual vtable structure contains pointers to functions that implement the\n+methods for that particular PMC.  All pointers must point to valid functions\n+with appropriate prototypes.\n+\n+In C code, the first parameter to any vtable routine is the current\n+interpreter. The second parameter is the PMC itself.\n+\n+The following list details each of the vtable methods, their prototypes, and\n+their behavior.\n+\n+=head3 Core Vtable Functions\n+\n+=over 4\n+\n+=item void init(INTERP, PMC* self)\n+\n+Called when a PMC is first instantiated. It takes an unused PMC parameter and\n+turns it into a PMC of the appropriate class.\n+\n+=item void init_pmc(INTERP, PMC* self, PMC* initializer)\n+\n+Alternative entry point called when a PMC is first instantiated.  Accepts a PMC\n+parameter used to initialize the given object.  Interpretation of the PMC\n+initializer is left open, each PMC is free to choose its own implemention. A\n+NULL value passed as the initializer parameter is allowed.\n+\n+NOTE: It is strongly suggested that init_pmc(PMCNULL) be equivalent to\n+init(), though there will of necessity be exceptions.\n+\n+=item void morph(INTERP, PMC* self, INTVAL type)\n+\n+Turn the PMC into a PMC of type I. If the morphing can't be done in any\n+reasonable way -- for instance if an integer is asked to turn into an Array --\n+then the PMC is first destroyed, then recreated as an empty PMC of the new\n+type.\n+\n+This method is primarily used when the interpreter has need of coercing a PMC\n+to a particular type, and isn't meant as a general purpose casting tool.\n+Compilers should only emit valid morphing operations.\n+\n+=item void mark(INTERP, PMC* self)\n+\n+Called when the DOD is tracing live PMCs. If this method is called then the\n+code must mark all strings and PMCs that it contains as live, otherwise they\n+may be collected.\n+\n+This method is only called if the DOD has detected that this PMC is both alive\n+and has a custom mark routine as indicated by the custom mark PMC flag.  (Most\n+normal PMCs don't need a custom mark routine.)\n+\n+If a PMC has this flag set, then it is responsible for marking all buffers and\n+PMCs under its control as alive. If it does not, those PMCs or buffers may be\n+collected later. This method does I have to call the C method on any\n+PMCs it marks--the DOD system takes care of that. (So no need to recurse into\n+aggregate PMCs or anything of the sort).\n+\n+This method may allocate no memory from Parrot, nor may it alter Parrot's\n+internal structures. It should have no side-effects from the C level either.\n+This routine may not throw an exception.\n+\n+=item void destroy(INTERP, PMC* self)\n+\n+Called when the PMC is destroyed. This method is called by the DOD when it\n+determines that a PMC is dead and that the PMC has marked itself as having a\n+destroy method (an active finalizer).\n+\n+When this method finishes, the PMC will be marked as dead. As such you should\n+make sure that you don't leave any references to it in any Parrot structure\n+by the end of the method.\n+\n+This method may not throw an exception. It will be ignored if it does.\n+\n+=item PMC* clone(INTERP, PMC* self)\n+\n+Return a clone of a PMC.\n+\n+=item defined\n+\n+=back\n+\n+=head3 Accessors\n+\n+=over 4\n+\n+=item PMC* getprop(INTERP, PMC* self, STRING* key)\n+\n+Return the value from the property hash of I keyed by I. The key\n+should not be NULL.\n+\n+=item void setprop(INTERP, PMC* self, STRING* key, PMC* value)\n+\n+Set the value in the property hash of I that is keyed by I to the\n+value of I. The key should not be NULL.\n+\n+=item void delprop(INTERP, PMC* self, STRING* key)\n+\n+Delete the value from the property hash of I keyed by I. The key\n+should not be NULL.\n+\n+=item PMC* getprops(INTERP, PMC* self)\n+\n+Return the entire property hash for I.\n+\n+=item INTVAL type(INTERP, PMC* self)\n+\n+Return the type of the PMC. Type is a unique number associated with the PMC when\n+the PMC's class is loaded. Negative numbers are considered\n+interpreter-specific, non-public types.\n+\n+=item UINTVAL subtype(INTERP, PMC* self, INTVAL type) [deprecated]\n+\n+Return the subtype of a PMC. (Note that this may be unimplemented, and may go\n+away). This is intended to return information about the PMC--what type of\n+number or string it is, whether it's a scalar, hash, array, or list, and\n+suchlike things.\n+\n+[This can be adequately handled by C and C.]\n+\n+=item STRING* name(INTERP, PMC* self)\n+\n+Return the name of the class for the PMC.\n+\n+=item get_integer\n+\n+  INTVAL get_integer(INTERP, PMC* self)\n+\n+Return the native integer value of the PMC.\n+\n+=item get_number\n+\n+  FLOATVAL get_number(INTERP, PMC* self)\n+\n+Return the native floating-point value of the PMC.\n+\n+=item get_bignum\n+\n+  PMC* get_bignum(INTERP, PMC* self)\n+\n+Return the extended precision numeric value of the PMC as a new bignum PMC.\n+\n+=item get_string\n+\n+  STRING* get_string(INTERP, PMC* self)\n+\n+Return the native string value of the PMC. This may be in any encoding, chosen\n+by the PMC.\n+\n+=item get_bool\n+\n+  INTVAL get_bool(INTERP, PMC* self)\n+\n+Return the true/false value of the PMC (the constant TRUE or the constant\n+FALSE). The definition of truth for a given PMC will depend on the type of the\n+PMC. For a scalar, it may be as simple as returning false when the PMC has a\n+value 0 or \"\", and returning true when the PMC has any other value.\n+\n+=item get_pmc\n+\n+  PMC* get_pmc(INTERP, PMC* self)\n+\n+Return the PMC value for this PMC. This is useful in circumstances where the\n+thing being accessed may return something other than its own value. For\n+example, an array might return a reference to itself. Any PMC may return a\n+value different from the PMC that C is being called on.\n+\n+=item set_integer_native\n+\n+  void set_integer_native(INTERP, PMC* self, INTVAL value)\n+\n+Set the integer value of this PMC from a native integer value (integer\n+register/constant).\n+\n+=item set_integer_same\n+\n+  void set_integer_same(INTERP, PMC* self, PMC* value)\n+\n+Set the value of this PMC from the integer value of another PMC. The value PMC\n+is guaranteed to be of the same type as the I PMC, so optimizations may\n+be made.\n+\n+=item set_number_native\n+\n+  void set_number_native(INTERP, PMC* self, FLOATVAL value)\n+\n+Set the value of this PMC from a native floating-point value (float\n+register/constant).\n+\n+=item set_number_same\n+\n+  void set_number_same(INTERP, PMC* self, PMC* value)\n+\n+Set the value of this PMC from the floating-point value another PMC. The value\n+PMC is guaranteed to be of the same type as the I PMC, so optimizations\n+may be made.\n+\n+=item get_pointer\n+\n+  void* get_pointer(INTERP, PMC* self)\n+\n+Returns a pointer value for the PMC. Useful for PMCs that hold pointers to\n+arbitrary data. The details of the data (type, location etc.) depend on the\n+PMC.\n+\n+=item set_bignum_int\n+\n+  void set_bignum_int(INTERP, PMC* self, INTVAL value)\n+\n+Morph the PMC to a BIGNUM PMC, and set the extended-precision value from a\n+native integer.\n+\n+=item set_string_native\n+\n+  void set_string_native(INTERP, PMC* self, STRING* value)\n+\n+Set the value of this PMC from a native string value (string\n+register/constant).\n+\n+=item assign_string_native\n+\n+  void assign_string_native(INTERP, PMC* self, STRING* value)\n+\n+Set the value of this PMC to a copied native string value (string\n+register/constant).\n+\n+=item set_string_same\n+\n+  void set_string_same(INTERP, PMC* self, PMC* value)\n+\n+Set the value of this PMC from the string value of another PMC. The value PMC\n+is guaranteed to be of the same type as the I PMC, so optimizations may\n+be made.\n+\n+=item set_bool\n+\n+  void set_bool(INTERP, PMC* self, INTVAL value)\n+\n+Set the boolean state of the PMC to TRUE if the native integer value passed in\n+is TRUE, or FALSE if the value is FALSE. The definition of truth is left open\n+to the particular PMC. For a scalar, it may be as simple as setting false when\n+a 0 value is passed in, and seting true when any other value is passed in.\n+\n+=item assign_pmc\n+\n+  void assign_pmc(INTERP, PMC* self, PMC* value)\n+\n+Set the value of the PMC in I to the value of the PMC in I by\n+copying the value.\n+\n+=item set_pmc\n+\n+  void set_pmc(INTERP, PMC* self, PMC* value)\n+\n+Make the PMC in I refer to the PMC passed as I.\n+\n+=item set_pointer\n+\n+  void set_pointer(INTERP, PMC* self, void* value)\n+\n+Set the pointer value of the PMC Useful for PMCs that hold pointers to\n+arbitrary data. The details of the data (type, location etc.) depend on the\n+PMC.\n+\n+=back\n+\n+=head3 Aggregate Vtable Functions\n+\n+Many of the following functions have a *_keyed form, a *_keyed_int form, and a\n+*_keyed_str form. The keyed forms take a PMC*, INTVAL, or STRING* key as a\n+parameter. The PMC* parameter is NULL if there is no key for that\n+PMC; this means that that argument is unkeyed.\n+\n+In some cases, the caller must provide a non-NULL key.  Those cases are\n+explicitly stated below.  In the other cases, you may have to implement the\n+keyed vtable functions and check for a NULL I key even if you are\n+implementing a non-aggregate type.  If the I key is non-NULL and the PMC\n+class is a non-aggregate type, the _keyed_* methods should throw an exception.\n+\n+If you do not implement the *_keyed_int and *_keyed_str functions, the default\n+will convert the INTVAL or STRING* into a key PMC* and call the corresponding\n+*_keyed functions.\n+\n+=over 4\n+\n+=item elements\n+\n+  INTVAL elements(INTERP, PMC* self)\n+\n+Return the number of elements in the PMC.\n+\n+=item get_integer_keyed\n+\n+  INTVAL get_integer_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the integer value for the element indexed by a PMC key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item get_integer_keyed_int\n+\n+  INTVAL get_integer_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the integer value for the element indexed by an integer key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item get_integer_keyed_str\n+\n+  INTVAL get_integer_keyed_str(INTERP, PMC* self, STRING* key)\n+\n+Return the integer value for the element indexed by a string key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item get_number_keyed\n+\n+  FLOATVAL get_number_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the native floating-point value for the element indexed by a PMC key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_number_keyed_int\n+\n+  FLOATVAL get_number_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the native floating-point value for the element indexed by an integer\n+key. The key is guaranteed not to be NULL for this function.\n+\n+=item get_number_keyed_str\n+\n+Return the native floating-point value for the element indexed by a string key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_string_keyed\n+\n+  STRING* get_string_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the string value for the element indexed by a PMC key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_string_keyed_int\n+\n+  STRING* get_string_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the string value for the element indexed by an integer key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_string_keyed_str\n+\n+  STRING* get_string_keyed_str(INTERP, PMC* self, STRING* key)\n+\n+Return the string value for the element indexed by a string key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_bool_keyed\n+\n+Return the boolean value for the element indexed by a PMC key.\n+\n+=item get_bool_keyed_int\n+\n+Return the boolean value for the element indexed by an integer key.\n+\n+=item get_bool_keyed_str\n+\n+Return the boolean value for the element indexed by a string key.\n+\n+=item get_pmc_keyed\n+\n+  PMC* get_pmc_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the PMC value for the element indexed by a PMC key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_pmc_keyed_int\n+\n+  PMC* get_pmc_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the PMC value for the element indexed by an integer key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_pmc_keyed_str\n+\n+  PMC* get_pmc_keyed_str(INTERP, PMC* self, STRING* key)\n+\n+Return the PMC value for the element indexed by a string key.\n+The key is guaranteed not to be NULL for this function.\n+\n+=item get_pointer_keyed\n+\n+  void* get_pointer_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the pointer value for the element indexed by a PMC key. The details of\n+the data (type, location etc.) depend on the PMC.\n+\n+=item get_pointer_keyed_int\n+\n+  void* get_pointer_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the pointer value for the element indexed by an integer key. The\n+details of the data (type, location etc.) depend on the PMC.\n+\n+=item get_pointer_keyed_str\n+\n+  void* get_pointer_keyed_str(INTERP, PMC* self, STRING* key)\n+\n+Return the pointer value for the element indexed by a string key. The details\n+of the data (type, location etc.) depend on the PMC.\n+\n+=item set_integer_keyed\n+\n+  void set_integer_keyed(INTERP, PMC* self, PMC* key, INTVAL value)\n+\n+Set the integer value of the element indexed by a PMC key. The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_integer_keyed_int\n+\n+  void set_integer_keyed_int(INTERP, PMC* self, INTVAL key, INTVAL value)\n+\n+Set the integer value of the element indexed by an integer key. The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_integer_keyed_str\n+\n+  void set_integer_keyed_str(INTERP, PMC* self, STRING* key, INTVAL value)\n+\n+Set the integer value of the element indexed by a string key. The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_number_keyed\n+\n+  void set_number_keyed(INTERP, PMC* self, PMC* key, FLOATVAL value)\n+\n+Set the floating-point value of the element indexed by a PMC key. The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_number_keyed_int\n+\n+  void set_number_keyed_int(INTERP, PMC* self, INTVAL key, FLOATVAL value)\n+\n+Set the floating-point value of the element indexed by an integer key. The key\n+is guaranteed not to be NULL for this function.\n+\n+=item set_number_keyed_str\n+\n+  void set_number_keyed_str(INTERP, PMC* self, STRING* key, FLOATVAL value)\n+\n+Set the floating-point value of the element indexed by a string key. The key\n+is guaranteed not to be NULL for this function.\n+\n+=item set_string_keyed\n+\n+  void set_string_keyed(INTERP, PMC* self, PMC* key, STRING* value)\n+\n+Set the string value of the element indexed by a PMC key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_string_keyed_int\n+\n+  void set_string_keyed_int(INTERP, PMC* self, INTVAL key, STRING* value)\n+\n+Set the string value of the element indexed by an integer key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_string_keyed_str\n+\n+  void set_string_keyed_str(INTERP, PMC* self, STRING* key, STRING* value)\n+\n+Set the string value of the element indexed by a string key.  The key is\n+guaranteed not to be NULL for this function.\n+\n+=item set_pmc_keyed\n+\n+  void set_pmc_keyed(INTERP, PMC* self, PMC* key, PMC* value)\n+\n+Set the value of the element indexed by a PMC key, by copying the value of\n+another PMC.\n+\n+=item set_pmc_keyed_int\n+\n+  void set_pmc_keyed_int(INTERP, PMC* self, INTVAL key, PMC* value)\n+\n+Set the PMC value of the element indexed by an integer key, by copying the\n+value of another PMC.\n+\n+=item set_pmc_keyed_str\n+\n+  void set_pmc_keyed_str(INTERP, PMC* self, STRING* key, PMC* value)\n+\n+Set the PMC value of the element indexed by a string key, by copying the value\n+of another PMC.\n+\n+=item set_pointer_keyed\n+\n+  void set_pointer_keyed(INTERP, PMC* self, PMC* key, void* value)\n+\n+Set the pointer value of the element indexed by a PMC key.\n+\n+=item set_pointer_keyed_int\n+\n+  void set_pointer_keyed_int(INTERP, PMC* self, INTVAL key, void* value)\n+\n+Set the pointer value of the element indexed by an integer key.\n+\n+=item set_pointer_keyed_str\n+\n+  void set_pointer_keyed_str(INTERP, PMC* self, STRING* key, void* value)\n+\n+Set the pointer value of the element indexed by a string key.\n+\n+=item INTVAL type_keyed(INTERP, PMC* self, PMC* key)\n+\n+Return the type number of the PMC indexed by a PMC key.  The I parameter\n+is guaranteed not to be NULL for this method.\n+\n+=item INTVAL type_keyed_int(INTERP, PMC* self, INTVAL key)\n+\n+Return the type number of the PMC indexed by an integer key.  The I\n+parameter is guaranteed not to be NULL for this method.\n+\n+=item INTVAL type_keyed_str(INTERP, PMC* self, STRING* key)\n+\n+Return the type number of the PMC indexed by a string key.  The I\n+parameter is guaranteed not to be NULL for this method.\n+\n+=item pop_integer\n+\n+  INTVAL pop_integer(INTERP, PMC* self)\n+\n+Return the integer value of the last item on the list, removing that item.\n+\n+=item pop_float\n+\n+  FLOATVAL pop_float(INTERP, PMC* self)\n+\n+Return the floating-point value of the last item on the list, removing that\n+item.\n+\n+=item pop_string\n+\n+  STRING* pop_string(INTERP, PMC* self)\n+\n+Return the string value of the last item on the list, removing that item.\n+\n+=item pop_pmc\n+\n+  PMC* pop_pmc(INTERP, PMC* self)\n+\n+Return the PMC value of the last item on the list, removing that item.\n+\n+=item push_integer\n+\n+  void push_integer(INTERP, PMC* self, INTVAL value)\n+\n+Add the passed in integer value to the end of the list.\n+\n+=item push_float\n+\n+  void push_float(INTERP, PMC* self, FLOATVAL value)\n+\n+Add the passed in floating-point number to the end of the list.\n+\n+=item push_string\n+\n+  void push_string(INTERP, PMC* self, STRING* value)\n+\n+Add the passed in string to the end of the list.\n+\n+=item push_pmc\n+\n+  void push_pmc(INTERP, PMC* self, PMC* value)\n+\n+Add the passed in PMC to the end of the list.\n+\n+=item shift_integer\n+\n+  INTVAL shift_integer(INTERP, PMC* self)\n+\n+Return the integer value of the first item on the list, removing that item.\n+\n+=item shift_float\n+\n+  FLOATVAL shift_float(INTERP, PMC* self)\n+\n+Return the floating-point value of the first item on the list, removing that\n+item.\n+\n+=item shift_string\n+\n+  STRING* shift_string(INTERP, PMC* self)\n+\n+Return the string value of the first item on the list, removing that item.\n+\n+=item shift_pmc\n+\n+  PMC* shift_pmc(INTERP, PMC* self)\n+\n+Return the PMC value of the first item on the list, removing that item.\n+\n+=item unshift_integer\n+\n+  void unshift_integer(INTERP, PMC* self, INTVAL value)\n+\n+Add the passed in integer value to the beginning of the list.\n+\n+=item unshift_float\n+\n+  void unshift_float(INTERP, PMC* self, FLOATVAL value)\n+\n+Add the passed in floating-point number to the beginning of the list.\n+\n+=item unshift_string\n+\n+  void unshift_string(INTERP, PMC* self, STRING* value)\n+\n+Add the passed in string to the beginning of the list.\n+\n+=item unshift_pmc\n+\n+  void unshift_pmc(INTERP, PMC* self, PMC* value)\n+\n+Add the passed in PMC to the beginning of the list.\n+\n+=item splice\n+\n+=item void splice(INTERP, PMC* self, PMC* value, INTVAL offset, INTVAL count)\n+\n+Replace the I PMCs at offset I from the beginning of I\n+with the PMCs in the aggregate I.\n+\n+=item exists_keyed\n+\n+=item exists_keyed_int\n+\n+=item exists_keyed_str\n+\n+=item defined_keyed\n+\n+=item defined_keyed_int\n+\n+=item defined_keyed_str\n+\n+=item dtem delete_keyed_str\n+\n+=item nextkey_keyed\n+\n+=item nextkey_keyed_itr_str\n+\n+=back\n+\n+=head3 Math Vtable Functions\n+\n+=over 4\n+\n+=item add\n+\n+  void add(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void add_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  void add_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Add the value of I to the value of a PMC, native integer, or native\n+floating-point number and store the result in a PMC I. Note that I\n+may be the same PMC as I; in that case optimizations may be made.\n+\n+=item subtract\n+\n+  PMC* subtract(INTERP, PMC* self, PMC* value, PMC* dest)\n+  PMC* subtract_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  PMC* subtract_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Subtract the value of a PMC, native integer, or native floating-point number\n+from a PMC and store the result in I. If I is NULL create a result\n+PMC of an appropriate type.  Note that I may be the same PMC as I;\n+in that case optimizations may be made.\n+\n+=item i_subtract\n+\n+  void i_subtract(INTERP, PMC* self, PMC* value)\n+  void i_subtract_int(INTERP, PMC* self, INTVAL value)\n+  void i_subtract_float(INTERP, PMC* self, FLOATVAL value)\n+\n+Inplace operation: subtract a PMC, native integer, or native floating-point\n+number from the value of a PMC and store the result back in the same PMC.\n+\n+=item increment\n+\n+=item decrement\n+\n+=item multiply\n+\n+  void multiply(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void multiply_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  void multiply_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Multiply a PMC, native integer, or floating-point value by the value of the PMC\n+I and store the result in the I PMC. Note that I may be the\n+same PMC as I; in that case optimizations may be made.\n+\n+=item divide\n+\n+  void divide(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void divide_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  void divide_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Divide the value of the I PMC by a PMC, native integer, or native\n+floating-point number and store the result in I.  Note that I may\n+be the same PMC as I; in that case optimizations may be made.\n+\n+=item modulus\n+\n+  void modulus(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void modulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  void modulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Divide the value of the I PMC by the value of a PMC, native integer, or\n+native floating-point number and store the remainder in I.  Note that\n+I may be the same PMC as I; in that case optimizations may be made.\n+\n+=item cmodulus\n+\n+  void cmodulus(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void cmodulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+  void cmodulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)\n+\n+Divide the value of the I PMC by the value of a PMC, native integer, or\n+native floating-point number and store the remainder in I.  Note that\n+I may be the same PMC as I; in that case optimizations may be made.\n+\n+Note that C uses Knuth's \"corrected mod\" algorithm, as implemented in\n+F, while C uses the C-style fmod function.\n+\n+=item neg\n+\n+  void neg(INTERP, PMC* self, PMC* dest)\n+\n+Negate the sign of I and store the result in I. Note that I\n+and I may refer to the same PMC, in which case optimizations may be\n+made.\n+\n+=back\n+\n+=head3 Logical Vtable Functions\n+\n+=over 4\n+\n+=item bitwise_or\n+\n+  void bitwise_or(INTERP, PMC* self, PMC* value, PMC* dest)\n+  void bitwise_or_int(INTERP, PMC* self, INTVAL value, PMC* dest)\n+\n+Calculate the bitwise-OR of the value of the I PMC and the value of a PMC\n+or native integer and store the result in I. Note that I may be the\n+same PMC as I; in that case optimizations may be made.\n+[Question: what happens when the I and I PMCs aren't integers?]\n+\n+=item bitwise_and\n+\n+=item bitwise_and_int\n+\n+=item bitwise_xor\n+\n+=item bitwise_xor_int\n+\n+=item bitwise_ors\n+\n+=item bitwise_ors_str\n+\n+=item bitwise_ands\n+\n+=item bitwise_ands_str\n+\n+=item bitwise_xors\n+\n+=item bitwise_xors_str\n+\n+=item bitwise_not\n+\n+=item bitwise_shl\n+\n+=item bitwise_shl_int\n+\n+=item bitwise_shr\n+\n+=item bitwise_shr_int\n+\n+=item is_equal\n+\n+=item is_same\n+\n+=item cmp\n+\n+=item cmp_num\n+\n+=item cmp_string\n+\n+=item logical_or\n+\n+=item logical_and\n+\n+=item logical_xor\n+\n+=item logical_not\n+\n+=back\n+\n+=head3 String Vtable Functions\n+\n+=over 4\n+\n+=item concatenate\n+\n+=item concatenate_native\n+\n+=item repeat\n+\n+=item repeat_int\n+\n+=back\n+\n+=head3 Code Vtable Functions\n+\n+=item invoke\n+\n+=item fsh\n+\n+=item visit\n+\n+=item share\n+\n+=back\n+\n+=head3 Class/Object Vtable Functions\n+\n+=over 4\n+\n+=item can\n+\n+=item does\n+\n+=item isa\n+\n+=item add_method\n+\n+=item add_attribute\n+\n+=item add_parent\n+\n+=item add_role\n+\n+=item PMC* find_method(INTERP, PMC* self, STRING* method_name)\n+\n+Return a subroutine PMC for the passed method name. This subroutine PMC may be\n+cached, so the method I return an equivalent sub PMC each time, or be\n+capable of dealing with the returned sub PMCs being reused. [Why should it be\n+cached? Can you turn off caching? What if you want to override find_method to\n+generate methods on the fly?]\n+\n+\n+=back\n+\n+\n+=head2 Interaction between PMCs and high-level objects\n+\n+{{ Address the problem of high-level objects inheriting from low-level PMCs,\n+and any structural changes to low-level PMCs that might require. }}\n+\n+=head2 Core PMCs\n+\n+Parrot has a number of core PMC types that all programs can guarantee will be\n+available to them. (With the possible exception of Parrot programs executing on\n+an embedded device or other restricted environment)\n+\n+=head3 Scalar types\n \n =over 4\n \n@@ -87,7 +1061,7 @@\n \n =item Float\n \n-The PMC wrapper for Parrot's low-level floating point type. Always a float,\n+The PMC wrapper for Parrot's low-level floating-point type. Always a float,\n with other types autoconverted to a float when stored into this PMC.\n \n The boolean value for a Float is false if exactly zero, otherwise true.\n@@ -176,7 +1150,7 @@\n \n =back\n \n-=head2 Array types\n+=head3 Array types\n \n Note that for the following types you can set the size of the array by using\n the VTABLE_set_integer_native() method. Assigning an integer to the array as a\n@@ -238,7 +1212,7 @@\n \n =back\n \n-=head2 Hash types\n+=head3 Hash types\n \n =over 4\n \n@@ -271,7 +1245,7 @@\n \n =back\n \n-=head2 Subroutine types\n+=head3 Subroutine types\n \n =over 4\n \n@@ -308,31 +1282,17 @@\n \n =back\n \n-=head2 Binary Math operations\n-\n-{{ NOTE: this section is barely a stub, and not particularly useful. I\n-suggest deleting it. Any objections? }}\n-\n-The following is a list of what should happen with the basic types when used in\n-a binary math operation:\n-\n-=over 4\n-\n-=item Integer x Integer\n-\n-The operation is an integer.\n-\n-=back \n+=head1 ATTACHMENTS\n \n-=head1 LANGUAGE NOTES\n+None.\n \n =head1 FOOTNOTES\n \n-List of footnotes to the text.\n+None.\n \n =head1 REFERENCES\n \n-  src/pmc/*.pmc\n+None.\n \n =cut\n \n\n"}
{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14415 - doc/trunk/design/syn", "body": "Author: larry\nDate: Sun Jun  3 17:23:15 2007\nNew Revision: 14415\n\nModified:\n   doc/trunk/design/syn/S03.pod\n   doc/trunk/design/syn/S04.pod\n   doc/trunk/design/syn/S06.pod\n\nLog:\ntypo from Aaron Crane++\ns/cat/list/ for flattening captures in order\ncat() now only produces pseudo-strings even in list context\n\n\nModified: doc/trunk/design/syn/S03.pod\n==============================================================================\n--- doc/trunk/design/syn/S03.pod\t(original)\n+++ doc/trunk/design/syn/S03.pod\tSun Jun  3 17:23:15 2007\n@@ -610,7 +610,7 @@\n     $string x $count\n \n Evaluates the left argument in string context, replicates the resulting\n-string value the number of time specified by the right argument and\n+string value the number of times specified by the right argument and\n returns the result as a single concatenated string regardless of context.\n \n If the count is less than 1, returns the null string.\n@@ -625,7 +625,7 @@\n     @list xx $count\n \n Evaluates the left argument in list context, replicates the resulting\n-C value the number of time specified by the right argument and\n+C value the number of times specified by the right argument and\n returns the result in a context dependent fashion.  If the operator\n is being evaluated in ordinary list context, the operator returns a\n flattened list.  In slice (C<@@>) context, the operator converts each C\n@@ -3554,15 +3554,12 @@\n         ...\n     }\n \n-To read arrays serially rather than in parallel, use C.\n-This wins a \"useless use of cat award\" in this case since you could\n+To read arrays serially rather than in parallel, use C.\n+This wins a \"useless use of list award\" in this case since you could\n always just write C<(@x,@y)> to mean the same thing.  But sometimes\n it's nice to be explicit about that:\n \n-    @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6\n-\n-(The C function is not entirely useless; it also provides stringy\n-semantics in string context.)\n+    @foo := [[1,2,3],[4,5,6]]; say list([;] @foo); # 1,2,3,4,5,6\n \n =head1 Minimal whitespace DWIMmery\n \n\nModified: doc/trunk/design/syn/S04.pod\n==============================================================================\n--- doc/trunk/design/syn/S04.pod\t(original)\n+++ doc/trunk/design/syn/S04.pod\tSun Jun  3 17:23:15 2007\n@@ -391,14 +391,11 @@\n \n     for %hash.kv -> $key, $value { print \"$key => $value\\n\" }\n \n-To process two arrays in parallel, use the C function:\n+To process two arrays in parallel use the C function to generate a\n+list that can be bound to the corresponding number of parameters:\n \n-    for each(@a;@b) -> $a, $b { print \"[$a, $b]\\n\" }\n-\n-or use the C function to generate a list of C objects that each can\n-be bound to multiple arguments enclosed in square brackets:\n-\n-    for zip(@a;@b) -> [$a, $b] { print \"[$a, $b]\\n\" }\n+    for zip(@a;@b) -> $a, $b { print \"[$a, $b]\\n\" }\n+    for @a Z @b -> $a, $b { print \"[$a, $b]\\n\" }        # same thing\n \n The list is evaluated lazily by default, so instead of using a C\n to read a file a line at a time as you would in Perl\u00a05:\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tSun Jun  3 17:23:15 2007\n@@ -1060,16 +1060,16 @@\n \n Various contexts may or may not be expecting multi-dimensional slices\n or feeds.  By default, ordinary arrays are flattened, that is, they\n-have \"cat\" semantics.  If you say\n+have \"list\" semantics.  If you say\n \n     (0..2; 'a'..'c') ==> my @tmp;\n     for @tmp { .say }\n \n then you get 0,1,2,'a','b','c'.  If you have a multidim array, you\n-can ask for cat semantics explicitly with cat():\n+can ask for list semantics explicitly with list():\n \n     (0..2; 'a'..'c') ==> my @@tmp;\n-    for @@tmp.cat { .say }\n+    for @@tmp.list { .say }\n \n As we saw earlier, \"zip\" produces an interleaved result by taking one element\n from each list in turn, so\n\n"}
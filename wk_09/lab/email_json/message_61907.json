{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 558: forgot to add this in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 558\nrevision-id: tridge@samba.org-20070704074546-njwthegu8tr03nh1\nparent: tridge@samba.org-20070704065238-u4jop7aazj7ptv10\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Wed 2007-07-04 17:45:46 +1000\nmessage:\n  forgot to add this\nadded:\n  server/eventscript.c           eventscript.c-20070704074533-95f10rsay8um8wrr-1\n=== added file 'server/eventscript.c'\n--- a/server/eventscript.c\t1970-01-01 00:00:00 +0000\n+++ b/server/eventscript.c\t2007-07-04 07:45:46 +0000\n@@ -0,0 +1,192 @@\n+/* \n+   event script handling\n+\n+   Copyright (C) Andrew Tridgell  2007\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+   \n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+*/\n+\n+#include \"includes.h\"\n+#include \"system/filesys.h\"\n+#include \"system/wait.h\"\n+#include \"../include/ctdb_private.h\"\n+#include \"lib/events/events.h\"\n+\n+/*\n+  run the event script - varargs version\n+ */\n+static int ctdb_event_script_v(struct ctdb_context *ctdb, const char *fmt, va_list ap)\n+{\n+\tchar *options, *cmdstr;\n+\tint ret;\n+\tva_list ap2;\n+\tstruct stat st;\n+\n+\tif (stat(ctdb->takeover.event_script, &st) != 0 && \n+\t    errno == ENOENT) {\n+\t\tDEBUG(0,(\"No event script found at '%s'\\n\", ctdb->takeover.event_script));\n+\t\treturn 0;\n+\t}\n+\n+\tva_copy(ap2, ap);\n+\toptions  = talloc_vasprintf(ctdb, fmt, ap2);\n+\tva_end(ap2);\n+\tCTDB_NO_MEMORY(ctdb, options);\n+\n+\tcmdstr = talloc_asprintf(ctdb, \"%s %s\", ctdb->takeover.event_script, options);\n+\tCTDB_NO_MEMORY(ctdb, cmdstr);\n+\n+\tret = system(cmdstr);\n+\tif (ret != -1) {\n+\t\tret = WEXITSTATUS(ret);\n+\t}\n+\n+\ttalloc_free(cmdstr);\n+\ttalloc_free(options);\n+\n+\treturn ret;\n+}\n+\n+/*\n+  run the event script\n+ */\n+int ctdb_event_script(struct ctdb_context *ctdb, const char *fmt, ...)\n+{\n+\tva_list ap;\n+\tint ret;\n+\n+\tva_start(ap, fmt);\n+\tret = ctdb_event_script_v(ctdb, fmt, ap);\n+\tva_end(ap);\n+\n+\treturn ret;\n+}\n+\n+\n+struct ctdb_event_script_state {\n+\tstruct ctdb_context *ctdb;\n+\tpid_t child;\n+\tvoid (*callback)(struct ctdb_context *, int, void *);\n+\tint fd[2];\n+\tvoid *private_data;\n+};\n+\n+/* called when child is finished */\n+static void ctdb_event_script_handler(struct event_context *ev, struct fd_event *fde, \n+\t\t\t\t      uint16_t flags, void *p)\n+{\n+\tstruct ctdb_event_script_state *state = \n+\t\ttalloc_get_type(p, struct ctdb_event_script_state);\n+\tint status = -1;\n+\tvoid (*callback)(struct ctdb_context *, int, void *) = state->callback;\n+\tvoid *private_data = state->private_data;\n+\tstruct ctdb_context *ctdb = state->ctdb;\n+\n+\twaitpid(state->child, &status, 0);\n+\tif (status != -1) {\n+\t\tstatus = WEXITSTATUS(status);\n+\t}\n+\ttalloc_set_destructor(state, NULL);\n+\ttalloc_free(state);\n+\tcallback(ctdb, status, private_data);\n+}\n+\n+\n+/* called when child times out */\n+static void ctdb_event_script_timeout(struct event_context *ev, struct timed_event *te, \n+\t\t\t\t      struct timeval t, void *p)\n+{\n+\tstruct ctdb_event_script_state *state = talloc_get_type(p, struct ctdb_event_script_state);\n+\tvoid (*callback)(struct ctdb_context *, int, void *) = state->callback;\n+\tvoid *private_data = state->private_data;\n+\tstruct ctdb_context *ctdb = state->ctdb;\n+\n+\tDEBUG(0,(\"event script timed out\\n\"));\n+\ttalloc_free(state);\n+\tcallback(ctdb, -1, private_data);\n+}\n+\n+/*\n+  destroy a running event script\n+ */\n+static int event_script_destructor(struct ctdb_event_script_state *state)\n+{\n+\tkill(state->child, SIGKILL);\n+\twaitpid(state->child, NULL, 0);\n+\treturn 0;\n+}\n+\n+/*\n+  run the event script in the background, calling the callback when \n+  finished\n+ */\n+int ctdb_event_script_callback(struct ctdb_context *ctdb, \n+\t\t\t       struct timeval timeout,\n+\t\t\t       TALLOC_CTX *mem_ctx,\n+\t\t\t       void (*callback)(struct ctdb_context *, int, void *),\n+\t\t\t       void *private_data,\n+\t\t\t       const char *fmt, ...)\n+{\n+\tstruct ctdb_event_script_state *state;\n+\tva_list ap;\n+\tint ret;\n+\n+\tstate = talloc(mem_ctx, struct ctdb_event_script_state);\n+\tCTDB_NO_MEMORY(ctdb, state);\n+\n+\tstate->ctdb = ctdb;\n+\tstate->callback = callback;\n+\tstate->private_data = private_data;\n+\t\n+\tret = pipe(state->fd);\n+\tif (ret != 0) {\n+\t\ttalloc_free(state);\n+\t\treturn -1;\n+\t}\n+\n+\tstate->child = fork();\n+\n+\tif (state->child == (pid_t)-1) {\n+\t\tclose(state->fd[0]);\n+\t\tclose(state->fd[1]);\n+\t\ttalloc_free(state);\n+\t\treturn -1;\n+\t}\n+\n+\tif (state->child == 0) {\n+\t\tclose(state->fd[0]);\n+\t\tctdb_set_realtime(false);\n+\t\tset_close_on_exec(state->fd[1]);\n+\t\tva_start(ap, fmt);\n+\t\tret = ctdb_event_script_v(ctdb, fmt, ap);\n+\t\tva_end(ap);\n+\t\t_exit(ret);\n+\t}\n+\n+\ttalloc_set_destructor(state, event_script_destructor);\n+\n+\tclose(state->fd[1]);\n+\n+\tevent_add_fd(ctdb->ev, state, state->fd[0], EVENT_FD_READ|EVENT_FD_AUTOCLOSE,\n+\t\t     ctdb_event_script_handler, state);\n+\n+\tif (!timeval_is_zero(&timeout)) {\n+\t\tevent_add_timed(ctdb->ev, state, timeout, ctdb_event_script_timeout, state);\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n\n"}
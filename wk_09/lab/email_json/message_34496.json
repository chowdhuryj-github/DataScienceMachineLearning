{"category": "ham", "to_address": "Allison Randal <allison@perl.org>", "from_address": "\"Patrick R. Michaud\" <pmichaud@pobox.com>", "subject": "Re: PMC architecture discussion", "body": "On Tue, May 22, 2007 at 01:41:32PM -0700, Allison Randal wrote:\n> Oh, could someone capture that IRC discussion we just had and paste it \n> on the list?\n\nHere it is (long, 247 lines).  \n\nPm\n\n\n19:45  I know I should already know this, but is there a way to make a named function that is global to all namespaces?  Does putting something\n                 in the root namespace do that for me?\n19:45  and what sort of naming convention should we use to avoid naming collisions there?\n19:46  (in particular, I'm looking at a PIR version of the assign_keyed operation from my email\n19:46  why not stick it in a library?\n19:46  you don't want to load the lib in each namespace?\n19:46  right\n19:47  well, you could use exporter\n19:47  by \"global to all namespaces\", do you mean you store it in one namespace, but can look it up in any namespace? if so, there isn't any\n                such option (it would be a massive pollution)\n19:47  can you stick it in a constant?\n19:47  but, you can store it in the top level namespace, and look it up with get_root_global\n19:47  .const pmc myassign = ...\n19:48  I don't necessarily want to look it up in every subroutine generated by PAST-pm\n19:48  I mean, I can, but...\n19:48  macros are global\n19:48  I'd like for PAST-pm to be able to simply generate  'assign_keyed'($P0, key, $P1)     and have it work\n19:48  what are you looking to pass into the subroutine?\n19:49  pmichaud: you could create a dynamic opcode lib\n19:49  allison: did you happen to read my post to parrot-porters about assignment?  That's what I'm looking at\n19:49  or, what are $P0 and $P1 in those examples\n19:49  it'd be c, but i think that's your ultimate goal anyway\n19:49  particle: yes, that would probably work\n19:49  I skimmed them this morning, but can look again\n19:49  allison:  ideally I'd like to be able to have it as an opcode\n19:49  assign_keyed aggregate, key, value\n19:49  given an aggregate $P0, a key, and a value to be assigned $P1\n19:49  assign_keyed $P0[key], $P1\n19:49  key could be an int, string, or PMC\n19:50  pmichaud: current pir won't allow that syntax iirc\n19:50  is that an advantage over aggregate[key] = value?\n19:50  yes, = is set\n19:50  yes, because aggregate[key] = value does a bind, not an assign\n19:50  $P0 = aggregate[key]\n19:50  aggregate[key] = $P1\n19:50  aggregate[key] := value\n19:51  so \"assign aggregate[key], value\"?\n19:51  unfortunately, := is what we have already as =\n19:51  there is no \"assign aggregate[key], value\"\n19:51  and yes, I'd like that sort of assign, but with a huge caveat\n19:51  but that's what you're looking for?\n19:51  yes, but I also want it to create aggregate[key] if it doesn't exist, and to morph aggregate[key] to value's type if it does\n19:52  dwim_assign_keyed\n19:52  is it the op's job to create a nonexistent key, or the aggregate's job?\n19:53  seems like something that may vary per-pmc, so you'd want it to be handled by vtable entries\n19:53  it should be a vtable on the aggregate, same as set aggregate[key], value   does now\n19:53  who's in charge of auto-vivifying?\n19:53  but I'll look over your proposal\n19:53  yeah, i agree it should be the pmc\n19:53  in the meantime, I was looking for a way to implement it even if it's not an opcode\n19:54  thus, something \"global-ish\"  :-)\n19:54  do you need both set_pmc_keyed and assign_pmc_keyed?\n19:54  probably, yes\n19:54  yep\n19:54  one is binding, one is assignment\n19:54  however... parrot *can* punt on this one\n19:55  it can?\n19:55  iiuc you can implement the semantics of assignment with binding only or vice-versa\n19:55  particle:  If you can show me how to do that for the example I gave in the message, I'm all ears :_)\n19:55  er, eyes\n19:55  however you need a container type\n19:55  right, we don't have a scalar container type\n19:55  the container type is PMC\n19:56  ok, a value type :)\n19:56  which is Integer, String, etc\n19:57  if we had a scalar container type, it could work, yes.  But then an aggregate would need to be an array of scalar containers\n19:58  what's the advantage of morphing the PMC to an Undef first and then morphing it to a new type?\n19:58  it works :-)\n19:58  you lose the value anyway, so why not just store a new PMC?\n19:58  because of binding\n19:58  I may have other lexicals bound to the old PMC\n19:58  my $b := @a[2]\n19:58  if @a[2] goes to a new PMC, then $b still points to the old one\n19:58  you may have the aggregate member aliased to another name\n19:59  yep\n19:59  so, we have to make sure that the existing PMC at @a[2] changes to the new value, as opposed to simply giving @a[2] a new PMC\n20:00  so, it used to be that all PMCs could morph to another type, but we dropped that feature\n20:00  pm: we can create a Scalar, ResizableScalarArray, and ScalarHash if you wish\n20:00  because it was only needed by perl\n20:00  I don't think it's ever been that all PMCs could morph to another type, at least not as long as I've been with Parrot\n20:00  well, the basic types\n20:00  I know that several of the basic types (Int, Scalar, Fl... ) yeah\n20:00  but I couldn't, say, morph an array into an Integer\n20:00  tcl has \"shimmering\" which is morphing\n20:00  (they were called PerlInt, PerlString, etc in those days)\n20:01  well, Int, String, and Float still morph\n20:01  sorry, Integer, String, and Float still morph\n20:01  what you're really looking to is an alias to a structural slot\n20:02  I'm not sure that's what I'm looking for :-)\n20:03  unless we have some way of keeping track of structural slots\n20:04  does Perl 6 specify that if you take an alias to an array within an array, and assign an integer to the same position in the array, that\n                the alias will still point to the integer?\n20:04  I don't think Perl 6 specifies\n20:04  I can't see anywhere that's useful\n20:04  however, it's not just here that's an issue\n20:05  sub foo($x is rw) { ... }     foo(@a[2]);\n20:05  the caller would need to know to construct an lvalue reference to @a[2]\n20:06  yes, we can do this, but it seems nicer if we just supported the standard assign semantics that most dynamic languages use directly in\n                 parrot\n20:06  I have to leave now to pick up kids from school... be back in 30 or so\n20:07  I'll be on a plane then, but will look over your message\n20:08  I question the idea that this is \"standard assign semantics that most dynamic languages use\" (or if it is, I haven't fully understood\n                your message yet)\n20:11  assign here means bind\n20:12  our vtable function names are unfortunate (set and assign)\n20:12  seems that the core of the behavior is in this code:\n20:12      assign $P6, $P4                 # $P6 needs to morph\n20:12                                      #   to whatever type $P4 is\n20:13  yes, then there's all the if key doesn't exist, etc\n20:13  but that's the core\n20:14  well, you can't take an alias to a key that doesn't exist\n20:14  aliases are to values. no value means no alias\n20:15  what about autovivification?\n20:15  i suppose that would have to happen at a higher level\n20:16  as in, opcodes would have to be emitted to check whether or not the index exists in the aggregate, and create it if not--then perform\n                 the bind\n20:16  if taking an alias kicks off autovivification, then the key would always exist any time it was aliased\n20:17  (shimmering) note that we're not actually shimmering, we're morphing. it's just that it's *close* to shimmering. =-)\n20:17  right, i think it's the aggregate's job to determine whether or not a keyed lookup will work or not\n20:17  coke: i was pretty sure you were morphing\n20:17  yeah, that's the aggregate's implementation of get_pmc_keyed\n20:17  thanks for the confirmation\n20:18  so assign_keyed would have to call get_pmc_keyed, then\n20:18  or, both ops would need to be emitted\n20:18  shimmering seems to involve having multiple slots to keep this information, and being able to switch back and forth if the value hasn't been\n             mucked with without having to recalc.\n20:19  Perl 5 does that.\n20:19  coke: that's a caching strategy then, like perl SVs\n20:20  allison: nicholas is right about pmc design size wrt cache size\n20:20  s/design/\n20:20  so the Tcl data types have slots for all standard values?\n20:20  gah, shouldn't have had that beer\n20:20  particle: it was designed as a cache, yes, but it's being used as the core data of the PMC\n20:21  allison: I've been avoiding looking at the tcl source, mostly. =-)\n20:21  i mean, the size of the pmc was designed to fit in processor caches\n20:21  particle: which is a problem for role composition, and for intelligent inheritance across the low-level to high-level boundary\n20:21  particle: that too\n20:22  that's why the UnionVal is funny... that's the different types of things that would fit in that space\n20:22  aye\n20:23  back\n20:23  certain gc implementations (currently in core) rely on constant-size pmcs\n20:23  standard assign semantics:  in most languages that I've dealt with, if I say $a = $b, then I expect $a to be a duplicate of $b,\n                 including its type\n20:23  the PMCs will stay constant sized\n20:23  that's one aspect of Leo's proposal that I've rejected\n20:24  pmichaud: but generally I'd also expect $a to be a copy of $b\n20:24  by \"duplicate\" I was meaning \"copy\"\n20:25  not an alias to $b, and not retaining any connection to the former value of $a\n20:25  so, if a attached a property to $a, and then called $a = $b, I would expect it to lose the property\n20:25  really?  I don't think so\n20:25  my $a is context(rw);\n20:25  $a = $b\n20:26  (okay, that's a trait. hrm.)\n20:26  ah, drat, this is back to the very old argument of how many levels of container we need\n20:27  yes, and I spent several weeks last fall struggling with it to end up with what we have now\n20:27  I'm only bringing it up now in response to Nicholas Clark's question about \"how much morphing do we need in Parrot\", and the current\n                 answer, at least for PAST-pm, is \"well, quite a lot, actually\"\n20:27  we've tried to keep it as simple as possible, with the PMC container and a core struct\n20:27  I just do the morph through a sequence of   morph/assign\n20:28  how much of the behavior could be implemented in the assign vtable function for the Perl 6 PMC types?\n20:29  is this assuming I have an assign_keyed op?\n20:29  oh, wait, assuming I don't\n20:29  hmmm\n20:29  yeah, assuming you don't have it\n20:29  we'd need many more perl 6 pmc types\n20:29  if all of the Perl 6 PMC types knew how to morph to any other Perl6 PMC type, then I think it would work\n20:30  yeah, totally own type system, starting with Perl6Undef\n20:30  there's still the issue of dealing with non-existent keys, however\n20:30  the Perl 6 types could be simple inherits from core types, with morphing added\n20:30  that's where the advantage of assign_keyed comes in, in that it creates the key at the time of assignment\n20:30  isn't that a question of autovivification on the aggregate types for Perl 6?\n20:30  pmichaud: the pmc will handle the _keyed lookup semantics\n20:31  particle:  looking up a key shouldn't always autovivify it\n20:31  right, it depends on the pmc type\n20:31  $a = $b[2]   should not autovivify $b[2]\n20:31  oh, i see. hrmm.\n20:31  that's a get_pmc_keyed\n20:31  ah, yes. we have different vtable functions for that\n20:32  right, but I don't have an equivalent of assign_pmc_keyed that autovivifies\n20:32  so it'll be more than one opcode to do that\n20:32  so, set_pmc_keyed clearly always autovivifies\n20:33  yes and now\n20:33  er, yes and no\n20:33  it does create the key, yes, but it could still point to NULL\n20:33  well, it always sets a value\n20:33  (not even autovivify)\n20:33  in perl 5, auto-vivify means an undef value is associated with the key\n20:33  and set_pmc_keyed breaks any binding to an existing PMC.  Sometimes we want that, yes, but sometimes we don't\n20:34  so, perl 6 types, when they autovivify a key must also give it an .Perl6Undef value?\n20:34  you can't take an alias to a NULL\n20:34  exactly\n20:34  and yes, we'd autovivify to an undef\n20:35  ... this sounds like a very similar conversation to the tcl way of doing things vs. the core parrot way of doing things from years ago.\n20:35  allison: autoviv will give Perl6Undef value... if key exists, it must morph value to Perl6Undef\n20:35  that's what would happen for, say,   my $b := @a[2]\n20:35  ...during assign_keyed\n20:35  during assign_keyed, if key doesn't exist then we clone value and bind the key to that value\n20:36  so, what code path could you follow to end up with an alias to a keyed element that is still NULL?\n20:36  if key does exist, then we give that key the new value\n20:36  allison: in PIR or in Perl 6?\n20:36  ah, clone value. right\n20:36  (or, instead of clone value we do COW semantics, but it's much the same)\n20:36  pmichaud: Perl 6\n20:36  allison: in Perl 6 I don't think we get there, no.\n20:37  allison: in Perl 6 I don't think we end up with a case of assigning to a keyed element that is NULL\n20:37  so, if there is a NULL, it's always safe to set_pmc_keyed, because there can't be an alias to it\n20:37  right\n20:37  that's what PAST-pm is doing now\n20:37  if a key is NULL, then we clone the value and use set_pmc_keyed\n20:37  if a key is not NULL, then we get a reference to it and do morph/assign\n20:38  okay, we're all on the same page, that's goo\n20:38  good\n20:38  (my flight\n20:38  note that this occurs not only for arrays, but can also occur for lexicals and package variables\n20:38   is about to board)\n20:38  okay, allison, thanks\n20:40  I'm still not quite getting the need for assign_pmc_keyed, unless it's just to condense the code? If so, then it's a simple complexity\n                balance: whether it's better to have the complexity in one place than another.\n20:40  allison: fly safe.\n20:40  thanks, ttyl\n20:40  it's better to have the complexity hidden from the HLL authors.\n20:40  chromatic: ping\n20:40  it's better to get parrot out the door\n20:40  agreed, if it is a form of complexity that is always standard across all HLLs\n20:41  it's to condense the code\n20:41  we'd be replacing a sequence of 10 or more PIR instructions with one\n20:41  and since assignment is a _very_ common operation, it seems better to do that\n20:41  I'll email\n20:41 -!- allison [~chatzilla@ip67-88-206-99.z206-88-67.customer.algx.net] has quit [Quit: ChatZilla 0.9.78.1 [Firefox 2.0.0.3/2007030919]]\n20:42  at any rate, I've already decided that at some point I'm going to revise PAST-pm so that it's using the same code for keyed assignment\n                 and global variables, instead of separate store_global instructions as it does now\n\n\n"}
{"category": "ham", "to_address": "Michael Frumin <michael@frumin.net>", "from_address": "Peter Dalgaard <p.dalgaard@biostat.ku.dk>", "subject": "Re: [R] Lookups in R", "body": "Michael Frumin wrote:\n> i wish it were that simple.  unfortunately the logic i have to do on \n> each transaction is substantially more complicated, and involves \n> referencing the existing values of the user table through a number of \n> conditions.\n>\n> any other thoughts on how to get better-than-linear performance time?  \n> is there a recommended binary searching/sorting (i.e. BTree) module that \n> I could use to maintain my own index?\n>   \nThe point remains: To do anything efficient in R, you need to get rid of \nthat for loop and use something vectorized. Notice that you can expand \nvalues from the user table into the transaction table by indexing with \ntransactions$userid, or you can use a merge operation.\n\n> thanks,\n> mike\n>\n> Peter Dalgaard wrote:\n>   \n>> mfrumin wrote:\n>>     \n>>> Hey all; I'm a beginner++ user of R, trying to use it to do some \n>>> processing\n>>> of data sets of over 1M rows, and running into a snafu.  imagine that my\n>>> input is a huge table of transactions, each linked to a specif user \n>>> id.  as\n>>> I run through the transactions, I need to update a separate table for \n>>> the\n>>> users, but I am finding that the traditional ways of doing a table \n>>> lookup\n>>> are way too slow to support this kind of operation.\n>>>\n>>> i.e:\n>>>\n>>> for(i in 1:1000000) {\n>>>    userid = transactions$userid[i];\n>>>    amt = transactions$amounts[i];\n>>>    users[users$id == userid,'amt'] += amt;\n>>> }\n>>>\n>>> I assume this is a linear lookup through the users table (in which \n>>> there are\n>>> 10's of thousands of rows), when really what I need is O(constant \n>>> time), or\n>>> at worst O(log(# users)).\n>>>\n>>> is there any way to manage a list of ID's (be they numeric, string, \n>>> etc) and\n>>> have them efficiently mapped to some other table index?\n>>>\n>>> I see the CRAN package for SQLite hashes, but that seems to be going \n>>> a bit\n>>> too far.\n>>>   \n>>>       \n>> Sometimes you need a bit of lateral thinking. I suspect that you could \n>> do it like this:\n>>\n>> tbl <- with(transactions, tapply(amount, userid, sum))\n>> users$amt <- users$amt + tbl[users$id]\n>>\n>> one catch is that there could be users with no transactions, in which \n>> case you may need to replace userid by factor(userid, \n>> levels=users$id). None of this is tested, of course.\n>>     \n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
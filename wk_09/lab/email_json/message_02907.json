{"category": "ham", "to_address": "\"Sundar Dorai-Raj\" <sundar.dorai-raj@pdf.com>", "from_address": "\"Deepayan Sarkar\" <deepayan.sarkar@gmail.com>", "subject": "Re: [R] Positioning in xyplot", "body": "On 4/11/07, Sundar Dorai-Raj  wrote:\n\n> Seems like you may get a workaround (albeit kludgey) by using\n> ?print.trellis. Here's another example:\n>\n> library(lattice)\n> z <- expand.grid(x = 1:10, p = 1:5, r = 1:10)\n> z$y <- rnorm(nrow(z))\n> z$p <- factor(z$p, levels = c(1, 5, 2, 4, 3))\n> bot <- xyplot(y ~ x | p, z, groups = r,\n>                layout = c(2, 2), type = \"l\",\n>                scales = list(alternating = 1),\n>                subset = p != 3)\n> top <- xyplot(y ~ x | p, z, groups = r,\n>                type = \"l\", xlab = \"\",\n>                scales = list(alternating = 2),\n>                subset = p == 3)\n>\n> print(bot, c(0, 0, 1, 11/16))\n> print(top, c(1/5, 7/12, 4/5, 1), newpage = FALSE)\n\nHere's another hack (thanks to Sundar for the reproducible example):\n\n\n\nlibrary(grid)\n\n## this is a safer version of current.panel.limits()\n\ncurrent.limits <-\n    function ()\n{\n    xlim <- convertX(unit(c(0, 1), \"npc\"), \"native\", valueOnly = TRUE)\n    ylim <- convertY(unit(c(0, 1), \"npc\"), \"native\", valueOnly = TRUE)\n    if (any(!is.finite(xlim))) xlim <- c(0, 1)\n    if (any(!is.finite(ylim))) ylim <- c(0, 1)\n    list(xlim = xlim, ylim = ylim)\n}\n\n## this calls 'fun' after moving its viewport if panel.number() == 5\n\ncallAfterMoving <-\n    function(fun, border = TRUE, move.x = 1, ...)\n{\n    if (panel.number() == 5) {\n        fun(...)\n        if (border) grid.rect()\n    }\n    else {\n        cpl <- current.limits()\n        pushViewport(viewport(x = move.x,\n                              width = unit(1, \"npc\"),\n                              xscale = cpl$xlim,\n                              yscale = cpl$ylim,\n                              clip = \"off\"))\n        fun(...)\n        if (border) grid.rect()\n        upViewport()\n    }\n}\n\n\n## this almost works, except for the axes on the left, because in the\n## context in which it is drawn (the strip on the left, invisible in\n## this example), information about how much to move right is not\n## available.\n\n\nxyplot(y ~ x | p, z, groups = r,\n       layout = c(2, 3), type = \"l\",\n       par.settings =\n       list(axis.line = list(col = \"transparent\"),\n            strip.border = list(col = \"transparent\")),\n       panel = function(...) {\n           callAfterMoving(panel.xyplot, ...)\n       },\n       strip = function(...) {\n           callAfterMoving(strip.default, ...)\n       },\n       axis = function(..., line.col) {\n           callAfterMoving(axis.default,\n                           border = FALSE,\n                           line.col = 'black',\n                           ...)\n       })\n\n\n## one way to bail out is simply not draw the left axes.  It can also be\n## added back explicitly by adding a call to panel.axis inside the\n## panel function (see below)\n\n\nxyplot(y ~ x | p, z, groups = r,\n       layout = c(2, 3), type = \"l\",\n       par.settings =\n       list(axis.line = list(col = \"transparent\"),\n            strip.border = list(col = \"transparent\")),\n       panel = function(...) {\n           callAfterMoving(panel.xyplot, ...)\n       },\n       strip = function(...) {\n           callAfterMoving(strip.default, ...)\n       },\n       axis = function(..., line.col, side) {\n           if (side != \"left\" || panel.number() != 5) {\n               callAfterMoving(axis.default,\n                               border = FALSE,\n                               line.col = 'black',\n                               side = side,\n                               ...)\n           }\n       })\n\n\n## panel function with axes on the left:\n\npanel.leftaxes <- function(...)\n{\n    if (panel.number() == 5)\n       panel.axis(\"left\", outside = TRUE,\n                   line.col = \"black\")\n    panel.xyplot(...)\n}\n\n\nxyplot(y ~ x | p, z, groups = r,\n       layout = c(2, 3), type = \"l\",\n       par.settings =\n       list(axis.line = list(col = \"transparent\"),\n            strip.border = list(col = \"transparent\")),\n       panel = function(...) {\n           callAfterMoving(panel.leftaxes, ...)\n       },\n       strip = function(...) {\n           callAfterMoving(strip.default, ...)\n       },\n       axis = function(..., line.col, side) {\n           if (side != \"left\" || panel.number() != 5) {\n               callAfterMoving(axis.default,\n                               border = FALSE,\n                               line.col = 'black',\n                               side = side,\n                               ...)\n           }\n       })\n\n-Deepayan\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
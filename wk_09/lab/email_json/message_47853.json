{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 11190: Remove the creg backend: in\n\tfile:///home/jelmer/bzr.samba-old/4.0-regwrite/", "body": "At file:///home/jelmer/bzr.samba-old/4.0-regwrite/\n\n------------------------------------------------------------\nrevno: 11190\nrevision-id: jelmer@samba.org-20070612234637-779h4pffu0ybx829\nparent: jelmer@samba.org-20070612231137-i8mbl1sgmcfkb5vn\ncommitter: Jelmer Vernooij \nbranch nick: 4.0-regwrite\ntimestamp: Wed 2007-06-13 01:46:37 +0200\nmessage:\n  Remove the creg backend:\n   - it is not very relevant\n   - doesn't implement the full data model (classname and security descriptors are missing)\n   - was only partially implemented anyway (no write support, for example)\nremoved:\n  source/lib/registry/creg.c     svn-v2:4132@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2freg_backend_w95.c\nmodified:\n  source/lib/registry/README     svn-v2:4132@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2fREADME\n  source/lib/registry/config.mk  svn-v2:851@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2fconfig.mk\n  source/lib/registry/hive.c     hive.c-20070602140117-9a3wth1mhbrq7ej1-1\n  source/lib/registry/hive.h     hive.h-20070423140448-w1nvzs8d2qxvyswz-1\n=== removed file 'source/lib/registry/creg.c'\n--- a/source/lib/registry/creg.c\t2007-06-12 16:54:40 +0000\n+++ b/source/lib/registry/creg.c\t1970-01-01 00:00:00 +0000\n@@ -1,375 +0,0 @@\n-/*\n-   Samba Unix/Linux SMB client utility libeditreg.c \n-   Copyright (C) 2004-2007 Jelmer Vernooij, jelmer@samba.org\n-\n-   Backend for Windows '95 registry files. Explanation of file format \n-   comes from http://www.cs.mun.ca/~michael/regutils/.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2 of the License, or\n-   (at your option) any later version.\n-   \n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-   \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n-\n-#include \"includes.h\"\n-#include \"hive.h\"\n-#include \"system/filesys.h\"\n-#include \"system/shmem.h\"\n-\n-/**\n- * The registry starts with a header that contains pointers to \n- * the rgdb.\n- *\n- * After the main header follows the RGKN header (key index table).\n- * The RGKN keys are listed after each other. They are put into \n- * blocks, the first having a length of 0x2000 bytes, the others \n- * being 0x1000 bytes long.\n- *\n- * After the RGKN header follow one or more RGDB blocks. These blocks \n- * contain keys. A key is followed by its name and its values.\n- *\n- * Values are followed by their name and then their data.\n- *\n- * Basically the idea is that the RGKN contains the associations between \n- * the keys and the RGDB contains the actual data.\n- */\n-\n-typedef uint32_t DWORD;\n-typedef unsigned short WORD;\n-\n-typedef struct creg_block {\n-\tDWORD CREG_ID;\t\t/* CREG */\n-\tDWORD uk1;\n-\tDWORD rgdb_offset;\n-\tDWORD chksum;\n-\tWORD  num_rgdb;\n-\tWORD  flags;\n-\tDWORD uk2;\n-\tDWORD uk3;\n-\tDWORD uk4;\n-} CREG_HDR;\n-\n-typedef struct rgkn_block {\n-\tDWORD RGKN_ID; \t\t/* RGKN */\n-\tDWORD size;\n-\tDWORD root_offset;\n-\tDWORD free_offset;\n-\tDWORD flags;\n-\tDWORD chksum;\n-\tDWORD uk1;\n-\tDWORD uk2;\n-} RGKN_HDR;\n-\n-typedef struct reg_id {\n-\tWORD id;\n-\tWORD rgdb;\n-} REG_ID;\n-\n-typedef struct rgkn_key {\n-\tDWORD type;\t\t\t/* 0x00000000 = normal key, 0x80000000 = free block */\n-\tDWORD hash;\t\t\t/* Contains either hash or size of free blocks that follows */\n-\tDWORD next_free;\n-\tDWORD parent_offset;\n-\tDWORD first_child_offset;\n-\tDWORD next_offset;\n-\tREG_ID id;\n-} RGKN_KEY;\n-\n-typedef struct rgdb_block {\n-\tDWORD RGDB_ID;\t\t/* RGDB */\n-\tDWORD size;\n-\tDWORD unused_size;\n-\tWORD flags;\n-\tWORD section;\n-\tDWORD free_offset;\t/* -1 if there is no free space */\n-\tWORD max_id;\n-\tWORD first_free_id;\n-\tDWORD uk1;\n-\tDWORD chksum;\n-} RGDB_HDR;\n-\n-typedef struct rgdb_key {\n-\tDWORD size;\n-\tREG_ID id;\n-\tDWORD used_size;\n-\tWORD  name_len;\n-\tWORD  num_values;\n-\tDWORD uk1;\n-} RGDB_KEY;\n-\n-typedef struct rgdb_value {\n-\tDWORD type;\n-\tDWORD uk1;\n-\tWORD name_len;\n-\tWORD data_len;\n-} RGDB_VALUE;\n-\n-typedef struct creg_struct_s {\n-\tint fd;\n-\tBOOL modified;\n-\tchar *base;\n-\tstruct stat sbuf;\n-\tCREG_HDR *creg_hdr;\n-\tRGKN_HDR *rgkn_hdr;\n-\tRGDB_KEY ***rgdb_keys;\n-} CREG;\n-\n-struct creg_key_data {\n-\tstruct hive_key key;\n-\tRGKN_KEY *data;\n-\tCREG *hive;\n-};\n-\n-#if 0 /* unused */\n-#define RGKN_START_SIZE 0x2000\n-#define RGKN_INC_SIZE   0x1000\n-#endif\n-\n-#define LOCN_RGKN(creg, o) ((RGKN_KEY *)((creg)->base + sizeof(CREG_HDR) + o))\n-#define LOCN_RGDB_BLOCK(creg, o) (((creg)->base + (creg)->creg_hdr->rgdb_offset + o))\n-#define LOCN_RGDB_KEY(creg, rgdb, id) ((RGDB_KEY *)((creg)->rgdb_keys[(rgdb)][(id)]))\n-\n-static DWORD str_to_dword(const char *a) {\n-    int i;\n-    unsigned long ret = 0;\n-    for(i = strlen(a)-1; i >= 0; i--) {\n-        ret = ret * 0x100 + a[i];\n-    }\n-    return ret;\n-}\n-\n-#if 0 /* unused */\n-\n-static DWORD calc_hash(const char *str) {\n-\tDWORD ret = 0;\n-\tint i;\n-\tfor(i = 0; str[i] && str[i] != '\\\\'; i++) {\n-\t\tret+=toupper(str[i]);\n-\t}\n-\treturn ret;\n-}\n-\n-static void parse_rgkn_block(CREG *creg, off_t start_off, off_t end_off) \n-{\n-\toff_t i;\n-\tfor(i = start_off; end_off - i > sizeof(RGKN_KEY); i+= sizeof(RGKN_KEY)) {\n-\t\tRGKN_KEY *key = (RGKN_KEY *)LOCN_RGKN(creg, i);\n-\t\tif(key->type == 0) {\n-\t\t\tDEBUG(4,(\"Regular, id: %d, %d, parent: %x, firstchild: %x, next: %x hash: %lX\\n\", key->id.id, key->id.rgdb, key->parent_offset, key->first_child_offset, key->next_offset, (long)key->hash));\n-\t\t} else if(key->type == 0x80000000) {\n-\t\t\tDEBUG(3,(\"free\\n\"));\n-\t\t\ti += key->hash;\n-\t\t} else {\n-\t\t\tDEBUG(0,(\"Invalid key type in RGKN: %0X\\n\", key->type));\n-\t\t}\n-\t}\n-}\n-\n-#endif\n-\n-static void parse_rgdb_block(CREG *creg, RGDB_HDR *rgdb_hdr)\n-{\n-\tDWORD used_size = rgdb_hdr->size - rgdb_hdr->unused_size;\n-\tDWORD offset = 0;\n-\n-\twhile(offset < used_size) {\n-\t\tRGDB_KEY *key = (RGDB_KEY *)(((char *)rgdb_hdr) + sizeof(RGDB_HDR) + offset);\n-\t\t\n-\t\tif(!(key->id.id == 0xFFFF && key->id.rgdb == 0xFFFF))creg->rgdb_keys[key->id.rgdb][key->id.id] = key;\n-\t\toffset += key->size;\n-\t}\n-}\n-\n-WERROR reg_open_creg_file(TALLOC_CTX *parent_ctx, const char *location, \n-\t\t\t\t\t\t  struct hive_key **root)\n-{\n-\tCREG *creg;\n-\tDWORD creg_id, rgkn_id;\n-\tDWORD i;\n-\tDWORD offset;\n-\tstruct creg_key_data *creg_root;\n-\n-\tcreg = talloc(parent_ctx, CREG);\n-\tmemset(creg, 0, sizeof(CREG));\n-\n-\tif((creg->fd = open(location, O_RDONLY, 0000)) < 0) {\n-\t\treturn WERR_FOOBAR;\n-\t}\n-\n-    if (fstat(creg->fd, &creg->sbuf) < 0) {\n-\t\treturn WERR_FOOBAR;\n-    }\n-\n-    creg->base = mmap(0, creg->sbuf.st_size, PROT_READ, MAP_SHARED, creg->fd, 0);\n-                                                                                                                                              \n-    if (creg->base == (void *)-1) {\n-\t\tDEBUG(0,(\"Could not mmap file: %s, %s\\n\", location, strerror(errno)));\n-        return WERR_FOOBAR;\n-    }\n-\n-\tcreg->creg_hdr = (CREG_HDR *)creg->base;\n-\n-\tif ((creg_id = IVAL(&creg->creg_hdr->CREG_ID,0)) != str_to_dword(\"CREG\")) {\n-\t\tDEBUG(0, (\"Unrecognized Windows 95 registry header id: 0x%0X, %s\\n\", \n-\t\t\t\t  creg_id, location));\n-\t\treturn WERR_FOOBAR;\n-\t}\n-\n-\tcreg->rgkn_hdr = (RGKN_HDR *)LOCN_RGKN(creg, 0);\n-\n-\tif ((rgkn_id = IVAL(&creg->rgkn_hdr->RGKN_ID,0)) != str_to_dword(\"RGKN\")) {\n-\t\tDEBUG(0, (\"Unrecognized Windows 95 registry key index id: 0x%0X, %s\\n\", \n-\t\t\t\t  rgkn_id, location));\n-\t\treturn WERR_FOOBAR;\n-\t}\n-\n-#if 0\t\n-\t/* If'ed out because we only need to parse this stuff when allocating new \n-\t * entries (which we don't do at the moment */\n-\t/* First parse the 0x2000 long block */\n-\tparse_rgkn_block(creg, sizeof(RGKN_HDR), 0x2000);\n-\n-\t/* Then parse the other 0x1000 length blocks */\n-\tfor(offset = 0x2000; offset < creg->rgkn_hdr->size; offset+=0x1000) {\n-\t\tparse_rgkn_block(creg, offset, offset+0x1000);\n-\t}\n-#endif\n-\n-\tcreg->rgdb_keys = talloc_array(parent_ctx, RGDB_KEY **, creg->creg_hdr->num_rgdb);\n-\n-\toffset = 0;\n-\tDEBUG(3, (\"Reading %d rgdb entries\\n\", creg->creg_hdr->num_rgdb));\n-\tfor(i = 0; i < creg->creg_hdr->num_rgdb; i++) {\n-\t\tRGDB_HDR *rgdb_hdr = (RGDB_HDR *)LOCN_RGDB_BLOCK(creg, offset);\n-\t\t\n-\t\tif(strncmp((char *)&(rgdb_hdr->RGDB_ID), \"RGDB\", 4)) {\n-\t\t\tDEBUG(0, (\"unrecognized rgdb entry: %4d, %s\\n\", \n-\t\t\t\t\t  rgdb_hdr->RGDB_ID, location));\n-\t\t\treturn WERR_FOOBAR;\n-\t\t} else {\n-\t\t\tDEBUG(3, (\"Valid rgdb entry, first free id: %d, max id: %d\\n\", rgdb_hdr->first_free_id, rgdb_hdr->max_id));\n-\t\t}\n-\n-\n-\t\tcreg->rgdb_keys[i] = talloc_array(creg, RGDB_KEY *, rgdb_hdr->max_id+1);\n-\t\tmemset(creg->rgdb_keys[i], 0, sizeof(RGDB_KEY *) * (rgdb_hdr->max_id+1));\n-\n-\t\tparse_rgdb_block(creg, rgdb_hdr);\n-\n-\t\toffset+=rgdb_hdr->size;\n-\t}\n-\t\n-\t/* First element in rgkn should be root key */\n-\tcreg_root = talloc(parent_ctx, struct creg_key_data);\n-\tcreg_root->hive = creg;\n-\tcreg_root->data = LOCN_RGKN(creg, sizeof(RGKN_HDR));\n-\t/* FIXME: attach creg to key */\n-\n-\t*root = (struct hive_key *)creg_root;\n-\t\n-\treturn WERR_OK;\n-}\n-\n-static WERROR creg_get_subkey_by_index (TALLOC_CTX *mem_ctx, \n-\t\t\t\tconst struct hive_key *parent, uint32_t n, const char **name,\n-\t\t\t\tconst char **classname, \n-\t\t\t\tNTTIME *last_mod_time)\n-{\n-\tconst struct creg_key_data *private_data = \n-\t\t(const struct creg_key_data *)parent;\n-\tCREG *creg = private_data->hive;\n-\tRGKN_KEY *rgkn_key = private_data->data;\n-\tRGKN_KEY *child;\n-\tDWORD child_offset;\n-\tDWORD cur = 0;\n-\t\n-\t/* Get id of first child */\n-\tchild_offset = rgkn_key->first_child_offset;\n-\n-\twhile(child_offset != 0xFFFFFFFF) {\n-\t\tchild = LOCN_RGKN(creg, child_offset);\n-\n-\t\t/* n == cur ? return! */\n-\t\tif(cur == n) {\n-\t\t\tRGDB_KEY *rgdb_key;\n-\t\t\trgdb_key = LOCN_RGDB_KEY(creg, child->id.rgdb, child->id.id);\n-\t\t\tif(!rgdb_key) {\n-\t\t\t\tDEBUG(0, (\"Can't find %d,%d in RGDB table!\\n\", child->id.rgdb, child->id.id));\n-\t\t\t\treturn WERR_FOOBAR;\n-\t\t\t}\n-\n-\t\t\t*name = talloc_strndup(mem_ctx, (char *)rgdb_key + sizeof(RGDB_KEY), rgdb_key->name_len);\n-\t\t\t*classname = NULL; /* Not applicable for creg */\n-\t\t\t*last_mod_time = 0; /* Not applicable */\n-\n-\t\t\treturn WERR_OK;\n-\t\t}\n-\n-\t\tcur++;\n-\t\t\n-\t\tchild_offset = child->next_offset;\n-\t}\n-\n-\treturn WERR_NO_MORE_ITEMS;\n-}\n-\n-static WERROR creg_get_info(TALLOC_CTX *mem_ctx,\n-\t\t\t\t\t\t\tconst struct hive_key *k, const char **classname,\n-\t\t\t\t\t\t\tuint32_t *subkey_count, uint32_t *value_count)\n-{\n-\tconst struct creg_key_data *creg_key = (const struct creg_key_data *)k;\n-\tRGKN_KEY *rgkn_key = creg_key->data;\n-\tRGDB_KEY *rgdb_key = LOCN_RGDB_KEY(creg_key->hive, rgkn_key->id.rgdb, rgkn_key->id.id);\n-\n-\tif (rgdb_key == NULL) \n-\t\treturn WERR_FOOBAR;\n-\t\n-\t*subkey_count = -1; /* FIXME */\n-\t*classname = NULL; /* Not applicable for creg */\n-\t*value_count = rgdb_key->num_values;\n-\t\n-\treturn WERR_OK;\n-}\n-\n-static WERROR creg_get_value_by_id(TALLOC_CTX *mem_ctx, const struct hive_key *k, int idx, const char **name, uint32_t *type, DATA_BLOB *data)\n-{\n-\tconst struct creg_key_data *creg_key = (const struct creg_key_data *)k;\n-\tRGKN_KEY *rgkn_key = creg_key->data;\n-\tDWORD i;\n-\tDWORD offset = 0;\n-\tRGDB_KEY *rgdb_key = LOCN_RGDB_KEY(creg_key->hive, rgkn_key->id.rgdb, rgkn_key->id.id);\n-\tRGDB_VALUE *curval = NULL;\n-\n-\tif (rgdb_key == NULL) \n-\t\treturn WERR_FOOBAR;\n-\t\n-\tif (idx >= rgdb_key->num_values) \n-\t\treturn WERR_NO_MORE_ITEMS;\n-\t\n-\tfor(i = 0; i < idx; i++) {\n-\t\tcurval = (RGDB_VALUE *)(((char *)rgdb_key) + sizeof(RGDB_KEY) + rgdb_key->name_len + offset);\n-\t\toffset += sizeof(RGDB_VALUE) + curval->name_len + curval->data_len;\n-\t}\n-\n-\t*name = talloc_strndup(mem_ctx, (char *)curval+sizeof(RGDB_VALUE), curval->name_len);\n-\t\t\n-\t*data = data_blob_talloc(mem_ctx, curval+sizeof(RGDB_VALUE)+curval->name_len, curval->data_len);\n-\t*type = curval->type;\n-\t\n-\treturn WERR_OK;\n-}\n-\n-static struct hive_operations reg_backend_creg = {\n-\t.name = \"creg\",\n-\t.enum_value = creg_get_value_by_id,\n-\t.get_key_info = creg_get_info,\n-\t.enum_key = creg_get_subkey_by_index\n-};\n\n=== modified file 'source/lib/registry/README'\n--- a/source/lib/registry/README\t2007-06-02 14:03:25 +0000\n+++ b/source/lib/registry/README\t2007-06-12 23:46:37 +0000\n@@ -14,7 +14,6 @@\n The following hive backends are supported:\n \n  - ldb \n- - creg (USER.DAT-style files)\n  - regf (NTUSER.DAT-style files)\n  - rpc (Remote individual hives)\n  - directory\n\n=== modified file 'source/lib/registry/config.mk'\n--- a/source/lib/registry/config.mk\t2007-06-02 14:03:25 +0000\n+++ b/source/lib/registry/config.mk\t2007-06-12 23:46:37 +0000\n@@ -30,7 +30,6 @@\n \t\tregf.o \\\n \t\thive.o \\\n \t\tlocal.o \\\n-\t\tcreg.o \\\n \t\tldb.o \\\n \t\tdir.o \\\n \t\trpc.o\n\n=== modified file 'source/lib/registry/hive.c'\n--- a/source/lib/registry/hive.c\t2007-06-12 20:08:26 +0000\n+++ b/source/lib/registry/hive.c\t2007-06-12 23:46:37 +0000\n@@ -47,10 +47,7 @@\n \t\treturn WERR_BADFILE;\n \t}\n \n-\tif (!strncmp(peek, \"CREG\", 4)) {\n-\t\tclose(fd);\n-\t\treturn reg_open_creg_file(parent_ctx, location, root);\n-\t} else if (!strncmp(peek, \"REGF\", 4)) {\n+\tif (!strncmp(peek, \"REGF\", 4)) {\n \t\tclose(fd);\n \t\treturn reg_open_regf_file(parent_ctx, location, root);\n \t} else if (!strncmp(peek, \"TDB file\", 8)) {\n\n=== modified file 'source/lib/registry/hive.h'\n--- a/source/lib/registry/hive.h\t2007-06-12 23:11:37 +0000\n+++ b/source/lib/registry/hive.h\t2007-06-12 23:46:37 +0000\n@@ -155,8 +155,6 @@\n /* Individual backends */\n WERROR reg_open_directory(TALLOC_CTX *parent_ctx, \n \t\t\tconst char *location, struct hive_key **key);\n-WERROR reg_open_creg_file(TALLOC_CTX *parent_ctx, const char *location, \n-\t\t\t\t\t\t  struct hive_key **root);\n WERROR reg_open_regf_file(TALLOC_CTX *parent_ctx, \n \t\t\t\t\t\t  const char *location, struct hive_key **key);\n WERROR reg_open_ldb_file(TALLOC_CTX *parent_ctx, const char *location, \n\n"}
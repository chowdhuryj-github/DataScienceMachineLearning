{"category": "ham", "to_address": "Will Coleda <will@coleda.com>", "from_address": "Joshua Isom <jrisom@gmail.com>", "subject": "Re: new FAQs", "body": "\nOn May 23, 2007, at 8:06 PM, Will Coleda wrote:\n\n> On May 23, 2007, at 1:58 AM, Joshua Isom wrote:\n>\n> I confess to not grasping the point you claim is simple.  As you\n> understand it, what is there about a register based machine, as\n> opposed to a stack based machine, that specifically improves the\n> performance of operating on dynamically typed data, without regard to\n> performance differences between the two architectures that are\n> independent of typing models?\n\nI don't believe there's a benefit for a certain type, but all types.  \nThere will be less time moving data around, and keeping the same data \nin the same places.  The less you move data around, the more you \nimprove speed.  Proven concepts for compiling to a register based \nmachine will be easier to implement.  And since after all, speed is \noften in large part to the compiler, a better compiler will create \nbetter programs.  So speed will be a combination of parrot version, and \ncompiler version.\n\nWhen it comes to which is better for a type of language, both Java and \nPerl 5 use a stack based machine, but Python can be ran as native code \nor on a JVM, so it's hard to truly say what is best for a type of \nlanguage.  To me personally, a virtual machine simulating real hardware \nas much as practical is a great benefit.\n\n> It sounds like you are saying that languages are free to implement\n> their own semantics using their own code, and that they can choose not\n> to interoperate with predefined Parrot types or types from other\n> languages when that would negatively impact their goals, such as\n> performance. While that rings true, it seems that Parrot is not\n> providing that ability -- languages can already implement whatever\n> they want without Parrot.  And if languages are free to ignore\n> predefined and foreign types, when what benefit will they actually get\n> from Parrot?\n\nA language can use whatever semantics it so chooses.  But \ninteroperability between languages will likely be broken, and they \nwon't be able to utilize future improvements in parrot.  Part of the \nwhole point of parrot is to provide one portable virtual machine for \nlanguages.  Languages will be able to benefit from improvements in \nparrot without needing to spend all their time on their own virtual \nmachine.  If you have an idea for a new language, you can use parrot as \na base and deal solely with designing and compiling, instead of \nrunning.\n\n> Moreover, this does not address my initial question.  I am asking, to\n> rephrase it bluntly, \"If Parrot makes dynamic typing faster, doesn't\n> that have to make static typing slower?\"  That is, is Parrot making a\n> tradeoff here?  If it is, how large is the tradeoff and what is its\n> nature.  If it is not, then why doesn't everyone else simply do what\n> you are doing and gain the same benefit?\n\nWhat about static typing is so fast?  Compiler optimizations help, but \nthose can still exist.  I don't see any reason why parrot can't still \nrun statically typed code faster than dynamically typed code(as is \noften the case anyway).\n\n> It would seem that Parrot either has to be different from the JVM and\n> CLR due to design or implementation optimizations that favor a\n> specific typing model over others -- which is what it seems to claim --\n> or else it does not -- either it is not thus differently designed, or\n> it is not thus differently implemented.  If it does not, then it seems\n> inappropriate for it to make the claim -- and thus would raise the\n> question of why Parrot should be considered a superior target for\n> dynamically or statically typed language compilers.\n\nParrot has a benefit of starting from scratch.  We aren't trying to \ncompile java to perl 5's vm, or compiling perl 5 to java's vm, instead \nwe're building a vm that will work well for them all without late term \nslow hacks.  A language won't need to use all of parrot's features.  \nMost won't, but they won't need to use weird hacks to get the \nfunctionality they need.  They can use a subset of parrot.\n\nPersonally, I rarely use some of the higher level features of parrot.  \nBut parrot having the additional features doesn't seem to slow down my \ncode at all.  Sometimes I want to mix regular expressions and jitable \nassembly.\n\n> What tradeoffs could Parrot be making that will have a significant\n> benefit for dynamically typed languages -- significant enough to\n> justify the creation of Parrot itself -- without significant detriment\n> to statically typed languages?  Again, if these tradeoffs are so\n> broadly beneficial, why would the JVM or CLR not simply implement them\n> themselves?\n>\n> Most simply: What is being lost to gain whatever is being gained?\n\nI'm not sure anything is lost.  Perhaps when a Java to Parrot compiler \nand a Perl 5 to Parrot compiler are both finished, we can see how they \ncompare to their \"original\" vm's.\n\n> I don't understand your answer.  Allow me to rephrase and expand the\n> question.\n>\n> If Parrot is designed to benefit of dynamically typed languages, how\n> will Parrot handle statically typed code in those languages.  Will\n> Parrot discourage the use of static typing features in languages like\n> Perl by making that code execute more slowly or inefficiently than\n> equivalent dynamically typed code?\n\nThere's no reason for parrot to hinder one languages performance.  Can \nyou give an example of code to use that would help others to understand \nyour question?  Vague questions get vague answers, or no answers.  \nClarify for us, please.\n\n> > Perhaps miniparrot can help take care of this.  If miniparrot's a\n> > miniature parrot, and perhaps supporting only those features that \n> that\n> > language needs, we might be able to get a parrot suited for embedded\n> > systems.  PMC's not needed won't be compiled in, the runcores other\n> > than the default could be left out, and parrot's size could shrink\n> > dramatically.\n>\n> While many things are perhaps true, this answer sounds like \"There is\n> no definite plan for supporting this.\"\n\nThere is no immediate plan for embedded systems.  But the groundwork is \nalready laid.\n\n> > > f. How will Parrot support direct access to \"unmanaged\" resources?\n> >\n> > Is this like UnmanagedStruct?\n>\n> I mean supporting direct access to the underlying address space and\n> support for determining the sizes of data within that memory.  For\n> example, direct access to a framebuffer.\n>\n> > > g. How will Parrot facilitate distributed processing?\n> >\n> > With native threading support.\n>\n> I think you misunderstood my question.  By \"distributed\", I meant the\n> execution of code in multiple address spaces, or the non-concurrent\n> execution of code.  What support will Parrot provide for migrating\n> data or code between environment with different byte orders.  How will\n> Parrot support capturing execution state into a preservable or\n> transportable form?\n\nAll PIR is compiled to PBC, a portable(including endianness) format for \nexecuting.  Parrot can run it directly, or compile and run it in \nmemory.  You can take a PBC file written on a power pc and run it on \nIA64(theoretically, I don't believe it's been tested lately), and visa \nversa.\n\n> Again, this does not seem to be clear, so I will provide an\n> example. If a Perl compiler is compiling Perl code, and that code is\n> written to increment the result of a call into some Python code that\n> returns a PythonString, how can the compiler ask the PythonString PMC\n> if it implements the \"increment\", so that it can detect at compile\n> time what the behavior of the statement will be?\n>\n> More broadly, how can statically typed code determine if the values\n> produced by an operation will conform to the type requirements?\n\nI believe your understanding of parrot is somewhat at fault of \nconfusion.  Perl doesn't increment a string.  Python doesn't increment \na string.  A PerlString increment's itself, and a PythonString \nincrement's itself.\n\nIt's possible that you're integrating code for a language that you \ndon't have installed, so it may not be possible.  But cross language \nhandling probably isn't the most explored part of parrot.  But most \nissues will be more a matter of assumptions regarding handling two \nlanguages at once than parrot's handling.  But don't forget, most \npeople who use parrot will only use one language at a time.\n\n> What are \"basic things\"?  What if a language inherently differs in how\n> it handles those things?  For example, incrementing a scalar would\n> seem to be a basic operation in Perl, but Python will not implement\n> that basic thing in the same way.  It would seem that one or both\n> sides of this cross-language exchange of very basic types of data will\n> be problematic.\n\nEven if one doesn't implement increment on a string, it doesn't mean \nthat the \"slot\" for increment is at the same place.\n\n> You say \"the best way for parrot\" -- how can Parrot have a judgmental\n> reference point independent from the languages that target it and the\n> users of those languages?\n\nIf a language is being compiled for parrot, the compiler author is \nobviously aware of parrot's abilities and potential.  A language may be \nimplemented differently, but under the concepts that parrot is built \nupon, it won't use parrot's capabilities and potential to the fullest.  \nUsing Intel's ABI for a compiler may not be the best method for the \ngiven language, but it will help provide interoperability between other \nlanguages that use it, and benefit from advances Intel makes for \nimproving that method.\n\n> > > d. Will each language have to provide its own support for \n> interacting\n> > > with PMCs for other languages?\n> > >\n> >\n> > No, the PMC's will do that themselves.  Getting the PMC's is another\n> > story.  A language is reponsible for it's cross language semantics.\n> > But parrot is designed for the widest possible case.  Many languages\n> > limit valid characters that a subroutine can use, but parrot does \n> not.\n> > But as long as \"common\" cases are adhered to, most problems will not\n> > exist, e.g. no unicode whitespace in a subroutine name.\n>\n> You say \"No\" initially, but then go on to say \"yes\" in substance.  If\n> the PMCs are responsible for this, and if languages provide the PMCs,\n> then the languages are responsible for this.\n\nI can write a program that would benefit greatly from cross language \ncommunication.  Say I wish to combine Perl with AppleScript to control \nmy computer.  But if AppleScript doesn't support it, but Perl does, \nI'll have to use Perl to send data to AppleScript and to retrieve it.  \nIf my AppleScript program has weird subroutine names in it that Perl \ndoesn't like, I can't call those subroutines.  But if I can call those \nsubroutines, and send it a PerlScalar, I can get to do things with that \nvariable in AppleScript as well as Perl.  Parrot will handle the \nPerlScalar, even in AppleScript, but I have to get it to cross the \nboundary between languages.  I will be able to join together two Perl \nstrings from within AppleScript(although it'll probably return a Perl \nstring instead of an AppleScript string).\n\nThis is only an example, and someone else can probably come up with a \nmore valid example.\n\n> To explicitly state what is implied by this question.  If every\n> language must provide PMCs that understand how to interact with types\n> of other languages, then languages will only be able to interact with\n> each other to the degree that one or both of those languages provides\n> support.  For Perl to use data returned from Python code, either Perl\n> will have to recognize Python types or Python will have to know to\n> produce Perl types.  Then for Perl to call Tcl code, Perl and/or Tcl\n> will have to be taught about each other.  And then for Python to call\n> Tcl, yet additional code will need to be created.  Indeed, it could be\n> necessary for Python code to call Perl code that calls Tcl code,\n> because Perl might understand how to handle a Tcl type that Python\n> does not.  And the more languages that are added, the more types each\n> language will be asked to implement code to interact with.\n>\n> This seems like a scalability problem.\n\nVtables are the type.  It all comes down to being a Parrot type, using \nparrot's interface.\n\nTo create the scenario you are visioning, parrot would need to be \nextremely minimalistic, and all opcodes and pmc's would need to be \nloading via a dynpmc library and a dynop library, with no set \ndefinition of how to implement things.  Fortunately, \"rules\" exist!  \nRules are why Windows NT was a POSIX system as well to all the other \ntypes it is/was.  It aid's in the \"it just works\" idea that helps so \nmany programmers in their code.\n\n> One possible approach would be to tell every language that when they\n> wish to interact, they must produce Parrot-provided types, like String\n> or Number.  Another possible approach would be for Parrot to forcibly\n> convert language-specific data to Parrot-provided types.  Both of\n> these approaches have issues.\n>\n> Incidentally, the JVM/CTS approach is to tell every language to use\n> the same primitive types all the time and to use the same object types\n> as close to all the time as possible.  (I am only aware of one case of\n> this, being the separate 'String' type in Rhino, needed to provide\n> both Java and JavaScript String semantics. In that case, Java code\n> returns a Java String object and the caller must explicitly convert it\n> to a JavaScript string with an operation like 'string+\"\"'.)\n>\n> > > e. How will a PerlScalar interact with a PythonString?\n> >\n> > The best method would probably convert both down to a String, do\n> > whatever operation, and convert up to whatever is request.  But, for\n> > optimization, multimethod vtables could be used to provide custom\n> > behavior.  I know src/pmc/complex.pmc has some examples of \n> multimethod\n> > vtables.\n>\n> See above.  The intent of this question is not so much \"What could\n> someone happen to do in this situation\", but rather \"What exactly will\n> Parrot enforce, require or provide?\"\n\nCrossing the language boundary is up to the language, handling the \nlanguage boundary is largely up to parrot, and the programmer.\n\nDon't increment a PythonString from Perl.  If you write your code to \nsupport cross language support, you won't have a problem.  But if you \ntry to use cross language abilities with a function that doesn't expect \nit, you might have trouble.\n\n> > > f. What will happen when a PythonString is incremented in Perl \n> code?\n> >\n> > Parrot call's PythonString's increment vtable.  Perl doesn't have an\n> > increment, but PerlScalar does.  Python doesn't have an increment, \n> but\n> > PythonString does.  Now, if the PMC doesn't implement that vtable\n> > function, an exception is thrown, but Parrot still tries to call it.\n>\n> This would mean that any cross-language code could generate runtime\n> exceptions in operations that otherwise are generally considered not to\n> be able to fail.  Indeed, it would seem that every possible operation\n> would possibly fail at runtime when handling foreign data.\n\nAsking for the third element in a PerlString isn't possible, but \nperfectly normal in C.  There's the potential for a problem, but in \nmany instances you'll be passing an array to something expecting an \narray rather than passing a string to something expecting an array.\n\n> This would seem to strongly discourage multi-language programming --\n> to the point of it never happening.\n\nThe reasons programming languages exist are to aid development, namely \nspeed of development.  The language used for a program is often a \nresult of the features of the language.  PGE was written in PIR because \nit was easier than writing it in C.  This, at least at present, has a \nspeed hit, but it made it easier to implement.\n\nSuppose you want to mix Fortran with Perl 6.  Both have their \nadvantages in coding for different aspects, so you choose to write \ndifferent parts of your code in either.  You have quicker development \noverall, and few lines of code to debug.  Suppose you want Perl's regex \ncombined with Java's IO groups, with Parrot it becomes possible.\n\n> What will Parrot do to make this acceptable?  Will end-users be forced\n> to write their own test cases that attempt all valid combinations of\n> all data between all languages they wish to use?\n\nI'll remember to require a string argument to every Perl subroutine I \nwrite and increment it just to forbid Python from using it.\n\nIf you don't intend it for cross language support, then don't care.  If \nyou do intend it for cross language support, be more prudent about your \nchoices for a language, and work with users of other languages to \nimprove your library.\n\n> > > Comparing the vtable for a PMC to the JVM and CLR base Object \n> classes,\n> > > the PMC is essentially an \"abstract\" class with dozens of\n> > > \"unimplemented\" methods, while Java's Object provides (and \n> implements)\n> > > the following public methods:\n> > >\n> > >   equals getClass hashCode notify notifyAll toString wait\n> > >\n> > > Discounting the methods related to Java's peculiar threading\n> > > implementation, that's:\n> > >\n> > >   equals                 getClass hashCode    toString\n> > >\n> > > Similarly, the CLR's CTS Object provides:\n> > >\n> > >   Equals ReferenceEquals GetType  GetHashCode ToString\n> > >\n> > > g. Why is it a good thing that PMCs essentially non-contractual\n> > > abstract base classes that define a lot of functionality without\n> > > implementing it?\n> >\n> > In some instances, this is a benefit.  Suppose you want an\n> > auto-iterating string array.  For the most part, it's an array with\n> > normal array properties.  But if you get it's string value, it \n> iterates\n> > over the next one.  If you set it's string value, maybe it splices \n> that\n> > value into the array.  Having both array and string properties is\n> > beneficial in this case.\n>\n> I do not see the benefit.  You could implement exactly that without\n> having an undefined, abstract base type.  For example, with the\n> following code (which is clearly simplified):\n>\n> [...]\n>\n> Now, this was not the best of examples in the first place, because I\n> would not argue that 'ToString' is not the kind of really-useful thing\n> you want in a core data type.  The essential meaning of the routine\n> being \"make something a human can read\" -- and humans are the people\n> using the machines.  But, as you can see, there was no need for the\n> core data type to provide me with an implemented 'addValue' -- it can\n> simply be layered on using a more primitive and extensible runtime\n> support for properties.\n\nBut you forget \"zz\"++ == \"aaa\" as in perl!\n\nAnyway, wouldn't you much rather write i += \"A\"?  I know I would.  \nThere may be no need for the vtables, but otherwise you MUST know how a \nlanguage implements a given function.  With vtables, you don't, parrot \ndoes.\n\n> > But the downside is most things, such as an Integer, don't need many \n> of\n> > the vtables provided.  In fact, if you look at the c output of a pmc\n> > file, you'll see that every vtable is created.  I imagine it's more \n> for\n> > simplicity and speed than for memory(both executable and ram) than\n> > anything else.\n>\n> I don't see the simplicity or the speed benefit.  I do see the memory\n> cost.  If anything, I suspect that these larger objects will fill a\n> CPU cache faster and be slower to load because of this increased size,\n> leading to slower runtime performance.\n\nPerhaps some confusion was caused.  Parrot has an Integer PMC, like \njava's Integer object.  Parrot also has an int type, which is quite \nsimply an unsigned native integer, which has no more hit than in C.  If \nyou're worried about your speed and memory footprint in java, you'll \nuse int far more than Integer.\n\n> No, I mean why is the type-specific functionality not pushed down into\n> the next tier where it is actually needed, like the JVM and CTS do,\n> leaving the base PMC with only the same four or five methods those\n> systems have?\n\nWe have a Default, which others utilize.  Granted, parrot still uses a \n\"macro\" approach, but it works.  But as far as I know this is more \nimplementation than design.  Parrot could have just one tiny base \nclass.\n\n> Without opening a can of bees, this sounds like Parrot's performance\n> will vary greatly, depending on the quantity of variables in scope in\n> subroutines.  While it is generally true for most languages that a\n> large number of variables can trigger load/store operations when the\n> register capacity is exceeded, Parrot will switch from JIT code to\n> purely interpreted code?  While most people don't worry about\n> incurring a few load/store operations, this kind of variation may\n> cause programmers to alter their programming style significantly in\n> order to avoid unacceptable performance.\n>\n> As you say, i386 has fewer registers, but it is a very common\n> platform.  Given that, many programmers may consider it necessary to\n> write code that will be JIT-able on that platform, leading to a rather\n> awkward programming style, encouraging the use of a larger number of\n> subroutines, thus more calling, and ultimately a lot of register\n> shuffling anyway.\n\nYour computer behaves the same way, most likely.  Currently I \nuse(although not as my \"desktop\") FreeBSD on AMD64, with 16 total \ninteger registers and 16 floating point registers.  If I look at the \ndisassembled output of a function with a large number of variables, I'm \namazed at how few registers it uses, instead opting to constantly move \ndata in and out of the stack(where local variables are stored).  In \nfact, this is how Parrot has be able to achieve \"faster than c\" status \nbefore, because data is kept in registers.\n\nIf a programmer really wishes to ensure that the code is jitable, then \nthey'll need to look at the compiler output and the jit implementation.\n\nBut if you're looking at how to write your code to aid in jitability, \nyou shouldn't forget how well your compiler optimizes for certain \nfeatures, and how much of a hit certain assumptions about optimization \ncan hurt your program, such as arrays of arrays.\n\n> When I asked this question, I thought I was asking if the compiler\n> could suggest which variables should map to registers and which ones\n> should be loaded/stored.  But it seems this is a question of which\n> subroutines will use registers at all.  In that case, I wonder what\n> mechanisms Parrot will provide to inform a compiler how JIT-able a\n> subroutine is -- both on the current platform and on other\n> architectures -- to enable the compiler to know when it would make\n> sense to either automatically modify the code into JIT-able form, or\n> to warn the developer.\n\nThe tricky thing is, if it's compiled to PBC, parrot's \"ELF\" as it \nwere, you can't optimize for a particular platform.  Other than being \nopen source, parrot doesn't provide any capacity for aiding a compiler \nwith this at the moment, and a design hasn't been implemented, other \nthan some odd(and probably unportable) use of NCI(native call \ninterface) and ManagedStruct's.\n\n> Frankly, this is not much of an answer.  I am not asking if CISC\n> architectures exist, but rather I am asking why you are choosing to\n> create one.\n>\n> Moreover, I am not questioning your choices in terms of design options\n> and tradeoffs.  I am simply looking for the description of why what\n> you have was done the way you did it.\n\nWhy not ask AMD why their processors are RISC processors, with a CISC \ninterpreter as it were.\n\nBut consider a common function in cryptography.  Bitwise rotation is \noften used.  Both PPC and x86 have a rotate opcode, but C does not.  \nSimple code such as \"(a << b) | (a >> (sizeof(int)*8 - b))\" will be \ncompiled to the shifts and or that it specifies.  With a CISC vm, this \ncan be JIT'ed to one opcode perhaps, because Parrot does have a rot \nopcode.  Instead of trying to match against a sequence of codes to turn \ninto one, parrot provides that one opcode.\n\n> > > b. What is the basis for deciding what will be an operator?\n> > >\n> > > c. How can substantial quantities of additional functionality be \n> added\n> > > to this design cleanly?\n> >\n> > New vtable's can be added by editting vtable.tbl, new ops can be \n> added\n> > by adding to src/ops/experimental.ops, new pmc's can just be added to\n> > src/pmc afaik.  New charsets in src/charset, new jit architectures\n> > under src/jit(just add --jitcapable and it'll try to compile it in).\n> > I'd say it's a fairly clean layout for expanding things.  There's \n> even\n> > the capacity for adding a new garbage collected.\n>\n> It is not sufficient to say that one can write the code.  How will\n> Parrot inform an existing compiler that the new operation exists (or\n> does not exist if the version of Parrot is older).  Will compilers\n> have to themselves be recompiled even if they do not use the new\n> operators?\n\nYour question was about extending parrot's features, not seeing if they \nexist.  The best method would probably be finding the current version \nof parrot, and going from there.  Once parrot reaches version 1.0, the \nbytecode should remain relatively constant.  New opcodes may be added, \nbut older files will work regardless.  An older parrot may not run a \nnew bytecode file, but as long as a new opcode or feature isn't \nexpected, it should work find.  Given the fact that parrot isn't at \nversion 1.0, these issues are theoretical.\n\n> Also, this seems, as a design, to simply be a bag of operations.\n>\n> Finally, I would like to add some additional questions.\n>\n> 2.h. Will Parrot support inline assembly language?\n\nInline native assembly, doubtful.  But a language could support inline \npir which could be jitted, which is a little bit close.  With NCI, \nwhich allows for calling a c function, the power of parrot can become \nmassive.\n\n> 2.i. Will Parrot support primitive types?\n\nIt does, namely integers, floats, strings, and PMC's which are much \nlike a pointer.\n\n> 4.c. How will registers benefit PMCs (e.g. PerlScalar), which are not\n> primitive types and cannot be stored in a hardware register?\n>\n\nThe same way C does, as a pointer.\n\n"}
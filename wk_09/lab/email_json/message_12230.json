{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Patrick Rutkowski <rutski89@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "I was just reading (s/reading/trying to read/) the same routine\nearlier this morning. I'm glad to see that I'm not alone in my\nconfusion.\n\nIs it possible to track down the author of those odd bit-shifting\nstatements in order to ask him about it directly? I would do it myself\nbut I'm still learning my way around the finer points of SVN.\n\nOn Apr 21, 2007, at 9:24 PM, chromatic wrote:\n\n> Parrot_alloc_context() performs some calculations about the number of\n> registers used to determine how much memory to allocate:\n>\n>     const size_t size_n = sizeof (FLOATVAL) * n_regs_used[REGNO_NUM];\n>     const size_t size_nip = size_n +\n>         sizeof (INTVAL) *   n_regs_used[REGNO_INT] +\n>         sizeof (PMC*) *     n_regs_used[REGNO_PMC];\n>     size_t reg_alloc = size_nip +\n>         sizeof (STRING*) *  n_regs_used[REGNO_STR];\n>\n> Then it calculates a slot value:\n>\n>     const int slot = (reg_alloc + 7) >> 3;\n>     reg_alloc = slot << 3;\n>\n> This is where I start not to understand.  Why reg_alloc + 7?  Why  \n> shift left\n> and right by 3?\n>\n> It gets less clear.  The interpreter holds a structure for context  \n> memory with\n> a free list (an array of void pointers) and the number of free slots,\n> presumably in this list.\n>\n> After all of that calculation of slot, the function uses it as an  \n> index into\n> the free list.\n>\n> I don't understand that at all.\n>\n> I do understand the purpose of the resizing code, but not how slot  \n> relates to\n> it:\n>\n>     if (slot >= interp->ctx_mem.n_free_slots) {\n>         const int n = slot + 1;\n>         int i;\n>\n>         interp->ctx_mem.free_list = (void **)mem_sys_realloc(\n>                 interp->ctx_mem.free_list, n * sizeof (void*));\n>\n>         for (i = interp->ctx_mem.n_free_slots; i < n; ++i)\n>             interp->ctx_mem.free_list[i] = NULL;\n>         interp->ctx_mem.n_free_slots = n;\n>     }\n>\n> This is doubly weird because when Parrot initializes the free list in\n> create_initial_context(), it allocates a small number of free slots:\n>\n> #define INITIAL_FREE_SLOTS 8\n>\n>     interp->ctx_mem.n_free_slots = INITIAL_FREE_SLOTS;\n>     interp->ctx_mem.free_list    =\n>         (void **)mem_sys_allocate(INITIAL_FREE_SLOTS * sizeof (void  \n> *));\n>\n>     for (i = 0; i < INITIAL_FREE_SLOTS; ++i)\n>         interp->ctx_mem.free_list[i] = NULL;\n>\n> The result is that the free_list extends quite a bit over the initial\n> allocation, but it's mostly just an array of null.  It's fairly  \n> sparse apart\n> from that.\n>\n> Here's another curious thing when allocating a context:\n>\n>     ptr = interp->ctx_mem.free_list[slot];\n>     old = CONTEXT(interp->ctx);\n>     if (ptr) {\n>         interp->ctx_mem.free_list[slot] = *(void **) ptr;\n>     }\n>\n> I wish I could tell you what the assignments to and from ptr do  \n> here, but I\n> can't, nor what they signify.  There's a similar form to free a  \n> context:\n>\n>         ptr = ctxp;\n>         slot = ctxp->regs_mem_size >> 3;\n>\n>         assert(slot < interp->ctx_mem.n_free_slots);\n>         *(void **)ptr = interp->ctx_mem.free_list[slot];\n>         interp->ctx_mem.free_list[slot] = ptr;\n>\n> I originally thought the free_list was an array of recycled  \n> contexts to avoid\n> malloc() and free() pairs by reusing already-allocated-but-unused  \n> memory, but\n> now I can't tell what it's doing.  I tried to change this into a  \n> linked list,\n> but that failed with invalid reads.\n>\n> My best guess is that this is an odd way to store contexts of a  \n> specific size\n> in an array structure so that they're reusable with our new  \n> variable-sized\n> register sets... but the code is unclear and undocumented.  I think  \n> it's also\n> leaking memory.\n>\n> I'd like to find a simpler scheme, if it's possible.  Otherwise,  \n> I'd like to\n> figure out what's going on so we can at least explain it somehow.\n>\n> -- c\n\n"}
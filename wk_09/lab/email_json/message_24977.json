{"category": "ham", "to_address": "sigzero@gmail.com", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: looping through a file", "body": "On 5/7/07, Robert Hicks  wrote:\nsnip\n> I think part of the problem is the 'shift'ing that I was doing. I am\n> looking into that. Basically I was shift'ing the @log out of existence\n> after the first pass.\nsnip\n\nThat sounds like a viable candidate for the warning as well.\n\n\nsnip\n> > Also, you should never use a straight string in a regex; it should\n> > aways be quoted.\n> >\n> > $line = shift @log until $line =~ /\\Q$prime_id\\E/;\n>\n> What does that give you? I have never heard of that and have never had a\n> problem the way I have shown. Just curious...\nsnip\n\nThe \\Q turns off meta-characters until the \\E.  If your substr returns\n\"foo.id\" then /$prime_id/ will match \"foolid\" as well as as \"foo.id\".\nWorse yet if substr returns \"abc+de\" then /$prime_id/ won't match\nagainst \"abc+de\" only \"abcde\", \"abccde\", etc.  And the worst is\nunmatched open/close characters.  Try this\n\nperl -le '$smiley = \":)\"; print $1 if $smiley =~ /($smiley)/;'\n\nversus this\n\nperl -le '$smiley = \":)\"; print $1 if $smiley =~ /(\\Q$smiley\\E)/;'\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
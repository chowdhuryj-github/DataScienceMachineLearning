{"category": "ham", "to_address": "\"Xavier Noria\" <fxn@hashref.com>, \"Perl List\" <beginners@perl.org>", "from_address": "\"Mike Blezien\" <mickalo@frontiernet.net>", "subject": "Re: Assign a delimiter variable", "body": "Hello,\n\n----- Original Message ----- \nFrom: \"Xavier Noria\" \nTo: \"Perl List\" \nSent: Tuesday, May 15, 2007 11:49 AM\nSubject: Re: Assign a delimiter variable\n\n\n> On May 15, 2007, at 6:42 PM, Mike Blezien wrote:\n>\n>> Hello,\n>>\n>> this one has been driving me nuts and I'm sure it's something very  simple I \n>> maybe overlooking. I need to assign a delimiter variable  IE: Pipe or Comma \n>> delimiter:\n>>\n>> my $del         = '|'; # use either a '|' or ','\n>> my $dataline  = \"0|1|2|3|4|5|6|7|8|9\";\n>> my @data     = split(/$del/, $dataline);\n>>\n>> This does not work, it won't split the file line with the '|'  delimiter, and \n>> get no errors. But if I do this:\n>>\n>> my $dataline  = \"0|1|2|3|4|5|6|7|8|9\";\n>> my @data     = split(/\\|/, $dataline);\n>>\n>> Then it works prefectly, it splits the line as expected. What am I  missing \n>> ??\n>\n> The actual regexp is what you get _after_ interpolation.\n>\n> Since the pipe is a metacharacter it is being interpreted as such, as  if you \n> directly wrote\n>\n>   split /|/, ...\n>\n> To prevent this there's quotemeta(), which is available in literals  as \\E:\n>\n>   my @data     = split(/\\E$del/, $dataline);\n>\n> -- fxn\n\nActually it was the /\\Q that worked. Your suggestion got me looking back at the \nbooks and found it, thanks :)\n\nMike \n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
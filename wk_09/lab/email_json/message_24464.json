{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "mimir@samba.org", "subject": "svn commit: samba r22734 - in branches/SAMBA_4_0/source/libnet: .", "body": "Author: mimir\nDate: 2007-05-07 05:42:26 +0000 (Mon, 07 May 2007)\nNew Revision: 22734\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22734\n\nLog:\n- use samr pipe if it is already opened\n- close connection handle after domains enumeration\n- collect domain names in subsequent rounds of enumeration\n  (if there are more than one)\n\n\nrafal\n\n\nModified:\n   branches/SAMBA_4_0/source/libnet/libnet_domain.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/libnet/libnet_domain.c\n===================================================================\n--- branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-05-07 03:16:54 UTC (rev 22733)\n+++ branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-05-07 05:42:26 UTC (rev 22734)\n@@ -852,6 +852,7 @@\n \tstruct libnet_RpcConnect rpcconn;\n \tstruct samr_Connect samrconn;\n \tstruct samr_EnumDomains enumdom;\n+\tstruct samr_Close samrclose;\n \tconst char *hostname;\n \tstruct policy_handle connect_handle;\n \tint buf_size;\n@@ -866,6 +867,7 @@\n static void continue_rpc_connect(struct composite_context *c);\n static void continue_samr_connect(struct rpc_request *c);\n static void continue_samr_enum_domains(struct rpc_request *req);\n+static void continue_samr_close_handle(struct rpc_request *req);\n \n static struct domainlist* get_domain_list(TALLOC_CTX *mem_ctx, struct domain_list_state *s);\n \n@@ -927,13 +929,15 @@\n \n /*\n   Stage 3: Receive domain names available and repeat the request\n-  enumeration is not complete yet\n+  enumeration is not complete yet. Close samr connection handle\n+  upon completion.\n */\n static void continue_samr_enum_domains(struct rpc_request *req)\n {\n \tstruct composite_context *c;\n \tstruct domain_list_state *s;\n \tstruct rpc_request *enumdom_req;\n+\tstruct rpc_request *samrclose_req;\n \n \tc = talloc_get_type(req->async.private, struct composite_context);\n \ts = talloc_get_type(c->private_data, struct domain_list_state);\n@@ -944,17 +948,18 @@\n \tif (NT_STATUS_IS_OK(s->enumdom.out.result)) {\n \n \t\ts->domains = get_domain_list(c, s);\n-\t\tcomposite_done(c);\n \n \t} else if (NT_STATUS_EQUAL(s->enumdom.out.result, STATUS_MORE_ENTRIES)) {\n \t\t\n \t\ts->domains = get_domain_list(c, s);\n \t\t\n+\t\t/* prepare next round of enumeration */\n \t\ts->enumdom.in.connect_handle = &s->connect_handle;\n \t\ts->enumdom.in.resume_handle  = &s->resume_handle;\n \t\ts->enumdom.in.buf_size       = s->buf_size;\n \t\ts->enumdom.out.resume_handle = &s->resume_handle;\n \n+\t\t/* send the request */\n \t\tenumdom_req = dcerpc_samr_EnumDomains_send(s->ctx->samr.pipe, c, &s->enumdom);\n \t\tif (composite_nomem(enumdom_req, c)) return;\n \n@@ -962,11 +967,45 @@\n \n \t} else {\n \t\tcomposite_error(c, s->enumdom.out.result);\n+\t\treturn;\n \t}\n+\n+\t/* close samr connection handle */\n+\ts->samrclose.in.handle  = &s->connect_handle;\n+\ts->samrclose.out.handle = &s->connect_handle;\n+\t\n+\t/* send the request */\n+\tsamrclose_req = dcerpc_samr_Close_send(s->ctx->samr.pipe, c, &s->samrclose);\n+\tif (composite_nomem(samrclose_req, c)) return;\n+\n+\tcomposite_continue_rpc(c, samrclose_req, continue_samr_close_handle, c);\n }\n \n \n /*\n+  Stage 4: Receive result of closing samr connection handle.\n+*/\n+static void continue_samr_close_handle(struct rpc_request *req)\n+{\n+\tstruct composite_context *c;\n+\tstruct domain_list_state *s;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_list_state);\n+\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n+\n+\t/* did everything go fine ? */\n+\tif (!NT_STATUS_IS_OK(s->samrclose.out.result)) {\n+\t\tcomposite_error(c, s->samrclose.out.result);\n+\t}\n+\n+\tcomposite_done(c);\n+}\n+\n+\n+/*\n   Utility function to copy domain names from result of samr_EnumDomains call\n */\n static struct domainlist* get_domain_list(TALLOC_CTX *mem_ctx, struct domain_list_state *s)\n@@ -974,20 +1013,28 @@\n \tint i;\n \tif (mem_ctx == NULL || s == NULL) return NULL;\n \n-\t/* number of entries returned (domains enumerated) */\n-\ts->count = s->enumdom.out.num_entries;\n-\t\n \t/* copy domain names returned from samr_EnumDomains call */\n-\ts->domains = talloc_array(mem_ctx, struct domainlist, s->enumdom.out.num_entries);\n-\tfor (i = 0; i < s->enumdom.out.num_entries; i++)\n+\tif (s->domains == NULL) {\n+\t\ts->domains = talloc_array(mem_ctx, struct domainlist,\n+\t\t\t\t\t  s->enumdom.out.num_entries);\n+\t} else {\n+\t\ts->domains = talloc_realloc(mem_ctx, s->domains, struct domainlist,\n+\t\t\t\t\t    s->count + s->enumdom.out.num_entries);\n+\t}\n+\n+\tfor (i = s->count; i < s->count + s->enumdom.out.num_entries; i++)\n \t{\n+\t\tstruct lsa_String *domain_name = &s->enumdom.out.sam->entries[i - s->count].name;\n+\n \t\t/* strdup name as a child of allocated array to make it follow the array\n \t\t   in case of talloc_steal or talloc_free */\n-\t\ts->domains[i].name = talloc_strdup(s->domains,\n-\t\t\t\t\t\t   s->enumdom.out.sam->entries[i].name.string);\n+\t\ts->domains[i].name = talloc_strdup(s->domains, domain_name->string);\n \t\ts->domains[i].sid  = NULL;  /* this is to be filled out later */\n \t}\n \n+\t/* number of entries returned (domains enumerated) */\n+\ts->count += s->enumdom.out.num_entries;\n+\t\n \treturn s->domains;\n }\n \n@@ -1009,6 +1056,7 @@\n \tstruct composite_context *c;\n \tstruct domain_list_state *s;\n \tstruct composite_context *rpcconn_req;\n+\tstruct rpc_request *samrconn_req;\n \n \t/* composite context and state structure allocation */\n \tc = composite_create(ctx, ctx->event_ctx);\n@@ -1027,15 +1075,30 @@\n \t/* set the default buffer size if not stated explicitly */\n \ts->buf_size = (io->in.buf_size == 0) ? 512 : io->in.buf_size;\n \n-\t/* prepare rpc connect call */\n-\ts->rpcconn.level           = LIBNET_RPC_CONNECT_SERVER;\n-\ts->rpcconn.in.name         = s->hostname;\n-\ts->rpcconn.in.dcerpc_iface = &dcerpc_table_samr;\n+\t/* check whether samr pipe has already been opened */\n+\tif (ctx->samr.pipe == NULL) {\n+\t\t/* prepare rpc connect call */\n+\t\ts->rpcconn.level           = LIBNET_RPC_CONNECT_SERVER;\n+\t\ts->rpcconn.in.name         = s->hostname;\n+\t\ts->rpcconn.in.dcerpc_iface = &dcerpc_table_samr;\n \n-\trpcconn_req = libnet_RpcConnect_send(ctx, c, &s->rpcconn);\n-\tif (composite_nomem(rpcconn_req, c)) return c;\n+\t\trpcconn_req = libnet_RpcConnect_send(ctx, c, &s->rpcconn);\n+\t\tif (composite_nomem(rpcconn_req, c)) return c;\n+\t\t\n+\t\tcomposite_continue(c, rpcconn_req, continue_rpc_connect, c);\n \n-\tcomposite_continue(c, rpcconn_req, continue_rpc_connect, c);\n+\t} else {\n+\t\t/* prepare samr_Connect call */\n+\t\ts->samrconn.in.system_name     = 0;\n+\t\ts->samrconn.in.access_mask     = SEC_GENERIC_READ;\n+\t\ts->samrconn.out.connect_handle = &s->connect_handle;\n+\t\t\n+\t\tsamrconn_req = dcerpc_samr_Connect_send(s->ctx->samr.pipe, c, &s->samrconn);\n+\t\tif (composite_nomem(samrconn_req, c)) return c;\n+\n+\t\tcomposite_continue_rpc(c, samrconn_req, continue_samr_connect, c);\n+\t}\n+\n \treturn c;\n }\n \n\n"}
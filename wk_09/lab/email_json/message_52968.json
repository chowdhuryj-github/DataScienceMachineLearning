{"category": "ham", "to_address": "\"Chas Owens\" <chas.owens@gmail.com>", "from_address": "\"jerry gay\" <jerry.gay@gmail.com>", "subject": "Re: Web Module (Was: Perl6 new features)", "body": "On 6/22/07, Chas Owens  wrote:\n> Most of the time the policy is enacted by lower-case-l lazy sysadmins\n> who can't be bothered to type\n>\n> perl -MCPAN -e install Foo::Bar\n>\n> My normal route around them is to install the module into the home\n> directory of the user who is going to run the script, but I have had\n> difficulty with this before when it comes time to move to production:\n> \"Where is the code review for that code?\".  My answer of \"where is the\n> code review for that (often open source) database install you just\n> did?\" doesn't tend to hold the weight I wish it did.  For some reason\n> binary blobs make some types of sysadmins feel all fuzzy and warm\n> inside.\n>\nso use the parrot back end and compile all the modules to bytecode.\noh, and you can merge the foreign module bytecode with the bytecode\nfor your application, so it's all one big happy binary file.\n\nin fact, parrot will even provide a way to compile bytecode to a\nnative executable which contains parrot itself. there, now you've got\na proper binary with *zero* external requirements in the production\nenvironment--it doesn't even need to have parrot installed.\n\nat that point, i'd be surprised if the release engineers or sysadmins\neven notice.\n~jerry\n\n"}
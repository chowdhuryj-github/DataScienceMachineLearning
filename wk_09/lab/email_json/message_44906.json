{"category": "ham", "to_address": "Jeremy Goldhaber-Fiebert <JGOLDHAB@hsph.harvard.edu>", "from_address": "Spencer Graves <spencer.graves@pdf.com>", "subject": "Re: [R] Fwd: Using odesolve to produce non-negative solutions", "body": "      On the 'lsoda' help page, I did not see any option to force some \nor all parameters to be nonnegative. \n\n      Have you considered replacing the parameters that must be \nnonnegative with their logarithms?  This effective moves the 0 lower \nlimit to (-Inf) and seems to have worked well for me in the past.  \nOften, it can even make the log likelihood or sum of squares surface \nmore elliptical, which means that the standard normal approximation for \nthe sampling distribution of parameter estimates will likely be more \naccurate. \n\n      Hope this helps. \n      Spencer Graves\np.s.  Your example seems not to be self contained.  If I could have \neasily copied it from your email and run it myself, I might have been \nable to offer more useful suggestions. \n\nJeremy Goldhaber-Fiebert wrote:\n> Hello,\n>\n> I am using odesolve to simulate a group of people moving through time and transmitting infections to one another. \n>\n> In Matlab, there is a NonNegative option which tells the Matlab solver to keep the vector elements of the ODE solution non-negative at all times. What is the right way to do this in R?\n>\n> Thanks,\n> Jeremy\n>\n> P.S., Below is a simplified version of the code I use to try to do this, but I am not sure that it is theoretically right \n>\n> dynmodel <- function(t,y,p) \n> { \n> ## Initialize parameter values\n>\n> \tbirth <- p$mybirth(t)\n> \tdeath <- p$mydeath(t)\n> \trecover <- p$myrecover\n> \tbeta <- p$mybeta\n> \tvaxeff <- p$myvaxeff\n> \tvaccinated <- p$myvax(t)\n>\n> \tvax <- vaxeff*vaccinated/100\n>\n> ## If the state currently has negative quantities (shouldn't have), then reset to reasonable values for computing meaningful derivatives\n>\n> \tfor (i in 1:length(y)) {\n> \t\tif (y[i]<0) {\n> \t\t\ty[i] <- 0\n> \t\t}\n> \t}\n>\n> \tS <- y[1]\n> \tI <- y[2]\n> \tR <- y[3]\n> \tN <- y[4]\n>\n> \tshat <- (birth*(1-vax)) - (death*S) - (beta*S*I/N)\n> \tihat <- (beta*S*I/N) - (death*I) - (recover*I)\n> \trhat <- (birth*(vax)) + (recover*I) - (death*R)\n>\n> ## Do we overshoot into negative space, if so shrink derivative to bring state to 0 \n> ## then rescale the components that take the derivative negative\n>\n> \tif (shat+S<0) {\n> \t\tshat_old <- shat\n> \t\tshat <- -1*S\n> \t\tscaled_transmission <- (shat/shat_old)*(beta*S*I/N)\n> \t\tihat <- scaled_transmission - (death*I) - (recover*I)\n> \t\t\n> \t}\t\n> \tif (ihat+I<0) {\n> \t\tihat_old <- ihat\n> \t\tihat <- -1*I\n> \t\tscaled_recovery <- (ihat/ihat_old)*(recover*I)\n> \t\trhat <- scaled_recovery +(birth*(vax)) - (death*R)\n> \t\n> \t}\t\n> \tif (rhat+R<0) {\n> \t\trhat <- -1*R\n> \t}\t\n>\n> \tnhat <- shat + ihat + rhat\n>\n> \tif (nhat+N<0) {\n> \t\tnhat <- -1*N\t\n> \t}\t\n>\n> ## return derivatives\n>\n> \tlist(c(shat,ihat,rhat,nhat),c(0))\n>\n> }\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
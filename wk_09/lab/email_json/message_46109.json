{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23416 - in branches/SAMBA_3_0_26/source/lib: .", "body": "Author: obnox\nDate: 2007-06-11 10:52:29 +0000 (Mon, 11 Jun 2007)\nNew Revision: 23416\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23416\n\nLog:\nForgot to \"svn add lib/util_reg.c\" in r23415...\n\nMichael\n\n\nAdded:\n   branches/SAMBA_3_0_26/source/lib/util_reg.c\n\n\nChangeset:\nAdded: branches/SAMBA_3_0_26/source/lib/util_reg.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/util_reg.c\t2007-06-11 10:46:25 UTC (rev 23415)\n+++ branches/SAMBA_3_0_26/source/lib/util_reg.c\t2007-06-11 10:52:29 UTC (rev 23416)\n@@ -0,0 +1,110 @@\n+/*\n+ * Unix SMB/CIFS implementation.\n+ * Registry helper routines\n+ * Copyright (C) Volker Lendecke 2006\n+ * \n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ * \n+ * This program is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+ * more details.\n+ * \n+ * You should have received a copy of the GNU General Public License along with\n+ * this program; if not, write to the Free Software Foundation, Inc., 675\n+ * Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+\n+#include \"includes.h\"\n+\n+const char *reg_type_lookup(uint32 type)\n+{\n+\tconst char *result;\n+\n+\tswitch(type) {\n+\tcase REG_NONE:\n+\t\tresult = \"REG_NONE\";\n+\t\tbreak;\n+\tcase REG_SZ:\n+\t\tresult = \"REG_SZ\";\n+\t\tbreak;\n+\tcase REG_EXPAND_SZ:\n+\t\tresult = \"REG_EXPAND_SZ\";\n+\t\tbreak;\n+\tcase REG_BINARY:\n+\t\tresult = \"REG_BINARY\";\n+\t\tbreak;\n+\tcase REG_DWORD:\n+\t\tresult = \"REG_DWORD\";\n+\t\tbreak;\n+\tcase REG_DWORD_BE:\n+\t\tresult = \"REG_DWORD_BE\";\n+\t\tbreak;\n+\tcase REG_LINK:\n+\t\tresult = \"REG_LINK\";\n+\t\tbreak;\n+\tcase REG_MULTI_SZ:\n+\t\tresult = \"REG_MULTI_SZ\";\n+\t\tbreak;\n+\tcase REG_RESOURCE_LIST:\n+\t\tresult = \"REG_RESOURCE_LIST\";\n+\t\tbreak;\n+\tcase REG_FULL_RESOURCE_DESCRIPTOR:\n+\t\tresult = \"REG_FULL_RESOURCE_DESCRIPTOR\";\n+\t\tbreak;\n+\tcase REG_RESOURCE_REQUIREMENTS_LIST:\n+\t\tresult = \"REG_RESOURCE_REQUIREMENTS_LIST\";\n+\t\tbreak;\n+\tcase REG_QWORD:\n+\t\tresult = \"REG_QWORD\";\n+\t\tbreak;\n+\tdefault:\n+\t\tresult = \"REG TYPE IS UNKNOWN\";\n+\t\tbreak;\n+\t}\n+\treturn result;\n+}\n+\n+NTSTATUS reg_pull_multi_sz(TALLOC_CTX *mem_ctx, const void *buf, size_t len,\n+\t\t\t   int *num_values, char ***values)\n+{\n+\tconst smb_ucs2_t *p = (const smb_ucs2_t *)buf;\n+\t*num_values = 0;\n+\n+\t/*\n+\t * Make sure that a talloc context for the strings retrieved exists\n+\t */\n+\n+\tif (!(*values = TALLOC_ARRAY(mem_ctx, char *, 1))) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tlen /= 2; \t\t/* buf is a set of UCS2 strings */\n+\n+\twhile (len > 0) {\n+\t\tchar *val;\n+\t\tsize_t dstlen, thislen;\n+\n+\t\tthislen = strnlen_w(p, len) + 1;\n+\t\tdstlen = convert_string_allocate(*values, CH_UTF16LE, CH_UNIX,\n+\t\t\t\t\t\t p, thislen*2, (void *)&val,\n+\t\t\t\t\t\t True);\n+\t\tif (dstlen == (size_t)-1) {\n+\t\t\tTALLOC_FREE(*values);\n+\t\t\treturn NT_STATUS_NO_MEMORY;\n+\t\t}\n+\n+\t\tADD_TO_ARRAY(*values, char *, val, values, num_values);\n+\t\tif (*values == NULL) {\n+\t\t\treturn NT_STATUS_NO_MEMORY;\n+\t\t}\n+\n+\t\tp += thislen;\n+\t\tlen -= thislen;\n+\t}\n+\n+\treturn NT_STATUS_OK;\n+}\n\n"}
{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: Should a dirhandle be a filehandle-like iterator?", "body": "On Sun, Apr 15, 2007 at 01:16:32PM -0400, John Macdonald wrote:\n: On Fri, Apr 13, 2007 at 08:14:42PM -0700, Geoffrey Broadwell wrote:\n: > [...] -- so non-dwimmy open\n: > variants are a good idea to keep around.\n: > \n: > This could be as simple as 'open(:!dwim)' I guess, or whatever the\n: > negated boolean adverb syntax is these days ....\n: \n: open(:file), open(:dir), open(:url), ... could be the non-dwimmy\n: versions.  If you don't specify an explicit non-dwimmy base\n: variant, the dwim magic makes a (preferrably appropriate) choice.\n\nI suspect that since we have a type system now we should probably use it\nfor the non-dwimmy versions.\n\n    my $io = IO::File.open($str)\n    my $io = IO::Pipe.open($str)\n    my $io = IO::Socket.open($str)\n    my $io = IO::Dir.open($str)\n    my $io = IO::URI.open($str)\n\netc.  And of course different kinds of objects can have different\ndefaults.  I'd guess the default for directories is to take a snapshot\nand sort the entries, for instance.  Certainly the open is the only\nplace we have to distinguish the type, and $io.close will close\nany of them.\n\nTo me the interesting question is, when do we assume that a string\nis a filename or uri?  I can argue that for historical and security\nreasons bare open() should always assume the provided string is a\nnormal filename.  However, given that the existence of feed operators\nremoves most of my objections to Ingy's io() interface, we could make\nthat default to uri processing:\n\n    io('http://www.wall.org/~larry') ==> my @homepage;\n\nThough we have a bit of a semantic problem insofar as\n\n    @source ==> io('file:foo')\n\nis going to want to supply more arguments to io() rather than send\nthe feed to some method of the IO object, unless io() is some kind of\na context-sensitive macro, or at least has a signature that doesn't\nallow slurpies.  And currently feed ops are considered statement\nterminators, which makes it odd to think about overloading them.\nMore of a problem is that multiple dispatch based on argument type\ndepends on eager evaluation of dynamic types, while feeds are basically\nlazy.  We don't know how \"hard\" to call io() without recognizing it\nas special, or specifying the actual method:\n\n    @source ==> io('file:foo').print\n\nMaybe that's good enough, but it seems like we could do a little\nbetter.  Hmm, type coercions tend to be unary, or at least not\n\"listy\", so maybe we can just recognize types as returning source\nand sink objects, which feeds automatically call with an appropriate\nvariadic method (.lines, .print, .tap) depending on pointiness:\n\n    IO('http://www.wall.org/~larry') ==> my @homepage;\t# implicit .lines\n    @source ==> IO('file:foo')\t\t\t\t# implicit .print\n    @source ==> IO($debuglog) ==> @sink\t\t\t# implicit .tap\n\nLarry\n\n"}
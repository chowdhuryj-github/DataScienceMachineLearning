{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Generalizing ?? !!", "body": "Rereading A03, I ran across the original reasoning behind why Perl 5's\n'?:' trinary operator became '?? ::' first, and then '?? !!'.  Three\nreasons were given:\n\n* the '?' and ':' tokens are far too broadly useful to be gobbled up\nby the trinary operator.\n\n* the doubled symbols bring to mind the short-circuiting operators\n(e.g., '&&' and '||'), suggesting a similar short-circuiting behavior\nhere.\n\n* the '!!' brings to mind \"evaluate this when the condition fails\".\n\nIMHO, the first point was always more about the ':' than it was about\nthe '?'; if you were to replace ':' with '!', I suspect that this\nconcern would largely go away.  That is, I don't see any infix: or\ninfix: operators in the current draft.  A case could be made that a\ntrinary '... ? ... ! ...' operator could work within the current state\nof things without conflict.  Also, the whitespace disambiguation rules\nthat were later implemented go a long way to resolving the original\nproblem of ':' trying to do too much.\n\nThat said, the latter two points are still valid.  '... ? ... : ...'\nmight be perfectly workable; but so is '... ?? ... !! ...'.\n\nHowever, there still may be room for improvement.  Consider the\nfollowing possibility:\n\nInstead of being a single, inflexible trinary operator, break this\ninto a pair of binary operators: infix: and infix:.  Each can\nbe used on its own, returning the right side if the condition\nevaluates as expected (i.e., true for ?? and false for !!), and\notherwise returns 'undef'.  A variation of chaining associativity gets\nused, with the \"chaining rule\" being '$v1 op1 $v2 // $v1 op2 $v3'\ninstead of '$v1 op1 $v2 && $v2 op2 $v3', as is the case for comparison\nchaining.  So all of the following would be valid syntax:\n\n  $test ?? $a !! $b  # true: $a; false: $b\n  $test !! $a ?? $b  # true: $b; false: $a\n  $test ?? $a       # true: $a; false: undef\n  $test !! $b       # true: undef; false: $a\n\nI suggest this mainly because it's potentially more extensible than\nthe current model.  I could see someone devising a \"fuzzy logic\"\nmodule which could allow for such things as:\n\n  $test ?? $a !! $b maybe $c likely $d unlikely $e\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 143: add debug tracing to fetch_lock in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 143\nrevision-id: tridge@samba.org-20070417123923-99d9e4b5174f992d\nparent: tridge@samba.org-20070417122717-55b27f525e956688\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-04-17 22:39:23 +1000\nmessage:\n  add debug tracing to fetch_lock\nmodified:\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-04-17 12:13:06 +0000\n+++ b/common/ctdb.c\t2007-04-17 12:39:23 +0000\n@@ -285,8 +285,11 @@\n \t\texpected++;\n \t}\n \twhile (ctdb->num_connected != expected) {\n+\t\tDEBUG(3,(\"ctdb_connect_wait: waiting for %d nodes (have %d)\\n\", \n+\t\t\t expected, ctdb->num_connected));\n \t\tevent_loop_once(ctdb->ev);\n \t}\n+\tDEBUG(3,(\"ctdb_connect_wait: got all %d nodes\\n\", expected));\n }\n \n /*\n\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-04-17 12:13:06 +0000\n+++ b/common/ctdb_client.c\t2007-04-17 12:39:23 +0000\n@@ -414,6 +414,8 @@\n \tr.hdr.ctdb_magic = CTDB_MAGIC;\n \tr.hdr.ctdb_version = CTDB_VERSION;\n \tr.hdr.operation = CTDB_REQ_CONNECT_WAIT;\n+\n+\tDEBUG(3,(\"ctdb_connect_wait: sending to ctdbd\\n\"));\n \t\n \tres = ctdb_queue_send(ctdb->daemon.queue, (uint8_t *)&r.hdr, r.hdr.length);\n \tif (res != 0) {\n@@ -421,6 +423,8 @@\n \t\treturn;\n \t}\n \n+\tDEBUG(3,(\"ctdb_connect_wait: waiting\\n\"));\n+\n \t/* now we can go into the normal wait routine, as the reply packet\n \t   will update the ctdb->num_connected variable */\n \tctdb_daemon_connect_wait(ctdb);\n@@ -556,6 +560,9 @@\n \t}\n \th->data    = data;\n \n+\tDEBUG(3,(\"ctdb_fetch_lock: key=%*.*s\\n\", key.dsize, key.dsize, \n+\t\t (const char *)key.dptr));\n+\n \t/* step 1 - get the chain lock */\n \tret = ctdb_ltdb_lock(ctdb_db, key);\n \tif (ret != 0) {\n@@ -564,6 +571,8 @@\n \t\treturn NULL;\n \t}\n \n+\tDEBUG(4,(\"ctdb_fetch_lock: got chain lock\\n\"));\n+\n \ttalloc_set_destructor(h, fetch_lock_destructor);\n \n \tret = ctdb_ltdb_fetch(ctdb_db, key, &h->header, ctdb_db, data);\n@@ -572,19 +581,26 @@\n \t\treturn NULL;\n \t}\n \n+\tDEBUG(4,(\"ctdb_fetch_lock: done local fetch\\n\"));\n+\n \t/* step 2 - check if we are the dmaster */\n \tif (h->header.dmaster == ctdb_db->ctdb->vnn) {\n+\t\tDEBUG(4,(\"ctdb_fetch_lock: we are dmaster - done\\n\"));\n \t\treturn h;\n \t}\n \n \t/* we're not the dmaster - ask the ctdb daemon to make us dmaster */\n \tstate = ctdb_client_fetch_lock_send(ctdb_db, mem_ctx, key, &h->header);\n+\tDEBUG(4,(\"ctdb_fetch_lock: done fetch_lock_send\\n\"));\n \tret = ctdb_client_fetch_lock_recv(state, mem_ctx, key, &h->header, data);\n \tif (ret != 0) {\n+\t\tDEBUG(4,(\"ctdb_fetch_lock: fetch_lock_recv failed\\n\"));\n \t\ttalloc_free(h);\n \t\treturn NULL;\n \t}\n \n+\tDEBUG(4,(\"ctdb_fetch_lock: record is now local\\n\"));\n+\n \t/* the record is now local, and locked. update the record on disk\n \t   to mark us as the dmaster*/\n \th->header.dmaster = ctdb_db->ctdb->vnn;\n@@ -595,6 +611,8 @@\n \t\treturn NULL;\n \t}\n \n+\tDEBUG(4,(\"ctdb_fetch_lock: done\\n\"));\n+\n \t/* give the caller a handle to be used for ctdb_record_store() or a cancel via\n \t   a talloc_free() */\n \treturn h;\n\n"}
{"category": "ham", "to_address": "Chas Owens <chas.owens@gmail.com>", "from_address": "Mathew Snyder <theillien@yahoo.com>", "subject": "Re: Proper class setup?", "body": "Chas Owens wrote:\n> On 6/22/07, Mathew Snyder  wrote:\n> snip\n>> I'm not sure what you mean by \"Change your new() in a new() and init()\".\n> snip\n>> What do you mean by \"set/get approach\"?\n> snip\n> \n> Some people believe that new should just create a new blank object and\n> call an init method to do setup.  There are good arguments both ways.\n> \n> Manually writing Accessor, Mutator, Getter, or Setter methods sucks\n> and is error prone.  It is often better to write one getter and one\n> setter that gets or sets the field(s) passed to it.  Another method is\n> to use Perl's autoload capability to magically create subroutines for\n> you.  Starting with some Perl in the 5.8 line the autoload function\n> gained the ability to be an lvalue, so I have written it that way.\n> \n> Perl script:\n> #!/usr/bin/perl\n> \n> use strict;\n> use warnings;\n> use Report;\n> \n> my $rpt = Report->new;\n> \n> $rpt->set({id => 5, queue => 10});\n> print $rpt->printable;\n> \n> my ($id, $queue) = $rpt->get(qw(id queue));\n> \n> print \"id is $id and queue is $queue\\n\";\n> \n> #same thing, but I like the => better\n> $rpt->set(\"id\", 6);\n> $rpt->set(id => 6);\n> \n> print \"id is now \", $rpt->get(\"id\"), \"\\n\";\n> \n> $rpt->id = 7;\n> print \"id is now \", $rpt->id, \"\\n\";\n> \n> Module:\n> package Report;\n> \n> use strict;\n> use warnings;\n> use Carp;\n> \n> our $AUTOLOAD;\n> our %fields = (\n>        _id       => 1,\n>        _queue    => 1,\n>        _owner    => 1,\n>        _priority => 1,\n>        _worked   => 1,\n>        _timeLeft => 1,\n>        _due      => 1,\n>        _created  => 1,\n>        _updated  => 1,\n>        _severity => 1,\n>        _ccl      => 1,\n> );\n> \n> #minimal new\n> sub new {\n>       my $class = shift;\n>       my $self  = bless {}, $class;\n>       $self->init(@_);\n>       return $self;\n> }\n> \n> #real object creation happens here\n> sub init {\n>        my $self   = shift;\n>        my @fields = keys %fields;\n>        @{$self}{@fields} = (undef) x @fields;\n> }\n> \n> sub _validate_field {\n>        my ($self, $k) = @_;\n>        croak \"$k is not a valid field for \" . ref $self\n>                unless $fields{\"_$k\"};\n> }\n> \n> #Getter/setter method 1\n> sub get {\n>        my ($self, @k) = @_;\n>        my @ret;\n>        for my $k (@k) {\n>                $self->_validate_field($k);\n>                push @ret, $self->{\"_$k\"};\n>        }\n>        local $\" = ' ::: ';\n>        return @ret\n> }\n> \n> sub set {\n>        my $self = shift;\n>        croak \"bad number of arguments\" unless @_ == 2 or @_ == 1;\n>        if (@_ == 2) {\n>                $self->_validate_field($_[0]);\n>                return $self->{\"_$_[0]\"} = $_[1];\n>        }\n>        croak \"not a hash reference\" unless ref $_[0] eq 'HASH';\n>        my $h = $_[0];\n>        my @ret;\n>        for my $k (keys %$h) {\n>                $self->_validate_field($k);\n>                push @ret, $self->{\"_$k\"} = $h->{$k};\n>        }\n>        return @ret;\n> }\n> \n> #another form of setter/getter\n> \n> sub AUTOLOAD : lvalue {\n>        my ($k) = $AUTOLOAD =~ /::(.*?)$/;\n>        return if $k eq 'DESTROY';\n>        my $self = shift;\n>        $self->_validate_field($k);\n>        $self->{\"_$k\"};\n> }\n> \n> sub printable {\n>       my ($self) = @_;\n> \n>       # return Printable Report info\n>       return $self->id . \" \" . $self->queue . \"\\n\";\n> }\n> \n> 1;\n> \n\nI pretty much have a very small idea of what is going on up there.\n\nMathew\nKeep up with me and what I'm up to: http://theillien.blogspot.com\n\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
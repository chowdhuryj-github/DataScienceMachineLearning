{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "svn commit: samba r22832 - in branches/SAMBA_4_0/source/lib/tdb:\n\tcommon include", "body": "Author: tridge\nDate: 2007-05-14 01:00:06 +0000 (Mon, 14 May 2007)\nNew Revision: 22832\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22832\n\nLog:\n\nmerged the latest tdb changes from ctdb to Samba4\n\nModified:\n   branches/SAMBA_4_0/source/lib/tdb/common/lock.c\n   branches/SAMBA_4_0/source/lib/tdb/common/tdb.c\n   branches/SAMBA_4_0/source/lib/tdb/include/tdb.h\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/lib/tdb/common/lock.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/lock.c\t2007-05-14 00:58:24 UTC (rev 22831)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/lock.c\t2007-05-14 01:00:06 UTC (rev 22832)\n@@ -28,6 +28,8 @@\n \n #include \"tdb_private.h\"\n \n+#define TDB_MARK_LOCK 0x80000000\n+\n /* a byte range locking function - return 0 on success\n    this functions locks/unlocks 1 byte at the specified offset.\n \n@@ -109,7 +111,10 @@\n {\n \tstruct tdb_lock_type *new_lck;\n \tint i;\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n \n+\tltype &= ~TDB_MARK_LOCK;\n+\n \t/* a global lock allows us to avoid per chain locks */\n \tif (tdb->global_lock.count && \n \t    (ltype == tdb->global_lock.ltype || ltype == F_RDLCK)) {\n@@ -158,7 +163,8 @@\n \n \t/* Since fcntl locks don't nest, we do a lock for the first one,\n \t   and simply bump the count for future ones */\n-\tif (tdb->methods->tdb_brlock(tdb,FREELIST_TOP+4*list,ltype, op,\n+\tif (!mark_lock &&\n+\t    tdb->methods->tdb_brlock(tdb,FREELIST_TOP+4*list, ltype, op,\n \t\t\t\t     0, 1)) {\n \t\treturn -1;\n \t}\n@@ -200,7 +206,10 @@\n \tint ret = -1;\n \tint i;\n \tstruct tdb_lock_type *lck = NULL;\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n \n+\tltype &= ~TDB_MARK_LOCK;\n+\n \t/* a global lock allows us to avoid per chain locks */\n \tif (tdb->global_lock.count && \n \t    (ltype == tdb->global_lock.ltype || ltype == F_RDLCK)) {\n@@ -244,8 +253,12 @@\n \t * anyway.\n \t */\n \n-\tret = tdb->methods->tdb_brlock(tdb, FREELIST_TOP+4*list, F_UNLCK,\n-\t\t\t\t       F_SETLKW, 0, 1);\n+\tif (mark_lock) {\n+\t\tret = 0;\n+\t} else {\n+\t\tret = tdb->methods->tdb_brlock(tdb, FREELIST_TOP+4*list, F_UNLCK,\n+\t\t\t\t\t       F_SETLKW, 0, 1);\n+\t}\n \ttdb->num_locks--;\n \n \t/*\n@@ -275,8 +288,12 @@\n \n \n /* lock/unlock entire database */\n-static int _tdb_lockall(struct tdb_context *tdb, int ltype)\n+static int _tdb_lockall(struct tdb_context *tdb, int ltype, int op)\n {\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n+\n+\tltype &= ~TDB_MARK_LOCK;\n+\n \t/* There are no locks on read-only dbs */\n \tif (tdb->read_only || tdb->traverse_read)\n \t\treturn TDB_ERRCODE(TDB_ERR_LOCK, -1);\n@@ -296,9 +313,12 @@\n \t\treturn TDB_ERRCODE(TDB_ERR_LOCK, -1);\n \t}\n \n-\tif (tdb->methods->tdb_brlock(tdb, FREELIST_TOP, ltype, F_SETLKW, \n+\tif (!mark_lock &&\n+\t    tdb->methods->tdb_brlock(tdb, FREELIST_TOP, ltype, op,\n \t\t\t\t     0, 4*tdb->header.hash_size)) {\n-\t\tTDB_LOG((tdb, TDB_DEBUG_ERROR, \"tdb_lockall failed (%s)\\n\", strerror(errno)));\n+\t\tif (op == F_SETLKW) {\n+\t\t\tTDB_LOG((tdb, TDB_DEBUG_ERROR, \"tdb_lockall failed (%s)\\n\", strerror(errno)));\n+\t\t}\n \t\treturn -1;\n \t}\n \n@@ -308,9 +328,15 @@\n \treturn 0;\n }\n \n+\n+\n /* unlock entire db */\n static int _tdb_unlockall(struct tdb_context *tdb, int ltype)\n {\n+\tbool mark_lock = ((ltype & TDB_MARK_LOCK) == TDB_MARK_LOCK);\n+\n+\tltype &= ~TDB_MARK_LOCK;\n+\n \t/* There are no locks on read-only dbs */\n \tif (tdb->read_only || tdb->traverse_read) {\n \t\treturn TDB_ERRCODE(TDB_ERR_LOCK, -1);\n@@ -325,7 +351,8 @@\n \t\treturn 0;\n \t}\n \n-\tif (tdb->methods->tdb_brlock(tdb, FREELIST_TOP, F_UNLCK, F_SETLKW, \n+\tif (!mark_lock &&\n+\t    tdb->methods->tdb_brlock(tdb, FREELIST_TOP, F_UNLCK, F_SETLKW, \n \t\t\t\t     0, 4*tdb->header.hash_size)) {\n \t\tTDB_LOG((tdb, TDB_DEBUG_ERROR, \"tdb_unlockall failed (%s)\\n\", strerror(errno)));\n \t\treturn -1;\n@@ -340,9 +367,27 @@\n /* lock entire database with write lock */\n int tdb_lockall(struct tdb_context *tdb)\n {\n-\treturn _tdb_lockall(tdb, F_WRLCK);\n+\treturn _tdb_lockall(tdb, F_WRLCK, F_SETLKW);\n }\n \n+/* lock entire database with write lock - mark only */\n+int tdb_lockall_mark(struct tdb_context *tdb)\n+{\n+\treturn _tdb_lockall(tdb, F_WRLCK | TDB_MARK_LOCK, F_SETLKW);\n+}\n+\n+/* unlock entire database with write lock - unmark only */\n+int tdb_lockall_unmark(struct tdb_context *tdb)\n+{\n+\treturn _tdb_unlockall(tdb, F_WRLCK | TDB_MARK_LOCK);\n+}\n+\n+/* lock entire database with write lock - nonblocking varient */\n+int tdb_lockall_nonblock(struct tdb_context *tdb)\n+{\n+\treturn _tdb_lockall(tdb, F_WRLCK, F_SETLK);\n+}\n+\n /* unlock entire database with write lock */\n int tdb_unlockall(struct tdb_context *tdb)\n {\n@@ -352,9 +397,15 @@\n /* lock entire database with read lock */\n int tdb_lockall_read(struct tdb_context *tdb)\n {\n-\treturn _tdb_lockall(tdb, F_RDLCK);\n+\treturn _tdb_lockall(tdb, F_RDLCK, F_SETLKW);\n }\n \n+/* lock entire database with read lock - nonblock varient */\n+int tdb_lockall_read_nonblock(struct tdb_context *tdb)\n+{\n+\treturn _tdb_lockall(tdb, F_RDLCK, F_SETLK);\n+}\n+\n /* unlock entire database with read lock */\n int tdb_unlockall_read(struct tdb_context *tdb)\n {\n@@ -376,6 +427,18 @@\n \treturn tdb_lock_nonblock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK);\n }\n \n+/* mark a chain as locked without actually locking it. Warning! use with great caution! */\n+int tdb_chainlock_mark(struct tdb_context *tdb, TDB_DATA key)\n+{\n+\treturn tdb_lock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK | TDB_MARK_LOCK);\n+}\n+\n+/* unmark a chain as locked without actually locking it. Warning! use with great caution! */\n+int tdb_chainlock_unmark(struct tdb_context *tdb, TDB_DATA key)\n+{\n+\treturn tdb_unlock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK | TDB_MARK_LOCK);\n+}\n+\n int tdb_chainunlock(struct tdb_context *tdb, TDB_DATA key)\n {\n \treturn tdb_unlock(tdb, BUCKET(tdb->hash_fn(&key)), F_WRLCK);\n\nModified: branches/SAMBA_4_0/source/lib/tdb/common/tdb.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/tdb.c\t2007-05-14 00:58:24 UTC (rev 22831)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/tdb.c\t2007-05-14 01:00:06 UTC (rev 22832)\n@@ -31,10 +31,10 @@\n TDB_DATA tdb_null;\n \n /*\n-  increment the tdb sequence number if the tdb has been opened using\n+  non-blocking increment of the tdb sequence number if the tdb has been opened using\n   the TDB_SEQNUM flag\n */\n-static void tdb_increment_seqnum(struct tdb_context *tdb)\n+void tdb_increment_seqnum_nonblock(struct tdb_context *tdb)\n {\n \ttdb_off_t seqnum=0;\n \t\n@@ -42,17 +42,30 @@\n \t\treturn;\n \t}\n \n-\tif (tdb_brlock(tdb, TDB_SEQNUM_OFS, F_WRLCK, F_SETLKW, 1, 1) != 0) {\n-\t\treturn;\n-\t}\n-\n \t/* we ignore errors from this, as we have no sane way of\n \t   dealing with them.\n \t*/\n \ttdb_ofs_read(tdb, TDB_SEQNUM_OFS, &seqnum);\n \tseqnum++;\n \ttdb_ofs_write(tdb, TDB_SEQNUM_OFS, &seqnum);\n+}\n \n+/*\n+  increment the tdb sequence number if the tdb has been opened using\n+  the TDB_SEQNUM flag\n+*/\n+static void tdb_increment_seqnum(struct tdb_context *tdb)\n+{\n+\tif (!(tdb->flags & TDB_SEQNUM)) {\n+\t\treturn;\n+\t}\n+\n+\tif (tdb_brlock(tdb, TDB_SEQNUM_OFS, F_WRLCK, F_SETLKW, 1, 1) != 0) {\n+\t\treturn;\n+\t}\n+\n+\ttdb_increment_seqnum_nonblock(tdb);\n+\n \ttdb_brlock(tdb, TDB_SEQNUM_OFS, F_UNLCK, F_SETLKW, 1, 1);\n }\n \n@@ -649,3 +662,11 @@\n \treturn tdb->flags;\n }\n \n+\n+/*\n+  enable sequence number handling on an open tdb\n+*/\n+void tdb_enable_seqnum(struct tdb_context *tdb)\n+{\n+\ttdb->flags |= TDB_SEQNUM;\n+}\n\nModified: branches/SAMBA_4_0/source/lib/tdb/include/tdb.h\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/include/tdb.h\t2007-05-14 00:58:24 UTC (rev 22831)\n+++ branches/SAMBA_4_0/source/lib/tdb/include/tdb.h\t2007-05-14 01:00:06 UTC (rev 22832)\n@@ -116,9 +116,13 @@\n int tdb_traverse_read(struct tdb_context *tdb, tdb_traverse_func fn, void *);\n int tdb_exists(struct tdb_context *tdb, TDB_DATA key);\n int tdb_lockall(struct tdb_context *tdb);\n+int tdb_lockall_nonblock(struct tdb_context *tdb);\n int tdb_unlockall(struct tdb_context *tdb);\n int tdb_lockall_read(struct tdb_context *tdb);\n+int tdb_lockall_read_nonblock(struct tdb_context *tdb);\n int tdb_unlockall_read(struct tdb_context *tdb);\n+int tdb_lockall_mark(struct tdb_context *tdb);\n+int tdb_lockall_unmark(struct tdb_context *tdb);\n const char *tdb_name(struct tdb_context *tdb);\n int tdb_fd(struct tdb_context *tdb);\n tdb_log_func tdb_log_fn(struct tdb_context *tdb);\n@@ -131,6 +135,8 @@\n int tdb_hash_size(struct tdb_context *tdb);\n size_t tdb_map_size(struct tdb_context *tdb);\n int tdb_get_flags(struct tdb_context *tdb);\n+void tdb_enable_seqnum(struct tdb_context *tdb);\n+void tdb_increment_seqnum_nonblock(struct tdb_context *tdb);\n \n /* Low level locking functions: use with care */\n int tdb_chainlock(struct tdb_context *tdb, TDB_DATA key);\n@@ -138,6 +144,8 @@\n int tdb_chainunlock(struct tdb_context *tdb, TDB_DATA key);\n int tdb_chainlock_read(struct tdb_context *tdb, TDB_DATA key);\n int tdb_chainunlock_read(struct tdb_context *tdb, TDB_DATA key);\n+int tdb_chainlock_mark(struct tdb_context *tdb, TDB_DATA key);\n+int tdb_chainlock_unmark(struct tdb_context *tdb, TDB_DATA key);\n \n /* Debug functions. Not used in production. */\n void tdb_dump_all(struct tdb_context *tdb);\n\n"}
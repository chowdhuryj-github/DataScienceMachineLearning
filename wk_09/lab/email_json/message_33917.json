{"category": "ham", "to_address": "p2 <parrot-porters@perl.org>", "from_address": "Will Coleda <will@coleda.com>", "subject": "new FAQs", "body": "I was talking to a colleague (who wishes to remain anonymous), and s/ \nhe had a list of questions about the state of parrot that I think  \nshould end up in the FAQ or elsewhere in the repo. I wanted to post  \nthem here to get some discussion - I don't have answers to many of  \nthese questions myself.\n\n---\n\n\n1. Why Parrot?\n\nhttp://www.parrotcode.org/docs/intro.html:\n\n\"Parrot is designed with the needs of dynamically typed languages\n(such as Perl and Python) in mind, and should be able to run programs\nwritten in these languages more efficiently than VMs developed with\nstatic languages in mind (JVM, .NET). Parrot is also designed to\nprovide interoperability between languages that compile to it. In\ntheory, you will be able to write a class in Perl, subclass it in\nPython and then instantiate and use that subclass in a Tcl program.\"\n\na. What, precisely, about Parrot makes possible more efficient\nexecution of a dynamically typed language than would be the case with\nthe JVM or the CLR?\n\nb. Whatever that is, how will it adversely impact the execution of\nstatically typed languages, including type-inferred languages?\n\nc. How will this impact the execution of statically typed code in\nPerl, Python and other targeted languages?\n\n2. General Features\n\na. How will Parrot support reflection and attributes?\n\nb. How will Parrot support generics types?\n\nc. How will Parrot support interface types?\n\nd. What kind of security models will Parrot support?\n\ne. How will Parrot support small-footprint systems?\n\nf. How will Parrot support direct access to \"unmanaged\" resources?\n\ng. How will Parrot facilitate distributed processing?\n\n3. Parrot PMC Issues\n\nThe Parrot PMC vtable provides a large number of optional functions,\nwhich PMCs can either implement or not. If not implemented, they will\nthrow an exception at runtime.\n\n\na. What support will Parrot provide a compiler to interrogate a PMC at\ncompile time to know what it actually implements?\n\nAll of these functions appear to be predefined because there is no\nmechanism for extending this functionality at runtime. It appears that\ncompilers will be limited to implementing functionality that is\ndefined in the vtable. The vtable contains the common operations\nrequired by certain languages.\n\nb. How will Parrot handle languages with operations that are not\nprovided?\n\nhttp://www.parrotcode.org/docs/vtables.html:\n\n\"To be perfectly honest, this is a slightly flawed example, since it's\nunlikely that there will be a distinct \"Python scalar\" PMC class. The\nPython compiler could well type-inference variables such that a would\nbe a PythonString and b would be a PythonNumber. But the point remains\n- incrementing a PythonString is very different from incrementing a\nPerlScalar.\"\n\nc. How will Parrot address cross-language semantics?\n\nd. Will each language have to provide its own support for interacting\nwith PMCs for other languages?\n\ne. How will a PerlScalar interact with a PythonString?\n\nf. What will happen when a PythonString is incremented in Perl code?\n\nComparing the vtable for a PMC to the JVM and CLR base Object classes,\nthe PMC is essentially an \"abstract\" class with dozens of\n\"unimplemented\" methods, while Java's Object provides (and implements)\nthe following public methods:\n\n   equals getClass hashCode notify notifyAll toString wait\n\nDiscounting the methods related to Java's peculiar threading\nimplementation, that's:\n\n   equals                 getClass hashCode    toString\n\nSimilarly, the CLR's CTS Object provides:\n\n   Equals ReferenceEquals GetType  GetHashCode ToString\n\ng. Why is it a good thing that PMCs essentially non-contractual\nabstract base classes that define a lot of functionality without\nimplementing it?\n\nh. Why is there no first-tier depth in Parrot's type system, such as:\n\n   PMCString, PMCIntger, PMCNumber, ...\n\n4. Parrot VM Issues\n\nParrot provides what it calls \"registers\" with no guarantee that these\nmap to hardware registers.\n\na. Will any registers ever map, in a Parrot-controlled way, to hardware\nregisters?\n\nb. How can a compiler efficiently allocate registers if it does not\nknow which ones will map to hardware registers?\n\n5. Parrot Design Issues\n\nParrot has many operators and number of Core PMC types for them to\noperate on. Parrot has so many operators that it appears to be using\nthem instead of having a standard library. This is markedly different\nthan the CLR and JVM systems.\n\na. Why was this done this way?\n\nb. What is the basis for deciding what will be an operator?\n\nc. How can substantial quantities of additional functionality be added\nto this design cleanly?\n\n\n\n\n--\nWill \"Coke\" Coleda\nwill@coleda.com\n\n\n"}
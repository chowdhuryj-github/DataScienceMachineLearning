{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 181: fixed the reverse of the last bug - handle the case when\n\tthe new dmaster is the lmaster in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 181\nrevision-id: tridge@samba.org-20070422161949-l7agikqiawx4ah1b\nparent: tridge@samba.org-20070422145309-2hanalfdwko2p6gn\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sun 2007-04-22 18:19:49 +0200\nmessage:\n  fixed the reverse of the last bug - handle the case when the new dmaster is the lmaster\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_ltdb.c             ctdb_ltdb.c-20061128065342-to93h6eejj5kon81-2\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-04-22 12:26:45 +0000\n+++ b/common/ctdb_call.c\t2007-04-22 16:19:49 +0000\n@@ -95,6 +95,7 @@\n \t}\n \n \tif (c->new_data) {\n+\t\t/* XXX check that we always have the lock here? */\n \t\tif (ctdb_ltdb_store(ctdb_db, call->key, header, *c->new_data) != 0) {\n \t\t\tctdb_set_error(ctdb, \"ctdb_call tdb_store failed\\n\");\n \t\t\ttalloc_free(c);\n@@ -292,6 +293,50 @@\n \ttalloc_free(r);\n }\n \n+/*\n+  called when a CTDB_REPLY_DMASTER packet comes in, or when the lmaster\n+  gets a CTDB_REQUEST_DMASTER for itself. We become the dmaster.\n+\n+  must be called with the chainlock held. This function releases the chainlock\n+*/\n+static void ctdb_become_dmaster(struct ctdb_context *ctdb, \n+\t\t\t\tuint32_t reqid, TDB_DATA data)\n+{\n+\tstruct ctdb_call_state *state;\n+\tstruct ctdb_db_context *ctdb_db;\n+\n+\tstate = idr_find_type(ctdb->idr, reqid, struct ctdb_call_state);\n+\tif (state == NULL) {\n+\t\treturn;\n+\t}\n+\n+\tctdb_db = state->ctdb_db;\n+\n+\tDEBUG(2,(\"vnn %u dmaster response %08x\\n\", \n+\t\t ctdb->vnn, ctdb_hash(&state->call.key)));\n+\n+\t/* we're now the dmaster - update our local ltdb with new header\n+\t   and data */\n+\tstate->header.dmaster = ctdb->vnn;\n+\n+\tif (ctdb_ltdb_store(ctdb_db, state->call.key, &state->header, data) != 0) {\n+\t\tctdb_fatal(ctdb, \"ctdb_reply_dmaster store failed\\n\");\n+\t\treturn;\n+\t}\n+\n+\tctdb_call_local(ctdb_db, &state->call, &state->header, &data, ctdb->vnn);\n+\n+\tctdb_ltdb_unlock(ctdb_db, state->call.key);\n+\n+\ttalloc_steal(state, state->call.reply_data.dptr);\n+\n+\tstate->state = CTDB_CALL_DONE;\n+\tif (state->async.fn) {\n+\t\tstate->async.fn(state);\n+\t}\n+}\n+\n+\n \n /*\n   called when a CTDB_REQ_DMASTER packet comes in\n@@ -331,17 +376,32 @@\n \t\tDEBUG(2,(__location__ \" deferring ctdb_request_dmaster\\n\"));\n \t\treturn;\n \t}\n-\t\n+\n+\tif (ctdb_lmaster(ctdb, &key) != ctdb->vnn) {\n+\t\tDEBUG(0,(\"vnn %u dmaster request to non-lmaster lmaster=%u\\n\",\n+\t\t\t ctdb->vnn, ctdb_lmaster(ctdb, &key)));\n+\t\tctdb_fatal(ctdb, \"ctdb_req_dmaster to non-lmaster\");\n+\t}\n+\n+\tDEBUG(2,(\"vnn %u dmaster request on %08x for %u from %u\\n\", \n+\t\t ctdb->vnn, ctdb_hash(&key), c->dmaster, c->hdr.srcnode));\n+\n \t/* its a protocol error if the sending node is not the current dmaster */\n \tif (header.dmaster != hdr->srcnode) {\n-\t\tDEBUG(0,(\"vnn=%u dmaster request non-master %u dmaster=%u\\n\",\n-\t\t\t ctdb->vnn, hdr->srcnode, header.dmaster));\n+\t\tDEBUG(0,(\"vnn %u dmaster request non-master %u dmaster=%u key %08x\\n\",\n+\t\t\t ctdb->vnn, hdr->srcnode, header.dmaster, ctdb_hash(&key)));\n \t\tctdb_fatal(ctdb, \"ctdb_req_dmaster from non-master\");\n \t\treturn;\n \t}\n \n-\tctdb_send_dmaster_reply(ctdb_db, &header, key, data, c->dmaster, hdr->reqid);\n-\tctdb_ltdb_unlock(ctdb_db, key);\n+\t/* check if the new dmaster is the lmaster, in which case we\n+\t   skip the dmaster reply */\n+\tif (c->dmaster == ctdb->vnn) {\n+\t\tctdb_become_dmaster(ctdb, hdr->reqid, data);\n+\t} else {\n+\t\tctdb_send_dmaster_reply(ctdb_db, &header, key, data, c->dmaster, hdr->reqid);\n+\t\tctdb_ltdb_unlock(ctdb_db, key);\n+\t}\n }\n \n \n@@ -404,6 +464,8 @@\n \t     ((header.laccessor == c->hdr.srcnode\n \t       && header.lacount >= ctdb->max_lacount)\n \t      || (c->flags&CTDB_IMMEDIATE_MIGRATION)) ) {\n+\t\tDEBUG(2,(\"vnn %u starting migration of %08x to %u\\n\", \n+\t\t\t ctdb->vnn, ctdb_hash(&call.key), c->hdr.srcnode));\n \t\tctdb_call_send_dmaster(ctdb_db, c, &header, &call.key, &data);\n \t\ttalloc_free(data.dptr);\n \t\tctdb_ltdb_unlock(ctdb_db, call.key);\n@@ -466,6 +528,7 @@\n \t}\n }\n \n+\n /*\n   called when a CTDB_REPLY_DMASTER packet comes in\n \n@@ -501,28 +564,7 @@\n \tdata.dptr = c->data;\n \tdata.dsize = c->datalen;\n \n-\ttalloc_steal(state, c);\n-\n-\t/* we're now the dmaster - update our local ltdb with new header\n-\t   and data */\n-\tstate->header.dmaster = ctdb->vnn;\n-\n-\tif (ctdb_ltdb_store(ctdb_db, state->call.key, &state->header, data) != 0) {\n-\t\tctdb_ltdb_unlock(ctdb_db, state->call.key);\n-\t\tctdb_fatal(ctdb, \"ctdb_reply_dmaster store failed\\n\");\n-\t\treturn;\n-\t}\n-\n-\tctdb_call_local(ctdb_db, &state->call, &state->header, &data, ctdb->vnn);\n-\n-\tctdb_ltdb_unlock(ctdb_db, state->call.key);\n-\n-\ttalloc_steal(state, state->call.reply_data.dptr);\n-\n-\tstate->state = CTDB_CALL_DONE;\n-\tif (state->async.fn) {\n-\t\tstate->async.fn(state);\n-\t}\n+\tctdb_become_dmaster(ctdb, hdr->reqid, data);\n }\n \n \n\n=== modified file 'common/ctdb_ltdb.c'\n--- a/common/ctdb_ltdb.c\t2007-04-19 08:31:49 +0000\n+++ b/common/ctdb_ltdb.c\t2007-04-22 16:19:49 +0000\n@@ -225,7 +225,11 @@\n  */\n int ctdb_ltdb_unlock(struct ctdb_db_context *ctdb_db, TDB_DATA key)\n {\n-\treturn tdb_chainunlock(ctdb_db->ltdb->tdb, key);\n+\tint ret = tdb_chainunlock(ctdb_db->ltdb->tdb, key);\n+\tif (ret != 0) {\n+\t\tDEBUG(0,(\"tdb_chainunlock failed\\n\"));\n+\t}\n+\treturn ret;\n }\n \n struct lock_fetch_state {\n\n"}
{"category": "ham", "to_address": "Will Coleda <will@coleda.com>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: new FAQs", "body": "By way of introduction, we quickly hit the law of diminishing returns \nwhen we spend a lot of time justifying the existence of Parrot. \nEspecially when we could be spending that time finishing off Parrot. At \nthe end of the day, no amount of talking will convince the skeptics. A \ncompleted virtual machine in production use will convince more, and make \nthe remaining skeptics irrelevant.\n\nThat said, I've spent some time here in the hope that this can work its \nway into a document, so next time these questions come around we can say \n\"read the FAQ\".\n\nWill Coleda wrote:\n> 1. Why Parrot?\n> \n> http://www.parrotcode.org/docs/intro.html:\n> \n> \"Parrot is designed with the needs of dynamically typed languages\n> (such as Perl and Python) in mind, and should be able to run programs\n> written in these languages more efficiently than VMs developed with\n> static languages in mind (JVM, .NET). Parrot is also designed to\n> provide interoperability between languages that compile to it. In\n> theory, you will be able to write a class in Perl, subclass it in\n> Python and then instantiate and use that subclass in a Tcl program.\"\n> \n> a. What, precisely, about Parrot makes possible more efficient\n> execution of a dynamically typed language than would be the case with\n> the JVM or the CLR?\n\nThis is an old FAQ entry that needs to be updated. At the time it was \nwritten, there was an enormous gap between Parrot and the performance of \nthe JVM/CLR in handling dynamic languages. (Note: not just \"dynamically \ntyped languages\". Dynamic typing is one small aspect of dynamic \nlanguages in general.)\n\nThe JVM & CLR have made progress, but they're still not all the way to \nfull handling of dynamic languages. They think they are, and are quite \nhappy to sit back and declare that they have the dynamic languages \nproblem licked. The only way they're ever going to tackle the full \nproblem is if someone else does it first to show them how. Just like the \nonly reason they ever tried working on dynamic languages in the first \nplace was because Parrot was there to show that a virtual machine could \ndo more than they imagined possible.\n\nBack to the specific question: dynamic typing is probably one of the \nleast interesting features of Parrot. It's handled by the fact that a \nPMC container can hold any type of PMC, and assignment between types is \nhandled by a set of standard vtable functions on the source PMC for \nretrieving its value and on the destination PMC for setting its value.\n\n> b. Whatever that is, how will it adversely impact the execution of\n> statically typed languages, including type-inferred languages?\n\nSince type declarations are not required, implementing a statically \ntyped language on a dynamically typed virtual machine means adding \nadditional code to do the type checking. This is likely less efficient \nthan implementing a statically typed language on a statically typed \nvirtual machine (though, likely not much less efficient, since the \nstatically typed virtual machine still has to do the type checking). \nSomeday we'll run some benchmarks to compare.\n\n> c. How will this impact the execution of statically typed code in\n> Perl, Python and other targeted languages?\n\nThat question doesn't make sense. Perl and Python don't have statically \ntyped code. See 1b for comments on efficiency of statically typed languages.\n\nIn general, we aren't targeting static languages (again, I'm referring \nto a more general category than just \"statically typed languages\"). We \nmay implement a few static languages on Parrot so they can use Parrot's \nlibraries and tools. Static languages don't take advantage of the \nadvanced features of a dynamic virtual machine. They may not be fast in \nan interpreted environment because they aren't designed for an \ninterpreted environment. They're specifically designed to take advantage \nof a statically compiled environment by eliminating all dynamic \nfeatures. I'm not going to get into a discussion of whether static \nlanguages or dynamic languages are \"better\". They're just different \ncreatures, and comparing them is about as useful as comparing a hybrid \ncar optimized for fuel economy with a race car optimized to win the \nDaytona 500.\n\n> 2. General Features\n> \n> a. How will Parrot support reflection and attributes?\n\nSimply put, reflection is the ability for code to access information \nabout itself and modify its own behavior. This is a concept so deeply \ningrained in the design of Parrot that the hard part of answering the \nquestion isn't figuring out how Parrot supports reflection, but figuring \nout which particular features to highlight. How about the fact than \ninstead of using a stack to control the flow of a program, it uses \nintrospectable continuation objects? Or the fact that subroutines, \nexceptions, and namespaces are all introspectable, modifiable, and can \nbe replaced by subclasses with different behavior as long as they \nrespect the interface.\n\nBy \"attributes\" do you mean instance variables for objects (what Parrot \ncalls an attribute), or do you mean auxiliary data attached to an object \n(what the CLR calls an attribute, and Parrot calls a property). Parrot \nimplements both.\n\n> b. How will Parrot support generics types?\n\nGenerics are mostly a static language way of allowing a tiny bit of \nsemi-dynamic behavior. There are many ways to do the same thing in \nParrot. The most literal-minded parallel would be declaring a class that \naccepts a parameter on instantiation specifying the type of some element \nthat it contains or operates on. For example, the following code might \nbe used to instantiate a generic aggregate that holds elements of type \nMyElement:\n\n$P0 = find_class MyGenericAggregate\n$P1 = $P0.new(elementtype=>'MyElement')\n\n> c. How will Parrot support interface types?\n\nAn interface is a role with no attributes and no implementation for its \nmethods (or, more specifically, it has implementations for its methods \nthat throw an exception complaining that the method needs to be \nimplemented).\n\n> d. What kind of security models will Parrot support?\n\nThe architecture is still in early stages. (Let us know if there's a \nparticular model you need.) In general we're taking a sandbox approach.\n\n> e. How will Parrot support small-footprint systems?\n\nThe absolute minimum needed to run Parrot is a bytecode interpreter. \nWe're aiming to fit a bytecode interpreter in 32M. Extremely small, but \nthat's what's needed to run on most modern cell phones. There isn't \ncurrently active development work in this area.\n\n> f. How will Parrot support direct access to \"unmanaged\" resources?\n\nMy original answer was that \"unmanaged\" resources are a notion from the \nCLR, and not really meaningful in the Parrot context. But from your \nfollowup message it sounds like you actually mean access to C-level \nresources. UnmanagedStruct (which Joshua mentioned) is one way, and \nprovides a Parrot interface to a C structure that isn't memory managed \nby Parrot. NCI is another way, allowing calls into and returns from C \nfunctions. In general, Parrot will never provide direct access to \nC-level resources, it will only provide access through an interface, \nwhere the interface handles the translation between C-like behavior and \nParrot-like behavior. As much as possible, those interfaces are defined \nin a standard way so that using a new external resource from within \nParrot doesn't require writing an entirely new interface layer from \nscratch, but only requires reusing, or easily extending an existing \ninterface layer.\n\n> g. How will Parrot facilitate distributed processing?\n\nParrot will provide a standard set of tools for concurrency. And, the \nfact that Parrot provides a standard interface across multiple platforms \nis an advantage to distributed processing. Distributed code can be \nwritten to run on the Parrot virtual machine, abstracting away from the \ndetails of the particular hardware or operating system. We'll also \nprovide a standard set of networking protocols, and tools for managing \nsome of the standard distributed \"messaging\" systems (SOAP, JSON, AJAX, \netc). We don't currently have any plans to support more advanced forms \nof serializing an execution state to carry between systems, but they \ncould be hooked into the core (extensible) concurrency framework.\n\n> 3. Parrot PMC Issues\n> \n> The Parrot PMC vtable provides a large number of optional functions,\n> which PMCs can either implement or not. If not implemented, they will\n> throw an exception at runtime.\n\nOr, will fall back to a default implementation.\n\n> a. What support will Parrot provide a compiler to interrogate a PMC at\n> compile time to know what it actually implements?\n\nSome custom vtable functions like \"can\", \"does\", and \"isa\", but when all \nelse fails, you can fall back on \"inspect\" which gives you all the \nnitty-gritty details about a PMC/object.\n\n> All of these functions appear to be predefined because there is no\n> mechanism for extending this functionality at runtime. It appears that\n> compilers will be limited to implementing functionality that is\n> defined in the vtable. The vtable contains the common operations\n> required by certain languages.\n\nWhat kind of dynamic virtual machine would we be if we didn't allow \nfunctionality to be extended at runtime? PMCs are just objects. To \nextend the functionality at runtime, subclass the PMC and extend the \nsubclass. Or, add a runtime role to the object.\n\n> b. How will Parrot handle languages with operations that are not\n> provided?\n\nParrot provides low-level operations. If the HLL has a more complex \nfeature, the compiler translates it down to a series of low-level \noperations. Ultimately all languages compile down to machine code, so \nI'm not at all likely to be convinced that an HLL may come up with a \nfeature that can't be implemented as a combination of low-level operations.\n\n> http://www.parrotcode.org/docs/vtables.html:\n> \n> \"To be perfectly honest, this is a slightly flawed example, since it's\n> unlikely that there will be a distinct \"Python scalar\" PMC class. The\n> Python compiler could well type-inference variables such that a would\n> be a PythonString and b would be a PythonNumber. But the point remains\n> - incrementing a PythonString is very different from incrementing a\n> PerlScalar.\"\n\nThis document is very old, and currently being replaced.\n\n> c. How will Parrot address cross-language semantics?\n\nAll languages are implemented in terms of low-level Parrot operations. A \ngiven language can have any semantics it wants, it just composes that \nbehavior from low-level components. When one language is interacting \nwith objects from another language, it performs standard Parrot \noperations on those objects, so the objects can respond in the same way \nthey would respond to the same operations called from their own language.\n\n(I once spent an hour trying to explain this to the CLR guys and they \njust couldn't understand it.)\n\n> d. Will each language have to provide its own support for interacting\n> with PMCs for other languages?\n\nNo, all they need to do is call standard opcodes on the PMC from other \nlanguages. Each PMC provides its own vtable functions for (as an \nexample) returning a string, integer, number, or PMC value.\n\n> e. How will a PerlScalar interact with a PythonString?\n\nInteract how? If you assign the value of a PythonString to a PerlScalar, \nthe value will be extracted by a standard vtable function on the \nPythonString, and assigned by a vtable function on the PerlScalar.\n\n> f. What will happen when a PythonString is incremented in Perl code?\n\nThe code will call the increment vtable function on the PythonString PMC.\n\n> Comparing the vtable for a PMC to the JVM and CLR base Object classes,\n> the PMC is essentially an \"abstract\" class with dozens of\n> \"unimplemented\" methods, while Java's Object provides (and implements)\n> the following public methods:\n> \n>   equals getClass hashCode notify notifyAll toString wait\n\nThis doesn't make any sense. Are you comparing Parrot's \"default\" PMC to \nJava's Object? It would make more sense to compare Parrot's Object to \nJava's Object.\n\n> Discounting the methods related to Java's peculiar threading\n> implementation, that's:\n> \n>   equals                 getClass hashCode    toString\n> \n> Similarly, the CLR's CTS Object provides:\n> \n>   Equals ReferenceEquals GetType  GetHashCode ToString\n\nAnd Parrot's Object provides:\n\nisa can does get_attr set_attr get_class inspect name find_method\n\n> g. Why is it a good thing that PMCs essentially non-contractual\n> abstract base classes that define a lot of functionality without\n> implementing it?\n\nParrot implements sane defaults for the majority of PMCs. But \nconsidering the wide range of types implemented as PMCs (scalars, \naggregates, subroutines, coroutines, continuations, namespaces, \nexceptions, threads, iterators, STM, etc) there really isn't a sane \ndefault for most operations that will apply to all PMC types. So, \ninstead, the sane defaults are built up by a chain of inheritance. For \nexample, all the different array types inherit sane defaults from a core \narray type.\n\nPerhaps what you're trying to ask is why we define a standard set of \nvtable operations, instead of allowing a PMC to create any arbitrary \nvtable entries. This goes back to the core design of interoperability \nacross languages. All PMCs are guaranteed to provide a sane response to \nthe standard vtable operations, even if that response is a \"not \nimplemented\" exception.\n\n> h. Why is there no first-tier depth in Parrot's type system, such as:\n> \n>   PMCString, PMCIntger, PMCNumber, ...\n\nAt the time the initial PMC system was implemented, Parrot had no notion \nof namespaces. That is changing now. (Though, we'll never have a \nnamespace hierarchy level called \"PMC\", as that's an implementation \ndetail, not type information.) And yes, types are connected to namespace \nhierarchies, though it's not always a one-to-one correspondence.\n\n> 4. Parrot VM Issues\n> \n> Parrot provides what it calls \"registers\" with no guarantee that these\n> map to hardware registers.\n> \n> a. Will any registers ever map, in a Parrot-controlled way, to hardware\n> registers?\n\nWell, of course they sometimes map to hardware registers underneath.\n\n> b. How can a compiler efficiently allocate registers if it does not\n> know which ones will map to hardware registers?\n\nHand-rolled allocation is never as efficient or as reliable as \nprogrammatic allocation. The virtual machine handles the efficient \nallocation of registers. The HLL compiler running on the virtual machine \ndoesn't pay any attention to it. This is an advantage of Parrot, \nallowing new HLLs to be quickly and easily implemented without \nreinventing low-level wheels like garbage collection and register \nallocation.\n\n> 5. Parrot Design Issues\n> \n> Parrot has many operators and number of Core PMC types for them to\n> operate on. Parrot has so many operators that it appears to be using\n> them instead of having a standard library. This is markedly different\n> than the CLR and JVM systems.\n> \n> a. Why was this done this way?\n\nBy operator, I'm assuming you mean opcode.\n\nSince this is a *virtual* machine, the only real difference between an \nopcode and a function is how you call it. See the last two entries in \n\n\n> b. What is the basis for deciding what will be an operator?\n\nIt's essentially a design decision of how core the operation is, how \nfrequently it will be used, and how standard it will be across all the \nlanguages implemented on Parrot. Non-core, rarely used, or behavior that \nvaries widely between languages isn't canonized as an opcode (or is \ncanonized as an opcode that simply calls the relevant vtable function on \na PMC).\n\n> c. How can substantial quantities of additional functionality be added\n> to this design cleanly?\n\nAs libraries: dynamically loaded opcode libraries, libraries of \nlow-level functions, or libraries written in PIR or an HLL and compiled \nto bytecode.\n\nAllison\n\n"}
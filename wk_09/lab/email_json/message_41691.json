{"category": "ham", "to_address": "\"Chas Owens\" <chas.owens@gmail.com>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: 'x' vs. 'xx'", "body": "Chas Owens wrote:\n> The current Perl 5 behavior is\n>\n> cowens@amans:~$ perl -le 'my @a = (\"-\" x 5, \"foo\", \"-\" x 5); print \"@a\"'\n> ----- foo -----\n> cowens@amans:~$ perl -le 'my @a = ((\"-\") x 5, \"foo\", (\"-\") x 5); print \"@a\"'\n> - - - - - foo - - - - -\n>\n> I am against anything other than that for x or xx without a really\n> compelling reason.\n\n...with x always corresponding to the first and xx always\ncorresponding to the second, right?  In essence, x always produces a\nstring, while xx always produces a list.\n\n> Jonathan Lang wrote:\n> > Personally, I would tend to favor the notion that infix: always\n> > produces a single string.  With this in mind, I'm now leaning toward\n> > \"~cat($a xx $n)\" as the more verbose equivalent of \"$a x $n\".  You\n> > always produce a single string, and you do so lazily (according to the\n> > way that 'cat' works in item context).\n>\n> I assume it is a bug in Pugs implementation of cat, but\n> pugs> ~cat('a' xx 5)\n> \"a a a a a\"\n\nYes, that would be a bug - probably closely tied to the fact that pugs\ndoesn't implement cat properly in item context.  IIRC, the original\ninspiration for the 'cat' function was 'concatenate' - thus, in item\ncontext at least, one would expect 'cat' to resemble '[~]'.\n\n> I also am having a hard time figuring out why I would want an infinite\n> string.  My first thought was something like\n>\n> my $ten_zeros = substr(cat(0 xx *), 0, 10);\n>\n> but that is more clearly written as\n>\n> my $ten_zeros = 0 x 10;\n\nI'll punt the practical usage to someone else, other than to suggest\nthat the goal of using an asterisk for the number of repetitions isn't\nso much to produce an \"infinite string\" as a \"string of arbitrary\nlength\".  Remember, '*' ne 'Inf'; '*' eq 'Whatever'.  A practical use\nfor '~cat($string xx *)' would most likely be one that relies on the\narbitrariness of the number of repetitions.  Hmm... how about\nsomething like:\n\n  if $a gt ~cat('-' xx *) { ... }\n\nor, if 'x' is defined along the lines that I'm considering:\n\n  if $a gt '-' x * { ... }\n\nBear in mind that you're not limited to single-character repetitions:\n\n  if $a lt '142857' x * { ... }\n\nIn short, the string will get replicated exactly as many times as is\nneeded to resolve the comparison.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
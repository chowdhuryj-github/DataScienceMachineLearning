{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22661 - in branches/SAMBA_4_0/source/lib/events:\n\t.", "body": "Author: metze\nDate: 2007-05-04 09:22:52 +0000 (Fri, 04 May 2007)\nNew Revision: 22661\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22661\n\nLog:\noptimize the handling of directly triggered timed events:\n\n- if someone adds a timed_event with a zero timeval\n  we now avoid serval gettimeofday() calls and the\n  event handler doesn't get the current time when it's\n  called, instead we also pass a zero timeval\n\n- this also makes sure multiple timed events with a zero timeval\n  are processed in the order there're added.\n\nthe little benchmark shows that processing 2000000 directly timed events\nis now much faster, while avoiding syscalls at all!\n\n> time ./evtest (with the old code)\n\nreal    0m6.388s\nuser    0m1.740s\nsys     0m4.632s\n> time ./evtest (with the new code)\n\nreal    0m1.498s\nuser    0m1.496s\nsys     0m0.004s\nmetze@SERNOX:~/devel/samba/4.0/samba4-ci/source> cat evtest.c\n#include \n#include \n#include \n#include \n#include \n\nstatic void dummy_fde_handler(struct event_context *ev_ctx, struct fd_event *fde,\n                              uint16_t flags, void *private_data)\n{\n}\n\nstatic void timeout_handler(struct event_context *ev, struct timed_event *te,\n                            struct timeval tval, void *private_data)\n{\n        uint32_t *countp = (uint32_t *)private_data;\n        (*countp)++;\n        if (*countp > 2000000) exit(0);\n        event_add_timed(ev, ev, tval, timeout_handler, countp);\n}\n\nint main(void)\n{\n        struct event_context *ev;\n        struct timeval tval =  { 0, 0 };\n        uint32_t count = 0;\n        ev = event_context_init(NULL);\n        event_add_fd(ev, ev, 0, 0, dummy_fde_handler, NULL);\n        event_add_timed(ev, ev, tval, timeout_handler, &count);\n        return event_loop_wait(ev);\n}\nModified:\n   branches/SAMBA_4_0/source/lib/events/events_aio.c\n   branches/SAMBA_4_0/source/lib/events/events_epoll.c\n   branches/SAMBA_4_0/source/lib/events/events_internal.h\n   branches/SAMBA_4_0/source/lib/events/events_select.c\n   branches/SAMBA_4_0/source/lib/events/events_standard.c\n   branches/SAMBA_4_0/source/lib/events/events_timed.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/lib/events/events_aio.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_aio.c\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_aio.c\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -250,7 +250,8 @@\n \t}\n \n \tif (ret == 0 && tvalp) {\n-\t\tcommon_event_loop_timer(aio_ev->ev);\n+\t\t/* we don't care about a possible delay here */\n+\t\tcommon_event_loop_timer_delay(aio_ev->ev);\n \t\treturn 0;\n \t}\n \n@@ -431,10 +432,8 @@\n \t\t \t\t\t\t\t   struct aio_event_context);\n \tstruct timeval tval;\n \n-\ttval = common_event_loop_delay(ev);\n-\n+\ttval = common_event_loop_timer_delay(ev);\n \tif (timeval_is_zero(&tval)) {\n-\t\tcommon_event_loop_timer(ev);\n \t\treturn 0;\n \t}\n \n\nModified: branches/SAMBA_4_0/source/lib/events/events_epoll.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_epoll.c\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_epoll.c\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -233,7 +233,8 @@\n \t}\n \n \tif (ret == 0 && tvalp) {\n-\t\tcommon_event_loop_timer(epoll_ev->ev);\n+\t\t/* we don't care about a possible delay here */\n+\t\tcommon_event_loop_timer_delay(epoll_ev->ev);\n \t\treturn 0;\n \t}\n \n@@ -376,10 +377,8 @@\n \t\t \t\t\t\t\t   struct epoll_event_context);\n \tstruct timeval tval;\n \n-\ttval = common_event_loop_delay(ev);\n-\n+\ttval = common_event_loop_timer_delay(ev);\n \tif (timeval_is_zero(&tval)) {\n-\t\tcommon_event_loop_timer(ev);\n \t\treturn 0;\n \t}\n \n\nModified: branches/SAMBA_4_0/source/lib/events/events_internal.h\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_internal.h\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_internal.h\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -117,8 +117,7 @@\n \n struct timed_event *common_event_add_timed(struct event_context *, TALLOC_CTX *,\n \t\t\t\t\t   struct timeval, event_timed_handler_t, void *);\n-void common_event_loop_timer(struct event_context *);\n-struct timeval common_event_loop_delay(struct event_context *);\n+struct timeval common_event_loop_timer_delay(struct event_context *);\n \n struct signal_event *common_event_add_signal(struct event_context *ev, \n \t\t\t\t\t     TALLOC_CTX *mem_ctx,\n\nModified: branches/SAMBA_4_0/source/lib/events/events_select.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_select.c\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_select.c\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -218,7 +218,8 @@\n \t}\n \n \tif (selrtn == 0 && tvalp) {\n-\t\tcommon_event_loop_timer(select_ev->ev);\n+\t\t/* we don't care about a possible delay here */\n+\t\tcommon_event_loop_timer_delay(select_ev->ev);\n \t\treturn 0;\n \t}\n \n@@ -252,10 +253,8 @@\n \t\t \t\t\t\t\t   struct select_event_context);\n \tstruct timeval tval;\n \n-\ttval = common_event_loop_delay(ev);\n-\n+\ttval = common_event_loop_timer_delay(ev);\n \tif (timeval_is_zero(&tval)) {\n-\t\tcommon_event_loop_timer(ev);\n \t\treturn 0;\n \t}\n \n\nModified: branches/SAMBA_4_0/source/lib/events/events_standard.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_standard.c\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_standard.c\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -248,7 +248,8 @@\n \t}\n \n \tif (ret == 0 && tvalp) {\n-\t\tcommon_event_loop_timer(std_ev->ev);\n+\t\t/* we don't care about a possible delay here */\n+\t\tcommon_event_loop_timer_delay(std_ev->ev);\n \t\treturn 0;\n \t}\n \n@@ -471,7 +472,8 @@\n \t}\n \n \tif (selrtn == 0 && tvalp) {\n-\t\tcommon_event_loop_timer(std_ev->ev);\n+\t\t/* we don't care about a possible delay here */\n+\t\tcommon_event_loop_timer_delay(std_ev->ev);\n \t\treturn 0;\n \t}\n \n@@ -505,10 +507,8 @@\n \t\t \t\t\t\t\t   struct std_event_context);\n \tstruct timeval tval;\n \n-\ttval = common_event_loop_delay(ev);\n-\n+\ttval = common_event_loop_timer_delay(ev);\n \tif (timeval_is_zero(&tval)) {\n-\t\tcommon_event_loop_timer(ev);\n \t\treturn 0;\n \t}\n \n\nModified: branches/SAMBA_4_0/source/lib/events/events_timed.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/events/events_timed.c\t2007-05-04 07:00:09 UTC (rev 22660)\n+++ branches/SAMBA_4_0/source/lib/events/events_timed.c\t2007-05-04 09:22:52 UTC (rev 22661)\n@@ -68,9 +68,7 @@\n \tlast_te = NULL;\n \tfor (cur_te = ev->timed_events; cur_te; cur_te = cur_te->next) {\n \t\t/* if the new event comes before the current one break */\n-\t\tif (!timeval_is_zero(&cur_te->next_event) &&\n-\t\t    timeval_compare(&te->next_event,\n-\t\t\t\t    &cur_te->next_event) < 0) {\n+\t\tif (timeval_compare(&te->next_event, &cur_te->next_event) < 0) {\n \t\t\tbreak;\n \t\t}\n \n@@ -85,17 +83,47 @@\n }\n \n /*\n-  a timer has gone off - call it\n+  do a single event loop using the events defined in ev\n+\n+  return the delay untill the next timed event,\n+  or zero if a timed event was triggered\n */\n-void common_event_loop_timer(struct event_context *ev)\n+struct timeval common_event_loop_timer_delay(struct event_context *ev)\n {\n-\tstruct timeval t = timeval_current();\n+\tstruct timeval current_time = timeval_zero();\n \tstruct timed_event *te = ev->timed_events;\n \n-\tif (te == NULL) {\n-\t\treturn;\n+\tif (!te) {\n+\t\t/* have a default tick time of 30 seconds. This guarantees\n+\t\t   that code that uses its own timeout checking will be\n+\t\t   able to proceeed eventually */\n+\t\treturn timeval_set(30, 0);\n \t}\n \n+\t/*\n+\t * work out the right timeout for the next timed event\n+\t *\n+\t * avoid the syscall to gettimeofday() if the timed event should\n+\t * be triggered directly\n+\t *\n+\t * if there's a delay till the next timed event, we're done\n+\t * with just returning the delay\n+\t */\n+\tif (!timeval_is_zero(&te->next_event)) {\n+\t\tstruct timeval delay;\n+\n+\t\tcurrent_time = timeval_current();\n+\n+\t\tdelay = timeval_until(&current_time, &te->next_event);\n+\t\tif (!timeval_is_zero(&delay)) {\n+\t\t\treturn delay;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * ok, we have a timed event that we'll process ...\n+\t */\n+\n \t/* deny the handler to free the event */\n \ttalloc_set_destructor(te, common_event_timed_deny_destructor);\n \n@@ -104,33 +132,21 @@\n \t * handler we don't want to come across this event again -- vl */\n \tDLIST_REMOVE(ev->timed_events, te);\n \n-\tte->handler(ev, te, t, te->private_data);\n+\t/*\n+\t * If the timed event was registered for a zero current_time,\n+\t * then we pass a zero timeval here too! To avoid the\n+\t * overhead of gettimeofday() calls.\n+\t *\n+\t * otherwise we pass the current time\n+\t */\n+\tte->handler(ev, te, current_time, te->private_data);\n \n \t/* The destructor isn't necessary anymore, we've already removed the\n \t * event from the list. */\n \ttalloc_set_destructor(te, NULL);\n \n \ttalloc_free(te);\n-}\n \n-/*\n-  do a single event loop using the events defined in ev \n-*/\n-struct timeval common_event_loop_delay(struct event_context *ev)\n-{\n-\tstruct timeval tval;\n-\n-\t/* work out the right timeout for all timed events */\n-\tif (ev->timed_events) {\n-\t\tstruct timeval t = timeval_current();\n-\t\ttval = timeval_until(&t, &ev->timed_events->next_event);\n-\t} else {\n-\t\t/* have a default tick time of 30 seconds. This guarantees\n-\t\t   that code that uses its own timeout checking will be\n-\t\t   able to proceeed eventually */\n-\t\ttval = timeval_set(30, 0);\n-\t}\n-\t\n-\treturn tval;\n+\treturn timeval_zero();\n }\n \n\n"}
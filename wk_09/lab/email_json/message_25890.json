{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [perl #42905] [PATCH] implement vtable overriding for PDD15,\n bugfix", "body": "On general development styles, you've altered the spec, the tests, and \nthe code all in one massive patch. It's better to make changes in \nsmaller steps. That gives the whole list an opportunity to discuss the \nchanges, and accept or reject individual components.\n\nIf you have spec changes, it's best to talk about those on the list \nbefore you start implementing the code for the spec changes. (At the \nvery least, it's less work for you, since it saves you the trouble of \nimplementing and reimplementing code depending on which of your proposed \nspec changes are accepted.)\n\nWhen you change existing tests, that means you could be breaking \nexisting code, so it's likely that the code changes that go with the \ntest changes will need at least a full deprecation cycle. If you split \nthe code and test changes for that feature out into a separate patch, \nthen you won't have to delay all your changes waiting for the \ndeprecation cycle.\n\nAlek Storm (via RT) wrote:\n> \n> I've attached a patch to implement vtable overriding for PDD15.  The basic\n> idea is to wrap all Object vtable methods in code that searches up the\n> parent stack for the corresponding vtable method, call it if found, and if\n> it's not found, call the original implementation of the method, or throw an\n> exception.  Any variables used in the wrapper code are prefixed with '__' to\n> avoid name collisions.\n\nThe existing code does need a refactor, and given how it's written now I \ncan understand why you went in this direction. But, the direction I want \nthe refactor to go is increased encapsulation. src/objects.c should be \nstripped down to as little code as possible, and should have no \nknowledge of the specific object model it's operating on, or the \ninternals of the class or object. The details of the implementation \nshould live in the Class PMC (or ParrotClass PMC, or MyHLLsCustomClass PMC).\n\nParrotObject has the right idea here. The C-level definitions of the \nvtable entries are responsible for checking whether they've been \noverridden. (A lot of that code is boiler-plate and could be refactored \ndown to a few internal utility functions, but the basic implementation \nstrategy is sound.)\n\n> The PCCMETHOD 'add_vtable_method' is added to Class.  Using two separate\n> methods for adding normal methods and vtable methods is much cleaner and\n> more logical, since they are two completely separate functionalities.\n\nThe methods aren't a core part of the Class implementation, they'll just \nbe added as a role. So, technically it doesn't matter much whether we do \nor don't have an 'add_vtable_method'. But from an interface perspective, \nit doesn't seem like much of an advantage over passing a flag to \n'add_method', especially since it would mean you have to call both \n'add_method' and 'add_vtable_method' separately when you want a \nparticular chunk of code to be both a method and a vtable function.\n\n> In\n> fact, using this interface, the :vtable pragma is completely unnecessary, so\n> we could remove it if we wanted to.  Because I was unsure exactly how the\n> interface is going to end up, 'add_method' also adds vtable methods also, if\n> :vtable is set on the method. If we decide to go with this interface, I'd\n> like to take it out, along with the :vtable pragma.\n\nThe fact that there's a verbose way to overload a vtable function at \nruntime is not enough justification to remove the :vtable syntax. It stays.\n\n> Trying to override 'mark', 'destroy', or 'morph' throws an exception,\n> because overriding them might be dangerous.  An exception is also thrown for\n> 'init_pmc', see below.\n\nWhy do these throw an exception? You should be able to override them.\n\n> The 'init' vtable method in Object is not wrapped by pmc2c, since its\n> override is called from Class.new().  Class.new() is changed from accepting\n> a named slurpy of attributes to an unnamed slurpy of initializer\n> parameters.  This slurpy is :flattened and passed to 'init'.  This is really\n> cool, because now 'init' acts like a normal method, and can accept a\n> variable-sized parameter list.  This makes 'init_pmc' obsolete, so trying to\n> override it throws an exception.  Named parameters don't work, but c'mon,\n> you can't have it all, right?\n\n'init' isn't a normal method, it's a vtable function. And it's never \ncalled directly, so how is it useful to make it take a variable sized \nparameter list? Named parameters stay. Just slurp them up and pass them \non to init_pmc as a hash.\n\n> Currently, passing arguments to Class.new() when 'init' is not overridden\n> doesn't throw an exception.  Should it?\n\nNo. There's no reason to require every class to override 'init'.\n\n> This patch also fixes a bug with 'invoke' in both ParrotObject and Object:\n> 'self' had to be explicitly passed to the override.  This is fixed by adding\n> the signature flag PARROT_ARG_OBJECT, and unshifting that OR-ed with\n> PARROT_ARG_PMC onto the args signature.  This has a counterpart already used\n> in fetch_arg_sig() in src/inter_call.c.\n\nWhat bug? Submit a separate ticket with example code.\n\n> The old double-underscore method of vtable overriding can die along with the\n> old object system, but I would prefer to submit a patch to get rid of it\n> sooner, since I don't know how long the old object system will stick around.\n\nPending complete resolution of RT#40626. This can go in the next \ndeprecation cycle if we add a test for that last (resolved?) bug, and \nverify that no code in the repository is using the old double-underscore \noverride.\n\n> Tests are included for 'init', 'invoke', and vtable method lookup through\n> the parent stack.  Also, I fixed some tests in t/pmc/parrotobject.t that\n> overrode 'invoke' without using the :method pragma, and removed the test for\n> #41372, which is now obsolete.\n\nObsolete how? Does it test for a feature that no longer exists? (In \nwhich case why isn't it failing?) Or does it test for a bug that's been \nfixed? (In which case, it's a useful regression test.)\n\n> Also, a question: what exactly is the '_namespace' member of Parrot_Class\n> used for?  I don't see it used anywhere; it can be gotten and set, but is\n> otherwise useless, since methods are added using a separate mechanism.\n\nIt's used to store a pointer to the namespace object associated with the \nclass.\n\n >  lib/Parrot/Pmc2c/Object.pm    |  158\n\nWhy do we need this file? Objects don't need that much custom code \ngeneration, and it's highly unlikely that the code here will be useful \nfor any object implementation other than PDD 15.\n\n >  src/pmc/class.pmc             |  150\n\nAdding a (global) interpreter entry for \"current_object\", \"current_args\" \nand \"args_signature\" is not a good solution to anything.\n\n> Well, that's about it.  I realize some people (especially Allison ;)) will\n> probably disagree with parts of this patch, \n\nI'll take that as a compliment. :) It's my job to keep the numerous and \ndiverse contributions to Parrot headed in a consistent and coherent \ndirection.\n\nMany thanks,\nAllison\n\n"}
{"category": "ham", "to_address": "\"Alek Storm\" <alek.storm@gmail.com>", "from_address": "Bob Rogers <rogers-perl6@rgrjr.dyndns.org>", "subject": "Re: modifying classes after they're instantiated", "body": "   From: \"Alek Storm\" \n   Date: Wed, 11 Apr 2007 00:02:29 +0000\n\n   On 4/10/07, Allison Randal  wrote:\n   > 4) Do away with automatic morphing. Attempting to make changes to a\n   > class that's already been instantiated is not allowed (add_method, etc.\n   > will throw an exception). This also eliminates the need for\n   > remove_method, remove_attribute, remove_role, and remove_parent. To\n   > modify a class that has instantiated objects you must clone it first:\n   >\n   >    classobj = newclass 'Foo'\n   >    object = classobj.'new'()\n   >\n   >    newclassobj = classobj.'clone'('exclude_methods'=>$P1)\n   >    newclassobj.'add_method'('bar', $P3)\n   >    object2 = newclassobj.'new'()\n   >\n   > And 'clone' could take an option specifying whether this particular\n   > clone will replace the existing class in the namespace. Disadvantage: It\n   > eliminates some of the DWIMery of the system. On the other hand, it\n   > might make it easier to implement a language that doesn't allow\n   > modifications to instantiated classes. (This is currently my favorite\n   > alternative.)\n   >\n   > Allison\n\n   I like this one, but I also have another alternative.  First, make all\n   class-modification code (add_method, remove_attribute, etc) return a\n   PMC*.  Whenever one of these methods is called on a class, the class\n   is cloned . . .\n\nWhat does \"find_class\" return after one of these?  If it returns the new\nclass, then there is no need for the class-mutating ops to do so, except\npossibly for convenience.\n\n   classobj = newclass 'Foo'\n   object = classobj.'new'()\n\n   # add_method returns a clone of the original class with \"bar\" added\n   # C keeps its reference to the original class\n   classobj = classobj.'add_method'('bar', $P3)\n   object2 = classobj.'new'()\n\nSurely you are not suggesting that any random \"add_method\" should\nrequire creating a new class?  Did you mean \"add_attribute\" (or\nwhatever)?\n\n   The only downside I can think of is the overhead involved in creating\n   a new clone of the class for every change to it, for example, when\n   many attributes are added at once . . .\n\nThis is not necessary; you only need to clone the class after the first\ntime it is instantiated.  So you can put an \"instantiated_p\" flag in the\nclass to keep track, and keep mutating the same new class until the next\ninstantiation.  The remove_* operations could stay, they would just\nthrow errors on instantiated classes.\n\n   But in that case, it might be simpler for HLL code to stick to\nAllison's original alternative 4, i.e. make an explicit clone, mutate it\nas required, and then install it as \"the\" class returned by find_class.\nError recovery would also be easier for explicit cloning; what happens\nif one of the class-mutating methods throws an error?\n\n   Sorry if this is misplaced; I haven't been paying a whole lot of\nattention to objects.\n\n\t\t\t\t\t-- Bob Rogers\n\t\t\t\t\t   http://rgrjr.dyndns.org/\n\n"}
{"category": "ham", "to_address": "beginners@perl.org", "from_address": "\"John W. Krahn\" <krahnj@telus.net>", "subject": "Re: logic not working", "body": "Tony Heal wrote:\n\n> OK I am probably missing something stupid, but I can not get this to work.\n> The output should be 'Daily-{day of week)-{MMM}-{DD}-{YYYY}' for Sunday\n> thru Friday and 'Weekly-{1|2|3}-{day of week)-{MMM}-{DD}-{YYYY} for\n> Saturday and every fourth Saturday should start rotating months\n> 'Month-{1|2|3}-{day of week)-{MMM}-{DD}-{YYYY}\n> \n> Anyone got any ideas?\n> \n> Oh, there is some code at the front that changes the system date from May\n> 1 to 31\n\n\n\n[ Whitespace adjusted to aid legibility. ]\n\n> #!/usr/bin/perl\n> use warnings;\n> use strict;\n> my $today = `date +%m%d%H%M`;\n\nWhy call an external program to do something that you can do in perl:\n\nmy @today = ( localtime )[ 4, 3, 2, 1 ];\n$today[ 0 ]++;\nmy $today = sprintf '%02d%02d%02d%02d', @today;\n\nOr:\n\nuse POSIX 'strftime';\nmy $today = strftime '%m%d%H%M', localtime;\n\n\n> my $count = \"501\";\n> while ( $count lt 532 ) {\n>   my $that = \"0$count\" . \"2100\";\n\nDo you want to use strings or numbers?\n\nFor strings:\n\nfor ( '0501' .. '0531' ) {\n  my $that = $_ . '2100';\n\nFor numbers:\n\nfor ( 501 .. 531 ) {\n  my $that = sprintf '%04d2100', $_;\n\n\n>   system(\"date $that\");\n\nThe date command changes the *system* date!  In other words, this change\nwill effect all other programs running on your system.  Do you really want\nto do that?\n\n\n>   my $backupBaseDir = '/gfsbackup';\n>   my $logFile = \"$backupBaseDir\\/gfs_backup.log\";\n\nYou don't have to escape the slash in a double quoted string.\n\n>   my $scpCMD = 'scp -i /usr/backup/.ssh/haddock';\n\nAnd here you have a double quoted string without escaped slashes.\n\n>   my $backupDir = gfsBackup();\n>   my @ePaceServers = (\"silverfish\", \"catfish\", \"bonefish\");\n>   if ( ! -d $backupBaseDir )\n>   {\n>     mkdir $backupBaseDir;\n>   }\n>   sub gfsBackup\n\nSubroutines in perl are package variables so there is no point defining them\ninside a loop.\n\n\n>   {\n>     my ( $sec, $min, $hour, $mday, $mon, $yearOffset, $wday, $yday,\n$isdst ) = localtime( time );\n>     my $year = $yearOffset + 1900;\n>     my ( $weeksec, $weekmin, $weekhour, $weekmday, $weekmon,\n$weekyearOffset, $weekwday, $weekyday, $weekisdst ) = localtime( time - (\n84600 * 8 ) );\n>     my $weekyear = $weekyearOffset + 1900;\n>     my ( $msec, $mmin, $mhour, $mmday, $mmon, $myearOffset, $mwday,\n$myday, $misdst ) = localtime( time - ( 84600 * 29 ) );\n>     my $myear = $yearOffset + 1900;\n\nShouldn't that be:\n\n    my $myear = $myearOffset + 1900;\n\n>     my $week = int( $yday / 7 );\n>     my $sevendays = ( time - ( 84600 * 7 ) );\n>     my @days =\n( \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" );\n>     my @months =\n( \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" );\n>     my ( $directory, @dir, $month, $gfsDir, $DatedgfsDir, $monthDirectory,\n@monthDir, $lastWeek, $dirtemp );\n\nThe only variable you need to declare at this level is:\n\n    my $gfsDir;\n\n>     if ( $days[$wday] =~ \"Saturday\" )\n\nWhy not more simply:\n\n    if ( $wday == 6 )  # 6 = Saturday\n\n>     {\n>       opendir( DIR, $backupBaseDir );\n\nYou should *always* verify that the directory opened correctly:\n\n      opendir DIR, $backupBaseDir or die \"Cannot open '$backupBaseDir' $!\";\n\n\n>       my @readdir = readdir( DIR );\n>       closedir( DIR );\n>       while ( <@readdir> )\n\nThat is the same as:\n\n      while ( glob \"@readdir\" )\n\nWhich means that you are globbing the file names that you just got from\nreaddir so you are now reading the directory contents a second time.  This\nwill *not* work correctly if any of the file names contain whitespace or\nglob meta-characters.\n\nWhat you want is:\n\n      for my $directory ( @readdir )\n\n\n>       {\n>         $directory = $_;\n>         print \"directory = $directory\\n\";\n>         if ( $directory =~ \"$months[$weekmon]-$weekmday-$weekyear\" )\n>         {\n>           @dir = split( /-/, $directory );\n\n          my @dir = split( /-/, $directory );\n\n\n>           if ( $dir[0] =~ \"Monthly\" )\n\nShouldn't that be:\n\n          if ( $dir[0] eq 'Monthly' )\n\n\n>           {\n>             $gfsDir = \"Weekly-1\";\n>           }\n>           if ( $dir[0] =~ \"Weekly\" )\n\nShouldn't that be:\n\n          if ( $dir[0] eq 'Weekly' )\n\n\n>           {\n>             if ( $dir[1] lt 3 )\n\n            if ( $dir[1] < 3 )\n\n\n>             {\n>               my $weekcount = $dir[ 1 ] + 1;\n>               $gfsDir = \"Weekly-$weekcount\";\n>             }\n>             if ( $dir[1] eq 3 )\n\n            if ( $dir[1] == 3 )\n\n\n>             {\n>               my $monthcount = `ls $backupBaseDir |\ngrep \"$months[$mmon]-$mmday-$myear\" | cut -d- -f2`;\n\nNo need to call three external programs to do what you can do in perl:\n\n              my ( $monthcount ) = map +( split /-/ )[ 1 ],\n<$backupBaseDir/*$months[$mmon]-$mmday-$myear*>;\n\n\n>               if ( $monthcount eq \"13\" )\n\nThis will *never* match!  If the backquotes return '13' then $monthcount\nwill contain \"13\\n\" and it will not match '13'.\n\n\n>               {\n>                 $gfsDir = \"Monthly-1\";\n>               }\n>               else\n>               {\n>                 $monthcount++;\n>                 $gfsDir = \"Monthly-$monthcount\";\n>               }\n>             }\n>           }\n>           last;\n>         }\n>       }\n>     }\n>     elsif ( $days[$wday] =~ \"Saturday\" )\n\nThe if clause for this elsif is:\n\n      if ( $days[$wday] =~ \"Saturday\" )\n\nWhich is *exactly* the same so this elsif block will *never* execute.\n\n\n>     {\n>       $gfsDir = \"Weekly-1\";\n>       last;\n\nAt this point you are not inside a loop so using last is an error.\n\n\n>     }\n>     if ( ! $gfsDir )\n>     {\n>       $gfsDir = \"Daily-$days[$wday]-$months[$mon]-$mday-$year\";\n>       mkdir \"$backupBaseDir/$gfsDir\";\n>       chdir \"$backupBaseDir/$gfsDir\";\n>       return $gfsDir;\n>     }\n>     else\n>     {\n>       $DatedgfsDir = \"$gfsDir-$days[$wday]-$months[$mon]-$mday-$year\";\n>       mkdir \"$backupBaseDir/$DatedgfsDir\";\n>       chdir \"$backupBaseDir/$DatedgfsDir\";\n>       $gfsDir = $DatedgfsDir;\n>       return $gfsDir;\n>     }\n\nYou can remove a lot of duplicate code like this:\n\n    $gfsDir = ( $gfsDir ?\n$gfsDir : 'Daily' ) . \"-$days[$wday]-$months[$mon]-$mday-$year\";\n    mkdir \"$backupBaseDir/$gfsDir\" or die \"Cannot\nmkdir '$backupBaseDir/$gfsDir' $!\";\n    chdir \"$backupBaseDir/$gfsDir\" or die \"Cannot\nchdir '$backupBaseDir/$gfsDir' $!\";\n    return $gfsDir;\n\n\n>   }\n> $count++;}\n\n\n\nJohn\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
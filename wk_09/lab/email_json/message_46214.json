{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: Generalizing ?? !!", "body": "Audrey Tang wrote:\n> Jonathan Lang wrote:\n> > A variation of chaining associativity gets\n> > used, with the \"chaining rule\" being '$v1 op1 $v2 // $v1 op2 $v3'\n> > instead of '$v1 op1 $v2 && $v2 op2 $v3', as is the case for comparison\n> > chaining.\n>\n> But wouldn't that make:\n>\n>    True ?? undef !! Moose;\n>\n> evaluate to Moose, instead of undef as we wanted?\n\nNope; because of the short-circuiting behavior:\n\n    True ?? undef !! Moose\n->\n    True ?? undef // True !! Moose\n\nThe condition evaluates to True, causing the ?? to evaluate its RHS\nand then short-circuit the rest of the expression.  The fact that the\nRHS evaluates to undef is irrelevant.\n\nIn a sense, ?? and !! would invert the usual short-circuiting\nbehavior: with normal short-circuiting operators (&& and ||), the RHS\nis evaluated if and only if the operator does not short-circuit; with\n?? and !!, the RHS would be evaluated if and only if the operator\n_does_ short-circuit.\n\nNeonGraal wrote:\n> Surely if you defined !! to return \"undef but true\" and both operators\n> to be left associative then it all works.\n>\n>  1==0 ?? \"True\" !! \"False\" -> (undef) !! \"False\" which seems right to\n> me.\n>\n>  1==1 !! \"False\" ?? \"True\" -> (undef but true) ?? \"True\" also good.\n\n...except that '1==1 !! \"False\"' would return 'undef but true' on a\nfailure.  I'm sure that a rationale could be provided for doing this;\nbut it's a potentially surprising result which could get you in\ntrouble.  Best to keep to a simple 'undef' result on a failure.\n\nHakim: I'm not familiar with Haskell, so I can't follow your code as\nwell as I need to to provide an informed response.\n\nJuerd Waalboer wrote:\n> Zev Benjamin wrote:\n> > ?? and !! could always return some kind of result object that boolizes\n> > to true or false.\n>\n> Can we *please* keep simple things simple?\n\nAgreed.  I'm in favor of this proposal to the extent that it breaks a\nsimple trinary operator down into equally simple binary operators\n(with the trinary form continuing to exist as an emergent property of\nthe interaction of the binaries); if those binary operators become\nmore complex than the trinary form, or if you lose the ability to\nrecover the trinary form from them, there's no point in pursuing this\nproposal.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
{"category": "ham", "to_address": "Leopold Toetsch <lt@toetsch.at>", "from_address": "Patrick Rutkowski <rutski89@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "Ok, so I see now that reg_alloc is rounded up to a multiple of 8 by\nthe following two lines:\n\n   /*code*/ const int slot = (reg_alloc + 7) >> 3;\n   /*code*/ reg_alloc = slot << 3;\n\nHowever, this still begs the question of what the slot variable is\nfor. Clearly it's being used as an index into\ninterp->ctx_mem.free_list; but its value, which is always set to\nreg_alloc/8, seems to me to be rather arbitrary (either that or it has\nsome meaning but I just don't know any better).\n\nSo if slot (which equals reg_alloc/8) is greater than n_free_slots\nthen the array is resized to fit slot+1 void* types. The last element\n(now indexed by slot by definition) is then stored in \"ptr\" and used\nthroughout the rest of the procedure.\n\nQUESTION: For what purpose is the array resized to hold so many more\nelements? e.g. if n_free_slots is 8 and slot is 80 then 72 extra\nelements are allocated and the last one of them is used laster on as\nthe \"ptr\" variable; why is that? (This 8 and 80 example is actually the\ncase on my machine when create_initial_context calls\nParrot_alloc_context()).\n\nIf, on the other hand, slot is less than n_free_slots then slot is a\nnow seemingly random index into the free_list; the item at that index\nis pulled out and used as the \"ptr\" varible.\n\nQUESTION: Is that seemingly random indexing intended? Or is slot\nalways a well defined and in no way random value with some deeper\npurpose? If so, that deeper purpose needs to be explained in a\ncomment.\n\nOn another note, there also seems to be some confusion as to what the\nfree_list actually is in the first place:\n\n\n\n   Chromatic wrote:\n     I originally thought the free_list was an array of recycled\n     contexts to avoid malloc() and free() pairs by reusing\n     already-allocated-but-unused memory, but now I can't tell what it's\n     doing.  I tried to change this into a linked list, but that failed\n     with invalid reads.\n\n   Joshua Isom responded:\n     I thought it was a list of items to be freed, but that may be a\n     different free_list sadly.  We have more than one in parrot.\n\n\n\nThis definitely needs to be documented if it's not already. \"typedef\nstruct _context_mem { ... } context_mem\" in interpreter.h might be a\ngood place to put a brief descrpiton of how the free_list is meant to\nbe used.\n\n-Patrick\n\nOn Apr 22, 2007, at 5:56 AM, Leopold Toetsch wrote:\n\n> Am Sonntag, 22. April 2007 09:11 schrieb Patrick Rutkowski:\n>> I think Leo would be the best person to go to for an explanation,\n>> especially if you plan to dramatically rework the code.\n>\n>>>> This is where I start not to understand.  Why reg_alloc + 7?  Why\n>>>> shift left\n>>>> and right by 3?\n>>>\n>>> I'm not sure if it is actually doing anything that needs to be that\n>>> complicated to code that way.  It could be able to be written as:\n>>>\n>>>     const int slot = (reg_alloc + 7) / 8; /* divide by eight for\n>>> some reason and round up on remainder */\n>>>     reg_alloc = slot * 8; /* reg_alloc is now evenly divisible by  \n>>> 8 */\n>\n> Sure. It's just rounding up to the next multpile of 8.\n>\n>>> ...  Now, slot is multiplied by sizeof(void*) later on,\n>>> which may be why it's divided by eight in the first place.\n>\n> The rounding up happens to reduce the size of the free_list array.\n>\n>>> The n = slot + 1 I find a little odd, because the number is already\n>>> rounded up, so it's rounding up and then adding an extra place of\n>>> memory.\n>\n> This is for the extension of the free_list.\n>\n>>>> I do understand the purpose of the resizing code, but not how slot\n>>>> relates to\n>>>> it:\n>>>>\n>>>>     if (slot >= interp->ctx_mem.n_free_slots) {\n>\n> Well, if slot is beyond the end of the list, it's resized.\n>\n>>> The *(void **) has been confusing me for a long time.\n>\n> The free list per size (i.e. one slot) is a linked list of pointers.\n>\n>>>> I'd like to find a simpler scheme, if it's possible.  Otherwise,\n>>>> I'd like to\n>>>> figure out what's going on so we can at least explain it somehow.\n>\n> Why? This is all rather straight-forward and can be found in any  \n> memory\n> allocator e.g. ins smallobjects.\n>\n> leo\n\n"}
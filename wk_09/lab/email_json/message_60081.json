{"category": "ham", "to_address": "Volker.Lendecke@SerNet.DE", "from_address": "tridge@samba.org", "subject": "Re: talloc_stack.c?", "body": "Volker,\n\n > +/*\n > + * Implement a stack of talloc frames. We can't rely on a linked list with\n > + * talloc destructors because in a hierarchy of talloc destructors the parent\n > + * destructor is called before its children destructors.\n > + */\n\nlinked lists work fine - I use them all the time with talloc\ndestructors. \n\nYou are right that the parent destructor is called first, but the\nmemory is actually freed from the bottom up (ie. child is freed\nfirst). The recursion marks the memory for deletion on the way down\n(to prevent loops) and actually frees it on the way up.\n\nDid you try and use talloc destructors with linked lists and hit a\nproblem or did you just assume they wouldn't work from looking at the\ncode? If they didn't work, can you post a snippet of code showing what\nyou tried to do?\n\nRegarding the talloc_stack.c idea, this is awfully similar to what we\nhave had in the past with a \"loop\" memory context - a memory context\nthat gets freed in the top level event loop. What advantage does\ntalloc_stack have over that idea? (that idea is still present in the\nlp_TALLOC_FREE() call and tmp_talloc_ctx() in Samba3.\n\n(what is this obsession with capitalising routine names? I sometimes\nwonder if some people think that CAPITALS makes code less buggy?)\n\nCheers, Tridge\n\n"}
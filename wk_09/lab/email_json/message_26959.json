{"category": "ham", "to_address": "\"Nisse Tuta\" <nissetuta@gmail.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: complex sort", "body": "On 5/7/07, Nisse Tuta  wrote:\n> Hi All,\n>\n> I am having big problems solving this sorting issue and would really\n> appreciate any help on this.\n>\n> I have a list with each row containing 3 numbers(Run In Out).\n>\n> For example,\n> R01 13 19\n> R01 25 30\n> R01 23 47\n> R01 2 14\n> R02 2 45\n> R02 55 60\n> R01 1 17\n> R03 45 66\n> R03 20 35\n> and so on......\n>\n> I would like to go through these and check for any overlapping numbers\n> at both In and Out and replacing either the in out or both if\n> overlapped. And any cuts/breaks in each run will add a count.\n>\n> To create a list like\n>\n> Run Count In Out\n> R01 1 1 19\n> 2 25 47\n> R02 1 2 45\n> 2 55 60\n>\nsnip\n\nIf I understand correctly then R03 should look like\n\nR03 1 20 35\n2 45 46\n\nThe sort itself isn't that bad; you are just sorting on three columns,\ncolumn 1 first, column 2 second, and column 3 last:\n\nmy @sorted = sort {\n        $a->[0] cmp $b->[0] or #sort on run, if equal then\n        $a->[1] <=> $b->[1] or #sort on in, if equal then\n        $a->[2] <=> $b->[2]    #sort on out\n} @input;\n\nBut that doesn't solve your problem.  You then need to loop over the\nsorted values and compress the runs.  Note, if you write the code that\ntransforms the data correctly, it is not necessary to sort it first,\nbut it does make it easier.\n\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nmy @input = (\n        [ qw(R01 13 19) ],\n        [ qw(R01 25 30) ],\n        [ qw(R01 23 47) ],\n        [ qw(R01  2 14) ],\n        [ qw(R02  2 45) ],\n        [ qw(R02 55 60) ],\n        [ qw(R01  1 17) ],\n        [ qw(R03 45 66) ],\n        [ qw(R03 20 35) ],\n);\n\nmy @sorted = sort {\n        $a->[0] cmp $b->[0] or #sort on run, if equal then\n        $a->[1] <=> $b->[1] or #sort on in, if equal then\n        $a->[2] <=> $b->[2]    #sort on out\n} @input;\n\n#printf \"%s %3d %3d\\n\", @$_ for @sorted;\n\nmy %output;\nROW:\nfor my $row (@sorted) {\n        my ($runname, $in, $out) = @$row;\n        for my $run (@{$output{$runname}}) {\n                if ($in < $run->[2]) {\n                        if ($out > $run->[2]) {\n                                $run->[2] = $out;\n                        }\n                        next ROW;\n                }\n        }\n        push @{$output{$runname}}, $row;\n}\n\nfor my $runname (sort keys %output) {\n        print \"$runname \";\n        my $i   = 0;\n        for my $run (@{$output{$runname}}) {\n                $i++;\n                printf \"$i %3d %3d\\n\", @{$run}[1,2];\n        }\n}\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
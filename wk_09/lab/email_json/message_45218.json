{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jpeach@samba.org", "subject": "svn commit: samba r23398 - in branches/SAMBA_3_0/source: . smbd", "body": "Author: jpeach\nDate: 2007-06-09 00:10:26 +0000 (Sat, 09 Jun 2007)\nNew Revision: 23398\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23398\n\nLog:\nSupport membership of >16 groups on Darwin by making sure we opt in to the\ndynamic group resolution mechanism when switching UNIX credentials.\n\nModified:\n   branches/SAMBA_3_0/source/configure.in\n   branches/SAMBA_3_0/source/smbd/sec_ctx.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/configure.in\n===================================================================\n--- branches/SAMBA_3_0/source/configure.in\t2007-06-08 23:13:04 UTC (rev 23397)\n+++ branches/SAMBA_3_0/source/configure.in\t2007-06-09 00:10:26 UTC (rev 23398)\n@@ -3100,7 +3100,22 @@\n fi\n fi\n \n+AC_CACHE_CHECK([for the Darwin initgroups system call],\n+\tsamba_cv_DARWIN_INITGROUPS,\n+\tAC_TRY_LINK([\n+#include \n+#include \n+\t],\n+\t[ syscall(SYS_initgroups, 16, NULL, NULL, 0); ],\n+\tsamba_cv_DARWIN_INITGROUPS=yes,\n+\tsamba_cv_DARWIN_INITGROUPS=no)\n+)\n \n+if test x\"$samba_cv_DARWIN_INITGROUPS\" = x\"yes\" ; then\n+    AC_DEFINE(HAVE_DARWIN_INITGROUPS, 1,\n+\t[Whether to use the Darwin-specific initgroups system call])\n+fi\n+\n AC_CACHE_CHECK([for working mmap],samba_cv_HAVE_MMAP,[\n AC_TRY_RUN([#include \"${srcdir-.}/tests/shared_mmap.c\"],\n            samba_cv_HAVE_MMAP=yes,samba_cv_HAVE_MMAP=no,samba_cv_HAVE_MMAP=cross)])\n\nModified: branches/SAMBA_3_0/source/smbd/sec_ctx.c\n===================================================================\n--- branches/SAMBA_3_0/source/smbd/sec_ctx.c\t2007-06-08 23:13:04 UTC (rev 23397)\n+++ branches/SAMBA_3_0/source/smbd/sec_ctx.c\t2007-06-09 00:10:26 UTC (rev 23398)\n@@ -231,6 +231,10 @@\n  Change UNIX security context. Calls panic if not successful so no return value.\n ****************************************************************************/\n \n+#ifndef HAVE_DARWIN_INITGROUPS\n+\n+/* Normal credential switch path. */\n+\n static void set_unix_security_ctx(uid_t uid, gid_t gid, int ngroups, gid_t *groups)\n {\n \t/* Start context switch */\n@@ -242,6 +246,51 @@\n \t/* end context switch */\n }\n \n+#else /* HAVE_DARWIN_INITGROUPS */\n+\n+/* The Darwin groups implementation is a little unusual. The list of\n+* groups in the kernel credential is not exhaustive, but more like\n+* a cache. The full group list is held in userspace and checked\n+* dynamically.\n+*\n+* This is an optional mechanism, and setgroups(2) opts out\n+* of it. That is, if you call setgroups, then the list of groups you\n+* set are the only groups that are ever checked. This is not what we\n+* want. We want to opt in to the dynamic resolution mechanism, so we\n+* need to specify the uid of the user whose group list (cache) we are\n+* setting.\n+*\n+* The Darwin rules are:\n+*  1. Thou shalt setegid, initgroups and seteuid IN THAT ORDER\n+*  2. Thou shalt not pass more that NGROUPS_MAX to initgroups\n+*  3. Thou shalt leave the first entry in the groups list well alone\n+*/\n+\n+#include \n+\n+static void set_unix_security_ctx(uid_t uid, gid_t gid, int ngroups, gid_t *groups)\n+{\n+\tint max = groups_max();\n+\n+\t/* Start context switch */\n+\tgain_root();\n+\n+\tbecome_gid(gid);\n+\n+\n+\tif (syscall(SYS_initgroups, (ngroups > max) ? max : ngroups,\n+\t\t\tgroups, uid) == 1) {\n+\t\tDEBUG(0, (\"WARNING: failed to set group list \"\n+\t\t\t\"(%d groups) for UID %ld: %s\\n\",\n+\t\t\tngroups, uid, strerror(errno)));\n+\t}\n+\n+\tbecome_uid(uid);\n+\t/* end context switch */\n+}\n+\n+#endif /* HAVE_DARWIN_INITGROUPS */\n+\n /****************************************************************************\n  Set the current security context to a given user.\n ****************************************************************************/\n\n"}
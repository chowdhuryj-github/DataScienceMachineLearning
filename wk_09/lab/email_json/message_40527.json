{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "\"Mehmet Yavuz Selim Soyturk\" <mehmet.yavuz.selim@gmail.com>", "subject": "mmd for bitwise_and causes a segfault with my pmc types", "body": "Hello,\n\nI have two pmc classes PjsNumber and PjsBoolean, which define\nbitwise_and like this:\n\n    PMC* bitwise_and(PMC* value, PMC* dest) {\n        FLOATVAL a, b;\n        if (! dest) {\n            dest = pmc_new(INTERP, dynpmc_PjsNumber);\n        } else if (dest->vtable->base_type != dynpmc_PjsNumber) {\n            VTABLE_morph(INTERP, dest, dynpmc_PjsNumber);\n        }\n        a = DYNSELF.get_number();\n        b = VTABLE_get_number(INTERP, value);\n        VTABLE_set_number_native(INTERP, dest, (INTVAL)a & (INTVAL)b);\n        return dest;\n    }\n\nIt seems to work in general, but in some cases (especially when I\nallocate too much memory) it causes me a segfault\nor an error like: Trace/breakpoint trap (core dumped)\n\nAn example of such a case:\n\n.HLL 'Pjs', 'pjs_group'\n.loadlib 'pjs_group_ops'\n\n.sub _ :main\n    use_much_memory()\n    test()\n.end\n\n.sub test :anon\n    .local pmc a, b, c, d, e\n    a = new .PjsBoolean\n    b = new .PjsNumber\n    c = new .PjsNumber\n    d = new .PjsNumber\n    e = new .PjsNumber\n\n    c = a & b\n    trace 1\n    e = c & d\n.end\n\n.sub use_much_memory\n    $P0 = new .ResizablePMCArray\n    $I0 = 0\n  loop:\n    $P1 = new .String\n    $P1 = 'hello world'\n    $P0[$I0] = $P1\n    inc $I0\n    if $I0 < 100000 goto loop\n    .return ($P0)\n.end\n\n\n~/parrot_svn/parrot/languages/pjs$ parrot mmd.pir\n    43 bitwise_and P4, P2, P3           P4=PjsNumber=PMC(0xb62aa00c)\nP2=PjsNumber=PMC(0xb62aa034) P3=PjsNumber=PMC(0xb62aa020)\nTrace/breakpoint trap (core dumped)\n\n~/parrot_svn/parrot/languages/pjs$ parrot --no-gc mmd.pir\n    43 bitwise_and P4, P2, P3           P4=PjsNumber=PMC(0xb60c0fa8)\nP2=PjsNumber=PMC(0xb60c0fd0) P3=PjsNumber=PMC(0xb60c0fbc)\nSegmentation fault (core dumped)\n\n\nI am new to debugging, but (if I didn't do anything wrong) I think\nthat the problem resides in the mmd table of bitwise_and.\n\nin function mmd_dispatch_p_ppp in src/mmd.c, while executing the\nsecond bitwise_and:\n\n\n    real_function = (mmd_f_p_ppp)get_mmd_dispatcher(interp,\n            left, right, func_nr, &is_pmc); // is_pmc is set to 0\nhere, but I set it to 1 from the debugger\n\n    if (is_pmc) {\n        PMC * const sub = (PMC*)real_function; // if I look at the\ncontents of sub, it is a .String pmc with content \"Hello world\"\n\n\nI have the same problem with bitwise_or. I am suspecting that the mmd\ntable gets somehow overwritten, but I wasn't capable of finding out\nif/how it's.\n\nAny ideas? Did I do something wrong implementing my PMC's, or could it\nbe a general parrot problem? But I couldn't trigger the same problem\nwith parrot .Integer or .Float types.\n\n-- \nMehmet\n\n"}
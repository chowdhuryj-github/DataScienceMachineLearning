{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r23024 - in branches: SAMBA_3_0/source/lib\n\tSAMBA_3_0_26/source/lib", "body": "Author: vlendec\nDate: 2007-05-20 20:11:23 +0000 (Sun, 20 May 2007)\nNew Revision: 23024\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23024\n\nLog:\nOk, neither the duplicates_allowed nor the timeout argument to\nmessage_send_pid is used anymore. Two users of duplicates_allowed: winbind and\nthe printer notify system.\n\nI don't thing this really changes semantics: duplicates_allowed is hell racy\nanyway, we can't guarantee that we don't send the same message in sequence\ntwice, and I think the only thing we can harm with the print notify is\nperformance.\n\nFor winbind I talked to G?\\195?\\188nther, and he did not seem too worried.\n\nVolker\n\n\nModified:\n   branches/SAMBA_3_0/source/lib/messages.c\n   branches/SAMBA_3_0_26/source/lib/messages.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/lib/messages.c\n===================================================================\n--- branches/SAMBA_3_0/source/lib/messages.c\t2007-05-20 19:43:49 UTC (rev 23023)\n+++ branches/SAMBA_3_0/source/lib/messages.c\t2007-05-20 20:11:23 UTC (rev 23024)\n@@ -4,6 +4,7 @@\n    Copyright (C) Andrew Tridgell 2000\n    Copyright (C) 2001 by Martin Pool\n    Copyright (C) 2002 by Jeremy Allison\n+   Copyright (C) 2007 by Volker Lendecke\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -106,8 +107,7 @@\n }\n \n static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n-\t\t\t\t const void *buf, size_t len,\n-\t\t\t\t BOOL duplicates_allowed);\n+\t\t\t\t const void *buf, size_t len);\n \n /****************************************************************************\n  A useful function for testing the message system.\n@@ -120,7 +120,7 @@\n \n \tDEBUG(1,(\"INFO: Received PING message from PID %s [%s]\\n\",\n \t\t procid_str_static(&src), msg));\n-\tmessage_send_pid(src, MSG_PONG, buf, len, True);\n+\tmessage_send_pid(src, MSG_PONG, buf, len);\n }\n \n /****************************************************************************\n@@ -240,17 +240,13 @@\n  Send a message to a particular pid.\n ****************************************************************************/\n \n-static NTSTATUS message_send_pid_internal(struct server_id pid, int msg_type,\n-\t\t\t\t\t  const void *buf, size_t len,\n-\t\t\t\t\t  BOOL duplicates_allowed,\n-\t\t\t\t\t  unsigned int timeout)\n+static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n+\t\t\t\t const void *buf, size_t len)\n {\n \tTDB_DATA kbuf;\n \tTDB_DATA dbuf;\n-\tTDB_DATA old_dbuf;\n \tstruct message_rec rec;\n-\tuint8 *ptr;\n-\tstruct message_rec prec;\n+\tint ret;\n \n \t/* NULL pointer means implicit length zero. */\n \tif (!buf) {\n@@ -283,113 +279,19 @@\n \n \tdbuf.dsize = len + sizeof(rec);\n \n-\tif (duplicates_allowed) {\n+\tret = tdb_append(tdb, kbuf, dbuf);\n \n-\t\t/* If duplicates are allowed we can just append the message\n-\t\t * and return. */\n+\tSAFE_FREE(dbuf.dptr);\n \n-\t\t/* lock the record for the destination */\n-\t\tif (timeout) {\n-\t\t\tif (tdb_chainlock_with_timeout(tdb, kbuf,\n-\t\t\t\t\t\t       timeout) == -1) {\n-\t\t\t\tDEBUG(0,(\"message_send_pid_internal: failed \"\n-\t\t\t\t\t \"to get chainlock with timeout \"\n-\t\t\t\t\t \"%ul.\\n\", timeout));\n-\t\t\t\treturn NT_STATUS_IO_TIMEOUT;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (tdb_chainlock(tdb, kbuf) == -1) {\n-\t\t\t\tDEBUG(0,(\"message_send_pid_internal: failed \"\n-\t\t\t\t\t \"to get chainlock.\\n\"));\n-\t\t\t\treturn NT_STATUS_LOCK_NOT_GRANTED;\n-\t\t\t}\n-\t\t}\t\n-\t\ttdb_append(tdb, kbuf, dbuf);\n-\t\ttdb_chainunlock(tdb, kbuf);\n-\n-\t\tSAFE_FREE(dbuf.dptr);\n-\t\terrno = 0;                    /* paranoia */\n-\t\treturn message_notify(pid);\n+\tif (ret == -1) {\n+\t\treturn NT_STATUS_INTERNAL_ERROR;\n \t}\n \n-\t/* lock the record for the destination */\n-\tif (timeout) {\n-\t\tif (tdb_chainlock_with_timeout(tdb, kbuf, timeout) == -1) {\n-\t\t\tDEBUG(0,(\"message_send_pid_internal: failed to get \"\n-\t\t\t\t \"chainlock with timeout %ul.\\n\", timeout));\n-\t\t\treturn NT_STATUS_IO_TIMEOUT;\n-\t\t}\n-\t} else {\n-\t\tif (tdb_chainlock(tdb, kbuf) == -1) {\n-\t\t\tDEBUG(0,(\"message_send_pid_internal: failed to get \"\n-\t\t\t\t \"chainlock.\\n\"));\n-\t\t\treturn NT_STATUS_LOCK_NOT_GRANTED;\n-\t\t}\n-\t}\t\n-\n-\told_dbuf = tdb_fetch(tdb, kbuf);\n-\n-\tif (!old_dbuf.dptr) {\n-\t\t/* its a new record */\n-\n-\t\ttdb_store(tdb, kbuf, dbuf, TDB_REPLACE);\n-\t\ttdb_chainunlock(tdb, kbuf);\n-\n-\t\tSAFE_FREE(dbuf.dptr);\n-\t\terrno = 0;                    /* paranoia */\n-\t\treturn message_notify(pid);\n-\t}\n-\n-\t/* Not a new record. Check for duplicates. */\n-\n-\tfor(ptr = old_dbuf.dptr; ptr < old_dbuf.dptr + old_dbuf.dsize; ) {\n-\t\t/*\n-\t\t * First check if the message header matches, then, if it's a\n-\t\t * non-zero sized message, check if the data matches. If so\n-\t\t * it's a duplicate and we can discard it. JRA.\n-\t\t */\n-\n-\t\tif (!memcmp(ptr, &rec, sizeof(rec))) {\n-\t\t\tif (!len\n-\t\t\t    || (len\n-\t\t\t\t&& !memcmp( ptr + sizeof(rec), buf, len))) {\n-\t\t\t\ttdb_chainunlock(tdb, kbuf);\n-\t\t\t\tDEBUG(10,(\"message_send_pid_internal: \"\n-\t\t\t\t\t  \"discarding duplicate message.\\n\"));\n-\t\t\t\tSAFE_FREE(dbuf.dptr);\n-\t\t\t\tSAFE_FREE(old_dbuf.dptr);\n-\t\t\t\treturn NT_STATUS_OK;\n-\t\t\t}\n-\t\t}\n-\t\tmemcpy(&prec, ptr, sizeof(prec));\n-\t\tptr += sizeof(rec) + prec.len;\n-\t}\n-\n-\t/* we're adding to an existing entry */\n-\n-\ttdb_append(tdb, kbuf, dbuf);\n-\ttdb_chainunlock(tdb, kbuf);\n-\n-\tSAFE_FREE(old_dbuf.dptr);\n-\tSAFE_FREE(dbuf.dptr);\n-\n \terrno = 0;                    /* paranoia */\n \treturn message_notify(pid);\n }\n \n /****************************************************************************\n- Send a message to a particular pid - no timeout.\n-****************************************************************************/\n-\n-static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n-\t\t\t\t const void *buf, size_t len,\n-\t\t\t\t BOOL duplicates_allowed)\n-{\n-\treturn message_send_pid_internal(pid, msg_type, buf, len,\n-\t\t\t\t\t duplicates_allowed, 0);\n-}\n-\n-/****************************************************************************\n  Count the messages pending for a particular pid. Expensive....\n ****************************************************************************/\n \n@@ -646,8 +548,7 @@\n \t * the msg has already been deleted from the messages.tdb.*/\n \n \tstatus = message_send_pid(crec.pid, msg_all->msg_type,\n-\t\t\t\t  msg_all->buf, msg_all->len,\n-\t\t\t\t  msg_all->duplicates);\n+\t\t\t\t  msg_all->buf, msg_all->len);\n \n \tif (NT_STATUS_EQUAL(status, NT_STATUS_INVALID_HANDLE)) {\n \t\t\n@@ -860,8 +761,7 @@\n \t\t\tstruct server_id server, \n \t\t\tuint32_t msg_type, const DATA_BLOB *data)\n {\n-\treturn message_send_pid_internal(server, msg_type, data->data,\n-\t\t\t\t\t data->length, True, 0);\n+\treturn message_send_pid(server, msg_type, data->data, data->length);\n }\n \n NTSTATUS messaging_send_buf(struct messaging_context *msg_ctx,\n\nModified: branches/SAMBA_3_0_26/source/lib/messages.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/messages.c\t2007-05-20 19:43:49 UTC (rev 23023)\n+++ branches/SAMBA_3_0_26/source/lib/messages.c\t2007-05-20 20:11:23 UTC (rev 23024)\n@@ -4,6 +4,7 @@\n    Copyright (C) Andrew Tridgell 2000\n    Copyright (C) 2001 by Martin Pool\n    Copyright (C) 2002 by Jeremy Allison\n+   Copyright (C) 2007 by Volker Lendecke\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -106,8 +107,7 @@\n }\n \n static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n-\t\t\t\t const void *buf, size_t len,\n-\t\t\t\t BOOL duplicates_allowed);\n+\t\t\t\t const void *buf, size_t len);\n \n /****************************************************************************\n  A useful function for testing the message system.\n@@ -120,7 +120,7 @@\n \n \tDEBUG(1,(\"INFO: Received PING message from PID %s [%s]\\n\",\n \t\t procid_str_static(&src), msg));\n-\tmessage_send_pid(src, MSG_PONG, buf, len, True);\n+\tmessage_send_pid(src, MSG_PONG, buf, len);\n }\n \n /****************************************************************************\n@@ -240,17 +240,13 @@\n  Send a message to a particular pid.\n ****************************************************************************/\n \n-static NTSTATUS message_send_pid_internal(struct server_id pid, int msg_type,\n-\t\t\t\t\t  const void *buf, size_t len,\n-\t\t\t\t\t  BOOL duplicates_allowed,\n-\t\t\t\t\t  unsigned int timeout)\n+static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n+\t\t\t\t const void *buf, size_t len)\n {\n \tTDB_DATA kbuf;\n \tTDB_DATA dbuf;\n-\tTDB_DATA old_dbuf;\n \tstruct message_rec rec;\n-\tuint8 *ptr;\n-\tstruct message_rec prec;\n+\tint ret;\n \n \t/* NULL pointer means implicit length zero. */\n \tif (!buf) {\n@@ -283,113 +279,19 @@\n \n \tdbuf.dsize = len + sizeof(rec);\n \n-\tif (duplicates_allowed) {\n+\tret = tdb_append(tdb, kbuf, dbuf);\n \n-\t\t/* If duplicates are allowed we can just append the message\n-\t\t * and return. */\n+\tSAFE_FREE(dbuf.dptr);\n \n-\t\t/* lock the record for the destination */\n-\t\tif (timeout) {\n-\t\t\tif (tdb_chainlock_with_timeout(tdb, kbuf,\n-\t\t\t\t\t\t       timeout) == -1) {\n-\t\t\t\tDEBUG(0,(\"message_send_pid_internal: failed \"\n-\t\t\t\t\t \"to get chainlock with timeout \"\n-\t\t\t\t\t \"%ul.\\n\", timeout));\n-\t\t\t\treturn NT_STATUS_IO_TIMEOUT;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (tdb_chainlock(tdb, kbuf) == -1) {\n-\t\t\t\tDEBUG(0,(\"message_send_pid_internal: failed \"\n-\t\t\t\t\t \"to get chainlock.\\n\"));\n-\t\t\t\treturn NT_STATUS_LOCK_NOT_GRANTED;\n-\t\t\t}\n-\t\t}\t\n-\t\ttdb_append(tdb, kbuf, dbuf);\n-\t\ttdb_chainunlock(tdb, kbuf);\n-\n-\t\tSAFE_FREE(dbuf.dptr);\n-\t\terrno = 0;                    /* paranoia */\n-\t\treturn message_notify(pid);\n+\tif (ret == -1) {\n+\t\treturn NT_STATUS_INTERNAL_ERROR;\n \t}\n \n-\t/* lock the record for the destination */\n-\tif (timeout) {\n-\t\tif (tdb_chainlock_with_timeout(tdb, kbuf, timeout) == -1) {\n-\t\t\tDEBUG(0,(\"message_send_pid_internal: failed to get \"\n-\t\t\t\t \"chainlock with timeout %ul.\\n\", timeout));\n-\t\t\treturn NT_STATUS_IO_TIMEOUT;\n-\t\t}\n-\t} else {\n-\t\tif (tdb_chainlock(tdb, kbuf) == -1) {\n-\t\t\tDEBUG(0,(\"message_send_pid_internal: failed to get \"\n-\t\t\t\t \"chainlock.\\n\"));\n-\t\t\treturn NT_STATUS_LOCK_NOT_GRANTED;\n-\t\t}\n-\t}\t\n-\n-\told_dbuf = tdb_fetch(tdb, kbuf);\n-\n-\tif (!old_dbuf.dptr) {\n-\t\t/* its a new record */\n-\n-\t\ttdb_store(tdb, kbuf, dbuf, TDB_REPLACE);\n-\t\ttdb_chainunlock(tdb, kbuf);\n-\n-\t\tSAFE_FREE(dbuf.dptr);\n-\t\terrno = 0;                    /* paranoia */\n-\t\treturn message_notify(pid);\n-\t}\n-\n-\t/* Not a new record. Check for duplicates. */\n-\n-\tfor(ptr = old_dbuf.dptr; ptr < old_dbuf.dptr + old_dbuf.dsize; ) {\n-\t\t/*\n-\t\t * First check if the message header matches, then, if it's a\n-\t\t * non-zero sized message, check if the data matches. If so\n-\t\t * it's a duplicate and we can discard it. JRA.\n-\t\t */\n-\n-\t\tif (!memcmp(ptr, &rec, sizeof(rec))) {\n-\t\t\tif (!len\n-\t\t\t    || (len\n-\t\t\t\t&& !memcmp( ptr + sizeof(rec), buf, len))) {\n-\t\t\t\ttdb_chainunlock(tdb, kbuf);\n-\t\t\t\tDEBUG(10,(\"message_send_pid_internal: \"\n-\t\t\t\t\t  \"discarding duplicate message.\\n\"));\n-\t\t\t\tSAFE_FREE(dbuf.dptr);\n-\t\t\t\tSAFE_FREE(old_dbuf.dptr);\n-\t\t\t\treturn NT_STATUS_OK;\n-\t\t\t}\n-\t\t}\n-\t\tmemcpy(&prec, ptr, sizeof(prec));\n-\t\tptr += sizeof(rec) + prec.len;\n-\t}\n-\n-\t/* we're adding to an existing entry */\n-\n-\ttdb_append(tdb, kbuf, dbuf);\n-\ttdb_chainunlock(tdb, kbuf);\n-\n-\tSAFE_FREE(old_dbuf.dptr);\n-\tSAFE_FREE(dbuf.dptr);\n-\n \terrno = 0;                    /* paranoia */\n \treturn message_notify(pid);\n }\n \n /****************************************************************************\n- Send a message to a particular pid - no timeout.\n-****************************************************************************/\n-\n-static NTSTATUS message_send_pid(struct server_id pid, int msg_type,\n-\t\t\t\t const void *buf, size_t len,\n-\t\t\t\t BOOL duplicates_allowed)\n-{\n-\treturn message_send_pid_internal(pid, msg_type, buf, len,\n-\t\t\t\t\t duplicates_allowed, 0);\n-}\n-\n-/****************************************************************************\n  Count the messages pending for a particular pid. Expensive....\n ****************************************************************************/\n \n@@ -646,8 +548,7 @@\n \t * the msg has already been deleted from the messages.tdb.*/\n \n \tstatus = message_send_pid(crec.pid, msg_all->msg_type,\n-\t\t\t\t  msg_all->buf, msg_all->len,\n-\t\t\t\t  msg_all->duplicates);\n+\t\t\t\t  msg_all->buf, msg_all->len);\n \n \tif (NT_STATUS_EQUAL(status, NT_STATUS_INVALID_HANDLE)) {\n \t\t\n@@ -860,8 +761,7 @@\n \t\t\tstruct server_id server, \n \t\t\tuint32_t msg_type, const DATA_BLOB *data)\n {\n-\treturn message_send_pid_internal(server, msg_type, data->data,\n-\t\t\t\t\t data->length, True, 0);\n+\treturn message_send_pid(server, msg_type, data->data, data->length);\n }\n \n NTSTATUS messaging_send_buf(struct messaging_context *msg_ctx,\n\n"}
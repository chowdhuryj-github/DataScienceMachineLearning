{"category": "ham", "to_address": "\"Tom Allison\" <tom@tacocat.net>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: character encoding & regex", "body": "On 6/16/07, Tom Allison  wrote:\n\n> I'm trying to do some regular expression on strings in email. They could be\n> encoded to something.  But I can't tell because I don't have a utf8 unicode\n> xterm window that will show me anything.  At best I get ?????a??  and other\n> trash like that.  I think this is typical for ascii text renderings of two-bit\n> characters.\n\nBut, I think what you're saying is, you want to be able to tell\nwhether today's ?????a?? is the same mystery word that looked like\n?????a?? in yesterday's mail, right? That is, you still won't know\nwhat it is, but at least you'll be able to say you saw it again.\n\n> I found something that SpamAssassin uses to convert all this \"goo\" into a\n> repeatable set of characters (which is all I'm really after) by running\n> something that looks like this:\n>\n> sub _quote_bytea {\n>      my ($str) = @_;\n>      my $buf = \"\";\n>      foreach my $char (split(//,$str)) {\n>          my $oct = sprintf (\"%lo\", ord($char));\n>          if (length( $oct ) < 2 ) { $oct = '0' . $oct; }\n>          if (length( $oct ) < 3 ) { $oct = '0' . $oct; }\n>          $buf .= '\\\\\\\\\\\\\\\\' . $oct;\n>      }\n>      return $buf;\n> }\n\nSo that's somebody else's code, not yours? Does that code have any\ncomments that explain what it's doing? What does \"_quote_bytea\" mean?\n\nThat looks to me like it's replacing each character with four\nbackslashes and at least three octal digits. The two ifs are confusing\nme. Do you know about leading zeroes in sprintf formats?\n\n  my $oct = sprintf (\"%03lo\", ord($char));  # maybe?\n\n  my $buf = join \"\",\n    map sprintf(\"\\\\\\\\\\\\\\\\%03lo\", ord($_)),\n    split //, $str;              # ???\n\n  $str =~ s{(.)}{ sprintf \"\\\\\\\\\\\\\\\\%03lo\", ord($1) }seg;   #???\n\nBut it sounds to me as if you don't want that particular string; you\nwant any function that gives you a lossless, repeatable coding of your\ninput string, but unlike the input string, the desired result is\ncomposed only of printable characters. Yes? And presumably,\ncompactness and readability are also desirable features of the encoded\nstring.\n\n  # Encode everything except the \"normal\" ASCII\n  # characters. Normal includes newline and space, but no other\n  # inkless characters. Normal does not include backslash.\n  ###UNPORTABLE### Newline character is machine-dependent\n  $str =~ s{([^\\n\\x20-\\x5b\\x5d-\\x7e])}{ sprintf \"\\\\{%x}\", ord($1) }seg;\n\nBy now, I'm sure I must have sufficiently misunderstood either the\ntask or Perl's abilities to accomplish it, so I'll leave it at this.\nHope this helps!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
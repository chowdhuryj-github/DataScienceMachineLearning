{"category": "ham", "to_address": "\"brian d foy\" <brian.d.foy@gmail.com>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: [svn:perl6-synopsis] r14421 - doc/trunk/design/syn", "body": "Jonathan Lang wrote:\n> Which is not to say that there isn't a time and place when ease of\n> implementation should trump ease of programming; taking an extreme\n> example, being able to write a program that consists of the single\n> line:\n>\n>   attend my every wish\n>\n> is the ultimate in terms of ease of programming; it's also impossible\n> to implement, barring the invention of mind-reading hardware and\n> sapient artificial intelligence software.  If a small increase in the\n> programmer's learning curve is the price that must be paid to achieve\n> a massive reduction in the implementor's workload, it may very well be\n> worthwhile to foist some of the complexity onto the programmer.\n>\n> The question is whether or not this is one of those cases.\n\nAddendum: let me note that Perl has a reputation for bending over\nbackward to accommodate the programmer; as such, the difference in\nimplementation workloads for the two models that Damian referenced is\ngoing to have to be _very_ severe for \"ease of implementation\" to win\nout over \"ease of programming\" - IMHO.  Unfortunately for me, MHO\ndoesn't count as much as DHO.  \"Help, help!  I'm being oppressed!\"\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
{"category": "ham", "to_address": "\"Alek Storm\" <alek.storm@gmail.com>", "from_address": "Bob Rogers <rogers-perl6@rgrjr.dyndns.org>", "subject": "Re: modifying classes after they're instantiated", "body": "   From: \"Alek Storm\" \n   Date: Thu, 12 Apr 2007 21:55:34 -0500\n\n   On 4/11/07, Allison Randal  wrote:\n\n   > They might not clone their classes from the user perspective, but\n   > internally it's the only truly safe way to modify a class that already\n   > has objects instantiated (especially when you're talking about remove\n   > operations). Otherwise, you have objects referencing attributes that\n   > don't exist any longer in the class, or methods referencing attributes\n   > that were never initialized in the object. The closest they can come is\n   > the option 1) I listed.\n\n   Whether it's safe or not, languages need the option of not cloning their\n   classes.  Therefore, Parrot needs it.  We can't tell language implementors\n   that we can't support their language because it's not \"safe\" . . .\n\nNow that I've finally read that part of the spec, it turns out that Lisp\ndoesn't allow the class to be cloned when it is modified.  And (as I\nmentioned earlier) it *does* require that modified instances be updated\nto reflect the new class definition.  I am in the process of studying\nhow CMUCL achieves this feat, which involves an intermediate data\nstructure, and can post a summary if anyone is interested.\n\n   As a result, I withdraw my statements in support of explicit cloning,\nand would prefer a solution that avoids *any* cloning.\n\n   Any language whose class modifications affect already-instantiated\n   objects would have its own way of resolving removed\n   methods/attributes in find_method() or (get|set)_attribute().\n\nTrue, but cross-language inheritance complicates the situation.  If\nLanguage A permits radical class redefinition and exports ClassA, which\nis used as a superclass of ClassB in Language B that does not permit any\nredefinition, what should happen to ClassB instances when ClassA is\nredefined in a way that requires updating instances?  Here are some\npossibilities:\n\n   1.  Redefinition in ClassA is prevented, effectively propagating the\nLanguage B restriction up the inheritance chain.\n\n   2.  ClassB instances are magically updated, because ClassB also\ninherits the Language A metaclass behavior.  (This need not require\nLanguage B to permit class modification itself, since the propagation of\nchanges to subclasses would need to be handled independently.)\n\n   3.  ClassB is forbidden to inherit from ClassA at all, due to\nmetaclass incompatibility.\n\n   Since there aren't many formal constraints on inter-language\ninheritance, I think pretty much any behavior (short of segfaulting)\ncould be argued to be correct.  Furthermore, dynamic class redefinition\nis mostly useful in development, so this isn't a real use case; the\nClassB developer is presumably using a packaged ClassA.\n\n   Nevertheless, the implementor of Language B has a choice:  Use the\nmore fluid update semantics (which I hope is intended to be the Parrot\ndefault) and risk violating letter of the Language B spec, or restrict\nthe update semantics and risk interoperability problems.  Since the\nfirst choice is easier to implement, more helpful to users for\ndebugging, and stands a good change of behaving as a compatible\nextension to the language, I know which I would pick.  ;-}\n\n   On 4/11/07, Bob Rogers  wrote:\n\n   > Hmm.  If a Lisp implementation ever worked this way, FWIW, it would be\n   > considered buggy . . .\n\n   You've hit the nail on the head.  The problem is that Parrot can't assume\n   that every language clones its classes.  With solution 4, all classes are\n   cloned, whether the language they belong to likes it or not.  With the\n   solution I proposed, LispClass would not clone itself on 'add_method', but\n   ParrotClass would.\n\nApart from the cloning issue, I submit that this would be buggy even for\nParrotClass.  Consider:\n\n   1.  If 'add_method' always clones a ParrotClass, then autoloading\nmethods would be self-defeating.  (Maybe even class-defeating.  ;-)\n\n   2.  At some point later in the session, the user (who is developing\nin a Parrot language) will have some ParrotClass objects that support\nthe new protocol, and some lying around that don't.  I've been there,\nand can attest that this is a pain.\n\n   To clarify, the 'instantiated' bit should be cleared on the newly-created\n   clone, not on the original class, since cloning does not change the fact\n   that it has instantiated objects.  If that's what you meant, sorry, just\n   making sure I understand you.\n\nYes, exactly.  No extra charge for double-checking.  ;-}\n\n   > The normal use case for this class-changing API, it seems to me, is to\n   > redefine an HLL class definition incrementally by recompiling it.\n   > Having one HLL mutate the class of another HLL seems relatively arcane.\n   > Are you suggesting that this is a bad idea simply because it can be\n   > abused in this manner?\n\n   Yes.  For example, code that deals with classes through their abstracted\n   interface (good design from an OO standpoint) would have no idea which\n   language they came from.  It wouldn't be too common . . .\n\nActually, now that I think about it, it's not arcane at all.  Basic\ninheritance is enough to provide a natural mechanism for one language's\nclass manipulation to affect the classes of another, just by normal\nredefinition.  IMHO, that is all the more reason for Parrot to adopt the\nbroadest practical functionality in ParrotClass, and to discourage\nlanguage designers from dumbing it down.\n\n   . . .\n\n   Sorry for the length - couldn't help myself ;)\n\nLength shouldn't be something to apologize for.  (I sure hope not; if it\nwere, I'd be in trouble.  ;-)\n\n\t\t\t\t\t-- Bob\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22628 - in\n\tbranches/SAMBA_4_0/source/libcli/smb_composite: .", "body": "Author: metze\nDate: 2007-05-01 09:06:25 +0000 (Tue, 01 May 2007)\nNew Revision: 22628\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22628\n\nLog:\nconvert to new composite api\nand free the smbcli_request explicit to fix a crash where\nthe request handler gets called after its private data is already\nfreed\n\nmetze\nModified:\n   branches/SAMBA_4_0/source/libcli/smb_composite/sesssetup.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/libcli/smb_composite/sesssetup.c\n===================================================================\n--- branches/SAMBA_4_0/source/libcli/smb_composite/sesssetup.c\t2007-05-01 08:43:52 UTC (rev 22627)\n+++ branches/SAMBA_4_0/source/libcli/smb_composite/sesssetup.c\t2007-05-01 09:06:25 UTC (rev 22628)\n@@ -38,6 +38,16 @@\n \tstruct smbcli_request *req;\n };\n \n+static int sesssetup_state_destructor(struct sesssetup_state *state)\n+{\n+\tif (state->req) {\n+\t\ttalloc_free(state->req);\n+\t\tstate->req = NULL;\n+\t}\n+\n+\treturn 0;\n+}\n+\n static NTSTATUS session_setup_old(struct composite_context *c,\n \t\t\t\t  struct smbcli_session *session, \n \t\t\t\t  struct smb_composite_sesssetup *io,\n@@ -75,6 +85,7 @@\n \tNTSTATUS session_key_err, nt_status;\n \n \tc->status = smb_raw_sesssetup_recv(req, state, &state->setup);\n+\tstate->req = NULL;\n \n \tswitch (state->setup.old.level) {\n \tcase RAW_SESSSETUP_OLD:\n@@ -90,8 +101,7 @@\n \t\t\t\t\t\t\t      &state->req);\n \t\t\t\tif (NT_STATUS_IS_OK(nt_status)) {\n \t\t\t\t\tc->status = nt_status;\n-\t\t\t\t\tstate->req->async.fn = request_handler;\n-\t\t\t\t\tstate->req->async.private = c;\n+\t\t\t\t\tcomposite_continue_smb(c, state->req, request_handler, c);\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n@@ -109,8 +119,7 @@\n \t\t\t\t\t\t\t      &state->req);\n \t\t\t\tif (NT_STATUS_IS_OK(nt_status)) {\n \t\t\t\t\tc->status = nt_status;\n-\t\t\t\t\tstate->req->async.fn = request_handler;\n-\t\t\t\t\tstate->req->async.private = c;\n+\t\t\t\t\tcomposite_continue_smb(c, state->req, request_handler, c);\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n@@ -128,8 +137,7 @@\n \t\t\t\t\t\t\t\t      &state->req);\n \t\t\t\tif (NT_STATUS_IS_OK(nt_status)) {\n \t\t\t\t\tc->status = nt_status;\n-\t\t\t\t\tstate->req->async.fn = request_handler;\n-\t\t\t\t\tstate->req->async.private = c;\n+\t\t\t\t\tcomposite_continue_smb(c, state->req, request_handler, c);\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n@@ -158,7 +166,7 @@\n \t\t} else {\n \t\t\tstate->setup.spnego.in.secblob = data_blob(NULL, 0);\n \t\t}\n-\t\t\t\n+\n \t\t/* we need to do another round of session setup. We keep going until both sides\n \t\t   are happy */\n \t\tsession_key_err = gensec_session_key(session->gensec, &session_key);\n@@ -176,8 +184,7 @@\n \t\t\tsession->vuid = state->io->out.vuid;\n \t\t\tstate->req = smb_raw_sesssetup_send(session, &state->setup);\n \t\t\tsession->vuid = vuid;\n-\t\t\tstate->req->async.fn = request_handler;\n-\t\t\tstate->req->async.private = c;\n+\t\t\tcomposite_continue_smb(c, state->req, request_handler, c);\n \t\t\treturn;\n \t\t}\n \t\tbreak;\n@@ -196,14 +203,12 @@\n \t\t}\n \t}\n \n-\tif (NT_STATUS_IS_OK(c->status)) {\n-\t\tc->state = COMPOSITE_STATE_DONE;\n-\t} else {\n-\t\tc->state = COMPOSITE_STATE_ERROR;\n+\tif (!NT_STATUS_IS_OK(c->status)) {\n+\t\tcomposite_error(c, c->status);\n+\t\treturn;\n \t}\n-\tif (c->async.fn) {\n-\t\tc->async.fn(c);\n-\t}\n+\n+\tcomposite_done(c);\n }\n \n \n@@ -457,20 +462,16 @@\n \tstruct sesssetup_state *state;\n \tNTSTATUS status;\n \n-\tc = talloc_zero(session, struct composite_context);\n+\tc = composite_create(session, session->transport->socket->event.ctx);\n \tif (c == NULL) return NULL;\n \n-\tstate = talloc(c, struct sesssetup_state);\n-\tif (state == NULL) {\n-\t\ttalloc_free(c);\n-\t\treturn NULL;\n-\t}\n+\tstate = talloc_zero(c, struct sesssetup_state);\n+\tif (composite_nomem(state, c)) return c;\n+\tc->private_data = state;\n \n \tstate->io = io;\n \n-\tc->state = COMPOSITE_STATE_IN_PROGRESS;\n-\tc->private_data = state;\n-\tc->event_ctx = session->transport->socket->event.ctx;\n+\ttalloc_set_destructor(state, sesssetup_state_destructor);\n \n \t/* no session setup at all in earliest protocol varients */\n \tif (session->transport->negotiate.protocol < PROTOCOL_LANMAN1) {\n@@ -491,13 +492,11 @@\n \n \tif (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED) || \n \t    NT_STATUS_IS_OK(status)) {\n-\t\tstate->req->async.fn = request_handler;\n-\t\tstate->req->async.private = c;\n+\t\tcomposite_continue_smb(c, state->req, request_handler, c);\t\n \t\treturn c;\n \t}\n \n-\tc->state = COMPOSITE_STATE_ERROR;\n-\tc->status = status;\n+\tcomposite_error(c, status);\n \treturn c;\n }\n \n\n"}
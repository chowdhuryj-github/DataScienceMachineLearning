{"category": "ham", "to_address": "tewk <tewk@tewk.com>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: Initial patch for pdd15 testing.", "body": "Another one wiped out by Thunderbird crash.\n\ntewk wrote:\n> \n> Allison Randal wrote:\n>> tewk wrote:\n>>> Patch was to large to attach so: http://tewk.com/pdd15_testing.diff\n>>>\n>>> Tests currently fail because they use the \"new\" opcode to instantiate \n>>> objects.\n>>\n>> Fixing the 'new' opcode is the first change we need to make to get \n>> both object models working simultaneously. Pick one:\n>>\n>> - The 'new' opcode can no longer lookup string class names by type \n>> number (eventually true).\n>>\n> I'd really like to work on permanent solutions.  \n\nWe are working on permanent solutions, we're just moving there by a \nprocess of refactoring. Removing the type number system from Parrot is \ntoo extensive a change to be the first step in integrating the new \nobject system. (This is what we'll need to do to make this \nimplementation path work.)\n\nSo, for now we go with:\n\n >> - The PDD 15 object implementation needs to register a type number for\n >> its classes (as a temporary measure to smooth over integration).\n\n> So how should we \n> implement option one?\n> Should we have a pmc lookup resolution order of current namespace, hll \n> namespace,  parrot namespace, and finally root namespace.\n> Then all current, non-hll pmcs should be placed in the parrot namespace.\n> \n> Nope that won't work, the parrot and root namespaces can't blead into \n> hll namespaces' visibility.\n> \n> We really need independent opcodes which segment the current namespace, \n> hll namespaces, and the root parrot namespace.\n> \n> I think we should have:\n> new_cur  - resolves using the current namespace\n> new_hll   - resolves pmcs and classes using the hll namespace\n> new         - resolves using the parrot namespace.\n> \n> we probably need the same thing for newclass.\n> \n> newclass_cur\n> newclass_hll\n> newclass\n\nI'm more inclined to stick with new and newclass, and just provide \nnamespace options as flags.\n\n> Second issue:\n> \n> PDD15 registers methods in the class.  So methods defined using :method \n> in the class namespace aren't found by the find_method.\n> So:\n> 1: We force compiler writers to make add_method calls for every method \n> and drop :method\n\nDefinitely not.\n\n> 2: After running :init and :load subs we auto-call add_method for \n> methods defined in pir with :method. (this has nasty corner cases)\n>       What do we do about evaled :methods, repeat the same auto-call \n> technique after ever eval?\n\nClose.\n\n> 3: We modify the Class PMC's find_method to look in the namespace for \n> method and lazily call add_method.\n\nNot really desirable.\n\n4: The call to newclass checks the namespace associated with the class \nto see if it contains any :methods or :vtables. If it does, it \nautomatically adds them to the class. (This covers the case where the \nmethods were loaded before the class was created.)\n\nAlso, the code that installs subs in a namespace checks to see if that \nnamespace is associated with a class, and if it is installs any :method \nor :vtable entries in the class. (This handles methods loaded after the \nclass is created, and evals.)\n\nThere will still be some methods that need to be manually installed with \nadd_method.\n\nAllison\n\n"}
{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14414 - doc/trunk/design/syn", "body": "Author: larry\nDate: Sat Jun  2 14:45:43 2007\nNew Revision: 14414\n\nModified:\n   doc/trunk/design/syn/S03.pod\n\nLog:\nFirst installment of filling out descriptions of operator semantics.\n\n\nModified: doc/trunk/design/syn/S03.pod\n==============================================================================\n--- doc/trunk/design/syn/S03.pod\t(original)\n+++ doc/trunk/design/syn/S03.pod\tSat Jun  2 14:45:43 2007\n@@ -97,21 +97,40 @@\n \n =item *\n \n+Heredoc\n+\n+    qq:to/END/\n+        Dear $recipient:\n+        Thanks!\n+        Sincerely,\n+        $me\n+        END\n+\n+=item *\n+\n Array composer\n \n     [1,2,3]\n \n+Provides list context inside.\n+\n =item *\n \n Hash composer\n \n     { a => 42 }\n \n+Inside must be a list of pairs, otherwise you must use C\n+or C<%()> instead.\n+\n =item *\n \n Closure\n \n-    {...}\n+    { ... }\n+\n+When found where a statement is expected, executes immediately.  Othewise\n+always defers evaluation of the inside scope.\n \n =item *\n \n@@ -119,6 +138,8 @@\n \n     \\(@a,$b,%c)\n \n+An abstraction representing an argument list that doesn't yet know its context.\n+\n =item *\n \n Sigiled variables\n@@ -128,7 +149,7 @@\n     %z\n     $^a\n     $?FILE\n-    @@multidim\n+    @@slice\n     &func\n     &div:(Int, Int --> Int)\n \n@@ -247,6 +268,9 @@\n     $obj.::Class::meth\n     $obj.Class::meth    # same thing, assuming Class is predeclared\n \n+As in Perl 5, tells the dispatcher which class to start searching from,\n+not the exact method to call.\n+\n =item *\n \n Mutating method call\n@@ -286,7 +310,7 @@\n \n Dotted postfix form of any other prefix operator\n \n-    $x.'++'       # prefix:<++>($x), fallback to postfix:<++>\n+    $x.:<++>       # prefix:<++>($x)\n \n =back\n \n@@ -396,79 +420,109 @@\n \n prefix:, boolean context\n \n-    ?\n+    ?$x\n \n+Evaluates the expression as a boolean and returns C if expression\n+is true or C otherwise.\n See \"true\" below for a low-precedence alternative.\n \n =item *\n \n prefix:, boolean negation\n \n-    !\n+    !$x\n \n+Returns the opposite of what C would.\n See \"not\" below for a low-precedence alternative.\n \n =item *\n \n prefix:<+>, numeric context\n \n-    +\n+    +$x\n+\n+Unlike in Perl 5, where C<+> is a no-op, this operator coerces\n+to numeric context in Perl 6.  (It coerces only the value, not the\n+original variable.)  The narrowest appropriate type of C, C,\n+or C will be returned.  A string containing two integers\n+separated by a C will be returned as a C.  Exponential notation\n+and radix notations are recognized.\n \n =item *\n \n prefix:<->, numeric negation\n \n-    -\n+    -$x\n+\n+Coerces to numeric and returns the negation of the resulting number.\n \n =item *\n \n prefix:<~>, string context\n \n-    ~\n+    ~$x\n+\n+Coerces the value to a string.  (It only coerces the value, not the\n+original variable.)\n \n =item *\n \n prefix:<|>, flatten object into arglist\n \n-    |\n+    | $capture\n+\n+Interpolates the contents of the C (or C-like) value\n+into the current argument list as if they had been specified literally.\n \n =item *\n \n prefix:<+^>, numeric bitwise negation\n \n-    +^\n+    +^$x\n+\n+Coerces to numeric and then does bitwise negation on the number.\n \n =item *\n \n prefix:<~^>, string bitwise negation\n \n-    ~^\n+    ~^$x\n+Coerces to string buffer and then does bitwise negation on each element.\n \n =item *\n \n prefix:, boolean bitwise negation\n \n-    ?^\n+    ?^$x\n+\n+Coerces to boolean and then flips the bit.  (Same as C.)\n \n =item *\n \n prefix:<\\>, Capture constructor\n \n-    \\\n+    \\$x\n+    \\@x\n+    \\%x\n+    \\($invocant: $pos1, $pos2, :named($arg))\n+\n+Defers the contextualization of its argument or arguments till it is\n+bound into some other context.\n \n =item *\n \n prefix:<^>, upto operator\n \n-    ^\n+    ^$limit\n \n-Constructs a range or locates a metaclass.  See L.\n+Constructs a range of C<0..^$limit> or locates a metaclass as a shortcut\n+for C<$limit.HOW>.  See L.\n \n =item *\n \n prefix:<=>, iterate iterator\n \n-    =\n+    =$iterator\n \n Unary C<=> reads lines from a filehandle or filename, or\n iterates an iterator, or in general causes a scalar to explode its guts\n@@ -491,7 +545,9 @@\n \n infix:<*>\n \n-    *\n+    $x*$y\n+\n+Multiplication, resulting in wider type of the two.\n \n =item *\n \n@@ -499,7 +555,8 @@\n \n     $numerator / $denominator\n \n-Converts both operands to C and does division returning C.\n+If either operand is of C type,\n+converts both operands to C and does division returning C.\n If the denominator is zero, returns either C<+Inf>, C, or C<-Inf>\n as the numerator is positive, zero, or negative.  (This is construed\n as the best default in light of the operator's possible use within\n@@ -507,6 +564,11 @@\n on an individual scalar division, you can always check the denominator\n yourself.)\n \n+If both operands are of integer type, you still get a C, but the\n+C type is allowed to do the division lazily; internally it may\n+store a C until the time a value is called for.  If converted\n+to C directly no division ever need be done.\n+\n =item *\n \n infix:, generic division\n@@ -529,7 +591,7 @@\n \n infix:<%>, modulus\n \n-    %\n+    $x % $mod\n \n Always floor semantics using C or C.\n \n@@ -537,7 +599,7 @@\n \n infix:, generic modulus\n \n-    mod\n+    $x mod $mod\n \n Dispatches to the infix: multi most appropriate to the operand types.\n \n@@ -553,7 +615,8 @@\n \n If the count is less than 1, returns the null string.\n The count may not be C<*> because Perl 6 does not support\n-infinite strings.  (At least, not yet...)\n+infinite strings.  (At least, not yet...)  Note, however, that an\n+infinite string may be emulated with C.\n \n =item *\n \n@@ -562,10 +625,10 @@\n     @list xx $count\n \n Evaluates the left argument in list context, replicates the resulting\n-Capture value the number of time specified by the right argument and\n+C value the number of time specified by the right argument and\n returns the result in a context dependent fashion.  If the operator\n is being evaluated in ordinary list context, the operator returns a\n-flattened list.  In C<@@> context, the operator converts each Capture\n+flattened list.  In slice (C<@@>) context, the operator converts each C\n to a separate sublist and returns the list of those sublists.\n \n If the count is less than 1, returns the empty list, C<()>.\n@@ -576,7 +639,9 @@\n \n infix:{'+&'}, numeric bitwise and\n \n-    +&\n+    $x +& $y\n+\n+Converts both arguments to C and does a bitwise numeric AND.\n \n =item *\n \n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 308:  in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 308\nrevision-id: tridge@samba.org-20070516081026-l0m82yuabzu91dlr\nparent: tridge@samba.org-20070515084056-6333fevxsd6cnlzz\nparent: sahlberg@ronnie-20070516023430-nle4lyaap7006te6\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Wed 2007-05-16 18:10:26 +1000\nmessage:\n  \n  - merge from ronnie\n  - fixed a memory leak found by dmitry\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n  common/ctdb_control.c          ctdb_control.c-20070426122724-j6gkpiofhbwdin63-1\n  common/ctdb_recover.c          ctdb_recover.c-20070503002147-admmfgt1oj6gexfo-1\n  common/ctdb_recoverd.c         recoverd.c-20070503213540-bvxuyd9jm1f7ig90-1\n  include/ctdb.h                 ctdb.h-20061117234101-o3qt14umlg9en8z0-11\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n    ------------------------------------------------------------\n    revno: 197.1.112\n    merged: sahlberg@ronnie-20070516023430-nle4lyaap7006te6\n    parent: sahlberg@ronnie-20070516011228-cap2v4f7lj3p2epm\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Wed 2007-05-16 12:34:30 +1000\n    message:\n      if a caller specifies a timeout when calling a control, it makes no \n      sense to have the daemon requeue the packets if they timeout or fail to \n      deliver to the remote node\n    ------------------------------------------------------------\n    revno: 197.1.111\n    merged: sahlberg@ronnie-20070516011228-cap2v4f7lj3p2epm\n    parent: sahlberg@ronnie-20070515003414-d6txjr8vr0ce1ypt\n    parent: tridge@samba.org-20070515084056-6333fevxsd6cnlzz\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Wed 2007-05-16 11:12:28 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.110\n    merged: sahlberg@ronnie-20070515003414-d6txjr8vr0ce1ypt\n    parent: sahlberg@ronnie-20070515002841-1obirc98ubq0e4de\n    parent: tridge@samba.org-20070515003328-ogsyrb3gnoyicfud\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Tue 2007-05-15 10:34:14 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.109\n    merged: sahlberg@ronnie-20070515002841-1obirc98ubq0e4de\n    parent: sahlberg@ronnie-20070514040719-j0wnxcbbcezb1vy3\n    parent: tridge@samba.org-20070515001716-tndy0z6bafkvdc3v\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Tue 2007-05-15 10:28:41 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.108\n    merged: sahlberg@ronnie-20070514040719-j0wnxcbbcezb1vy3\n    parent: sahlberg@ronnie-20070514040549-7fvs0gm0tvcjw1yu\n    parent: tridge@samba.org-20070514040133-2ktprtc6t6161yy5\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Mon 2007-05-14 14:07:19 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.107\n    merged: sahlberg@ronnie-20070514040549-7fvs0gm0tvcjw1yu\n    parent: sahlberg@ronnie-20070513220348-r6ejgh94ki3cwqib\n    parent: tridge@samba.org-20070514034901-vpwg24spu188ab97\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Mon 2007-05-14 14:05:49 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.106\n    merged: sahlberg@ronnie-20070513220348-r6ejgh94ki3cwqib\n    parent: sahlberg@ronnie-20070513205024-60p5pk9tju8ollgg\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Mon 2007-05-14 08:03:48 +1000\n    message:\n      remove the control to bump the rsn since we dont need it anymore\n    ------------------------------------------------------------\n    revno: 197.1.105\n    merged: sahlberg@ronnie-20070513205024-60p5pk9tju8ollgg\n    parent: sahlberg@ronnie-20070513202515-nxib2dfr0t23gzii\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Mon 2007-05-14 06:50:24 +1000\n    message:\n      add a mising parameter to the new signature for ctdb_control\n    ------------------------------------------------------------\n    revno: 197.1.104\n    merged: sahlberg@ronnie-20070513202515-nxib2dfr0t23gzii\n    parent: sahlberg@ronnie-20070511020319-631dcfd6ff1f1120\n    parent: tridge@samba.org-20070512232016-fdj2opy995c536bs\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Mon 2007-05-14 06:25:15 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.103\n    merged: sahlberg@ronnie-20070511020319-631dcfd6ff1f1120\n    parent: sahlberg@ronnie-20070511003742-32b5e6c3644d8ade\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Fri 2007-05-11 12:03:19 +1000\n    message:\n      we have to get a NEW generation id after completing recovery\n      to solve a race condition with the logic to retransmit in\n      ctdb_call.c/ctdb_call_timeout()\n    ------------------------------------------------------------\n    revno: 197.1.102\n    merged: sahlberg@ronnie-20070511003742-32b5e6c3644d8ade\n    parent: sahlberg@ronnie-20070511003647-00a5926a49a06b53\n    parent: tridge@samba.org-20070511003343-mdcfsv1todutp5mz\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Fri 2007-05-11 10:37:42 +1000\n    message:\n      merge from tridge\n    ------------------------------------------------------------\n    revno: 197.1.101\n    merged: sahlberg@ronnie-20070511003647-00a5926a49a06b53\n    parent: sahlberg@ronnie-20070510200817-cd0cc3a541930600\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Fri 2007-05-11 10:36:47 +1000\n    message:\n      add a control to bump the rsn number for all records in a database\n      \n      use this control from the recovery daemon to ensure that the recmaster \n      always have a higher rsn than andy other node for the records after \n      recovery completes\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-05-15 00:16:59 +0000\n+++ b/common/ctdb_call.c\t2007-05-16 08:10:26 +0000\n@@ -48,8 +48,8 @@\n   local version of ctdb_call\n */\n int ctdb_call_local(struct ctdb_db_context *ctdb_db, struct ctdb_call *call,\n-\t\t    struct ctdb_ltdb_header *header, TDB_DATA *data,\n-\t\t    uint32_t caller)\n+\t\t    struct ctdb_ltdb_header *header, TALLOC_CTX *mem_ctx,\n+\t\t    TDB_DATA *data, uint32_t caller)\n {\n \tstruct ctdb_call_info *c;\n \tstruct ctdb_registered_call *fn;\n@@ -322,12 +322,10 @@\n \t\treturn;\n \t}\n \n-\tctdb_call_local(ctdb_db, &state->call, &header, &data, ctdb->vnn);\n+\tctdb_call_local(ctdb_db, &state->call, &header, state, &data, ctdb->vnn);\n \n \tctdb_ltdb_unlock(ctdb_db, state->call.key);\n \n-\ttalloc_steal(state, state->call.reply_data.dptr);\n-\n \tstate->state = CTDB_CALL_DONE;\n \tif (state->async.fn) {\n \t\tstate->async.fn(state);\n@@ -477,7 +475,7 @@\n \t\treturn;\n \t}\n \n-\tctdb_call_local(ctdb_db, &call, &header, &data, c->hdr.srcnode);\n+\tctdb_call_local(ctdb_db, &call, &header, hdr, &data, c->hdr.srcnode);\n \n \tctdb_ltdb_unlock(ctdb_db, call.key);\n \n@@ -491,7 +489,6 @@\n \tr->datalen       = call.reply_data.dsize;\n \tif (call.reply_data.dsize) {\n \t\tmemcpy(&r->data[0], call.reply_data.dptr, call.reply_data.dsize);\n-\t\ttalloc_free(call.reply_data.dptr);\n \t}\n \n \tctdb_queue_packet(ctdb, &r->hdr);\n@@ -694,8 +691,7 @@\n \tstate->call = *call;\n \tstate->ctdb_db = ctdb_db;\n \n-\tret = ctdb_call_local(ctdb_db, &state->call, header, data, ctdb->vnn);\n-\ttalloc_steal(state, state->call.reply_data.dptr);\n+\tret = ctdb_call_local(ctdb_db, &state->call, header, state, data, ctdb->vnn);\n \n \tevent_add_timed(ctdb->ev, state, timeval_zero(), call_local_trigger, state);\n \n\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-05-12 11:25:26 +0000\n+++ b/common/ctdb_client.c\t2007-05-16 08:10:26 +0000\n@@ -264,8 +264,7 @@\n \tstate->call = *call;\n \tstate->ctdb_db = ctdb_db;\n \n-\tret = ctdb_call_local(ctdb_db, &state->call, header, data, ctdb->vnn);\n-\ttalloc_steal(state, state->call.reply_data.dptr);\n+\tret = ctdb_call_local(ctdb_db, &state->call, header, state, data, ctdb->vnn);\n \n \treturn state;\n }\n@@ -706,6 +705,13 @@\n \t\tctdb_socket_connect(ctdb);\n \t}\n \n+\t/* if the caller specified a timeout it makes no sense for the\n+\t   daemon to requeue the packet if the destination is unavailable\n+\t */\n+\tif (timeout) {\n+\t\tflags |= CTDB_CTRL_FLAG_NOREQUEUE;\n+\t}\n+\n \tstate = talloc_zero(ctdb, struct ctdb_client_control_state);\n \tCTDB_NO_MEMORY(ctdb, state);\n \n\n=== modified file 'common/ctdb_control.c'\n--- a/common/ctdb_control.c\t2007-05-15 00:17:16 +0000\n+++ b/common/ctdb_control.c\t2007-05-16 02:34:30 +0000\n@@ -359,14 +359,19 @@\n \t\t       struct timeval t, void *private_data)\n {\n \tstruct ctdb_control_state *state = talloc_get_type(private_data, struct ctdb_control_state);\n+\tstruct ctdb_req_control *c = (struct ctdb_req_control *)state->private_data;\n \tTALLOC_CTX *tmp_ctx = talloc_new(ev);\n \n \tstate->ctdb->status.timeouts.control++;\n \n \ttalloc_steal(tmp_ctx, state);\n \n-\tstate->callback(state->ctdb, -1, tdb_null, \"ctdb_control timed out\", \n-\t\t\tstate->private_data);\n+\t/* Dont retry the control if the caller asked for NOREQUEUE */\n+\tif (!(c->flags & CTDB_CTRL_FLAG_NOREQUEUE)) {\n+\t\tstate->callback(state->ctdb, -1, tdb_null,\n+\t\t\t\t\"ctdb_control timed out\", \n+\t\t\t\tstate->private_data);\n+\t}\n \ttalloc_free(tmp_ctx);\n }\n \n\n=== modified file 'common/ctdb_recover.c'\n--- a/common/ctdb_recover.c\t2007-05-14 03:48:40 +0000\n+++ b/common/ctdb_recover.c\t2007-05-14 04:05:49 +0000\n@@ -449,3 +449,4 @@\n \tctdb->recovery_mode = recmode;\n \treturn 0;\n }\n+\n\n=== modified file 'common/ctdb_recoverd.c'\n--- a/common/ctdb_recoverd.c\t2007-05-15 05:13:36 +0000\n+++ b/common/ctdb_recoverd.c\t2007-05-16 01:12:28 +0000\n@@ -400,6 +400,7 @@\n \n \n \t/* build a new vnn map with all the currently active nodes */\n+\tgeneration = random();\n \tvnnmap = talloc(mem_ctx, struct ctdb_vnn_map);\n \tCTDB_NO_MEMORY(ctdb, vnnmap);\n \tvnnmap->generation = generation;\n@@ -439,7 +440,6 @@\n \t}\n \n \n-\n \t/* disable recovery mode */\n \tret = set_recovery_mode(ctdb, nodemap, CTDB_RECOVERY_NORMAL);\n \tif (ret!=0) {\n\n=== modified file 'include/ctdb.h'\n--- a/include/ctdb.h\t2007-05-15 05:13:36 +0000\n+++ b/include/ctdb.h\t2007-05-16 01:12:28 +0000\n@@ -277,6 +277,11 @@\n int ctdb_ctrl_cleardb(struct ctdb_context *ctdb, uint32_t destnode, TALLOC_CTX *mem_ctx, uint32_t dbid);\n \n /*\n+  bump the rsn number for al records\n+ */\n+int ctdb_ctrl_bumprsn(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, TALLOC_CTX *mem_ctx, uint32_t dbid);\n+\n+/*\n   write a record on a specific db (this implicitely updates dmaster of the record to locally be the vnn of the node where the control is executed on)\n  */\n int ctdb_ctrl_write_record(struct ctdb_context *ctdb, uint32_t destnode, TALLOC_CTX *mem_ctx, uint32_t dbid, TDB_DATA key, TDB_DATA data);\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-05-15 05:13:36 +0000\n+++ b/include/ctdb_private.h\t2007-05-16 08:10:26 +0000\n@@ -518,7 +518,8 @@\n \tuint32_t opcode;\n \tuint64_t srvid;\n \tuint32_t client_id;\n-#define CTDB_CTRL_FLAG_NOREPLY 1\n+#define CTDB_CTRL_FLAG_NOREPLY   1\n+#define CTDB_CTRL_FLAG_NOREQUEUE 2\n \tuint32_t flags;\n \tuint32_t datalen;\n \tuint8_t data[1];\n@@ -680,7 +681,7 @@\n void ctdb_request_finished(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n \n int ctdb_call_local(struct ctdb_db_context *ctdb_db, struct ctdb_call *call,\n-\t\t    struct ctdb_ltdb_header *header, TDB_DATA *data,\n+\t\t    struct ctdb_ltdb_header *header, TALLOC_CTX *mem_ctx, TDB_DATA *data,\n \t\t    uint32_t caller);\n \n #define ctdb_reqid_find(ctdb, reqid, type)\t(type *)_ctdb_reqid_find(ctdb, reqid, #type, __location__)\n\n"}
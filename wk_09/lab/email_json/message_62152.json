{"category": "ham", "to_address": "\"Mathew Snyder\" <theillien@yahoo.com>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: Problem with runaway format", "body": "On 7/4/07, Mathew Snyder  wrote:\n\n> >> foreach my $user (keys %tickets) {\n> >>         foreach my $env (keys %{ $tickets{$user} }) {\n> >>                 foreach my $tikID (keys %{ $tickets{$user}{$env} }) {\n> >>                         foreach my $subject (keys %{\n> >> $tickets{$user}{$env}{$tikID} }) {\n> >\n> > You're doing the same dereferencing, just getting deeper each time.\n> > You'll save some time if you make some of those into temporary\n> > variables. That fourth nested loop could look more like this, but\n> > possibly with better variable names:\n> >\n> >        my $subjects_hash = $envs_hash->{$env};\n> >        foreach my $subject (keys %$subjects_hash) {\n> >\n>\n> Can you explain the reason for skipping the {$id} portion and assigning the\n> {$env} portion to %subjects_hash?  The logic eludes me.\n\nMaybe I've put the parts together wrong, or named them poorly. But the\ngeneral idea is that most references are copied to scalars, so that\nyou don't have to dereference $tickets{$user} as part of every\nvariable you access within four nested loops. That's probably going to\ngive you clearer code, but it will also be faster to execute.\n\nThe outer loop looks like this:\n\n  foreach my $user (keys %tickets) {\n\nSince there's just one value for $user each time through the loop,\n$tickets{$user} will have just one value each time through the loop.\nSo instead of doing that hash lookup again and again, we'll keep the\nresult in a scalar.\n\n    my $users_tix = $tickets{$user};\n\nSince the scalar is declared just inside the loop, its scope ends at\nthe same place that $user's scope ends. So any line of code that used\nto use $tickets{$user} can now use $users_tix just as well. (If their\nscopes ended in different places, those two expressions wouldn't\nalways be interchangeable.)\n\nOf course, the scalar could have been named $tickets_for_user or\n$current_users_tickets, or something that does a better job of\nmatching what it's really about. I'm not clear on the nature of the\noverall task or I'd have more confidence in my choice of name. I hope\nthat the technique is clear enough.\n\nSo, from now on, whenever we need $tickets{$user}, we can use\n$users_tix. And we need it in the next nested loop, which used to look\nlike this:\n\n    foreach my $env (keys %{ $tickets{$user} }) {\n\nBut now it looks like this:\n\n    foreach my $env (keys %{ $users_tix }) {\n\nOr, because the curly braces are optional around a just-plain-scalar,\nmany people prefer this:\n\n    foreach my $env (keys %$users_tix) {\n\nUsing the same trick another level down, we get the easy way to write\n$tickets{$user}{$env} , which could also be written\n$tickets{$user}->{$env} :\n\n      my $users_env = $users_tix->{$env};\n\nThe small arrow is optional in $tickets{$user}->{$env} because the\nother punctuation is sufficient. If there are curly braces or square\nbrackets on both sides of the arrow, or one of each, the small arrow\nmay be omitted. But it reappears in the line of code above; it's\nmandatory here because there's no longer a \"closing\" piece of\npunctuation to its left.\n\nAnd so on. By the time you get to the body of the fourth nested loop,\neach variable access has become significantly shorter, so each line of\ncode is that much more readable and speedy to execute.\n\nGood luck with it!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
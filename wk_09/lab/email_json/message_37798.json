{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14402 - doc/trunk/design/syn", "body": "Author: larry\nDate: Mon May 28 12:14:12 2007\nNew Revision: 14402\n\nModified:\n   doc/trunk/design/syn/S04.pod\n\nLog:\nClarifications to conditional bindings suggested by xinming++ and gaal++.\n\n\nModified: doc/trunk/design/syn/S04.pod\n==============================================================================\n--- doc/trunk/design/syn/S04.pod\t(original)\n+++ doc/trunk/design/syn/S04.pod\tMon May 28 12:14:12 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 19 Aug 2004\n-  Last Modified: 17 Apr 2007\n+  Last Modified: 28 May 2007\n   Number: 4\n-  Version: 57\n+  Version: 58\n \n This document summarizes Apocalypse 4, which covers the block and\n statement syntax of Perl.\n@@ -211,6 +211,24 @@\n false, might nevertheless be an I value of false.  (By similar\n reasoning, an C allows binding of a false parameter.)\n \n+An explicit placeholder may also be used:\n+\n+    if blahblah() { return $^it }\n+\n+However, use of C<$_> with a conditional statement's block is I\n+considered sufficiently explicit to turn a 0-ary block into a 1-ary\n+function, so both these methods use the same invocant:\n+\n+    if .haste { .waste }\n+\n+(Contrast with a non-conditional statement such as:\n+\n+    for .haste { .waste }\n+\n+where each call to the block would bind a new invocant for the\n+C<.waste> method, each of which is likely different from the original\n+invocant to the C<.hast> method.)\n+\n Conditional statement modifiers work as in Perl\u00a05.  So do the\n implicit conditionals implied by short-circuit operators.  Note though that\n the first expression within parens or brackets is parsed as a statement,\n@@ -253,13 +271,15 @@\n         ...\n     }\n \n-You may optionally bind the result of the conditional expression to a\n-parameter of the block:\n+As with conditionals, you may optionally bind the result of the\n+conditional expression to a parameter of the block:\n \n     while something() -> $thing {\n         ...\n     }\n \n+    while something() -> { ... $^thing ... }\n+\n Nothing is ever bound implicitly, however, and many conditionals would\n simply bind True or False in an uninteresting fashion.  This mechanism\n is really only good for objects that know how to return a boolean\n@@ -491,6 +511,18 @@\n explicit because it's not out front where it can be seen.  You can, of\n course, use a placeholder parameter if you also use C.)\n \n+Another consequence of this is that any block just inside a\n+left parenthesis is immediately called like a bare block, so a\n+multidimensional list comprehension may be written using a block with\n+multiple parameters fed by a C modifier:\n+\n+    @names = (-> $name, $num { \"$name.$num\" } for 'a'..'zzz' X 1..100);\n+\n+or equivalently, using placeholders:\n+\n+    @names = ({ \"$^name.$^num\" } for 'a'..'zzz' X 1..100);\n+\n+\n =head2 The gather statement\n \n A variant of C is C.  Like C, it is followed by a\n\n"}
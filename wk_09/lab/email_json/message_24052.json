{"category": "ham", "to_address": "Ian Bicking <ianb@colorstudy.com>", "from_address": "Marco Pesenti Gritti <mpg@redhat.com>", "subject": "Re: [sugar] Web activity & ebook reading", "body": "On Sat, 2007-05-05 at 19:46 -0500, Ian Bicking wrote:\n> So we've been talking about \"the\" ebook reader, and how it might work.\n> For reading HTML or things that would be converted into HTML (e.g.,\n> Crossmark), the browser seems like an obvious basis for a reader.\n> There's not a huge number of basic features that aren't in the browser\n> currently.  So we're thinking about how we might add these extra features.\n> \n> I've been reading the list of methods as described here:\n>    http://www.pygtk.org/pygtkmozembed/class-gtkmozembed.html\n> and there's not a lot of methods.  Changing buttons, maybe allowing you\n> to switch modes, all seems pretty reasonable -- the code at least all\n> looks simple enough.  But some of what we want to do involves getting at\n> the document object.\n> \n> As an example, if you get to the bottom of a document, and the document\n> has a  tag, then a page-down from there should take you\n> to the linked page.  Then you can flow through a linear but multi-page\n> document fairly seamlessly (assuming it's been marked up nicely).\n> There's a variety of things we'd like to do, including injecting the\n> Javascript to implement the ubiquitous annotation.\n> \n> Is the current browser activity -- and more specifically pygtkmozembed\n> -- the right basis for this kind of work?  In the short term, are there\n> ways we can start adding these features (even if the implementation may\n> have to be discarded later)?\n> \n\nIf you are planning to put this in the Read activity it should not be\nbased on the Web activity but rather on the sugar.Browser component. \n\ngtkmozembed API is very limited. There are multiple ways we can allow\nactivities to access the full mozilla API (and hence being able to do\nstuff like manipulating the DOM etc).\n\nThe two ways that makes more sense to me are:\n\n1 Hook up pyxpcom support to sugar.Browser. In theory this would allow\nyou to access the full xpcom mozilla API from python. My only doubt\nabout this approach is that pyxpcom has not been used a lot so far (and\ndevelopment does not seem to be very active).\n\n2 Implement come sort of extension system on the top of xpcom components\n(extensions could be written in javascript, c++ and maybe python at that\npoint)\n\nApproach 1 would probably end up being a lot cleaner if we manage to get\nit to work.\n\n> \n> Looking at details, we were thinking that maybe browser.append_data()\n> could be used to inject at least a little Javascript.  I tried adding\n> this to WebActivity.__init__:\n> \n>    self._browser.connect('notify::net-stop', self._doc_loaded_cb)\n> \n> Then:\n> \n>    def self._doc_loaded_cb(self, embed, *args):\n>        data = ''\n>        embed.append_data(StringIO(data), len(data))\n> \n> But I couldn't get the signal to fire at all; I couldn't get any signals\n> to work except notify::title.  Maybe there's something magic that I\n> don't understand here.  Anyway, that might give me a crude way to hack\n> on stuff.\n\nThe notify:: prefix is used to get signals on gobject properties\nchanges. You want just \"net-stop\" there.\n\nMarco\n\n_______________________________________________\nSugar mailing list\nSugar@laptop.org\nhttp://mailman.laptop.org/mailman/listinfo/sugar\n\n"}
{"category": "ham", "to_address": "\"Mathew Snyder\" <theillien@yahoo.com>", "from_address": "rcook@pcug.org.au", "subject": "Re: Effective date grab", "body": "> Yes,  a month from the first to the last day.  This is how I'm doing it\n> right\n> now which seems to be a lot of code which should be able to be pruned:\n> #Declare the variables we'll need\n> my $count = 1;\n> my $febDays;\n> my @days;\n> my %time;\n> my %months31 = (\n>         \"01\" => undef,\n>         \"03\" => undef,\n>         \"05\" => undef,\n>         \"07\" => undef,\n>         \"08\" => undef,\n>         \"10\" => undef,\n>         \"12\" => undef,\n> );\n> my %months30 = (\n>         \"04\" => undef,\n>         \"06\" => undef,\n>         \"09\" => undef,\n>         \"11\" => undef,\n> );\n> my %months = (\n>         \"01\" => \"Jan\",\n>         \"02\" => \"Feb\",\n>         \"03\" => \"Mar\",\n>         \"04\" => \"Apr\",\n>         \"05\" => \"May\",\n>         \"06\" => \"Jun\",\n>         \"07\" => \"Jul\",\n>         \"08\" => \"Aug\",\n>         \"09\" => \"Sept\",\n>         \"10\" => \"Oct\",\n>         \"11\" => \"Nov\",\n>         \"12\" => \"Dec\",\n> );\n>\n> my @date; #  = (localtime)[4,5];\n> my $month = (sprintf '%02d', (localtime)[4]); #$date[0]);\n> my $year      = (localtime)[5] + 1900; #$date[1] + 1900;\n>\n> # If the value of the 'month' variable is '00' we are in January so need\n> # to set the $month to 12 in order to get December's data.  Any other\n> # value is spot on.  The reason being that  while (localtime) will produce\n> # a value based  on a startpoint of '00', we are shifting this back one by\n> # making '00' equal to '12' causing all other numbers to match up to their\n> # respective month.\n> if ($month == '00') {\n>         $month = 12;\n>         $year--;\n> }\n>\n> # We need to determine if the current year is a leap year so we use the\n> # right number of days for Feb.\n> if (isleap($year)) {\n>         $febDays = 29;\n> }else{\n>         $febDays = 28;\n> }\n>\n>  Determine if the month requested has 31, 30 or 28 days and build\n> # our days array to match\n> if (exists($months31{$month})){\n>         while ($count <= 31) {\n>                 push @days, (sprintf '%02d', $count);\n>                 $count++;\n>         }\n> }elsif (exists($months30{$month})){\n>         while ($count <= 30) {\n>                 push @days, (sprintf '%02d', $count);\n>                 $count++;\n>         }\n> }else{\n>         while ($count <= $febDays) {\n>                 push @days, (sprintf '%02d', $count);\n>                 $count++;\n>         }\n> }\n>\n> That's just a keister-load of code just to create an array of 28/29, 30 or\n> 31 dates.\n\nYes.\n\nYou might want to think about this rather common snippet of code that pops\nup from time to time\n\nAssuming you input a month ( $mon ) like February as a 2, this may help\n========================================================\n    my @days_month = (31,28,31,30,31,30,31,31,30,31,30,31); # Number of\ndays in a month\n    if ($mon == 2 && ((!($year%4)) && (($year%100) || (!($year%400))))){\n           $days_month = 29;\n    }\n    else{\n           $days_month = $days_month[$mon-1];\n    }\n\n=========================================================\n\n\n\n\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "\"Mehmet Yavuz Selim Soyturk\" <mehmet.yavuz.selim@gmail.com>", "subject": "Re: [perl #42919] [BUG] and [PATCH] overriding 'invoke' requires current object to be explicitly passed", "body": "On 5/10/07, via RT Alek Storm  wrote:\n> # New Ticket Created by  \"Alek Storm\"\n> # Please include the string:  [perl #42919]\n> # in the subject line of all future correspondence about this issue.\n> # \n>\n>\n> Because PIR can't tell the difference between invoking an object PMC and\n> invoking a sub PMC, it doesn't generate a correct set_args when an object is\n> invoked.  Since the 'invoke' override is a method, it expects the current\n> object to be the first parameter.  There are currently two workarounds: pass\n> the current object explicitly as the first parameter, or don't declare\n> 'invoke' as a :method.  The first is inconvenient and unintuitive, and the\n> second means 'invoke' doesn't get access to its own object.\n>\n> Example code for bug:\n> .sub _ :main\n>   $P0 = newclass \"Foo\"\n>   $P1 = new \"Foo\"\n>   $P1(\"bar\")\n> .end\n>\n> .namespace [\"Foo\"]\n> .sub 'invoke' :method :vtable\n>   .param string bar\n>   say bar\n>   self.'baz'()\n> .end\n>\n> .sub 'baz' :method\n>   say \"baz\"\n> .end\n>\n> Output:\n> too few arguments passed (1) - 2 params expected\n> current instr.: 'parrot;Foo;invoke' pc 16 (/home/alek/test2.pir:8)\n> called from Sub '_' pc 11 (/home/alek/test2.pir:4)\n>\n> I've attached a patch that fixes this by grabbing the args signature inside\n> delegate.invoke() and unshifting an arg of type PARROT_ARG_PMC |\n> PARROT_ARG_OBJECT.  It also modifies src/inter_call.c to handle this by\n> setting the arg equal to interp->current_object, and enums.h to add the new\n> argument flag.  The tests in t/pmc/parrotobject.t have been changed to\n> include :method on the 'invoke' overrides, and to remove the test for\n> #41732, which is no longer applicable.\n>\n> --\n> Alek Storm\n\nShould we not be able to use an object that implements 'invoke' as a\nmethod of another object? There is some strange behaviour when I try\nto.\n\n\n.sub main :main\n    $P0 = newclass 'Func'\n    $P1 = newclass 'Obj'\n    $P2 = new 'Obj'\n    $P2.'some_method'()\n.end\n\n.namespace ['Func']\n\n.sub invoke :vtable :method\n    .param pmc an_arg\n\n    print 'vtable invoke with self = \"'\n    print self\n    print '\", arg = \"'\n    print an_arg\n    say '\"'\n.end\n\n.sub get_string :vtable\n    .return ('an instance of Func')\n.end\n\n.namespace ['Obj']\n\n.sub find_method :vtable :method\n    .param string meth_name\n\n    print 'find_method \"'\n    print meth_name\n    print '\" from \"'\n    print self\n    say '\" (***)'\n\n\n    .local pmc func\n    func = new 'Func'\n    .return (func)\n.end\n\n.sub get_string :vtable\n    .return ('an instance of Obj')\n.end\n\n=====\n\nI expect as output:\n\nfind_method \"some_method\" from \"an instance of Obj\" (***)\nvtable invoke with self = \"an instance of Func\", arg = \"an instance of Obj\"\n\nI don't know about the internals of parameter passing, it could be\nthat it's not possible.\n\n\nThe current output is:\n\nfind_method \"some_method\" from \"an instance of Obj\" (***)\nvtable invoke with self = \"an instance of Func\", arg = \"\" (***)\"\n\nSome strange things are happening with registers.\n\n-- \nMehmet\n\n"}
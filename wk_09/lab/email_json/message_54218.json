{"category": "ham", "to_address": "\"Mathew Snyder\" <theillien@yahoo.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: Proper class setup?", "body": "On 6/24/07, Mathew Snyder  wrote:\nsnip\n>\n> I pretty much have a very small idea of what is going on up there.\n>\nsnip\n\nAlright, lets walk through it piece by piece then.\n\n> > our %fields = (\n> >        _id       => 1,\n> >        _queue    => 1,\n> >        _owner    => 1,\n> >        _priority => 1,\n> >        _worked   => 1,\n> >        _timeLeft => 1,\n> >        _due      => 1,\n> >        _created  => 1,\n> >        _updated  => 1,\n> >        _severity => 1,\n> >        _ccl      => 1,\n> > );\n\nWe need to know which fields are valid a couple of times, so it is\nhelpful to move this information out into a class variable.\n\n> >\n> > #minimal new\n> > sub new {\n> >       my $class = shift;\n> >       my $self  = bless {}, $class;\n> >       $self->init(@_);\n> >       return $self;\n> > }\n> >\n> > #real object creation happens here\n> > sub init {\n> >        my $self   = shift;\n> >        my @fields = keys %fields;\n> >        @{$self}{@fields} = (undef) x @fields;\n> > }\n\nThis is an implementation of what Dr. Ruud was talking about.  The new\nmethod creates a new, blank object of the calling class and call's\nthat classes init to build it out.  The only tricky thing here is a\nuse of a hash slice and the list repetition operator to save some\ntyping.  The line\n\n@{$self}{@fields} = (undef) x @fields;\n\ncould also be written\n\nfor my $field (@fields) {\n    $self->{$field} = undef;\n}\n\n> > sub _validate_field {\n> >        my ($self, $k) = @_;\n> >        croak \"$k is not a valid field for \" . ref $self\n> >                unless $fields{\"_$k\"};\n> > }\n\nThis is a helper method (which is why it has an _ at the start of its\nname).  If the field name passed to it is not in %fields then it will\ncroak telling the user that he/she used an invalid field name.\n\n> > #Getter/setter method 1\n> > sub get {\n> >        my ($self, @k) = @_;\n> >        my @ret;\n> >        for my $k (@k) {\n> >                $self->_validate_field($k);\n> >                push @ret, $self->{\"_$k\"};\n> >        }\n> >        local $\" = ' ::: ';\n> >        return @ret\n> > }\n\nThis is an implementation of what I think Dr. Ruud was talking about\n(a getter method).  You can pass in one or more field names and the\nmethod will return the values associated with them in the calling\nobject.  I don't think there is anything tricky going on here, but\nthere is a piece of debug code that was accidentally left in that may\ncause confusion.  The line\n\nlocal $\" = ' ::: ';\n\ncan and should be removed.  It was just for testing purposes.\n\n> > sub set {\n> >        my $self = shift;\n> >        croak \"bad number of arguments\" unless @_ == 2 or @_ == 1;\n> >        if (@_ == 2) {\n> >                $self->_validate_field($_[0]);\n> >                return $self->{\"_$_[0]\"} = $_[1];\n> >        }\n> >        croak \"not a hash reference\" unless ref $_[0] eq 'HASH';\n> >        my $h = $_[0];\n> >        my @ret;\n> >        for my $k (keys %$h) {\n> >                $self->_validate_field($k);\n> >                push @ret, $self->{\"_$k\"} = $h->{$k};\n> >        }\n> >        return @ret;\n> > }\n\nAgain, this is an implementation of the setter that I think Dr. Ruud\nwas talking about.  It has two different forms.  The first takes two\narguments and the second takes only one.  In the first version (@_ ==\n2), the first argument is the field name to set and the second\nargument is the value to set.  The second version (@_ == 1) expects a\nhashref whose keys are the field names to set and whose values are the\nvalues to set.  I don't see anything tricky going on here, but please\nask about anything you don't understand\n\n> > #another form of setter/getter\n> >\n> > sub AUTOLOAD : lvalue {\n> >        my ($k) = $AUTOLOAD =~ /::(.*?)$/;\n> >        return if $k eq 'DESTROY';\n> >        my $self = shift;\n> >        $self->_validate_field($k);\n> >        $self->{\"_$k\"};\n> > }\n\nRemember how I said I didn't see anything tricky going on before?\nWell, this is tricky.  There are two separate tricky things going on\nhere: AUTOLOAD and lvalue subroutines.  In perldoc perlsub you will\nfind lots of information about AUTOLOAD, but here is the basic idea:\nif a subroutine named AUTOLOAD exists then it will be called whenever\nsomeone tries to call a subroutine in that package that does not\nexist.  So, if I say\n\n$obj->foo;\n\nand there is not a corresponding subroutine named foo in $obj's\npackage (or any of the packages in @ISA) then the subroutine AUTOLOAD\nwill be called.  The arguments to foo will be passed to AUTOLOAD and\nthe fully qualified name of the function/method that was called will\nbe placed in $AUTOLOAD (in this case OBJCLASS::foo).\n\nSo, the upshot of all of this is that we are catching the subroutine\nnames that match fields in our object and returning the value of that\nfield.\n\nThat takes care of the first part of the magic.  The second part is\nlvalue subroutines.  An lvalue is anything that is valid on the left\nside of an assignment (hence lvalue).  So, some common lvalues are\nscalars, arrays, hashes, array elements, and hash elements.\n\n$lvalue = 0;\n@lvalue = (1, 2, 3);\n%lvalue = (a => 1, b => 2, c => 3);\n$lvalue[3] = 4;\n$lvalue{d} = 4;\n\nAn odd case of something that is an lvalue is the trinary operator ?:\n\n($lvalue == 0 ? $lvalue[0] : $lvalue{a}) = 0;\n\nThis will set either $lvalue[0] or $lvalue{a} depending on what is in $lvalue.\n\nSubroutines are not lvalues by default, but there is experimental\nsupport for making them so.  If you set the attribute \"lvalue\" when\nyou create the subroutine and end the subroutine with a scalar value\n($self->{\"_$k\"}; in the code above) then that value is the target for\nthe assignment operator.  You can learn more in perldoc perlsub.\n\n> >\n> > sub printable {\n> >       my ($self) = @_;\n> >\n> >       # return Printable Report info\n> >       return $self->id . \" \" . $self->queue . \"\\n\";\n> > }\n> >\n> > 1;\n\nThis function is too mundane to explain.\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Brad Baxter <baxter.brad@gmail.com>", "subject": "Re: Passing arguments to subroutine", "body": "On Jun 1, 9:58 am, chas.ow...@gmail.com (Chas Owens) wrote:\n> On 31 May 2007 10:58:54 -0700, Paul Lalli  wrote:\n>\n> > On May 31, 10:15 am, yit...@users.sourceforge.net (Yitzle) wrote:\n> > > I suspect one of the tutorials that Google or Perl.org points to has\n> > > something in it that needs correcting.\n>\n> > Actually, it's an unfortunate truth that up until Edition 3, the Llama\n> > itself recommended that you use the & to call subroutines...\n>\n> > Paul Lalli\n>\n> Alright, I am a pedantic jerk, but this struck as wrong.  I learned on\n> 2nd edition Llama and Camel, so I dug up my old copies.  Learning Perl\n> 2nd Edition says on page 92\n>\n>     The subname is th name of the subroutine, which is any name like\n>     the names we've has for scalar variables, arrays, and hashes.  Once\n>     again, these come from a different namespace, so you can have a\n>     scalar variable $fred, an array @fred, a hash %fred, and now a\n>     subroutine fred*.\n>\n>     * Technically, the subroutine's name is &fred, but you seldom need\n> to call it that.\n>\n> Also, on page 93 it says\n>\n>     Invoking a User Function\n>     You invoke a subroutine from within any expression by following\n> the subroutine\n>     name with parentheses, as in:\n>\n>         say_hello();          # a simple expression\n>         $a = 3 + say_hello(); # part of a larger expression\n>         for ($x = start_value(); $x < end_value(); $x += increment()) {\n>             ...\n>         }                     # invoke three subroutines to define values\n>\n> I checked Programming Perl (2nd Edition), just in case you meant the\n> Camel instead of the Llama, and it appears* to talk about subroutines\n> in the same was as perlsub currently does with no specific\n> recommendations about whether to use & or not (it just explains all of\n> the options and their side effects).\n>\n> The Llama (2nd edition) was published in 1997.  That was ten years\n> ago.  You can see why I want to know where these people who are new to\n> Perl are being told to use & as part of the subroutine name.  I assume\n> there are some old tutorials out there (things live forever on the\n> Internet) and they are reading bad, old code at work.\n>\n> * there may be a recommendation somewhere, but I couldn't find one in\n> my cursory glance through it.\n\nOne thing I wonder about is that I see anonymous subs called\nas &$anon or &$anon() in various places in the docs, e.g., perlipc,\nperlmod, perlmodlib, perlref, -q What's a closure, -q How can I\npass/return a Function.  perl5004delta says:\n\nNew and changed syntax\n\n$coderef->(PARAMS)\n    A subroutine reference may now be suffixed with an\n    arrow and a (possibly empty) parameter list.  This\n    syntax denotes a call of the referenced subroutine,\n    with the given parameters (if any).\n\n    This new syntax follows the pattern of\n    \"$hashref->{FOO}\" and \"$aryref->[$foo]\": You may now\n    write \"&$subref($foo)\" as \"$subref->($foo)\".  All\n    these arrow terms may be chained; thus,\n    \"&{$table->{FOO}}($bar)\" may now be written\n    \"$table->{FOO}->($bar)\".\n\nso the $anon->() syntax as been around since then.\n\nApparently, unlike with named subs, both &$anon()\nand $anon->() ignore prototypes.  However, like named\nsubs &$anon gets the caller's @_.  But that is almost\nnever mentioned afaict at the places in the docs where\nthe &$anon style call is used.\n\nThis isn't intended to be a criticism; I just wonder if some\nsmall number of newcomers reading the docs might\nbe picking up calling habits from this.\n\n--\nBrad\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
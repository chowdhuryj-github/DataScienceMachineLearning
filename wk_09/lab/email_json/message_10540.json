{"category": "ham", "to_address": "\"Lukas Biewald\" <lukeb@powerset.com>, <r-help@stat.math.ethz.ch>", "from_address": "\"Steven McKinney\" <smckinney@bccrc.ca>", "subject": "Re: [R] Computing an ordering on subsets of a data frame", "body": "Hi Lukas,\n\nUsing by() or its cousins tapply() etc. is tricky,\nas you need to properly merge results back into X.\n\nYou can do that by adding a key ID variable to X, \nand carrying along that key ID variable in calls\nto by() etc., though I haven't tested out a method.\n\nYou can also create a new column in X to hold the\nresults, and then sort the subsections of X in a\nfor() loop.\n\n> X <- data.frame(A = c(1,1,1,2,2,2,3,3,3), B = c(2,3,4,3,1,1,2,1,3))\n> X\n  A B\n1 1 2\n2 1 3\n3 1 4\n4 2 3\n5 2 1\n6 2 1\n7 3 2\n8 3 1\n9 3 3\n> \n> X$C <- rep(as.numeric(NA), nrow(X))\n> \n> sortLevels <- unique(X$A)\n> \n> for(i in seq(along = sortLevels)) {\n+   sortIdxp <- X$A == sortLevels[i]\n+   X$C[sortIdxp] <- rank(X$B[sortIdxp], ties.method = \"random\")\n+ }\n> X\n  A B C\n1 1 2 1\n2 1 3 2\n3 1 4 3\n4 2 3 3\n5 2 1 1\n6 2 1 2\n7 3 2 2\n8 3 1 1\n9 3 3 3\n> \n\nMerging results back in after using\ntapply() or by() is harder if your\ndata frame is in random order, but the\nfor() loop approach with indexing\nstill works fine.\n\n> set.seed(123)\n> Y <- X[sample(9), ]\n> Y\n  A B C\n3 1 4 3\n7 3 2 2\n9 3 3 3\n6 2 1 2\n5 2 1 1\n1 1 2 1\n2 1 3 2\n8 3 1 1\n4 2 3 3\n> Y$C <- rep(as.numeric(NA), nrow(Y))\n> \n> sortLevels <- unique(Y$A)\n## You can also use levels() instead of unique() if Y$A is a factor.\n> \n> for(i in seq(along = sortLevels)) {\n+   sortIdxp <- Y$A == sortLevels[i]\n+   Y$C[sortIdxp] <- rank(Y$B[sortIdxp], ties.method = \"random\")\n+ }\n> Y\n  A B C\n3 1 4 3\n7 3 2 2\n9 3 3 3\n6 2 1 2\n5 2 1 1\n1 1 2 1\n2 1 3 2\n8 3 1 1\n4 2 3 3\n> oY <- order(Y$A)\n> Y[oY,]\n  A B C\n3 1 4 3\n1 1 2 1\n2 1 3 2\n6 2 1 2\n5 2 1 1\n4 2 3 3\n7 3 2 2\n9 3 3 3\n8 3 1 1\n>\n\n \nHTH\n \n\nSteven McKinney\n\nStatistician\nMolecular Oncology and Breast Cancer Program\nBritish Columbia Cancer Research Centre\n\nemail: smckinney@bccrc.ca\ntel: 604-675-8000 x7561\n\nBCCRC\nMolecular Oncology\n675 West 10th Ave, Floor 4\nVancouver B.C. \nV5Z 1L3\n\nCanada\n\n\n \n\n \n\n\n> -----Original Message-----\n> From: r-help-bounces@stat.math.ethz.ch [mailto:r-help-\n> bounces@stat.math.ethz.ch] On Behalf Of Lukas Biewald\n> Sent: Wednesday, April 18, 2007 2:49 PM\n> To: r-help@stat.math.ethz.ch\n> Subject: [R] Computing an ordering on subsets of a data frame\n> \n> If I have a data frame X that looks like this:\n> \n> A B\n> - -\n> 1 2\n> 1 3\n> 1 4\n> 2 3\n> 2 1\n> 2 1\n> 3 2\n> 3 1\n> 3 3\n> \n> and I want to make another column which has the rank of B computed\n> separately for each value of A.\n> \n> I.e. something like:\n> \n> A B C\n> - - -\n> 1 2 1\n> 1 3 2\n> 1 4 3\n> 2 3 3\n> 2 1 1\n> 2 1 2\n> 3 2 2\n> 3 1 1\n> 3 3 3\n> \n> by(X, X[,1], function(x) { rank(x[,1], ties.method=\"random\") } )\nalmost\n> seems to work, but the data is not in a frame, and I can't figure out\nhow\n> to\n> merge it back into X properly.\n> \n> Thanks,\n> Lukas\n> \n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-\n> guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
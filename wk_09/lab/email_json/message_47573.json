{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: Generalizing ?? !!", "body": "On Wed, Jun 13, 2007 at 05:08:34PM -0400, Charles Bailey wrote:\n: I'm concerned that the relevant precedent isn't just Perl5.  The ?: spelling\n: of the ternary is pretty deeply embedded in programming languages -- I'm\n: hard pressed to think of a widely used language in the past 10-15 years that\n: spells it differently (though that may say more about my experience than the\n: universe of \"widely used\" languages).\n\nIt's really just the C-based languages.  Lots of popular languages don't\neven give you a conditional operator, and seem to get by okay without it.\n\n: Put more practically, I don't think\n: the issue is just moving people forward from Perl5; we need to think about\n: whether it'll help or hinder users moving back and forth among several\n: languages, or bringing familiarity with other languages to the process of\n: learning Perl6.\n\nThat had to be one of the main design considerations for Perl 1, but now\nwe've got the \"design capital\" to fix some things.  The Perl 6 mandate\nis not universal compatibility (which Perl 5 still represents in a\nway), but the chance to fix everything that needs fixing.  And this\none of the things I think C got wrong.  Perl 6 is looking more for\nsemantic and pragmatic compatibility than syntactic compatibility.\nWe won't have to teach anyone the *idea* of a conditional operator,\njust send them off to look for the green bikeshed.\n\n: Granting that Perl6 is a new language, I think there's still a role for\n: deferring to existing usage.\n\nCertainly, all other things being equal (give or take), we'll go\nfor something familiar.  And I'll say we even put a thumb on the\nscales in favor of what Perl 5 programmers expect, now and again.\nBut sometimes it's still right to break something, and reduce the\nlevel of compatibility concern down to just making sure they get\na good error message if they fall into old habits.  In that case\nit means making something different enough that the old one can be\nrecognized and dealt with.  At some point you put the new wine into\nnew wine skins and throw the old ones out.\n\n: If it's technically impossible, or would\n: prevent Perl6 from delivering some other important benefit (e.g. would\n: require a lot of special-casing elsewhere), then it's worth making a\n: change.  But I'm not sure pure orthogonality, visual impact, or similar\n: considerations, adequate though they are for deciding how to implement a new\n: operation, are sufficient cause to trade common usage for a novel one.\n\nIt's not really that common, compared to, say, assignment, which you'll note\nwe've pretty much left untouched, except for relaxing the requirement for\nparens on the right side of list assignment.\n\n: There's also the less important social problem that Perl6 has\n: already spent a lot of goodwill in its long gestation.  I think it can be\n: earned back by doing things well, because they've been thought through\n: carefully, but the language will be viewed with some initial skepticism.\n\nI would like to think that \"doing things well\" is exactly the approach\nwe're taking.  We're not optimizing for the past, but for the future.\nThis might rehuffmanization of everything might influence more\ngenerations of computer language than we can possibly imagine.\n\n: That may be eased by sprinkling familiar ideas amongst the novel.\n\nWhich we do quite liberally...  :)\n\n: Sure,\n: it's still got +*-/, but would ?: hurt?  At a minimum, is there a strong\n: enough reason for changing it that it will be difficult for skeptics to\n: describe it as merely another ideological change?\n\nCertainly.  The main problem is not so much that ? is ambiguous,\nbut that the : is.  It's somewhat ambiguous with labels\n(though arguably those don't generally occur in the same context).\nThe killer is that it's formally ambiguous with the colon that is\nused to indicate the list of an unparenthesized method call (in either\ndirect or indirect form).  That colon occurs where an infix is expected.\nIt's also ambiguous with adverbs, which can occur in that position\nwhen modifying a preceding operator, as in 1..100:by(3).  The fact that\n?: tends to be used as one term in an expression means that things tend\nto be written compactly without spacing, which amplifies that ambiguity.\n\nOn the plus side, the fact that it's the : and not the ? that is most\nproblematic means that (unless the user adds their own infix:) it's\npretty easy to recognize the old usage and give a good error message at\ncompile time.  And I think that's all that's really necessary here.\nIt's the differences that silently produce an unexpected result\nthat we'll really need to worry about in terms of user satisfaction\nand FAQ minimization.  That's also why there's no infix:<.>, so at\nleast we can catch attempts to concatenate strings if they use spaces\naround it.  For the rest, the fact that \"foo\".\"bar\" is unlikely to a\nfind a .bar method on strings will have to suffice.  Of course, if the\n\"method\" is nonalphanumeric, we're even less likely to find the method.\nAnd in the alphanumeric case, we can probably also alert on the fact\nthat writing .\"bar\" is in fact a useless use of quotes.\n\nThese are the everyday worries of a language designer.  Well, me anyway...\n\nLarry\n\n"}
{"category": "ham", "to_address": "samba-technical@samba.org", "from_address": "Michael Cohen <michael.cohen@netspeed.com.au>", "subject": "talloc_reference bug?", "body": "Hi there,\n  The following example shows talloc_reference behaviour which perhaps needs to\n  be better documented?\n\n\n#include \n#include \n#include \n#include \n\n#include \"talloc.h\"\n\n// This is supposed to represent some other context which might be\n// owned by something else\nchar *g_context;\n\n// This string is supposed to hold a reference to a talloc string\nchar *some_string;\n\n// This bit of code tries to take ownership of the string by adding a reference to it.\nvoid process_string(char * string) {\n  // We want to keep hold of the string - so we take a reference on it:\n  talloc_reference(g_context, string);\n\n  some_string = string;\n};\n\n// This function tries to use the reference taken above. When done it tries to free it.\nvoid do_something() {\n  // We expect some_string to be set and valid here (because we took a\n  // reference to it before).\n\n  printf(\"string is %s\\n\", some_string);\n\n  // Ok we are dont with it now...\n  talloc_free(some_string);\n};\n\nint main() {\n  char *root;\n  char *string;\n \n  talloc_enable_leak_report_full();\n\n  g_context = talloc_named_const(NULL, 1, \"foreign context\");\n\n  // This is a provider of a string - the string is provided to the consumer\n  // which does what they like with it.\n  {\n  root = talloc_named_const(NULL, 1, \"root context\");\n\n  // We just create a string:\n  string = talloc_strdup(root, \"hi there\");\n\n  // Now we simulate a processing of the string:\n  process_string(string);\n\n  // Now we free the string:\n  talloc_free(string);\n\n  // This function is finished:\n  talloc_free(root);\n  };\n\n  \n  // Now we call some other bit of code:\n  do_something();\n\n  return 0;\n};\n\n\nThe main issue is that the caller prepares a talloc context and provides it to\na client, and then frees the context after use. The client wants to retain a\nreference to it, but in fact when the provider calls talloc_free(string) this\nreference is being removed _instead_ of string being freed. When the other part\nof the code wants to use its referenced string (and tries to free it when done)\nthis program will abort because that reference is no longer valid.\n\nThe solution is for the provider to use talloc_unlink() instead of talloc free\nto ensure that the reference is maintained - but that kind of instroduces lots\nof coupling between providers and consumers. i.e. the provider needs to know\nthat references will be used in the consumer to use talloc_unlink.\n\nMichael.\n\n"}
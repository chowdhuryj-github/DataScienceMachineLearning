{"category": "ham", "to_address": "\"perl6-language@perl.org\" <perl6-language@perl.org>", "from_address": "Damian Conway <damian@conway.org>", "subject": "Referring to source code within Perldoc: the new A<> code", "body": "Here's the first draft (documented in Pod 6, of course ;-).\n\nFeedback and suggestions are most welcome.\n\n(But please don't bother explaining to me this feature won't suffice\n  as the high-level automatic code-to-documentation mechanism that Markov\n  has been championing. I promise that I'm very well aware of that fact.\n  This new formatting code isn't intended to replace such advanced\n  autodocumentation tools...only to make such tools unnecessary in the\n  simple cases and--in the non-simple cases--to make such tools easier to\n  create, by providing a symbolic intermediate-level representation for\n  interwoven code and Pod.)\n\nDamian\n\n-----cut----------cut----------cut----------cut----------cut-----\n\n=head3 Ambient aliases\n\nThe C> formatting code specifies an B.\nThis is like a L, except\nthat the text that is inserted to replace the C> formatting code is\nsome portion of the L\nof the current document, rather than the entire contents of some\nexternal document.\n\nHence, the C> code makes it possible to incorporate pieces of\nambient text (typically source code) into Pod documentation.\nSpecifically, the C> code is replaced by searching backwards through\nall preceding non-Pod parts of the document, to locate the nearest prior\nsubstring that matches the contents of the C> code.\n\nThe contents of an C> code can specify a back-reference of this type\nin one of two ways:\n\n=item  as a I, or\n\n=item  as a I.\n\nBy default, C> aliases are \"keyword oriented\". That is, the contents\nof an C> block are treated as a keyword or prefix that introduces\nthe desired text. That text is located by searching backwards from the\nlocation of the C> code, to find the nearest preceding instance of\nthe specified prefix in any previous ambient block. The text that is\nthen used to replace the C> is the first \"symbol\" following that\nlocated prefix. In this context, a \"symbol\" is defined as a sequence of\nnon-whitespace characters terminated by a transition from an identifier\ncharacter to a non-identifier character.\n\nFor example, in the following:\n\n=begin code\n     class Pet {\n\n         has $name;\n\n     =DESCRIPTION\n     The class A provides a A attribute.\n=end code\n\nthe C> formatting code would be replaced by \"Pet\", since that\nis the sequence of non-whitespace characters that immediately follows\n\"class\" in the preceding ambient source code. Likewise, the C>\nformatting code would be replaced by \"$name\", because that is the\nlongest sequence of non-whitespace characters that follows a \"has\" and\nterminates in an identifier-to-nonidentifier boundary.\n\n=begin para\n=config C<> :allow\nIn other words, any formatting code of the form C>>\nis replaced by the substring of the nearest preceding\nambient block that matches the pattern:\n=end para\n\n=for code :allow\n     /  .*  R \\s*  <( \\S*? \\w )>  [\\W | $] /\n\nThis default is designed to work well for the commonest kind of\nback-reference in ambient text: a reference to a code construct that\nwas defined using a prefix keyword and whose name ends in an identifier.\n\nThe second and more general way of specifying an alias is to specify\nboth a prefix and a postfix delimiter for the replacement text. If the\ncontents of an C> formatting code include a range marker (C<..>),\nthe sequence before the C<..> is treated as the left delimiter of the\nreplacement text, and the sequence after the C<..> is the right\ndelimiter. In this case, there are no other constraints on the\nreplacement text. In particular, it may contain any number of non-\nidentifier or whitespace characters. For example:\n\n     class Pet {\n\n         method eat(Food $meal) {...}\n\n     =for DESCRIPTION\n     The A() method has the following argument list: A<(..)>\n\nThis would be interpreted as:\n\n     The eat() method has the following argument list: Food $meal\n\nbecause the C> specifies an alias to the closest preceding ambient\ntext that is left-delimited by a '(' and right-delimited by a ')'.\n\nTo specify an alias in which the sequence C<..> is itself\na left- or right-delimiter (rather than the separator between the two),\nuse a C> code:\n\n     constant @range = 0..99;\n\n     =para\n     The maximum value is A..;>\n\n\n=head4 Explicit aliasing\n\nThe replacement strings for C> formatting codes are normally\nspecified implicitly, by the closest preceding ambient text that matches\nthe contents of the C> code.\n\nHowever, it is possible to override this behaviour and create an\nI alias, using the C<=alias> directive:\n\n     class Agent {...}\n     =alias component Agent\n\n     class Transaction is Activity {\n\n     =DESCRIPTION\n     The A class represents a transaction activity between two\n     A objects.\n\nIn the preceding example, C> is a normal \"keyword\" alias\n(which would be replaced by the closest preceding prefixed match:\n\"Transaction\"). However, C> is a defined alias\n(which would be replaced by the explicitly specified text: \"Agent\").\n\nEach back-reference name defined by an <=alias> directive is lexically\nscoped within the block structure of the surrounding Pod. To create\n\"global\" aliases, define them at the start of the Pod document, at the\noutermost block level.\n\nExplicitly defined aliases always override normal prefix or delimited\naliases, and thereby allow you to refer to ambient constructs that would\notherwise be inaccessible to an implicit back-reference.\n\nFor example, within the C block of the previous example,\nthe Agent class couldn't be referred to as C>, since the\nintervening Transaction class \"hides\" it from the look-behind matching\nof implicit back-reference mechanism. But the C<=alias> command allows\nthe name of the earlier class to be associated with a distinct symbolic\nalias (i.e. \"component\"), which then allows it to be referred to\nunambiguously, regardless of other intervening code.\n\nAnother way of thinking of this is that explicitly defined aliases\nchange the normal C> substitution behaviour from being determined\nI by the location of the C> code, to being determined\nI by the alias name itself.\n\nAn C<=alias> directive expects two arguments:\n\n=item The name of the new alias\n\n=item The text with which that new alias is to be replaced\n\nThe alias name may be any sequence of non-whitespace characters. The\nremainder of the line (ignoring the whitespace immediately after the\nname) is treated as the replacement text. For example:\n\n     =alias Smith  Jones\n     =alias G&T    green tea\n     =alias #*@%!  Gosh darn\n\n     =para\n     A<#*@%!> it, A, you spilled my A!\n\nis equivalent to:\n\n     =para\n     Gosh darn it, Jones, you spilled my green tea!\n\nTo specify an alias name that includes a whitespace, or a replacement\ntext with surrounding whitespace, use a C> formatting code:\n\n     =alias slow            V< >...slow\n     =alias V   s-l-o-w\n     =alias V   V<  >s  l  o  wV<  >\n\n     =para\n     The service was not merely A, or even A.\n     It was A\n\nAlthough only the C> code is significant within the name of an alias,\nyou can use I formatting code(s) within the replacement text:\n\n     =alias V   S<  s  l  o  w  >\n     =alias V   B<...s...l...o...w...>\n\nIn particular, you can use an C> code in the replacement text of an\nC<=alias>. This is useful to preserve the abstract relationship between\nambient code and Pod documentation. For example, in the earlier Agent\nexample, instead of:\n\n     class Agent {...}\n     =alias component Agent\n\nthe alias could have been defined:\n\n     class Agent {...}\n     =alias component A\n\nso that the class name did not have to be repeated as part of the alias.\nThis approach has the important benefit that the alias would not have\nto be modified in any way if the name of the Agent class were\nsubsequently changed:\n\n     class Operative {...}\n     =alias component A\n\nLikewise, in the earlier range example, it would have been cleaner and\nmore maintainable to write:\n\n     constant @range = 0..99;\n     =alias max  A..;>\n\n     =para\n     The maximum value is A\n\nExplicit aliases also provide a way to \"retarget\" implicit back-references\nif they are later invalidated by keyword changes in the\nsource code. For example, given the following documented code:\n\n=begin code\n     class Transaction {\n\n         my Int $trans_counter;\n\n     =DESCRIPTION\n     The A variable is used to track the total number of\n     transactions active at any one time. The value of A is\n     incremented by A's C submethod and decremented by\n     the A destructor.\n=end code\n\nIf a subsequent redesign requires that the class be changed to a role,\nand the lexical counter converted to a state variable, then every\ncorresponding C> code in the documentation would have to be\naltered too:\n\n=begin code\n     role Transaction {\n\n         state Int $trans_counter;\n\n     =DESCRIPTION\n     The A variable is used to track the total number of\n     transactions active at any one time. The value of A is\n     incremented by A's C submethod and decremented by\n     the A destructor.\n=end code\n\nA less onerous and error-prone solution would be to leave the original\nC> codes \"as is\", and insert aliases to override the default prefix\nback-matching:\n\n=begin code\n     role Transaction {\n     =alias class  A\n\n         state Int $trans_counter;\n     =alias V  A\n\n     =DESCRIPTION\n     The A variable is used to track the total number of transactions\n     active at any one time. The value of A is incremented by the\n     A C submethod and decremented by the A destructor.\n=end code\n\nNote that C<=alias> is a fundamental Perldoc directive, like C<=begin>\nor C<=for>; it is I an instance of an\nL. Hence there is no paragraph\nor delimited form of the C<=encoding> directive (just as there is no\nparagraph or delimited form of C<=begin>).\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 134: start using ctdb_ltdb_lock_fetch_requeue() in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 134\nrevision-id: tridge@samba.org-20070417065403-79322cc42ed74b71\nparent: tridge@samba.org-20070417063528-1d3fb576e31269f0\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-04-17 16:54:03 +1000\nmessage:\n  start using ctdb_ltdb_lock_fetch_requeue()\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  tests/fetch.sh                 fetch.sh-20070405031756-lomzqpjyqg3xd1kv-1\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-04-17 06:35:28 +0000\n+++ b/common/ctdb_call.c\t2007-04-17 06:54:03 +0000\n@@ -270,11 +270,15 @@\n \t   we don't need to update the record header now */\n \tif (c->dmaster != ctdb->vnn) {\n \t\t/* fetch the current record */\n-\t\tret = ctdb_ltdb_fetch(ctdb_db, key, &header, hdr, &data2);\n-\t\tif (ret != 0) {\n+\t\tret = ctdb_ltdb_lock_fetch_requeue(ctdb_db, key, &header, hdr, &data2);\n+\t\tif (ret == -1) {\n \t\t\tctdb_fatal(ctdb, \"ctdb_req_dmaster failed to fetch record\");\n \t\t\treturn;\n \t\t}\n+\t\tif (ret == -2) {\n+\t\t\tprintf(\"deferring ctdb_request_dmaster\\n\");\n+\t\t\treturn;\n+\t\t}\n \t\t\n \t\t/* its a protocol error if the sending node is not the current dmaster */\n \t\tif (header.dmaster != hdr->srcnode) {\n@@ -283,7 +287,9 @@\n \t\t}\n \n \t\theader.dmaster = c->dmaster;\n-\t\tif (ctdb_ltdb_store(ctdb_db, key, &header, data) != 0) {\n+\t\tret = ctdb_ltdb_store(ctdb_db, key, &header, data);\n+\t\tctdb_ltdb_unlock(ctdb_db, key);\n+\t\tif (ret != 0) {\n \t\t\tctdb_fatal(ctdb, \"ctdb_req_dmaster unable to update dmaster\");\n \t\t\treturn;\n \t\t}\n@@ -345,17 +351,22 @@\n \t   fetches the record data (if any), thus avoiding a 2nd fetch of the data \n \t   if the call will be answered locally */\n \n-\tret = ctdb_ltdb_fetch(ctdb_db, call.key, &header, hdr, &data);\n-\tif (ret != 0) {\n+\tret = ctdb_ltdb_lock_fetch_requeue(ctdb_db, call.key, &header, hdr, &data);\n+\tif (ret == -1) {\n \t\tctdb_send_error(ctdb, hdr, ret, \"ltdb fetch failed in ctdb_request_call\");\n \t\treturn;\n \t}\n+\tif (ret == -2) {\n+\t\tprintf(\"deferred ctdb_request_call\\n\");\n+\t\treturn;\n+\t}\n \n \t/* if we are not the dmaster, then send a redirect to the\n \t   requesting node */\n \tif (header.dmaster != ctdb->vnn) {\n \t\tctdb_call_send_redirect(ctdb, c, &header);\n \t\ttalloc_free(data.dptr);\n+\t\tctdb_ltdb_unlock(ctdb_db, call.key);\n \t\treturn;\n \t}\n \n@@ -368,11 +379,14 @@\n \t   || c->flags&CTDB_IMMEDIATE_MIGRATION ) {\n \t\tctdb_call_send_dmaster(ctdb_db, c, &header, &call.key, &data);\n \t\ttalloc_free(data.dptr);\n+\t\tctdb_ltdb_unlock(ctdb_db, call.key);\n \t\treturn;\n \t}\n \n \tctdb_call_local(ctdb_db, &call, &header, &data, c->hdr.srcnode);\n \n+\tctdb_ltdb_unlock(ctdb_db, call.key);\n+\n \tlen = offsetof(struct ctdb_reply_call, data) + call.reply_data.dsize;\n \tr = ctdb->methods->allocate_pkt(ctdb, len);\n \tCTDB_NO_MEMORY_FATAL(ctdb, r);\n\n=== modified file 'tests/fetch.sh'\n--- a/tests/fetch.sh\t2007-04-12 06:49:37 +0000\n+++ b/tests/fetch.sh\t2007-04-17 06:54:03 +0000\n@@ -7,3 +7,11 @@\n bin/ctdb_fetch --nlist tests/nodes.txt --listen 127.0.0.1:9001 $* \n \n killall -q ctdb_fetch\n+\n+echo \"Trying 4 nodes\"\n+bin/ctdb_fetch --nlist tests/4nodes.txt --listen 127.0.0.4:9001 $* &\n+bin/ctdb_fetch --nlist tests/4nodes.txt --listen 127.0.0.3:9001 $* &\n+bin/ctdb_fetch --nlist tests/4nodes.txt --listen 127.0.0.2:9001 $* &\n+bin/ctdb_fetch --nlist tests/4nodes.txt --listen 127.0.0.1:9001 $* \n+\n+killall -q ctdb_fetch\n\n"}
{"category": "ham", "to_address": "Jonathan Worthington <jonathan@jnthn.net>", "from_address": "chromatic <chromatic@wgz.org>", "subject": "Re: [perl #42408] Re: [PATCH] refactor vtable overriding, delegate.c generation", "body": "On Monday 23 April 2007 09:07, Jonathan Worthington wrote:\n\n> chromatic wrote:\n> > Jonathan, can you help us figure out why deleting these lines out of\n> > init() fixes the problem?  Are they vestigial?\n> >\n> > \t    /* turn on marking of the class_data array */\n> > \t    PObj_data_is_PMC_array_SET(self);\n>\n> I saw those before and thought they were very suspect; I only gave SMOP\n> a cursory glance for inspiration before digging into PDD15\n> implementation though. When you set this flag, I believe the GC assumes\n> the data pointer of the PMC points to a chunk of memory containing an\n> array of pointers. It then looks at the int in the pmc_ext structure to\n> say how many pointers there are. That way you don't have to write your\n> own mark routine for some aggregate types. I may have the specific\n> details wrong, but it's something like that.\n>\n> I think in the case of SMOP, the usage of it is bogus/wrong. I don't\n> remember the int in pmc_ext being set, and assuming that everything in a\n> struct is and always will be contiguous non-NULL PMCs or STRING pointers\n> is probably a fast way to segfaults when you change something about the\n> struct in the future, or if it's uninitialized.\n\nThanks, that matches my reading of the code, too.\n\nI removed this dubious code in r18305 and applied Alek's original patch as \nr18306.\n\nThanks, everyone!\n\n-- c\n\n"}
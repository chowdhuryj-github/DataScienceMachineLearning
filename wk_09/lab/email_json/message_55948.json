{"category": "ham", "to_address": "\"Mark Wardle\" <mark@wardle.org>", "from_address": "\"jim holtman\" <jholtman@gmail.com>", "subject": "Re: [R] Aggregation of data frame with calculations of proportions", "body": "I think something like this will do it for you.\n\n\nset.seed(1)\nn <- 10\nx <- data.frame(a=sample(1:100,n), b=sample(1:100,n),d=sample(1:100,n))\nx$a[c(1,5)] <- NA\nx$b[c(7,6,4)] <- NA\nx$d[c(5,8)] <- NA\nx$total <- rowSums(x, na.rm=TRUE)\nx$type <- sample(1:3, n, replace=TRUE)\nby(x, list(x$type), function(z){\n    apply(z[,1:3], 2, calc.prevalence, total=z$total)\n})\n\n\n\n\n\nOn 6/26/07, Mark Wardle  wrote:\n>\n> Dear all,\n>\n> I have been stuck on this problem, am rather struggling and would\n> appreciate some advice if anyone can help. I apologise if this is a\n> bit long-winded, but I've tried to limit it to the bare essentials,\n> but don't know how to make it more generic!\n>\n> I have some slightly odd real world data that I'm looking at\n> representing number of positive diagnoses for different diseases, plus\n> the number tested. It's all in a data frame:\n>\n> This should all be directly runnable with cut+paste:\n>\n> sp = read.csv('http://www.wardle.org/sca-prev.csv', header=T)[,c(-1,-2)]\n>\n> str(sp)\n>\n> #'data.frame':   46 obs. of  19 variables:\n> # $ sca1        : int  5 1 NA NA 48 1 NA 17 21 4 ...\n> # $ sca2        : int  7 3 NA NA 53 1 NA NA 7 7 ...\n> # $ sca3        : int  3 1 NA NA 2 0 NA 29 0 0 ...\n> # $ sca6        : int  1 0 NA NA 2 2 NA NA 0 0 ...\n> # $ sca7        : int  NA NA NA NA 2 0 NA NA 1 0 ...\n> # $ sca8        : int  NA NA NA NA 2 1 NA NA NA NA ...\n> # $ sca10       : int  NA NA NA NA 0 0 NA NA NA NA ...\n> # $ sca12       : int  NA NA NA NA 0 0 NA NA NA NA ...\n> # $ sca17       : int  NA NA NA NA 2 1 NA NA NA NA ...\n> # $ frda        : int  NA NA NA NA 0 1 NA NA NA NA ...\n> # $ drpla       : int  NA NA 1 1 1 1 NA NA 0 0 ...\n> # $ fmr1        : int  NA NA NA NA NA NA 6 NA NA NA ...\n> # $ diagnosis   : int  16 5 1 1 112 8 6 46 29 11 ...\n> # $ unexplained : int  10 26 415 392 71 35 137 51 0 11 ...\n> # $ total       : int  26 31 416 393 183 43 143 97 29 22 ...\n> # $ patient.type: Factor w/ 8 levels \"\",\"ADCA\",\"ADCA I\",..: 2 5 2 5 2\n> 4 8 3 2 2 ...\n> # $ age.group   : Factor w/ 5 levels \"\",\"<40\",\">40\",..: 5 5 5 5 1 1 4 5 1\n> 1 ...\n> # $ country     : Factor w/ 19 levels \"\",\"Australia\",..: 7 7 1 1 8 8 8 1 8\n> 8 ...\n> # $ region      : Factor w/ 6 levels \"Americas\",\"Asia\",..: 4 4 3 3 3 3\n> 3 3 3 3 ...\n>\n> # It is straightforward to aggregate data:\n>\n> smart.sum <- function(x,...) {\n>        if (is.numeric(x)) return(sum(x, na.rm=T))\n>        else return(paste(unique(x), collapse=\", \"))            # for\n> natbib citations\n> }\n> sp.ag1 = aggregate(sp, by=list(region=sp$region), FUN=smart.sum)\n> sp.ag2 = aggregate(sp, by=list(patient.type=sp$patient.type), FUN=\n> smart.sum)\n> print(sp.ag1)\n>\n> # and even to calculate crude percentages\n> spp = sp.ag1\n> spp[,2:15] = sapply(spp[,2:15], FUN=function(x) { round(x*100/ spp$total,\n> 1)})\n>\n> # *BUT*, the problem is that this is underestimating the true\n> proportions, because some of the data is NA. This means the diagnosis\n> was not tested rather than not found (which would be zero).\n>\n> # What I want to do is calculate a true proportion, with the number\n> found divided by the number tested.\n> # I have managed to do this:\n>\n> # calculates true proportion by only including values in the\n> denominator that have non-NAs in the numerator\n> # x= vector of numbers\n> # total = vector of numbers\n> calc.prevalence <- function(x, total) {\n>        sum.x = sum(x, na.rm=T)         # calculate numerator\n>        sum.y = sum(total[!is.na(x)])           # calculate denominator\n>        return(sum.x/sum.y)\n> }\n>\n> correct.prevalence <- calc.prevalence(sp$drpla, sp$total)\n> incorrect.prevalence <- sum(sp$drpla, na.rm=T) / sum(sp$total, na.rm=T)\n> print(correct.prevalence)\n> print(incorrect.prevalence)\n>\n>\n> This is easy to apply to one column in one table, but I'm finding it\n> very difficult to do when I manipulate the data using the aggregate()\n> function above.\n>\n> Is there a straightforward way, while aggregating columns by a\n> variable (number of) factors, in generating the sum of a column and\n> dividing by the sum of another column, only including data from the\n> second column when the first column is not NA. AND is it possible to\n> do that to all of the relevant columns (3:15)?\n>\n> You won't believe how many iterations of by(), aggregate(), tapply(),\n> apply() and (finally) \"for loops\" I have tried with no success. The\n> best partial solution involved a combination of by() calling a\n> function calling aggregate(), but I can't parse the data returned. I'm\n> sure I am missing something! Can anyone help?\n>\n> Many (many many) thanks!\n>\n> Best wishes,\n>\n> Mark\n>\n> P.S. this is enough to drive me to drink!\n> --\n> Dr. Mark Wardle\n> Clinical research fellow and specialist registrar, Neurology\n> Cardiff, UK\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide\n> http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n>\n\n\n\n-- \nJim Holtman\nCincinnati, OH\n+1 513 646 9390\n\nWhat is the problem you are trying to solve?\n\n\t[[alternative HTML version deleted]]\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
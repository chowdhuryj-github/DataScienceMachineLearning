{"category": "ham", "to_address": "\"Speakup is a screen review system for Linux.\" <speakup@braille.uwo.ca>", "from_address": "\"Spie Sutherland\" <spie@proficio.ca>", "subject": "Re: Speakup in userspace", "body": "Consider the linux that most of use to be a \"protected mode\" \noperating system as opposed to \"real mode\". Protected mode\nallows access to things like virtual memory, multi-threading, \nand priviledge levels not available in real mode. Protected \nmode has been the standard on x86 PCs since the 80286.\n\nA protected mode system segregates virtual memory into \nkernel space and user space. Kernel space is strictly reserved\nfor running the kernel, device drivers, and kernel extensions.\nIt is usually the case that kernel space memory is not swapped\nto disk since that is much slower, which user space memory \ncan be swapped to disk.\n\nUser space or \"userland\" processes cannot access the memory\nof other processes, the basis of memory protection which \nmakes linux very stable. Prior to win2k, the windows os was \nnot a protected memory system, hence the freezing up or \ncrashing of whole system from one bug in one driver or app.\nA user space process, although restricted in memory access,\ncan request the kernel to map part of its memory onto its own\nspace, and can also access shared memory. \n\nThe kernel space is the direct hardware access space along\nwith the management software that controls virtual memory,\nDMA, threads, processes, etc. You have kernel processes \nand user processes. The kernel processes are supposed to \nbe basic things like the direct interface to hardware. User\nspace is where applications run. So there is kernel space \nmemory, threads, and processes, and user space memory, \nthreads, and processes. \n\nConsider ALSA sound as an example. It's in the kernel but\nit's also not in the kernel. There are kernel drivers and there\nare user space libraries. The alsa-lib delegates sound control\nto user space. This allows application developers to do all \nkinds of things without touching kernel code. The alsa-lib \nprovides various functionality like software mixing, support\nfor the older OSS API, and user specific configuration, and\nit is multi-thread safe, essential for complex audio programs.\n\nAlsa may not be the best example, but the idea is separating\nthe core functionality from the application layer. Let's say I\ncreate an API for writing text to a speech synth. The code \nthat actually talks to the synth would ideally be abstracted \nfrom the API such that the identical programming interface\nworks for any synth using any protocol like serial or usb.\nSome hardware may not implement all parts of the API but\nwhere there are same functions the API should look the \nsame. An example of a very well abstracted API is the \nJava API. It had to be done that way in order to make the\nprograms portable on different systems. I may be biased \nbecause I used to work there, but if you look at how much\nwork was done on abstraction it's the most impressively \nabstracted API around. I'm not talking about javascript, \nthat's like a virus hehe. Unfortunately Sun wanted Java to \nbe the answer to everything everywhere which it is not and\nwill never be, and Java, like many good ideas, has become\noverly bloated and complex, although at least the various \nparts of it are separate APIs, and the compact versions \nlike J2ME are still very efficient. They run on almost all \nphones now. There is a good reason for this. I wrote some\napps on blackberry and it was a breeze to do so. Compared\nwith doing it in C or ASM it's an entirely different world.\n\n  -- Spie\n\n_______________________________________________\nSpeakup mailing list\nSpeakup@braille.uwo.ca\nhttp://speech.braille.uwo.ca/mailman/listinfo/speakup\n\n"}
{"category": "ham", "to_address": "\"kyle.halberstam@gmail.com\" <kyle.halberstam@gmail.com>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: Check if file is being modified by another process", "body": "On 7/4/07, kyle.halberstam@gmail.com  wrote:\n\n> I have an application that creates and writes to an output file I need\n> to process. I need to process the file when it is completely written\n> to. I do not initially know how big the file will be in the end.\n> Further, the application does NOT put a write lock on the file while\n> it is writing it. because of the buffering, the program wirtes to the\n> file in random chunks not continuously. And what is worse, the file\n> format itself could vary so there is nothing in the actual file that\n> signals the end of it. Everything is on a linux server.\n>\n> What's the most efficient way of checking this? - one way is perhaps\n> inifinite loop checking mmtime until it is stable for a certain amount\n> of time?? I am not sure.\n\nThat's probably the right road to choose. Choose some time interval\nthat's long enough to be sure the file is done, but not so long that\nit results in undue impatience in whoever is waiting for the end\nresults.\n\nAn alternative might be if there is some way to spy on the process\ndoing the writing. This requires new interactions between the two\nprograms and the OS, making everything more fragile. But if you can\ndetermine that the other process has finished execution, or in any\nother way has closed its equivalent of a filehandle, you can probably\nbe certain that the writing is finished. Probably.\n\nStill, I'd prefer polling, using the longest interval I could justify.\n\nIs there absolutely no clue available, though? For example, you speak\nof buffering; if a file's size isn't a multiple of the buffer size,\ndoes that mean that it's finished? It may be that your application\nwill be happiest with nearly all data at the earliest possible moment,\neven though one file out of 8192 will be delayed by an extra hour to\nbe sure that it's really finished. But it would be bad, even fatal,\nfor some applications to get data out-of-order. (Or does it write just\n one file at a time, so that you know the first is done when the\nsecond is starting?)\n\nOne frill you could add would reduce impatience by increasing the\npolling frequency. It would take a lot of trouble, and maybe cause a\nlot of trouble, so it's probably not worth it. But you could set the\npolling interval to be arbitrarily quick, adding some code that would\nrecognize when some file has been updated and announcing \"This\nsupersedes file #42\", or whatever. It all depends upon whether clients\nwill be more troubled by missing information that is slow to come in,\nor incomplete information that is quick to be updated (although\npossibly still incomplete).\n\nOne last alternative comes to mind: Determine the supplier of the\nmystery application, and use any means necessary to have appropriate\nfile locking or equivalent behavior added to their source code. If\nyour clients are impatient, it's transitive: they're impatient with\nthis other software, really.\n\nIn the end, the road you take depends upon where your clients'\nimpatience drives you.\n\nGood luck with it!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 469: first step in health monitoring of cluster nodes. When not\n\thealthy they will be marked disabled in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 469\nrevision-id: tridge@samba.org-20070605074319-o4w21cijnl57gh4v\nparent: tridge@samba.org-20070605051837-j5h7se616o7a7zbz\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-06-05 17:43:19 +1000\nmessage:\n  first step in health monitoring of cluster nodes. When not healthy they will be marked disabled\nmodified:\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n  common/ctdb_recoverd.c         recoverd.c-20070503213540-bvxuyd9jm1f7ig90-1\n  common/ctdb_traverse.c         ctdb_traverse.c-20070503021550-ztfs5rwx8jfm8qqx-1\n  common/ctdb_tunables.c         ctdb_tunables.c-20070604095258-4m34d7cm1qa7yos9-1\n  config/events.d/50.samba       samba-20070601105340-vlcvnp6euoj3zdwy-3\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n  takeover/ctdb_takeover.c       ctdb_takeover.c-20070525071636-a5n1ihghjtppy08r-2\n  tools/ctdb_control.c           ctdb_control.c-20070426122705-9ehj1l5lu2gn9kuj-1\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-06-04 10:22:44 +0000\n+++ b/common/ctdb.c\t2007-06-05 07:43:19 +0000\n@@ -222,14 +222,16 @@\n }\n \n /*\n-  return the number of connected nodes\n+  return the number of enabled nodes\n */\n-uint32_t ctdb_get_num_connected_nodes(struct ctdb_context *ctdb)\n+uint32_t ctdb_get_num_enabled_nodes(struct ctdb_context *ctdb)\n {\n \tint i;\n \tuint32_t count=0;\n \tfor (i=0;ivnn_map->size;i++) {\n-\t\tif (ctdb->nodes[ctdb->vnn_map->map[i]]->flags & NODE_FLAGS_CONNECTED) {\n+\t\tstruct ctdb_node *node = ctdb->nodes[ctdb->vnn_map->map[i]];\n+\t\tif ((node->flags & NODE_FLAGS_CONNECTED) &&\n+\t\t    !(node->flags & NODE_FLAGS_DISABLED)) {\n \t\t\tcount++;\n \t\t}\n \t}\n\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-06-04 11:11:51 +0000\n+++ b/common/ctdb_client.c\t2007-06-05 07:43:19 +0000\n@@ -1364,7 +1364,7 @@\n \tctdb_db->db_id = *(uint32_t *)data.dptr;\n \ttalloc_free(data.dptr);\n \n-\tret = ctdb_ctrl_getdbpath(ctdb, timeval_current_ofs(1, 0), CTDB_CURRENT_NODE, ctdb_db->db_id, ctdb_db, &ctdb_db->db_path);\n+\tret = ctdb_ctrl_getdbpath(ctdb, timeval_current_ofs(2, 0), CTDB_CURRENT_NODE, ctdb_db->db_id, ctdb_db, &ctdb_db->db_path);\n \tif (ret != 0) {\n \t\tDEBUG(0,(\"Failed to get dbpath for database '%s'\\n\", name));\n \t\ttalloc_free(ctdb_db);\n\n=== modified file 'common/ctdb_recoverd.c'\n--- a/common/ctdb_recoverd.c\t2007-06-04 10:22:44 +0000\n+++ b/common/ctdb_recoverd.c\t2007-06-05 07:43:19 +0000\n@@ -697,6 +697,8 @@\n \t\t\t      \"MonitorFrequency\", &ctdb->tunable.monitor_frequency);\n \tctdb_ctrl_get_tunable(ctdb, CONTROL_TIMEOUT(), CTDB_CURRENT_NODE, \n \t\t\t      \"ElectionTimeout\", &ctdb->tunable.election_timeout);\n+\tctdb_ctrl_get_tunable(ctdb, CONTROL_TIMEOUT(), CTDB_CURRENT_NODE, \n+\t\t\t      \"TakeoverTimeout\", &ctdb->tunable.takeover_timeout);\n \n \tvnn = ctdb_ctrl_getvnn(ctdb, CONTROL_TIMEOUT(), CTDB_CURRENT_NODE);\n \tif (vnn == (uint32_t)-1) {\n\n=== modified file 'common/ctdb_traverse.c'\n--- a/common/ctdb_traverse.c\t2007-06-04 07:46:37 +0000\n+++ b/common/ctdb_traverse.c\t2007-06-05 07:43:19 +0000\n@@ -372,7 +372,7 @@\n \n \tif (key.dsize == 0 && data.dsize == 0) {\n \t\tstate->null_count++;\n-\t\tif (state->null_count != ctdb_get_num_connected_nodes(ctdb)) {\n+\t\tif (state->null_count != ctdb_get_num_enabled_nodes(ctdb)) {\n \t\t\treturn 0;\n \t\t}\n \t}\n\n=== modified file 'common/ctdb_tunables.c'\n--- a/common/ctdb_tunables.c\t2007-06-04 10:22:44 +0000\n+++ b/common/ctdb_tunables.c\t2007-06-05 07:43:19 +0000\n@@ -35,6 +35,7 @@\n \t{ \"RecoverTimeout\",    5,  offsetof(struct ctdb_tunable, recover_timeout) },\n \t{ \"MonitorFrequency\",  1,  offsetof(struct ctdb_tunable, monitor_frequency) },\n \t{ \"ElectionTimeout\",   3,  offsetof(struct ctdb_tunable, election_timeout) },\n+\t{ \"TakeoverTimeout\",   5,  offsetof(struct ctdb_tunable, takeover_timeout) },\n };\n \n /*\n\n=== modified file 'config/events.d/50.samba'\n--- a/config/events.d/50.samba\t2007-06-05 05:18:37 +0000\n+++ b/config/events.d/50.samba\t2007-06-05 07:43:19 +0000\n@@ -21,8 +21,10 @@\n \tservice smb stop > /dev/null 2>&1\n \tservice winbind stop > /dev/null 2>&1\n \n-\t# start Samba service\n-\tservice smb start\n+\t# start Samba service. Start it reniced, as under very heavy load \n+\t# the number of smbd processes will mean that it leaves few cycles for\n+\t# anything else\n+\tnice service smb start\n \tservice winbind start\n \n \t# wait for the Samba tcp ports to become available\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-06-04 12:13:59 +0000\n+++ b/include/ctdb_private.h\t2007-06-05 07:43:19 +0000\n@@ -50,6 +50,7 @@\n \tuint32_t recover_timeout;\n \tuint32_t monitor_frequency;\n \tuint32_t election_timeout;\n+\tuint32_t takeover_timeout;\n };\n \n /*\n@@ -109,6 +110,7 @@\n \tvoid *private_data; /* private to transport */\n \tuint32_t vnn;\n #define NODE_FLAGS_CONNECTED 0x00000001\n+#define NODE_FLAGS_DISABLED  0x00000002\n \tuint32_t flags;\n \n \t/* used by the dead node monitoring */\n@@ -905,7 +907,7 @@\n \n int ctdb_start_recoverd(struct ctdb_context *ctdb);\n \n-uint32_t ctdb_get_num_connected_nodes(struct ctdb_context *ctdb);\n+uint32_t ctdb_get_num_enabled_nodes(struct ctdb_context *ctdb);\n \n int ctdb_start_monitoring(struct ctdb_context *ctdb);\n void ctdb_send_keepalive(struct ctdb_context *ctdb, uint32_t destnode);\n\n=== modified file 'takeover/ctdb_takeover.c'\n--- a/takeover/ctdb_takeover.c\t2007-06-04 13:54:56 +0000\n+++ b/takeover/ctdb_takeover.c\t2007-06-05 07:43:19 +0000\n@@ -27,7 +27,7 @@\n #include \"../include/ctdb_private.h\"\n \n \n-#define TAKEOVER_TIMEOUT() timeval_current_ofs(5,0)\n+#define TAKEOVER_TIMEOUT() timeval_current_ofs(ctdb->tunable.takeover_timeout,0)\n \n #define CTDB_ARP_INTERVAL 1\n #define CTDB_ARP_REPEAT   3\n@@ -403,7 +403,8 @@\n \n \t/* work out which node will look after each public IP */\n \tfor (i=0;inum;i++) {\n-\t\tif (nodemap->nodes[i].flags & NODE_FLAGS_CONNECTED) {\n+\t\tif ((nodemap->nodes[i].flags & NODE_FLAGS_CONNECTED) && \n+\t\t    !(nodemap->nodes[i].flags & NODE_FLAGS_DISABLED)) {\n \t\t\tctdb->nodes[i]->takeover_vnn = nodemap->nodes[i].vnn;\n \t\t} else {\n \t\t\t/* assign this dead nodes IP to the next higher node */\n@@ -411,6 +412,7 @@\n \t\t\t     j != i;\n \t\t\t     j=(j+1)%nodemap->num) {\n \t\t\t\tif ((nodemap->nodes[j].flags & NODE_FLAGS_CONNECTED) &&\n+\t\t\t\t    !(nodemap->nodes[j].flags & NODE_FLAGS_DISABLED) &&\n \t\t\t\t    ctdb_same_subnet(ctdb->nodes[j]->public_address, \n \t\t\t\t\t\t     ctdb->nodes[i]->public_address, \n \t\t\t\t\t\t     ctdb->nodes[j]->public_netmask_bits)) {\n\n=== modified file 'tools/ctdb_control.c'\n--- a/tools/ctdb_control.c\t2007-06-04 11:11:51 +0000\n+++ b/tools/ctdb_control.c\t2007-06-05 07:43:19 +0000\n@@ -383,7 +383,7 @@\n {\n \tint ret;\n \n-\tret = ctdb_ctrl_shutdown(ctdb, timeval_current_ofs(1, 0), options.vnn);\n+\tret = ctdb_ctrl_shutdown(ctdb, TIMELIMIT(), options.vnn);\n \tif (ret != 0) {\n \t\tprintf(\"Unable to shutdown node %u\\n\", options.vnn);\n \t\treturn ret;\n\n"}
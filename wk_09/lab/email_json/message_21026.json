{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "\"Mark J. Reed\" <markjreed@mail.com>", "subject": "Re: Default filehandles, or topicalizing filehandles, or something", "body": "On 5/1/07, Larry Wall  wrote:\n> : I think I prefer a more significant difference between the default\n> : targets and the POSIXy std* values that they are initialized to,  like\n> : the Ruby notion of using global variables initialized to named\n> : constants, e.g. $stderr starts out as equal to STDERR but can be\n> : reassigned...\n>\n> Well, the question is, what does a subprocess get for fd(2) after\n> you do that?  I'd prefer to keep $*ERR nailed to fd(2) in general so\n> that modifying $*ERR actually changes the stderr of new subprocesses.\n\nAh.  I had imagined $*ERR as a bit more ephemeral than that, with an\nunderlying really-real stderr.\n\n> But that doesn't give you a method of indirection inside the current\n> process, so $*DEFERR would be a way to do that.  Forcing people\n> to use an explicit handle in that case would be another approach,\n> but certainly something like $*DEFERR would be kinder to embedding\n> systems that want to intercept such messages and log them.\n\nRight.  Something akin to P5's $SIG{__WARN__} and $SIG{__DIE__} would\nalso work, but that never seemed to be quite the right way to do that,\nto me.\n\n-- \nMark J. Reed \n"}
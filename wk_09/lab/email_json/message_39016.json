{"category": "ham", "to_address": "\"Laxminarayan G Kamath A\" <laxminarayan@deeproot.co.in>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: Outlook CSV Parser", "body": "On 5/30/07, Laxminarayan G Kamath A  wrote:\nsnip\n> Any ways of optimising it further?\nsnip\n\nPremature optimization is the root of all evil.  Have you profiled the\ncode yet?  If not then here is some documentation that will point you\nin the right direction\n\nhttp://www.perl.com/pub/a/2004/06/25/profiling.html\nhttp://search.cpan.org/~nwclark/perl-5.8.8/utils/dprofpp.PL\n\nBut while I am looking lets see what is going on.\n\nsnip\n>         1. One line need not be one record. They may cointain multine\n> fields.\n>         2. A sigh of relief but : only multi-line fields are wrapped in\n> double quotes.\n>         3. commas are both inside and outside the fields. the ones in\n> the fileds must not be treated as \"seperator\" - again fields with\n> commans are wrapped in double quotes.\nsnip\n\nThe following code seems to speed up the parsing by two orders of\nmagnitude (2.214 seconds for the old code and 0.036 seconds for this\ncode on 100 records).  Also, there seems to be a bug in your original\ncode.  I setup a test file with a 100 records of 30 fields each and it\nfound\n\nfound 33 fields in 1 records\nfound 34 fields in 1 records\nfound 36 fields in 3 records\nfound 37 fields in 5 records\nfound 38 fields in 10 records\nfound 39 fields in 9 records\nfound 40 fields in 12 records\nfound 41 fields in 17 records\nfound 42 fields in 15 records\nfound 43 fields in 13 records\nfound 44 fields in 7 records\nfound 45 fields in 5 records\nfound 46 fields in 1 records\nfound 48 fields in 1 records\n\n===code to generate test file===\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nmy $fields    = 30;\nmy $fieldlen  = 30;\nmy @fieldtype = qw(normal quoted comma);\nmy $records   = shift;\n\nfor my $rec (1 .. $records) {\n        for my $field (1 .. $fields) {\n                my $type = $fieldtype[int rand @fieldtype];\n                if ($type eq 'normal') {\n                        print 'n' x $fieldlen, \",\";\n                } elsif ($type eq 'quoted') {\n                        print '\"';\n                        my $i = 0;\n                        until ($i < $fieldlen) {\n                                my $len = int rand $fieldlen;\n                                print 'q' x $len, \"\\n\";\n                                $i += $len;\n                        }\n                        print '\",';\n                } elsif ($type eq 'comma') {\n                        print '\"';\n                        my $i = 0;\n                        until ($i == $fieldlen) {\n                                my $len = int rand $fieldlen;\n                                $len = $fieldlen - $i if $i+$len > $fieldlen;\n                                print 'c' x ($len/2), ',', 'c' x ($len/2), \"\\n\";\n                                $i += $len;\n                        }\n                        print '\",';\n                }\n        }\n        print \"\\n\";\n}\n\n===code to parse test file===\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nmy $record = \"\";\nmy $quotes = 0;\nmy @records;\nwhile (defined (my $line = <>)) {\n        next if $record eq \"\" and $line =~ /^\\s*$/;\n\n        $record .= $line;\n\n        #count the number of quotes\n        $quotes += () = $line =~ /\"/g;\n\n        #if $quotes is even then we have a full record\n        if ($quotes % 2 == 0) {\n                $quotes = 0;\n                chomp $record;\n                my @fields;\n                my $unbalanced = 0;\n                for my $field (split /,/, $record) {\n                        my $count = $field =~ s/\"//g;\n                        if ($count % 2) {\n                                if ($unbalanced) {\n                                        $unbalanced = 0;\n                                        $fields[-1] .= \",$field\";\n                                        next;\n                                }\n                                $unbalanced = 1;\n                                push @fields, $field;\n                                next;\n                        }\n                        if ($unbalanced) {\n                                $fields[-1] .= \",$field\";\n                        } else {\n                                push @fields, $field;\n                        }\n                }\n                push @records, { whole => $record, fields => \\@fields};\n                $record = \"\";\n        }\n\n}\n\nfor my $rec (@records) {\n        print join \"|\", @{$rec->{fields}},\"\\n===\\n\";\n}\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "\"'Jeremy Goldhaber-Fiebert'\" <JGOLDHAB@hsph.harvard.edu>,\n   \"'Spencer Graves'\" <spencer.graves@pdf.com>", "from_address": "\"Ravi Varadhan\" <rvaradhan@jhmi.edu>", "subject": "Re: [R] Fwd: Using odesolve to produce non-negative solutions", "body": "Jeremy,\n\nYou should examine the steady-state solution to your system of equations, by\nsetting the time-derivatives to zero and then solving/analyzing the\nresulting algebraic equations.  This should give you some insights.  \n\nLet us say you have 3 groups, A,B, and C, with initial conditions:\nN_A(t=0) = N_{A0}, N_B(t=0) = N_{B0}, and N_C(t=0) = N_{C0}, and that people\ntransition in and out of these 3 states (one of the states could even be\nabsorbing, e.g. death), but it is true for any time t that N_A(t) + N_B(t) +\nN_C(t) = N_{A0} + N_{B0} + N_{C0}.  Furthermore, you have 3 diff-equations\nthat describe the rate of change of N_A, N_B, and N_C, for t > 0.  If it\nhappens that one of the N's, say N_A, becomes negative, you could set it\nequal to zero.  But then you have to figure out how to re-adjust N_B and N_C\nso that they add up to the initial total count.  After re-adjustment, you\nalso have to think about whether the resulting system of equations are\nvalid, when there are no A people.\n\nRavi. \n\n\n----------------------------------------------------------------------------\n-------\n\nRavi Varadhan, Ph.D.\n\nAssistant Professor, The Center on Aging and Health\n\nDivision of Geriatric Medicine and Gerontology \n\nJohns Hopkins University\n\nPh: (410) 502-2619\n\nFax: (410) 614-9625\n\nEmail: rvaradhan@jhmi.edu\n\nWebpage:  http://www.jhsph.edu/agingandhealth/People/Faculty/Varadhan.html\n\n \n\n----------------------------------------------------------------------------\n--------\n\n\n-----Original Message-----\nFrom: r-help-bounces@stat.math.ethz.ch\n[mailto:r-help-bounces@stat.math.ethz.ch] On Behalf Of Jeremy\nGoldhaber-Fiebert\nSent: Monday, June 11, 2007 11:47 AM\nTo: Spencer Graves\nCc: r-help@stat.math.ethz.ch\nSubject: Re: [R] Fwd: Using odesolve to produce non-negative solutions\n\nHi Spencer,\n\nThank you for your response. I also did not see anything on the lsoda help\npage which is the reason that I wrote to the list.\n\n>From your response, I am not sure if I asked my question clearly.\n\nI am modeling a group of people (in a variety of health states) moving\nthrough time (and getting infected with an infectious disease). This means\nthat the count of the number of people in each state should be positive at\nall times. \n\nWhat appears to happen is that lsoda asks for a derivative at a given point\nin time t and then adjusts the state of the population. However, perhaps due\nto numerical instability, it occasionally lower the population count below 0\nfor one of the health states (perhaps because it's step size is too big or\nsomething). \n\nI have tried both the logarithm trick and also changing the relative and\nabsolute tolerance inputs but I still get the problem for certain\ncombinations of parameters and initial conditions. \n\nIt occurs both under MS Windows XP Service Pack 2 and on a Linux cluster so\nI am pretty sure it is not platform specific.\n\nMy real question to the group is if there is not a work around in lsoda are\nthere other ode solvers in R that will allow the constraint of solutions to\nthe ODEs remain non-negative?\n\nBest regards,\nJeremy\n      \n\n>>> Spencer Graves  6/8/2007 9:51 AM >>>\nOn the 'lsoda' help page, I did not see any option to force some \nor all parameters to be nonnegative. \n\n      Have you considered replacing the parameters that must be \nnonnegative with their logarithms?  This effective moves the 0 lower \nlimit to (-Inf) and seems to have worked well for me in the past.  \nOften, it can even make the log likelihood or sum of squares surface \nmore elliptical, which means that the standard normal approximation for \nthe sampling distribution of parameter estimates will likely be more \naccurate. \n\n      Hope this helps. \n      Spencer Graves\np.s.  Your example seems not to be self contained.  If I could have \neasily copied it from your email and run it myself, I might have been \nable to offer more useful suggestions. \n\nJeremy Goldhaber-Fiebert wrote:\n> Hello,\n>\n> I am using odesolve to simulate a group of people moving through time and\ntransmitting infections to one another. \n>\n> In Matlab, there is a NonNegative option which tells the Matlab solver to\nkeep the vector elements of the ODE solution non-negative at all times. What\nis the right way to do this in R?\n>\n> Thanks,\n> Jeremy\n>\n> P.S., Below is a simplified version of the code I use to try to do this,\nbut I am not sure that it is theoretically right \n>\n> dynmodel <- function(t,y,p) \n> { \n> ## Initialize parameter values\n>\n> \tbirth <- p$mybirth(t)\n> \tdeath <- p$mydeath(t)\n> \trecover <- p$myrecover\n> \tbeta <- p$mybeta\n> \tvaxeff <- p$myvaxeff\n> \tvaccinated <- p$myvax(t)\n>\n> \tvax <- vaxeff*vaccinated/100\n>\n> ## If the state currently has negative quantities (shouldn't have), then\nreset to reasonable values for computing meaningful derivatives\n>\n> \tfor (i in 1:length(y)) {\n> \t\tif (y[i]<0) {\n> \t\t\ty[i] <- 0\n> \t\t}\n> \t}\n>\n> \tS <- y[1]\n> \tI <- y[2]\n> \tR <- y[3]\n> \tN <- y[4]\n>\n> \tshat <- (birth*(1-vax)) - (death*S) - (beta*S*I/N)\n> \tihat <- (beta*S*I/N) - (death*I) - (recover*I)\n> \trhat <- (birth*(vax)) + (recover*I) - (death*R)\n>\n> ## Do we overshoot into negative space, if so shrink derivative to bring\nstate to 0 \n> ## then rescale the components that take the derivative negative\n>\n> \tif (shat+S<0) {\n> \t\tshat_old <- shat\n> \t\tshat <- -1*S\n> \t\tscaled_transmission <- (shat/shat_old)*(beta*S*I/N)\n> \t\tihat <- scaled_transmission - (death*I) - (recover*I)\n> \t\t\n> \t}\t\n> \tif (ihat+I<0) {\n> \t\tihat_old <- ihat\n> \t\tihat <- -1*I\n> \t\tscaled_recovery <- (ihat/ihat_old)*(recover*I)\n> \t\trhat <- scaled_recovery +(birth*(vax)) - (death*R)\n> \t\n> \t}\t\n> \tif (rhat+R<0) {\n> \t\trhat <- -1*R\n> \t}\t\n>\n> \tnhat <- shat + ihat + rhat\n>\n> \tif (nhat+N<0) {\n> \t\tnhat <- -1*N\t\n> \t}\t\n>\n> ## return derivatives\n>\n> \tlist(c(shat,ihat,rhat,nhat),c(0))\n>\n> }\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help \n> PLEASE do read the posting guide\nhttp://www.R-project.org/posting-guide.html \n> and provide commented, minimal, self-contained, reproducible code.\n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
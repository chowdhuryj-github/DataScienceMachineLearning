{"category": "ham", "to_address": "p2 <parrot-porters@perl.org>", "from_address": "Will Coleda <will@coleda.com>", "subject": "Re: new FAQs", "body": "A reply from the anonymous colleague.\n\nI pass it along as presented to me, unaltered except for this prelude.\n\nNote that while these are not *my* questions, I find both the  \noriginal questions and the followups compelling and in need of  \nanswering.\n\nI hope that we can get some of the design team (past and present)  \ninvolved in this thread, as this is part of the documentation effort  \nI mentioned.\n\n... And I hope Anonymous Colleague chooses to de-cloak soon so I can  \nstop all this CNP nonsense.\n\n.end\n\nOn May 23, 2007, at 1:58 AM, Joshua Isom wrote:\n\n > On May 21, 2007, at 5:56 PM, Will Coleda wrote:\n >\n > > 1. Why Parrot?\n > >\n > > http://www.parrotcode.org/docs/intro.html:\n > >\n > > \"Parrot is designed with the needs of dynamically typed languages\n > > (such as Perl and Python) in mind, and should be able to run  \nprograms\n > > written in these languages more efficiently than VMs developed with\n > > static languages in mind (JVM, .NET). Parrot is also designed to\n > > provide interoperability between languages that compile to it. In\n > > theory, you will be able to write a class in Perl, subclass it in\n > > Python and then instantiate and use that subclass in a Tcl  \nprogram.\"\n > >\n > > a. What, precisely, about Parrot makes possible more efficient\n > > execution of a dynamically typed language than would be the case  \nwith\n > > the JVM or the CLR?\n >\n > Parrot is a register based machine instead of a stack based machine.\n > This is the way your computer is designed.  Although many  \narchitectures\n > heavily use the stack, registers are far more efficient.  Using a\n > register based machine makes JITing executable code far more  \nefficient\n > to come far closer to machine compiled speeds.\n >\n > But that mainly affects statically typed languages, such as a parrot\n > without pdd15.  WRT dynamically typed languages, parrot's designed  \nfor\n > it.  It's as simple as that.\n\nI confess to not grasping the point you claim is simple.  As you\nunderstand it, what is there about a register based machine, as\nopposed to a stack based machine, that specifically improves the\nperformance of operating on dynamically typed data, without regard to\nperformance differences between the two architectures that are\nindependent of typing models?\n\n > > b. Whatever that is, how will it adversely impact the execution of\n > > statically typed languages, including type-inferred languages?\n >\n > If we don't force many high level components on all languages(such  \nas a\n > scalar is a scalar and is not an integer), and provide a capacity  \nfor a\n > language to create it's own types(new pmc's), they can provide the\n > functionality they need without excessive overhead of other  \noperations.\n >   But this is where \"one vm for them all\" comes to hurt us, as  \nwell.  In\n > trying to support all languages, and provide at least the capacity  \nfor\n > all languages, we hurt our optimization for one specific language  \nwhich\n > is what many languages do.\n\nIt sounds like you are saying that languages are free to implement\ntheir own semantics using their own code, and that they can choose not\nto interoperate with predefined Parrot types or types from other\nlanguages when that would negatively impact their goals, such as\nperformance. While that rings true, it seems that Parrot is not\nproviding that ability -- languages can already implement whatever\nthey want without Parrot.  And if languages are free to ignore\npredefined and foreign types, when what benefit will they actually get\nfrom Parrot?\n\nMoreover, this does not address my initial question.  I am asking, to\nrephrase it bluntly, \"If Parrot makes dynamic typing faster, doesn't\nthat have to make static typing slower?\"  That is, is Parrot making a\ntradeoff here?  If it is, how large is the tradeoff and what is its\nnature.  If it is not, then why doesn't everyone else simply do what\nyou are doing and gain the same benefit?\n\nIt would seem that Parrot either has to be different from the JVM and\nCLR due to design or implementation optimizations that favor a\nspecific typing model over others -- which is what it seems to claim --\nor else it does not -- either it is not thus differently designed, or\nit is not thus differently implemented.  If it does not, then it seems\ninappropriate for it to make the claim -- and thus would raise the\nquestion of why Parrot should be considered a superior target for\ndynamically or statically typed language compilers.\n\n > I imagine parrot won't have a significant issue with statically type\n > languages, but that it will be more of an issue of the compiler  \nitself.\n >   Parrot should be able to run java fast and efficently, so long  \nas it's\n > compiled from java to pir, instead of running java bytecode, or\n > compiling java bytecode to pir.\n\nWhat tradeoffs could Parrot be making that will have a significant\nbenefit for dynamically typed languages -- significant enough to\njustify the creation of Parrot itself -- without significant detriment\nto statically typed languages?  Again, if these tradeoffs are so\nbroadly beneficial, why would the JVM or CLR not simply implement them\nthemselves?\n\nMost simply: What is being lost to gain whatever is being gained?\n\n > > c. How will this impact the execution of statically typed code in\n > > Perl, Python and other targeted languages?\n >\n > Most problems will be from coding styles most likely.   \nInteroperability\n > between functional programs will probably be a non-issue, but two\n > different oo languages(and thus two inheritance models) will likely\n > impact performance more.  But this is an issue of having one vm for\n > all.\n\nI don't understand your answer.  Allow me to rephrase and expand the\nquestion.\n\nIf Parrot is designed to benefit of dynamically typed languages, how\nwill Parrot handle statically typed code in those languages.  Will\nParrot discourage the use of static typing features in languages like\nPerl by making that code execute more slowly or inefficiently than\nequivalent dynamically typed code?\n\n > > 2. General Features\n > >\n > > a. How will Parrot support reflection and attributes?\n > >\n > > b. How will Parrot support generics types?\n > >\n > > c. How will Parrot support interface types?\n > >\n > > d. What kind of security models will Parrot support?\n > >\n > > e. How will Parrot support small-footprint systems?\n >\n > Perhaps miniparrot can help take care of this.  If miniparrot's a\n > miniature parrot, and perhaps supporting only those features that  \nthat\n > language needs, we might be able to get a parrot suited for embedded\n > systems.  PMC's not needed won't be compiled in, the runcores other\n > than the default could be left out, and parrot's size could shrink\n > dramatically.\n\nWhile many things are perhaps true, this answer sounds like \"There is\nno definite plan for supporting this.\"\n\n > > f. How will Parrot support direct access to \"unmanaged\" resources?\n >\n > Is this like UnmanagedStruct?\n\nI mean supporting direct access to the underlying address space and\nsupport for determining the sizes of data within that memory.  For\nexample, direct access to a framebuffer.\n\n > > g. How will Parrot facilitate distributed processing?\n >\n > With native threading support.\n\nI think you misunderstood my question.  By \"distributed\", I meant the\nexecution of code in multiple address spaces, or the non-concurrent\nexecution of code.  What support will Parrot provide for migrating\ndata or code between environment with different byte orders.  How will\nParrot support capturing execution state into a preservable or\ntransportable form?\n\n > > 3. Parrot PMC Issues\n > >\n > > The Parrot PMC vtable provides a large number of optional  \nfunctions,\n > > which PMCs can either implement or not. If not implemented, they  \nwill\n > > throw an exception at runtime.\n > >\n > >\n > > a. What support will Parrot provide a compiler to interrogate a  \nPMC at\n > > compile time to know what it actually implements?\n > >\n > > All of these functions appear to be predefined because there is no\n > > mechanism for extending this functionality at runtime. It  \nappears that\n > > compilers will be limited to implementing functionality that is\n > > defined in the vtable. The vtable contains the common operations\n > > required by certain languages.\n >\n > The only extendibility that I know of is via PIR, or a dnypmc  \nlibrary.\n > But the vtables are primarily for interoperability with everything.\n > Methods can still be addded to a pmc to provide additional needs.\n\nAgain, this does not seem to be clear, so I will provide an\nexample. If a Perl compiler is compiling Perl code, and that code is\nwritten to increment the result of a call into some Python code that\nreturns a PythonString, how can the compiler ask the PythonString PMC\nif it implements the \"increment\", so that it can detect at compile\ntime what the behavior of the statement will be?\n\nMore broadly, how can statically typed code determine if the values\nproduced by an operation will conform to the type requirements?\n\n > > b. How will Parrot handle languages with operations that are not\n > > provided?\n > >\n > > http://www.parrotcode.org/docs/vtables.html:\n > >\n > > \"To be perfectly honest, this is a slightly flawed example,  \nsince it's\n > > unlikely that there will be a distinct \"Python scalar\" PMC  \nclass. The\n > > Python compiler could well type-inference variables such that a  \nwould\n > > be a PythonString and b would be a PythonNumber. But the point  \nremains\n > > - incrementing a PythonString is very different from incrementing a\n > > PerlScalar.\"\n > >\n > > c. How will Parrot address cross-language semantics?\n > >\n >\n > The purpose of a common calling convention, and vtables, are to  \naddress\n > cross language semantics.  All languages will implement the basic\n > things in the same way.  It's not a \"our way or the high way\" but\n > rather a \"our way is the best way for parrot.\"\n\nWhat are \"basic things\"?  What if a language inherently differs in how\nit handles those things?  For example, incrementing a scalar would\nseem to be a basic operation in Perl, but Python will not implement\nthat basic thing in the same way.  It would seem that one or both\nsides of this cross-language exchange of very basic types of data will\nbe problematic.\n\nYou say \"the best way for parrot\" -- how can Parrot have a judgmental\nreference point independent from the languages that target it and the\nusers of those languages?\n\n > > d. Will each language have to provide its own support for  \ninteracting\n > > with PMCs for other languages?\n > >\n >\n > No, the PMC's will do that themselves.  Getting the PMC's is another\n > story.  A language is reponsible for it's cross language semantics.\n > But parrot is designed for the widest possible case.  Many languages\n > limit valid characters that a subroutine can use, but parrot does  \nnot.\n > But as long as \"common\" cases are adhered to, most problems will not\n > exist, e.g. no unicode whitespace in a subroutine name.\n\nYou say \"No\" initially, but then go on to say \"yes\" in substance.  If\nthe PMCs are responsible for this, and if languages provide the PMCs,\nthen the languages are responsible for this.\n\nTo explicitly state what is implied by this question.  If every\nlanguage must provide PMCs that understand how to interact with types\nof other languages, then languages will only be able to interact with\neach other to the degree that one or both of those languages provides\nsupport.  For Perl to use data returned from Python code, either Perl\nwill have to recognize Python types or Python will have to know to\nproduce Perl types.  Then for Perl to call Tcl code, Perl and/or Tcl\nwill have to be taught about each other.  And then for Python to call\nTcl, yet additional code will need to be created.  Indeed, it could be\nnecessary for Python code to call Perl code that calls Tcl code,\nbecause Perl might understand how to handle a Tcl type that Python\ndoes not.  And the more languages that are added, the more types each\nlanguage will be asked to implement code to interact with.\n\nThis seems like a scalability problem.\n\nOne possible approach would be to tell every language that when they\nwish to interact, they must produce Parrot-provided types, like String\nor Number.  Another possible approach would be for Parrot to forcibly\nconvert language-specific data to Parrot-provided types.  Both of\nthese approaches have issues.\n\nIncidentally, the JVM/CTS approach is to tell every language to use\nthe same primitive types all the time and to use the same object types\nas close to all the time as possible.  (I am only aware of one case of\nthis, being the separate 'String' type in Rhino, needed to provide\nboth Java and JavaScript String semantics. In that case, Java code\nreturns a Java String object and the caller must explicitly convert it\nto a JavaScript string with an operation like 'string+\"\"'.)\n\n > > e. How will a PerlScalar interact with a PythonString?\n >\n > The best method would probably convert both down to a String, do\n > whatever operation, and convert up to whatever is request.  But, for\n > optimization, multimethod vtables could be used to provide custom\n > behavior.  I know src/pmc/complex.pmc has some examples of  \nmultimethod\n > vtables.\n\nSee above.  The intent of this question is not so much \"What could\nsomeone happen to do in this situation\", but rather \"What exactly will\nParrot enforce, require or provide?\"\n\n > > f. What will happen when a PythonString is incremented in Perl  \ncode?\n >\n > Parrot call's PythonString's increment vtable.  Perl doesn't have an\n > increment, but PerlScalar does.  Python doesn't have an increment,  \nbut\n > PythonString does.  Now, if the PMC doesn't implement that vtable\n > function, an exception is thrown, but Parrot still tries to call it.\n\nThis would mean that any cross-language code could generate runtime\nexceptions in operations that otherwise are generally considered not to\nbe able to fail.  Indeed, it would seem that every possible operation\nwould possibly fail at runtime when handling foreign data.\n\nThis would seem to strongly discourage multi-language programming --\nto the point of it never happening.\n\nWhat will Parrot do to make this acceptable?  Will end-users be forced\nto write their own test cases that attempt all valid combinations of\nall data between all languages they wish to use?\n\n > > Comparing the vtable for a PMC to the JVM and CLR base Object  \nclasses,\n > > the PMC is essentially an \"abstract\" class with dozens of\n > > \"unimplemented\" methods, while Java's Object provides (and  \nimplements)\n > > the following public methods:\n > >\n > >   equals getClass hashCode notify notifyAll toString wait\n > >\n > > Discounting the methods related to Java's peculiar threading\n > > implementation, that's:\n > >\n > >   equals                 getClass hashCode    toString\n > >\n > > Similarly, the CLR's CTS Object provides:\n > >\n > >   Equals ReferenceEquals GetType  GetHashCode ToString\n > >\n > > g. Why is it a good thing that PMCs essentially non-contractual\n > > abstract base classes that define a lot of functionality without\n > > implementing it?\n >\n > In some instances, this is a benefit.  Suppose you want an\n > auto-iterating string array.  For the most part, it's an array with\n > normal array properties.  But if you get it's string value, it  \niterates\n > over the next one.  If you set it's string value, maybe it splices  \nthat\n > value into the array.  Having both array and string properties is\n > beneficial in this case.\n\nI do not see the benefit.  You could implement exactly that without\nhaving an undefined, abstract base type.  For example, with the\nfollowing code (which is clearly simplified):\n\nModule Main\n         Sub Main()\n                 Dim i As New IncrString\n                 Console.WriteLine(i)\n                 Console.WriteLine(i)\n                 Console.WriteLine(i)\n                 Console.WriteLine(i)\n                 i.addValue = \"A\"\n                 Console.WriteLine(i)\n                 Console.WriteLine(i)\n                 Console.WriteLine(i)\n                 Console.ReadKey()\n         End Sub\nEnd Module\n\nClass IncrString\n         Private value As String = \"a\"\n\n         Public WriteOnly Property addValue() As String\n                 Set(value As String)\n                         Me.value += value\n                 End Set\n         End Property\n\n         Public Overrides Function ToString() As String\n                 Dim curValue As String = value\n                 Dim newValue As Char() = value.ToCharArray()\n                 Dim length As Integer = newValue.Length\n                 newValue(length-1) = chr(asc(newValue(length-1)) + 1)\n                 value = newValue\n                 Return curValue\n         End Function\nEnd Class\n\nThis code produces:\n\na\nb\nc\nd\neA\neB\neC\n\nNow, this was not the best of examples in the first place, because I\nwould not argue that 'ToString' is not the kind of really-useful thing\nyou want in a core data type.  The essential meaning of the routine\nbeing \"make something a human can read\" -- and humans are the people\nusing the machines.  But, as you can see, there was no need for the\ncore data type to provide me with an implemented 'addValue' -- it can\nsimply be layered on using a more primitive and extensible runtime\nsupport for properties.\n\n > But the downside is most things, such as an Integer, don't need  \nmany of\n > the vtables provided.  In fact, if you look at the c output of a pmc\n > file, you'll see that every vtable is created.  I imagine it's  \nmore for\n > simplicity and speed than for memory(both executable and ram) than\n > anything else.\n\nI don't see the simplicity or the speed benefit.  I do see the memory\ncost.  If anything, I suspect that these larger objects will fill a\nCPU cache faster and be slower to load because of this increased size,\nleading to slower runtime performance.\n\n > > h. Why is there no first-tier depth in Parrot's type system,  \nsuch as:\n > >\n > >   PMCString, PMCIntger, PMCNumber, ...\n > >\n >\n > You mean like String, Integer, Number, Array, etc?\n\nNo, I mean why is the type-specific functionality not pushed down into\nthe next tier where it is actually needed, like the JVM and CTS do,\nleaving the base PMC with only the same four or five methods those\nsystems have?\n\n > > 4. Parrot VM Issues\n > >\n > > Parrot provides what it calls \"registers\" with no guarantee that  \nthese\n > > map to hardware registers.\n > >\n > > a. Will any registers ever map, in a Parrot-controlled way, to  \nhardware\n > > registers?\n >\n > Yes.  If a subroutine uses less than or equal to the number of\n > registers on an architecture, the entire subroutine can be converted\n > into native code, leaving parrot out entirely.  Using a PPC system is\n > better than an i386 system in this case, since it has more registers.\n > Even if the subroutine isn't compiled entirely to native code,  \nportions\n > of that code will be compiled to native code as best as possible.\n >\n > The very basis of parrot's jit system is that both parrot and the\n > native system use registers, and that keeping data in registers helps\n > to improve speed greatly.\n\nWithout opening a can of bees, this sounds like Parrot's performance\nwill vary greatly, depending on the quantity of variables in scope in\nsubroutines.  While it is generally true for most languages that a\nlarge number of variables can trigger load/store operations when the\nregister capacity is exceeded, Parrot will switch from JIT code to\npurely interpreted code?  While most people don't worry about\nincurring a few load/store operations, this kind of variation may\ncause programmers to alter their programming style significantly in\norder to avoid unacceptable performance.\n\nAs you say, i386 has fewer registers, but it is a very common\nplatform.  Given that, many programmers may consider it necessary to\nwrite code that will be JIT-able on that platform, leading to a rather\nawkward programming style, encouraging the use of a larger number of\nsubroutines, thus more calling, and ultimately a lot of register\nshuffling anyway.\n\n > > b. How can a compiler efficiently allocate registers if it does not\n > > know which ones will map to hardware registers?\n >\n > I don't believe there's a capacity for doing this at the moment.   \nIt's\n > up to parrot to decide how much is jitted and how much isn't.\n\nWhen I asked this question, I thought I was asking if the compiler\ncould suggest which variables should map to registers and which ones\nshould be loaded/stored.  But it seems this is a question of which\nsubroutines will use registers at all.  In that case, I wonder what\nmechanisms Parrot will provide to inform a compiler how JIT-able a\nsubroutine is -- both on the current platform and on other\narchitectures -- to enable the compiler to know when it would make\nsense to either automatically modify the code into JIT-able form, or\nto warn the developer.\n\n > > 5. Parrot Design Issues\n > >\n > > Parrot has many operators and number of Core PMC types for them to\n > > operate on. Parrot has so many operators that it appears to be  \nusing\n > > them instead of having a standard library. This is markedly  \ndifferent\n > > than the CLR and JVM systems.\n > >\n > > a. Why was this done this way?\n >\n > If you look at the number of ops x86 has with an FPU, there are a\n > massive number.  The x87 cpu has an opcode for sine, just like parrot\n > does.  Many of parrot's opcodes are for accessing features of parrot\n > through pir.  Many of parrot's operations can't be easily taken away.\n > One of the likely reasons is speed, but what things are the  \nquestioner\n > curious about?\n\nFrankly, this is not much of an answer.  I am not asking if CISC\narchitectures exist, but rather I am asking why you are choosing to\ncreate one.\n\nMoreover, I am not questioning your choices in terms of design options\nand tradeoffs.  I am simply looking for the description of why what\nyou have was done the way you did it.\n\n > > b. What is the basis for deciding what will be an operator?\n > >\n > > c. How can substantial quantities of additional functionality be  \nadded\n > > to this design cleanly?\n >\n > New vtable's can be added by editting vtable.tbl, new ops can be  \nadded\n > by adding to src/ops/experimental.ops, new pmc's can just be added to\n > src/pmc afaik.  New charsets in src/charset, new jit architectures\n > under src/jit(just add --jitcapable and it'll try to compile it in).\n > I'd say it's a fairly clean layout for expanding things.  There's  \neven\n > the capacity for adding a new garbage collected.\n\nIt is not sufficient to say that one can write the code.  How will\nParrot inform an existing compiler that the new operation exists (or\ndoes not exist if the version of Parrot is older).  Will compilers\nhave to themselves be recompiled even if they do not use the new\noperators?\n\nAlso, this seems, as a design, to simply be a bag of operations.\n\nFinally, I would like to add some additional questions.\n\n2.h. Will Parrot support inline assembly language?\n\n2.i. Will Parrot support primitive types?\n\n4.c. How will registers benefit PMCs (e.g. PerlScalar), which are not\nprimitive types and cannot be stored in a hardware register?\n\n\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 120: add an explanation of ctdb_ltdb_lock_fetch_requeue() in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 120\nrevision-id: tridge@samba.org-20070416231820-74f66bb640e03880\nparent: tridge@samba.org-20070416231452-7dfc1928b2b71d20\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Tue 2007-04-17 09:18:20 +1000\nmessage:\n  add an explanation of ctdb_ltdb_lock_fetch_requeue()\nmodified:\n  common/ctdb_ltdb.c             ctdb_ltdb.c-20061128065342-to93h6eejj5kon81-2\n=== modified file 'common/ctdb_ltdb.c'\n--- a/common/ctdb_ltdb.c\t2007-04-16 13:52:14 +0000\n+++ b/common/ctdb_ltdb.c\t2007-04-16 23:18:20 +0000\n@@ -229,6 +229,21 @@\n /*\n   do a non-blocking ltdb_fetch with a locked record, deferring this\n   ctdb request until we have the chainlock\n+\n+  It does the following:\n+\n+   1) tries to get the chainlock. If it succeeds, then it fetches the record, and \n+      returns 0\n+\n+   2) if it fails to get a chainlock immediately then it sets up a\n+   non-blocking chainlock via ctdb_lockwait, and when it gets the\n+   chainlock it re-submits this ctdb request to the main packet\n+   receive function\n+\n+   This effectively queues all ctdb requests that cannot be\n+   immediately satisfied until it can get the lock. This means that\n+   the main ctdb daemon will not block waiting for a chainlock held by\n+   a client\n  */\n int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n \t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n\n"}
{"category": "ham", "to_address": "parrot-porters@perl.org", "from_address": "chromatic <chromatic@wgz.org>", "subject": "I Don't Understand The Context Allocation/Destruction Code", "body": "Parrot_alloc_context() performs some calculations about the number of \nregisters used to determine how much memory to allocate:\n\n    const size_t size_n = sizeof (FLOATVAL) * n_regs_used[REGNO_NUM];\n    const size_t size_nip = size_n +\n        sizeof (INTVAL) *   n_regs_used[REGNO_INT] +\n        sizeof (PMC*) *     n_regs_used[REGNO_PMC];\n    size_t reg_alloc = size_nip +\n        sizeof (STRING*) *  n_regs_used[REGNO_STR];\n\nThen it calculates a slot value:\n\n    const int slot = (reg_alloc + 7) >> 3;\n    reg_alloc = slot << 3;\n\nThis is where I start not to understand.  Why reg_alloc + 7?  Why shift left \nand right by 3?\n\nIt gets less clear.  The interpreter holds a structure for context memory with \na free list (an array of void pointers) and the number of free slots, \npresumably in this list.\n\nAfter all of that calculation of slot, the function uses it as an index into \nthe free list.\n\nI don't understand that at all.\n\nI do understand the purpose of the resizing code, but not how slot relates to \nit:\n\n    if (slot >= interp->ctx_mem.n_free_slots) {\n        const int n = slot + 1;\n        int i;\n\n        interp->ctx_mem.free_list = (void **)mem_sys_realloc(\n                interp->ctx_mem.free_list, n * sizeof (void*));\n\n        for (i = interp->ctx_mem.n_free_slots; i < n; ++i)\n            interp->ctx_mem.free_list[i] = NULL;\n        interp->ctx_mem.n_free_slots = n;\n    }\n\nThis is doubly weird because when Parrot initializes the free list in \ncreate_initial_context(), it allocates a small number of free slots:\n\n#define INITIAL_FREE_SLOTS 8\n\n    interp->ctx_mem.n_free_slots = INITIAL_FREE_SLOTS;\n    interp->ctx_mem.free_list    =\n        (void **)mem_sys_allocate(INITIAL_FREE_SLOTS * sizeof (void *));\n\n    for (i = 0; i < INITIAL_FREE_SLOTS; ++i)\n        interp->ctx_mem.free_list[i] = NULL;\n\nThe result is that the free_list extends quite a bit over the initial \nallocation, but it's mostly just an array of null.  It's fairly sparse apart \nfrom that.\n\nHere's another curious thing when allocating a context:\n\n    ptr = interp->ctx_mem.free_list[slot];\n    old = CONTEXT(interp->ctx);\n    if (ptr) {\n        interp->ctx_mem.free_list[slot] = *(void **) ptr;\n    }\n\nI wish I could tell you what the assignments to and from ptr do here, but I \ncan't, nor what they signify.  There's a similar form to free a context:\n\n        ptr = ctxp;\n        slot = ctxp->regs_mem_size >> 3;\n\n        assert(slot < interp->ctx_mem.n_free_slots);\n        *(void **)ptr = interp->ctx_mem.free_list[slot];\n        interp->ctx_mem.free_list[slot] = ptr;\n\nI originally thought the free_list was an array of recycled contexts to avoid \nmalloc() and free() pairs by reusing already-allocated-but-unused memory, but \nnow I can't tell what it's doing.  I tried to change this into a linked list, \nbut that failed with invalid reads.\n\nMy best guess is that this is an odd way to store contexts of a specific size \nin an array structure so that they're reusable with our new variable-sized \nregister sets... but the code is unclear and undocumented.  I think it's also \nleaking memory.\n\nI'd like to find a simpler scheme, if it's possible.  Otherwise, I'd like to \nfigure out what's going on so we can at least explain it somehow.\n\n-- c\n\n"}
{"category": "ham", "to_address": "\"Jeff Pang\" <pangj@earthlink.net>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: forking problem with dbd::mysql", "body": "On 5/9/07, Jeff Pang  wrote:\nsnip\n> Using InactiveDestroy flag seems a standard way since this module's author provide this flag.\n> But it's maybe bring some problems when the applications are large enough,and it's not\n> the fact that every programmer would disconnect their dbh connections in time.For\n> example,consider the case programs were run under modperl and without Apache::DBI,\n> using this flag would possibly make lots of db connections to database and consume db's\n> socket source quickly.\n>\n> Then for me I would maybe consider another way of creating its own dbh in child after fork.\n> Hope I'm right,:)\n\nThe only place InactiveDestroy is appropriate is just after a fork in\neither the parent or the child (depending on which one is keeping the\nhandle).  You should immediately disconnect the database handle after\nsetting the flag (either explicitly with disconnect or implicitly by\nopening another and assigning it to the same scalar).  In the case of\nthe code in question it looks like this\n\n                my $pid = fork();\n                if ($pid == 0 && defined($pid)){\n                        # child connection\n                        # do lots of stuff in here, including make our\nown db connection\n                        $dbh->{InactiveDestroy} = 1;\n                        $dbh = DBI->connect($dsn, $dbun, $dbpw,\n{RaiseError => 1});\n                        # do stuff\n                        exit;\n                } elsif ($pid) {\n                        # this is the parent - do nothing\n                } else {\n                        warn \"unable to fork: resources unavailable.\\n\";\n                }\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
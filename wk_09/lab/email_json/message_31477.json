{"category": "ham", "to_address": "\"Inman, Brant A. M.D.\" <Inman.Brant@mayo.edu>", "from_address": "Adaikalavan Ramasamy <ramasamy@cancer.org.uk>", "subject": "Re: [R] MICE for Cox model", "body": "I encountered this problem about 18 months ago. I contacted Prof. Fox \nand Dr. Malewski (the R package maintainers for mice) but they referred \nme to Prof. van Buuren. I wrote to Prof. van Buuren but am unable to \nfind his reply (if he did reply).\n\nHere are the functions I used at that time, if you want to take it with \nlots of salt. Let me know if you find anything fishy with it.\n\n\ncoxph.mids <- function (formula, data, ...) {\n\n   call <- match.call()\n   if (!is.mids(data)) stop(\"The data must have class mids\")\n\n   analyses <- as.list(1:data$m)\n\n   for (i in 1:data$m) {\n     data.i        <- complete(data, i)\n     analyses[[i]] <- coxph(formula, data = data.i, ...)\n   }\n\n   object <- list(call = call, call1 = data$call,\n                  nmis = data$nmis, analyses = analyses)\n\n   oldClass(object) <- if (.SV4.) \"mira\" else c(\"mira\", \"coxph\")\n   return(object)\n}\n\n\nAnd in the function 'pool', the small sample adjustment requires \nresidual degrees of freedom (i.e. dfc). For a cox model, I believe that \nthis is simply the number of events minus the regression coefficients. \nThere is support for this from middle of page 149 of the book by Parmer \n& Machin (ISBN 0471936405). Please correct me if I am wrong.\n\nHere is the slightly modified version of pool :\n\n\npool <- function (object, method = \"smallsample\") {\n\n   call <- match.call()\n   if (!is.mira(object)) stop(\"The object must have class 'mira'\")\n\n   if ((m <- length(object$analyses)) < 2)\n     stop(\"At least two imputations are needed for pooling.\\n\")\n\n   analyses <- object$analyses\n\n   k     <- length(coef(analyses[[1]]))\n   names <- names(coef(analyses[[1]]))\n   qhat  <- matrix(NA, nrow = m, ncol = k, dimnames = list(1:m, names))\n   u     <- array(NA, dim = c(m, k, k),\n                  dimnames = list(1:m, names, names))\n\n   for (i in 1:m) {\n     fit       <- analyses[[i]]\n     qhat[i, ] <- coef(fit)\n     u[i, , ]  <- vcov(fit)\n   }\n\n   qbar <- apply(qhat, 2, mean)\n   ubar <- apply(u, c(2, 3), mean)\n   e <- qhat - matrix(qbar, nrow = m, ncol = k, byrow = TRUE)\n   b <- (t(e) %*% e)/(m - 1)\n   t <- ubar + (1 + 1/m) * b\n   r <- (1 + 1/m) * diag(b/ubar)\n   f <- (1 + 1/m) * diag(b/t)\n   df <- (m - 1) * (1 + 1/r)2\n\n   if (method == \"smallsample\") {\n\n     if( any( class(fit) == \"coxph\" ) ){\n\n       ### this loop is the hack for survival analysis ###\n\n       status   <- fit$y[ , 2]\n       n.events <- sum(status == max(status))\n       p        <- length( coefficients( fit )  )\n       dfc      <- n.events - p\n\n     } else {\n\n       dfc <- fit$df.residual\n     }\n\n     df <- dfc/((1 - (f/(m + 1)))/(1 - f) + dfc/df)\n   }\n\n   names(r) <- names(df) <- names(f) <- names\n   fit <- list(call = call, call1 = object$call, call2 = object$call1,\n               nmis = object$nmis, m = m, qhat = qhat, u = u,\n               qbar = qbar, ubar = ubar, b = b, t = t, r = r, df = df,\n               f = f)\n   oldClass(fit) <- if (.SV4.) \"mipo\" else c(\"mipo\", oldClass(object))\n   return(fit)\n}\n\n\nprint.miro only gives the coefficients. Often I need the standard errors\nas well since I want to test if each regression coefficient from\nmultiple imputation is zero or not. Since the function summary.mipo does\nnot exist, can I suggest the following\n\n\nsummary.mipo <- function(object){\n\n    if (!is.null(object$call1)){\n      cat(\"Call: \")\n      dput(object$call1)\n    }\n\n    est  <- object$qbar\n    se   <- sqrt(diag(object$t))\n    tval <- est/se\n    df   <- object$df\n    pval <- 2 * pt(abs(tval), df, lower.tail = FALSE)\n\n    coefmat <- cbind(est, se, tval, pval)\n    colnames(coefmat) <- c(\"Estimate\", \"Std. Error\",\n                                         \"t value\", \"Pr(>|t|)\")\n\n    cat(\"\\nCoefficients:\\n\")\n    printCoefmat( coefmat, P.values=T, has.Pvalue=T, signif.legend=T )\n\n    cat(\"\\nFraction of information about the coefficients\n                                    missing due to nonresponse:\", \"\\n\")\n    print(object$f)\n\n    ans <- list( coefficients=coefmat, df=df,\n                 call=object$call1, fracinfo.miss=object$f )\n    invisible( ans )\n\n}\n\n\nHope this helps.\n\nRegards, Adai\n\n\n\nInman, Brant A. M.D. wrote:\n> R-helpers:\n> \n> I have a dataset that has 168 subjects and 12 variables.  Some of the\n> variables have missing data and I want to use the multiple imputation\n> capabilities of the \"mice\" package to address the missing data. Given\n> that mice only supports linear models and generalized linear models (via\n> the lm.mids and glm.mids functions) and that I need to fit Cox models, I\n> followed the previous suggestion of John Fox and have created my own\n> function \"cox.mids\" to use coxph to fit models to the imputed datasets.\n> \n> (http://tolstoy.newcastle.edu.au/R/help/06/03/22295.html)\n> \n> The function I created is:\n> \n> ------------\n> \n> cox.mids <- function (formula, data, ...)\n> {\n>     call <- match.call()\n>     if (!is.mids(data)) \n>         stop(\"The data must have class mids\")\n>     analyses <- as.list(1:data$m)\n>     for (i in 1:data$m) {\n>         data.i <- complete(data, i)\n>         analyses[[i]] <- coxph(formula, data = data.i, ...)\n>     }\n>     object <- list(call = call, call1 = data$call, nmis = data$nmis, \n>         analyses = analyses)\n>     oldClass(object) <- c(\"mira\", \"coxph\")\n>     return(object)\n> }\n> \n> ------------\n> \n> The problem that I encounter occurs when I try to use the \"pool\"\n> function to pool the fitted models into one general model. Here is some\n> code that reproduces the error using the pbc dataset.\n> \n> ------------\n> \n> d <- pbc[,c('time','status','age','sex','hepmeg','platelet', 'trt',\n> 'trig')]\n> d[d==-9] <- NA \n> d[,c(4,5,7)] <- lapply(d[,c(4,5,7)], FUN=as.factor)\n> str(d)\n> \n> imp <- mice(d, m=10, maxit=10, diagnostics=T, seed=500, \n> \tdefaultImputationMethod=c('norm', 'logreg', 'polyreg'))\n> \n> fit <- cox.mids(Surv(time,status) ~ age + sex + hepmeg + platelet + trt\n> + \ttrig, imp)\n> \n> pool(fit)\n> \n> ------------\n> \n> I have looked at the \"pool\" function but cannot figure out what I have\n> done wrong.  Would really appreciate any help with this.\n> \n> Thanks,\n> \n> Brant Inman\n> Mayo Clinic\n> \n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n> \n> \n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
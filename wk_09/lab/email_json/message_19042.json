{"category": "ham", "to_address": "samba-technical@lists.samba.org", "from_address": "tridge@samba.org", "subject": "Re: svn commit: samba r22539 - in branches:\n SAMBA_3_0/source/lib/talloc\n SAMBA_3_0_25/source/lib/talloc SAMBA_4_0/source/lib/talloc", "body": " > can you also update the documentation?\n > lib/talloc/talloc.3.xml and lib/talloc/talloc_guide.txt\n\nNO!!!!!\n\ntalloc checking for 'zero' as special is totally bogus. Please don't\nwaste time updating the docs, or updating talloc. Please also remove\nit from the samba4 talloc.\n\nJeremy, if you want a special wrapper for Samba3, then please create\nyour own lib/util_talloc.c and put the wrapper there. Better still,\nthink some more and I think you will realise that returning a valid\npointer for a zero length talloc is _correct_. This is even more the\ncase for talloc() than it is for malloc(), as for talloc the context\nmatters, so it is a quite valid and useful pattern to create an\ninitially zero length piece of memory and expand it later (as was done\nin Samba3 and which was broken by your change).\n\nI haven't looked at the bug that triggered this thread, but I'm\nwilling to bet the bug was not truly caused by talloc returning a\npointer on zero length, but instead by a routine not validating its\ninputs for the constraints of the routine, and now you've put in code\nto use talloc as a crutch for incorrect parameter checking.\n\nGet this out of talloc.c and talloc.h please. The _strict() idea is\nbogus. The \"strictly correct\" behaviour is exactly what talloc already\ndid. This was no accident in the design of talloc - it is exactly as\nit was designed to behave.\n\nCheers, Tridge\n\n"}
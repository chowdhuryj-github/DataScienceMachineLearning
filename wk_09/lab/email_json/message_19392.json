{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "mimir@samba.org", "subject": "svn commit: samba r22565 - in branches/SAMBA_4_0/source/libnet: .", "body": "Author: mimir\nDate: 2007-04-29 12:31:09 +0000 (Sun, 29 Apr 2007)\nNew Revision: 22565\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22565\n\nLog:\nadd libnet_DomainList function.\n\n\nrafal\n\n\nModified:\n   branches/SAMBA_4_0/source/libnet/libnet_domain.c\n   branches/SAMBA_4_0/source/libnet/libnet_domain.h\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/libnet/libnet_domain.c\n===================================================================\n--- branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-04-29 00:09:22 UTC (rev 22564)\n+++ branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-04-29 12:31:09 UTC (rev 22565)\n@@ -845,3 +845,250 @@\n \tc = libnet_DomainClose_send(ctx, io, NULL);\n \treturn libnet_DomainClose_recv(c, ctx, mem_ctx, io);\n }\n+\n+\n+struct domain_list_state {\t\n+\tstruct libnet_context *ctx;\n+\tstruct libnet_RpcConnect rpcconn;\n+\tstruct samr_Connect samrconn;\n+\tstruct samr_EnumDomains enumdom;\n+\tconst char *hostname;\n+\tstruct policy_handle connect_handle;\n+\tint buf_size;\n+\tstruct domainlist *domains;\n+\tuint32_t resume_handle;\n+\tuint32_t count;\n+\n+\tvoid (*monitor_fn)(struct monitor_msg*);\n+};\n+\n+\n+static void continue_rpc_connect(struct composite_context *c);\n+static void continue_samr_connect(struct rpc_request *c);\n+static void continue_samr_enum_domains(struct rpc_request *req);\n+\n+static struct domainlist* get_domain_list(TALLOC_CTX *mem_ctx, struct domain_list_state *s);\n+\n+\n+/*\n+  Stage 1: Receive connected rpc pipe and send connection\n+  request to SAMR service\n+*/\n+static void continue_rpc_connect(struct composite_context *ctx)\n+{\n+\tstruct composite_context *c;\n+\tstruct domain_list_state *s;\n+\tstruct rpc_request *samrconn_req;\n+\n+\tc = talloc_get_type(ctx->async.private_data, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_list_state);\n+\t\n+\tc->status = libnet_RpcConnect_recv(ctx, s->ctx, c, &s->rpcconn);\n+\tif (!composite_is_ok(c)) return;\n+\n+\ts->samrconn.in.system_name     = 0;\n+\ts->samrconn.in.access_mask     = SEC_GENERIC_READ;     /* should be enough */\n+\ts->samrconn.out.connect_handle = &s->connect_handle;\n+\n+\tsamrconn_req = dcerpc_samr_Connect_send(s->ctx->samr.pipe, c, &s->samrconn);\n+\tif (composite_nomem(samrconn_req, c)) return;\n+\n+\tcomposite_continue_rpc(c, samrconn_req, continue_samr_connect, c);\n+}\n+\n+\n+/*\n+  Stage 2: Receive policy handle to the connected SAMR service and issue\n+  a request to enumerate domain databases available\n+*/\n+static void continue_samr_connect(struct rpc_request *req)\n+{\n+\tstruct composite_context *c;\n+\tstruct domain_list_state *s;\n+\tstruct rpc_request *enumdom_req;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_list_state);\n+\t\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n+\n+\ts->enumdom.in.connect_handle = &s->connect_handle;\n+\ts->enumdom.in.resume_handle  = &s->resume_handle;\n+\ts->enumdom.in.buf_size       = s->buf_size;\n+\ts->enumdom.out.resume_handle = &s->resume_handle;\n+\n+\tenumdom_req = dcerpc_samr_EnumDomains_send(s->ctx->samr.pipe, c, &s->enumdom);\n+\tif (composite_nomem(enumdom_req, c)) return;\n+\n+\tcomposite_continue_rpc(c, enumdom_req, continue_samr_enum_domains, c);\n+}\n+\n+\n+/*\n+  Stage 3: Receive domain names available and repeat the request\n+  enumeration is not complete yet\n+*/\n+static void continue_samr_enum_domains(struct rpc_request *req)\n+{\n+\tstruct composite_context *c;\n+\tstruct domain_list_state *s;\n+\tstruct rpc_request *enumdom_req;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_list_state);\n+\t\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n+\n+\tif (NT_STATUS_IS_OK(s->enumdom.out.result)) {\n+\n+\t\ts->domains = get_domain_list(c, s);\n+\t\tcomposite_done(c);\n+\n+\t} else if (NT_STATUS_EQUAL(s->enumdom.out.result, STATUS_MORE_ENTRIES)) {\n+\t\t\n+\t\ts->domains = get_domain_list(c, s);\n+\t\t\n+\t\ts->enumdom.in.connect_handle = &s->connect_handle;\n+\t\ts->enumdom.in.resume_handle  = &s->resume_handle;\n+\t\ts->enumdom.in.buf_size       = s->buf_size;\n+\t\ts->enumdom.out.resume_handle = &s->resume_handle;\n+\n+\t\tenumdom_req = dcerpc_samr_EnumDomains_send(s->ctx->samr.pipe, c, &s->enumdom);\n+\t\tif (composite_nomem(enumdom_req, c)) return;\n+\n+\t\tcomposite_continue_rpc(c, enumdom_req, continue_samr_enum_domains, c);\n+\n+\t} else {\n+\t\tcomposite_error(c, s->enumdom.out.result);\n+\t}\n+}\n+\n+\n+/*\n+  Utility function to copy domain names from result of samr_EnumDomains call\n+*/\n+static struct domainlist* get_domain_list(TALLOC_CTX *mem_ctx, struct domain_list_state *s)\n+{\n+\tint i;\n+\tif (mem_ctx == NULL || s == NULL) return NULL;\n+\n+\t/* number of entries returned (domains enumerated) */\n+\ts->count = s->enumdom.out.num_entries;\n+\t\n+\t/* copy domain names returned from samr_EnumDomains call */\n+\ts->domains = talloc_array(mem_ctx, struct domainlist, s->enumdom.out.num_entries);\n+\tfor (i = 0; i < s->enumdom.out.num_entries; i++)\n+\t{\n+\t\t/* strdup name as a child of allocated array to make it follow the array\n+\t\t   in case of talloc_steal or talloc_free */\n+\t\ts->domains[i].name = talloc_strdup(s->domains,\n+\t\t\t\t\t\t   s->enumdom.out.sam->entries[i].name.string);\n+\t\ts->domains[i].sid  = NULL;  /* this is to be filled out later */\n+\t}\n+\n+\treturn s->domains;\n+}\n+\n+\n+/**\n+ * Sends a request to list domains on given host\n+ *\n+ * @param ctx initalised libnet context\n+ * @param mem_ctx memory context\n+ * @param io arguments and results of the call\n+ * @param monitor pointer to monitor function that is passed monitor messages\n+ */\n+\n+struct composite_context* libnet_DomainList_send(struct libnet_context *ctx,\n+\t\t\t\t\t\t TALLOC_CTX *mem_ctx,\n+\t\t\t\t\t\t struct libnet_DomainList *io,\n+\t\t\t\t\t\t void (*monitor)(struct monitor_msg*))\n+{\n+\tstruct composite_context *c;\n+\tstruct domain_list_state *s;\n+\tstruct composite_context *rpcconn_req;\n+\n+\t/* composite context and state structure allocation */\n+\tc = composite_create(ctx, ctx->event_ctx);\n+\tif (c == NULL) return c;\n+\n+\ts = talloc_zero(c, struct domain_list_state);\n+\tif (composite_nomem(s, c)) return c;\n+\n+\tc->private_data = s;\n+\ts->monitor_fn   = monitor;\n+\n+\ts->ctx      = ctx;\n+\ts->hostname = talloc_strdup(c, io->in.hostname);\n+\tif (composite_nomem(s->hostname, c)) return c;\n+\n+\t/* set the default buffer size if not stated explicitly */\n+\ts->buf_size = (io->in.buf_size == 0) ? 512 : io->in.buf_size;\n+\n+\t/* prepare rpc connect call */\n+\ts->rpcconn.level           = LIBNET_RPC_CONNECT_SERVER;\n+\ts->rpcconn.in.name         = s->hostname;\n+\ts->rpcconn.in.dcerpc_iface = &dcerpc_table_samr;\n+\n+\trpcconn_req = libnet_RpcConnect_send(ctx, c, &s->rpcconn);\n+\tif (composite_nomem(rpcconn_req, c)) return c;\n+\n+\tcomposite_continue(c, rpcconn_req, continue_rpc_connect, c);\n+\treturn c;\n+}\n+\n+\n+/**\n+ * Receive result of domain list request\n+ *\n+ * @param c composite context returned by DomainList_send function\n+ * @param ctx initialised libnet context\n+ * @param mem_ctx memory context of the call\n+ * @param io results and arguments of the call\n+ */\n+\n+NTSTATUS libnet_DomainList_recv(struct composite_context *c, struct libnet_context *ctx,\n+\t\t\t\tTALLOC_CTX *mem_ctx, struct libnet_DomainList *io)\n+{\n+\tNTSTATUS status;\n+\tstruct domain_list_state *s;\n+\n+\tstatus = composite_wait(c);\n+\n+\ts = talloc_get_type(c->private_data, struct domain_list_state);\n+\n+\tif (NT_STATUS_IS_OK(status) && ctx && mem_ctx && io) {\n+\t\t/* fetch the results to be returned by io structure */\n+\t\tio->out.count        = s->count;\n+\t\tio->out.domains      = talloc_steal(mem_ctx, s->domains);\n+\t\tio->out.error_string = talloc_asprintf(mem_ctx, \"Success\");\n+\n+\t} else if (!NT_STATUS_IS_OK(status)) {\n+\t\t/* there was an error, so return description of the status code */\n+\t\tio->out.error_string = talloc_asprintf(mem_ctx, \"Error: %s\", nt_errstr(status));\n+\t}\n+\n+\ttalloc_free(c);\n+\treturn status;\n+}\n+\n+\n+/**\n+ * Synchronous version of DomainList call\n+ *\n+ * @param ctx initialised libnet context\n+ * @param mem_ctx memory context for the call\n+ * @param io arguments and results of the call\n+ * @return nt status code of execution\n+ */\n+\n+NTSTATUS libnet_DomainList(struct libnet_context *ctx, TALLOC_CTX *mem_ctx,\n+\t\t\t   struct libnet_DomainList *io)\n+{\n+\tstruct composite_context *c;\n+\n+\tc = libnet_DomainList_send(ctx, mem_ctx, io, NULL);\n+\treturn libnet_DomainList_recv(c, ctx, mem_ctx, io);\n+}\n\nModified: branches/SAMBA_4_0/source/libnet/libnet_domain.h\n===================================================================\n--- branches/SAMBA_4_0/source/libnet/libnet_domain.h\t2007-04-29 00:09:22 UTC (rev 22564)\n+++ branches/SAMBA_4_0/source/libnet/libnet_domain.h\t2007-04-29 12:31:09 UTC (rev 22565)\n@@ -47,3 +47,21 @@\n \t\tconst char *error_string;\n \t} out;\n };\n+\n+\n+struct libnet_DomainList {\n+\tstruct {\n+\t\tconst char *hostname;\n+\t\tconst int buf_size;\n+\t} in;\n+\tstruct {\n+\t\tint count;\n+\t\t\n+\t\tstruct domainlist {\n+\t\t\tconst char *sid;\n+\t\t\tconst char *name;\n+\t\t} *domains;\n+\n+\t\tconst char *error_string;\n+\t} out;\n+};\n\n"}
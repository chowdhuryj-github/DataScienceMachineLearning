{"category": "ham", "to_address": "Jonathan Worthington <jonathan@jnthn.net>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: Class/Role namespace links", "body": "Jonathan Worthington wrote:\n> Hi,\n> \n> Tonight I started working on the association between classes and \n> namespaces as specified in PDD15. Have some questions.\n> \n> 1) I added a \"slot\" to the NameSpace PMC to hold a Class or Role PMC a \n> while back. However, there is no interface specified for storing/getting \n> at this slot. For now I've added \"set_class\" and \"get_class\" METHODs to \n> the NameSpace PMC. What should these actually be called (if something \n> else)? Whatever is decided on should be added to a PDD somewhere - I \n> guess the NameSpce PDD.\n\nThumbs up: 'set_class' and 'get_class' are consistent with the other \nmethods in the namespace PDD.\n\n> 2) I see that we now just have a .name method and no .namespace method. \n> For Class, the description of the name method says:\n> \n> \"The accessor for the name attribute. With no argument, it simply \n> returns the current value for name. When passed an argument, it sets the \n> name of the class, and also sets the association with a namespace. With \n> no argument it only returns the current value of the name attribute.\"\n> \n> That is a little unclear to me. What should the name slot be set to - \n> the name of the most nested bit of the namespace (e.g. for [ \"Animal\" ; \n> \"Monkey\" ], name is \"Monkey\")?\n> \n> Also, what should it return? Just the name attribute? What if you really \n> want to get at the namespace?\n\nThe class name isn't necessary for instantiating an object from the \nclass, so it's really just a bit of bookkeeping. I expect the name will \ncorrespond to: the HLL name for the class, the type a class represents, \nor an answer for \"does\" that isn't tied to the namespace, inheritance \nhierarchy, or role composition for a class. The most nested namespace is \na reasonable default.\n\nThe accessor part has largely been replaced by:\n\n   inspect classobject, 'name'\n   inspect classobject, 'namespace'\n\nSo, it's really a huffman question: is retrieving the namespace for a \nclass common enough to need a shortcut? Hmmm... common enough to provide \nsyntactic sugar in the optionally added methods for the Class PMC and \nRole PMC.\n\nThe setting of name and namespace primarily happens during a 'new' \noperation (i.e. newclass). You should be able to pass in both 'name' and \n'namespace' to 'new'. Without 'namespace' it should assume that the \nnamespace for the class has the same name as 'name' and is nested within \nthe namespace that has been selected in the context where 'new' is called.\n\nDynamically renaming classes and reassociating them with a new namespace \nis trickier. I'd say that's magic that should be possible, but perhaps \nnot extremely simple. So, in the optional add-on methods, make the \n'name' method set the name and namespace (following the same rules as \n'new'), and make the 'namespace' method set just the namespace.\n\nFor low-level changes of name and namespace, you're essentially \nreinitializing a class when you change its name or namespace, so I'm \ninclined to actually make this an initialization operation. If we gave \nthe 'clone' opcode an (optional) third PMC parameter of arguments like \n'new', it could fit the bill.\n\n   .local pmc initargs, renamed_class\n   initargs = new Hash\n   initargs['name'] = 'Foo'\n   initargs['namespace'] = namespace_object\n\n   renamedclass = clone oldclass, initargs\n\nWhat that doesn't give us is the illusion of \"renaming in place\" that \nother class modifications like 'add_method' have. I'm okay with that \n(for now), because renaming an existing class seems much rarer than \nadding a method or attribute to an existing class.\n\n> 3) For Role (but not Class - mistake?), it says:\n> \n> \"When you associate a class with a namespace, it pulls in all of the \n> methods and vtable methods held within that namespace.\"\n\nWe're gradually working toward the opposite: methods and vtable methods \naren't stored in the namespace at all, but only in the class. I'll \ndelete it from the PDD (already deleted it from the Class section, which \nexplains the inconsistency).\n\n> At the moment, we do not carry the \":method\" adverb on subs through to \n> the PBC. Thus while I guess you can iterate a namespace (not tried it \n> yet, just assuming you can since it's derived from Hash) and test for \n> PMCs to make sure they are Subs. However, beyond that you have no way of \n> knowing if it's a method or not (so far as I can see, I'd love to be \n> corrected on this if anyone knows otherwise). Should :method be carried \n> through to a PBC level?\n\nNot for this, but all adverbs should make their way down to the PBC \nlevel in some form. Adverbs may not be a flag, but simply affect how the \nsub was constructed, or what kind of sub was constructed.\n\n> 4) After this it says:\n> \n> \"And when replacing one class with another in the association, it \n> removes any methods and vtable methods from the previous class.\"\n> \n> Remove methods from what? The class or the namespace? If the class, does \n> it remove all methods from the class then pull in ones from the new \n> namespace? Or do we look at the old namespace and see what methods it \n> has, then remove just ones that appear there?\n\nThis was to handle cases where the the methods and vtable entries were \nstored both in the namespace and in the class. As long as that's true, \nany time we replace the class a particular namespace references \n(possibly just by updating a class that's already been instantiated) \nwe'll need to make sure that the information the namespace had stored is \nreplaced with the information for the new class.\n\nIf they're only stored in the class (which will ultimately be true), \nthen all it needs to do is replace the namespace's pointer to the class.\n\nAllison\n\n"}
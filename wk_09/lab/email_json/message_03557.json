{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "yoooooo <magno_yu@ml.com>", "subject": "Re: [R] Memory management", "body": "\nOkay thanks, I'm going through the docs now.. and I came through this.. \n\nThe named field is set and accessed by the SET_NAMED and NAMED macros, and\ntake values 0, 1 and 2. R has a `call by value' illusion, so an assignment\nlike \n     b <- a\nappears to make a copy of a and refer to it as b. However, if neither a nor\nb are subsequently altered there is no need to copy. What really happens is\nthat a new symbol b is bound to the same value as a and the named field on\nthe value object is set (in this case to 2). When an object is about to be\naltered, the named field is consulted. A value of 2 means that the object\nmust be duplicated before being changed. \n\nWhat does it mean \"the new symbol b is bound to the same value as a\". \nDoes it mean b has a pointer pointing to a? \n\nThanks!!\n- yooooooooooo\n\n\nyoooooo wrote:\n> \n> I guess I have more reading to do.... Are there any website that I can\n> read up on memory management, or specifically what happen when we 'pass\n> in' variables, which strategy is better at which situation? \n> \n> Thanks~\n> - yoooooooo\n> \n> \n> Prof Brian Ripley wrote:\n>> \n>> On Tue, 10 Apr 2007, yoooooo wrote:\n>> \n>>>\n>>> Hi all, I'm just curious how memory management works in R... I need to\n>>> run an\n>>> optimization that keeps calling the same function with a large set of\n>>> parameters... so then I start to wonder if it's better if I attach the\n>>> variables first vs passing them in (coz that involves a lot of copying..\n>>> )\n>> \n>> Your paranethetical comment is wrong: no copying is needed to 'pass in' a \n>> variable.\n>> \n>>> Thus, I do this\n>>> fn3 <- function(x, y, z, a, b, c){ sum(x, y, z, a, b, c) }\n>>> fn4 <- function(){ sum(x, y, z, a, b, c) }\n>>>\n>>> rdn <- rep(1.1, times=1e8)\n>>> r <- proc.time()\n>>> for (i in 1:5)\n>>>  fn3(rdn, rdn, rdn, rdn, rdn, rdn)\n>>> time1 <- proc.time() - r\n>>> print(time1)\n>>>\n>>> lt <- list(x = rdn, y = rdn, z = rdn, a = rdn, b = rdn, c = rdn)\n>>> attach(lt)\n>>> r <- proc.time()\n>>> for (i in 1:5)\n>>>  fn4()\n>>> time2 <- proc.time() - r\n>>> print(time2)\n>>> detach(\"lt\")\n>>>\n>>> The output is\n>>> [1] 25.691  0.003 25.735  0.000  0.000\n>>> [1] 25.822  0.005 25.860  0.000  0.000\n>>>\n>>> Turns out attaching takes longer to run.. which is counter intuitive\n>>> (unless\n>>> the search to the pos=2 envir takes long time as well) Do you guys know\n>>> why\n>>> this is the case?\n>> \n>> I would not trust timing differences of that nature: they often depend on \n>> the state of the system, and in particular of the garbage collector.\n>> You should be using system.time() for that reason: it calls the garbage \n>> collector immediately before timing.\n>> \n>> -- \n>> Brian D. Ripley,                  ripley@stats.ox.ac.uk\n>> Professor of Applied Statistics,  http://www.stats.ox.ac.uk/~ripley/\n>> University of Oxford,             Tel:  +44 1865 272861 (self)\n>> 1 South Parks Road,                     +44 1865 272866 (PA)\n>> Oxford OX1 3TG, UK                Fax:  +44 1865 272595\n>> \n>> ______________________________________________\n>> R-help@stat.math.ethz.ch mailing list\n>> https://stat.ethz.ch/mailman/listinfo/r-help\n>> PLEASE do read the posting guide\n>> http://www.R-project.org/posting-guide.html\n>> and provide commented, minimal, self-contained, reproducible code.\n>> \n>> \n> \n> \n\n-- \nView this message in context: http://www.nabble.com/Memory-management-tf3556238.html#a9961010\nSent from the R help mailing list archive at Nabble.com.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
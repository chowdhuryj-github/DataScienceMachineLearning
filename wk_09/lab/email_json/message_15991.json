{"category": "ham", "to_address": "Johannes Bauer <dfnsonfsduifb@gmx.de>", "from_address": "derrell@samba.org", "subject": "Re: libsmbclient: smbc_stat buffer overflow", "body": "Johannes Bauer  writes:\n\n> Hello list,\n>\n> I've recently encountered a problem with libsmbclient which causes the\n> smb_stat function to write over the \"struct stat\" buffer exactly 8 bytes\n> on x86_32 (i686) systems. x86_64 seems not to be affected.\n>\n> Affected versions:\n>   3.0.22 (Ubuntu)\n>   3.0.24 (Gentoo)\n>   3.0.24 (Gentoo, different system)\n>\n> This program demonstrates the problem (replace //joeserver/transfer by a\n> valid samba share, of course):\n\nYou don't indicate how you compiled this program, but I suspect that\nlibsmbclient is compiled for large file support, while your application is\nnot.  That would cause libsmbclient to be using different size fields in\nstruct stat than your program is assuming.\n\nPlease try compiling your program with these additional compile flags, and\nconfirm that this fixes the problem (or not):\n\n  -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64\n\nCheers,\n\nDerrell\n\n\n> #include \n> #include \n> #include \n> #include \n> #include \n> #include \n> #include \n>\n> struct smbstat {\n> \tstruct stat stat;\n> \tunsigned char pad[16];\n> };\n>\n> static void Authentication_Function(const char *pServer, const char\n> *pShare, char *pWorkgroup, int workgroup_len, char *pUsername, int\n> username_len, char *pPassword, int password_len) {\n>     strncpy(pUsername, \"guest\", username_len);\n>     strncpy(pPassword, \"\", password_len);\n> }\n>\n> int main(int argc, char **argv) {\n> \tint dir;\n> \tstruct smbc_dirent *Directory_Entry;\n> \tchar Buffer[256];\n>\n> \tif (smbc_init(Authentication_Function, 0) != 0) {\n> \t\tfprintf(stderr, \"smblister: Could not initialize smbc-library.\\n\");\n> \t\texit(6);\n> \t}\n>\n> \tdir = smbc_opendir(\"smb://joeserver/transfer\");\n> \t\n> \twhile ((Directory_Entry = smbc_readdir(dir)) != NULL) {\n> \t\tif (Directory_Entry->smbc_type == SMBC_FILE) {\n> \t\t\tint i;\n> \t\t\toff_t Filesize;\n> \t\t\tstruct smbstat Filestats;\n> \t\t\tmemset(&Filestats, 0x63, sizeof(struct smbstat));\n> \t\t\tsnprintf(Buffer, sizeof(Buffer), \"smb://joeserver/transfer/%s\",\n> Directory_Entry->name);\n> \t\t\tif (!smbc_stat(Buffer, (struct stat*)&Filestats)) {\n> \t\t\t\tFilesize = Filestats.stat.st_size;\n> \t\t\t} else {\n> \t\t\t\tFilesize = 0;\n> \t\t\t}\n> \t\t\tprintf(\"%s %ld\\n\", Directory_Entry->name, Filesize);\n> \t\t\tfor (i = 0; i < 16; i++) printf(\"%02x \", Filestats.pad[i]);\n> \t\t\tprintf(\"\\n\");\n> \t\t}\n> \t}\n> \t\n> \tsmbc_closedir(dir);\n> \treturn 0;\n> }\n>\n> And the output on an i686 machine:\n>\n> out.bmp 3932214\n> 16 2f 00 00 00 00 00 00 63 63 63 63 63 63 63 63\n> x.pdf 296844\n> 14 09 00 00 00 00 00 00 63 63 63 63 63 63 63 63\n>\n> Clearly it can be seen that the first eight bytes of \"pad\" become\n> overwritten.\n>\n> I've traced this error down to this point - it has, of course,\n> catastrophal consequences: programs using the smb_stat sometimes showed\n> chrashing (segfaults) und undefined behaviour (defect samba contexts).\n> Exploitation of this bug seems unlinkely, however.\n>\n> Please tell me what you think.\n> Thank you,\n> Greetings,\n> Johannes\n>\n>\n\n-- \n\n"}
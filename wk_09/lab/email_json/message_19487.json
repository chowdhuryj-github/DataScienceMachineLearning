{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "psomogyi@gamax.hu", "subject": "Rev 91: merged tridge's branch again in\n\thttp://samba.org/~tridge/psomogyi/", "body": "------------------------------------------------------------\nrevno: 91\nrevision-id: psomogyi@gamax.hu-20070429142835-4pd7m24sjko801ye\nparent: psomogyi@gamax.hu-20070429142748-xzhvikj20c14dnaf\nparent: tridge@samba.org-20070429141940-kxbij0fq3pj33qvn\ncommitter: Peter Somogyi \nbranch nick: ctdb\ntimestamp: Sun 2007-04-29 16:28:35 +0200\nmessage:\n  merged tridge's branch again\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n  common/ctdb_control.c          ctdb_control.c-20070426122724-j6gkpiofhbwdin63-1\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n  common/ctdb_io.c               ctdb_io.c-20070409200335-dzfc7f3rra5rcf60-1\n  common/ctdb_util.c             ctdb_util.c-20061128065342-to93h6eejj5kon81-3\n  direct/ctdbd.c                 ctdbd.c-20070411085044-dqmhr6mfeexnyt4m-1\n  include/ctdb.h                 ctdb.h-20061117234101-o3qt14umlg9en8z0-11\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n  tools/ctdb_control.c           ctdb_control.c-20070426122705-9ehj1l5lu2gn9kuj-1\n    ------------------------------------------------------------\n    revno: 44.1.177\n    merged: tridge@samba.org-20070429141940-kxbij0fq3pj33qvn\n    parent: tridge@samba.org-20070428171336-4yw1gh5qfslqan73\n    committer: Andrew Tridgell \n    branch nick: tridge\n    timestamp: Sun 2007-04-29 16:19:40 +0200\n    message:\n      yay! finally fixed the bug that volker, ronnie and I have been chasing\n      for 2 days.\n      \n      The main bug was in smbd, but there was a secondary (and more subtle)\n      bug in ctdb that the bug in smbd exposed. When we get send a dmaster\n      reply, we have to correctly update the dmaster in the recipient even\n      if the original requst has timed out, otherwise ctdbd can get into a\n      loop fighting over who will handle a key.\n      \n      This patch also cleans up the packet allocation, and makes ctdbd\n      become a real daemon.\n    ------------------------------------------------------------\n    revno: 44.1.176\n    merged: tridge@samba.org-20070428171336-4yw1gh5qfslqan73\n    parent: tridge@samba.org-20070428165537-dq8tirclx8okd1ec\n    committer: Andrew Tridgell \n    branch nick: tridge\n    timestamp: Sat 2007-04-28 19:13:36 +0200\n    message:\n      added reset status control\n    ------------------------------------------------------------\n    revno: 44.1.175\n    merged: tridge@samba.org-20070428165537-dq8tirclx8okd1ec\n    parent: tridge@samba.org-20070428161833-g1jbj1dibtxk28ih\n    committer: Andrew Tridgell \n    branch nick: tridge\n    timestamp: Sat 2007-04-28 18:55:37 +0200\n    message:\n      removed unnecessary variable\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-04-28 16:18:33 +0000\n+++ b/common/ctdb_call.c\t2007-04-29 14:19:40 +0000\n@@ -211,15 +211,19 @@\n \ttmp_ctx = talloc_new(ctdb);\n \n \t/* send the CTDB_REPLY_DMASTER */\n-\tlen = offsetof(struct ctdb_reply_dmaster, data) + data.dsize;\n+\tlen = offsetof(struct ctdb_reply_dmaster, data) + key.dsize + data.dsize;\n \tr = ctdb_transport_allocate(ctdb, tmp_ctx, CTDB_REPLY_DMASTER, len,\n \t\t\t\t    struct ctdb_reply_dmaster);\n \tCTDB_NO_MEMORY_FATAL(ctdb, r);\n \n \tr->hdr.destnode  = new_dmaster;\n \tr->hdr.reqid     = reqid;\n+\tr->rsn           = header->rsn;\n+\tr->keylen        = key.dsize;\n \tr->datalen       = data.dsize;\n-\tmemcpy(&r->data[0], data.dptr, data.dsize);\n+\tr->db_id         = ctdb_db->db_id;\n+\tmemcpy(&r->data[0], key.dptr, key.dsize);\n+\tmemcpy(&r->data[key.dsize], data.dptr, data.dsize);\n \n \tctdb_queue_packet(ctdb, &r->hdr);\n \n@@ -256,6 +260,7 @@\n \tr->hdr.destnode  = lmaster;\n \tr->hdr.reqid     = c->hdr.reqid;\n \tr->db_id         = c->db_id;\n+\tr->rsn           = header->rsn;\n \tr->dmaster       = c->hdr.srcnode;\n \tr->keylen        = key->dsize;\n \tr->datalen       = data->dsize;\n@@ -276,39 +281,43 @@\n \n   must be called with the chainlock held. This function releases the chainlock\n */\n-static void ctdb_become_dmaster(struct ctdb_context *ctdb, \n-\t\t\t\tuint32_t reqid, TDB_DATA data)\n+static void ctdb_become_dmaster(struct ctdb_db_context *ctdb_db, \n+\t\t\t\tuint32_t reqid, TDB_DATA key, TDB_DATA data,\n+\t\t\t\tuint64_t rsn)\n {\n \tstruct ctdb_call_state *state;\n-\tstruct ctdb_db_context *ctdb_db;\n+\tstruct ctdb_context *ctdb = ctdb_db->ctdb;\n+\tstruct ctdb_ltdb_header header;\n+\n+\tDEBUG(2,(\"vnn %u dmaster response %08x\\n\", ctdb->vnn, ctdb_hash(&key)));\n+\n+\tZERO_STRUCT(header);\n+\theader.rsn = rsn;\n+\theader.dmaster = ctdb->vnn;\n+\n+\tif (ctdb_ltdb_store(ctdb_db, key, &header, data) != 0) {\n+\t\tctdb_fatal(ctdb, \"ctdb_reply_dmaster store failed\\n\");\n+\t\tctdb_ltdb_unlock(ctdb_db, key);\n+\t\treturn;\n+\t}\n \n \tstate = ctdb_reqid_find(ctdb, reqid, struct ctdb_call_state);\n \n \tif (state == NULL) {\n+\t\tDEBUG(0,(\"vnn %u Invalid reqid %u in ctdb_become_dmaster\\n\",\n+\t\t\t ctdb->vnn, reqid));\n+\t\tctdb_ltdb_unlock(ctdb_db, key);\n \t\treturn;\n \t}\n \n \tif (reqid != state->reqid) {\n \t\t/* we found a record  but it was the wrong one */\n-\t\tDEBUG(0, (\"Dropped orphaned dmaster reply with reqid:%d\\n\",reqid));\n-\t\treturn;\n-\t}\n-\n-\tctdb_db = state->ctdb_db;\n-\n-\tDEBUG(2,(\"vnn %u dmaster response %08x\\n\", \n-\t\t ctdb->vnn, ctdb_hash(&state->call.key)));\n-\n-\t/* we're now the dmaster - update our local ltdb with new header\n-\t   and data */\n-\tstate->header.dmaster = ctdb->vnn;\n-\n-\tif (ctdb_ltdb_store(ctdb_db, state->call.key, &state->header, data) != 0) {\n-\t\tctdb_fatal(ctdb, \"ctdb_reply_dmaster store failed\\n\");\n-\t\treturn;\n-\t}\n-\n-\tctdb_call_local(ctdb_db, &state->call, &state->header, &data, ctdb->vnn);\n+\t\tDEBUG(0, (\"Dropped orphan in ctdb_become_dmaster with reqid:%d\\n\",reqid));\n+\t\tctdb_ltdb_unlock(ctdb_db, key);\n+\t\treturn;\n+\t}\n+\n+\tctdb_call_local(ctdb_db, &state->call, &header, &data, ctdb->vnn);\n \n \tctdb_ltdb_unlock(ctdb_db, state->call.key);\n \n@@ -381,7 +390,7 @@\n \t/* check if the new dmaster is the lmaster, in which case we\n \t   skip the dmaster reply */\n \tif (c->dmaster == ctdb->vnn) {\n-\t\tctdb_become_dmaster(ctdb, hdr->reqid, data);\n+\t\tctdb_become_dmaster(ctdb_db, hdr->reqid, key, data, c->rsn);\n \t} else {\n \t\tctdb_send_dmaster_reply(ctdb_db, &header, key, data, c->dmaster, hdr->reqid);\n \t\tctdb_ltdb_unlock(ctdb_db, key);\n@@ -434,8 +443,8 @@\n \t/* if we are not the dmaster, then send a redirect to the\n \t   requesting node */\n \tif (header.dmaster != ctdb->vnn) {\n+\t\ttalloc_free(data.dptr);\n \t\tctdb_call_send_redirect(ctdb, call.key, c, &header);\n-\t\ttalloc_free(data.dptr);\n \t\tctdb_ltdb_unlock(ctdb_db, call.key);\n \t\treturn;\n \t}\n@@ -465,7 +474,6 @@\n \t\t\t\t    struct ctdb_reply_call);\n \tCTDB_NO_MEMORY_FATAL(ctdb, r);\n \tr->hdr.destnode  = hdr->srcnode;\n-\tr->hdr.srcnode   = hdr->destnode;\n \tr->hdr.reqid     = hdr->reqid;\n \tr->status        = call.status;\n \tr->datalen       = call.reply_data.dsize;\n@@ -498,7 +506,7 @@\n \n \tif (hdr->reqid != state->reqid) {\n \t\t/* we found a record  but it was the wrong one */\n-\t\tDEBUG(0, (\"Dropped orphaned dmaster reply with reqid:%d\\n\",hdr->reqid));\n+\t\tDEBUG(0, (\"Dropped orphaned call reply with reqid:%d\\n\",hdr->reqid));\n \t\treturn;\n \t}\n \n@@ -525,26 +533,22 @@\n void ctdb_reply_dmaster(struct ctdb_context *ctdb, struct ctdb_req_header *hdr)\n {\n \tstruct ctdb_reply_dmaster *c = (struct ctdb_reply_dmaster *)hdr;\n-\tstruct ctdb_call_state *state;\n \tstruct ctdb_db_context *ctdb_db;\n-\tTDB_DATA data;\n+\tTDB_DATA key, data;\n \tint ret;\n \n-\tstate = ctdb_reqid_find(ctdb, hdr->reqid, struct ctdb_call_state);\n-\n-\tif (state == NULL) {\n-\t\treturn;\n-\t}\n-\n-\tif (hdr->reqid != state->reqid) {\n-\t\t/* we found a record  but it was the wrong one */\n-\t\tDEBUG(0, (\"Dropped orphaned dmaster reply with reqid:%d\\n\",hdr->reqid));\n-\t\treturn;\n-\t}\n-\n-\tctdb_db = state->ctdb_db;\n-\n-\tret = ctdb_ltdb_lock_requeue(ctdb_db, state->call.key, hdr,\n+\tctdb_db = find_ctdb_db(ctdb, c->db_id);\n+\tif (ctdb_db == NULL) {\n+\t\tDEBUG(0,(\"Unknown db_id 0x%x in ctdb_reply_dmaster\\n\", c->db_id));\n+\t\treturn;\n+\t}\n+\t\n+\tkey.dptr = c->data;\n+\tkey.dsize = c->keylen;\n+\tdata.dptr = &c->data[key.dsize];\n+\tdata.dsize = c->datalen;\n+\n+\tret = ctdb_ltdb_lock_requeue(ctdb_db, key, hdr,\n \t\t\t\t     ctdb_recv_raw_pkt, ctdb);\n \tif (ret == -2) {\n \t\treturn;\n@@ -554,10 +558,7 @@\n \t\treturn;\n \t}\n \n-\tdata.dptr = c->data;\n-\tdata.dsize = c->datalen;\n-\n-\tctdb_become_dmaster(ctdb, hdr->reqid, data);\n+\tctdb_become_dmaster(ctdb_db, hdr->reqid, key, data, c->rsn);\n }\n \n \n@@ -571,12 +572,14 @@\n \n \tstate = ctdb_reqid_find(ctdb, hdr->reqid, struct ctdb_call_state);\n \tif (state == NULL) {\n+\t\tDEBUG(0,(\"vnn %u Invalid reqid %u in ctdb_reply_error\\n\",\n+\t\t\t ctdb->vnn, hdr->reqid));\n \t\treturn;\n \t}\n \n \tif (hdr->reqid != state->reqid) {\n \t\t/* we found a record  but it was the wrong one */\n-\t\tDEBUG(0, (\"Dropped orphaned dmaster reply with reqid:%d\\n\",hdr->reqid));\n+\t\tDEBUG(0, (\"Dropped orphaned error reply with reqid:%d\\n\",hdr->reqid));\n \t\treturn;\n \t}\n \n@@ -595,7 +598,7 @@\n */\n static int ctdb_call_destructor(struct ctdb_call_state *state)\n {\n-\tctdb_reqid_remove(state->node->ctdb, state->reqid);\n+\tctdb_reqid_remove(state->ctdb_db->ctdb, state->reqid);\n \treturn 0;\n }\n \n@@ -609,7 +612,7 @@\n \tstruct ctdb_call_state *state = talloc_get_type(private_data, struct ctdb_call_state);\n \tDEBUG(0,(__location__ \" call timeout for reqid %d\\n\", state->c->hdr.reqid));\n \tstate->state = CTDB_CALL_ERROR;\n-\tctdb_set_error(state->node->ctdb, \"ctdb_call %u timed out\",\n+\tctdb_set_error(state->ctdb_db->ctdb, \"ctdb_call %u timed out\",\n \t\t       state->c->hdr.reqid);\n \tif (state->async.fn) {\n \t\tstate->async.fn(state);\n@@ -650,7 +653,6 @@\n \ttalloc_steal(state, data->dptr);\n \n \tstate->state = CTDB_CALL_DONE;\n-\tstate->node = ctdb->nodes[ctdb->vnn];\n \tstate->call = *call;\n \tstate->ctdb_db = ctdb_db;\n \n@@ -711,9 +713,7 @@\n \tstate->call.call_data.dptr = &state->c->data[call->key.dsize];\n \tstate->call.key.dptr       = &state->c->data[0];\n \n-\tstate->node   = ctdb->nodes[header->dmaster];\n \tstate->state  = CTDB_CALL_WAIT;\n-\tstate->header = *header;\n \tstate->ctdb_db = ctdb_db;\n \n \tctdb_queue_packet(ctdb, &state->c->hdr);\n@@ -734,16 +734,16 @@\n int ctdb_daemon_call_recv(struct ctdb_call_state *state, struct ctdb_call *call)\n {\n \twhile (state->state < CTDB_CALL_DONE) {\n-\t\tevent_loop_once(state->node->ctdb->ev);\n+\t\tevent_loop_once(state->ctdb_db->ctdb->ev);\n \t}\n \tif (state->state != CTDB_CALL_DONE) {\n-\t\tctdb_set_error(state->node->ctdb, \"%s\", state->errmsg);\n+\t\tctdb_set_error(state->ctdb_db->ctdb, \"%s\", state->errmsg);\n \t\ttalloc_free(state);\n \t\treturn -1;\n \t}\n \n \tif (state->call.reply_data.dsize) {\n-\t\tcall->reply_data.dptr = talloc_memdup(state->node->ctdb,\n+\t\tcall->reply_data.dptr = talloc_memdup(state->ctdb_db->ctdb,\n \t\t\t\t\t\t      state->call.reply_data.dptr,\n \t\t\t\t\t\t      state->call.reply_data.dsize);\n \t\tcall->reply_data.dsize = state->call.reply_data.dsize;\n\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-04-28 15:42:40 +0000\n+++ b/common/ctdb_client.c\t2007-04-29 14:19:40 +0000\n@@ -78,7 +78,7 @@\n \n \tif (hdr->reqid != state->reqid) {\n \t\t/* we found a record  but it was the wrong one */\n-\t\tDEBUG(0, (\"Dropped orphaned reply with reqid:%d\\n\",hdr->reqid));\n+\t\tDEBUG(0, (\"Dropped client call reply with reqid:%d\\n\",hdr->reqid));\n \t\treturn;\n \t}\n \n@@ -414,7 +414,6 @@\n \tCTDB_NO_MEMORY(ctdb, r);\n \n \tr->hdr.destnode  = vnn;\n-\tr->hdr.srcnode   = ctdb->vnn;\n \tr->srvid         = srvid;\n \tr->datalen       = data.dsize;\n \tmemcpy(&r->data[0], data.dptr, data.dsize);\n@@ -674,7 +673,6 @@\n \t\n \tc->hdr.reqid        = state->reqid;\n \tc->hdr.destnode     = destnode;\n-\tc->hdr.srcnode      = ctdb->vnn;\n \tc->hdr.reqid        = state->reqid;\n \tc->opcode           = opcode;\n \tc->srvid            = srvid;\n@@ -1054,3 +1052,24 @@\n \ttalloc_free(map);\n \treturn nodes;\n }\n+\n+\n+/*\n+  reset remote status\n+ */\n+int ctdb_status_reset(struct ctdb_context *ctdb, uint32_t destnode)\n+{\n+\tint ret;\n+\tTDB_DATA data;\n+\tint32_t res;\n+\n+\tZERO_STRUCT(data);\n+\tret = ctdb_control(ctdb, destnode, 0, \n+\t\t\t   CTDB_CONTROL_STATUS_RESET, data, \n+\t\t\t   NULL, NULL, &res);\n+\tif (ret != 0 || res != 0) {\n+\t\tDEBUG(0,(__location__ \" ctdb_control for reset status failed\\n\"));\n+\t\treturn -1;\n+\t}\n+\treturn 0;\n+}\n\n=== modified file 'common/ctdb_control.c'\n--- a/common/ctdb_control.c\t2007-04-28 13:15:21 +0000\n+++ b/common/ctdb_control.c\t2007-04-29 14:19:40 +0000\n@@ -80,6 +80,12 @@\n \t\treturn 0;\n \t}\n \n+\tcase CTDB_CONTROL_STATUS_RESET: {\n+\t\tCHECK_CONTROL_DATA_SIZE(0);\n+\t\tZERO_STRUCT(ctdb->status);\n+\t\treturn 0;\n+\t}\n+\n \tcase CTDB_CONTROL_GETVNNMAP: {\n \t\tuint32_t i, len;\n \t\tCHECK_CONTROL_DATA_SIZE(0);\n@@ -242,6 +248,8 @@\n \n \tstate = ctdb_reqid_find(ctdb, hdr->reqid, struct ctdb_control_state);\n \tif (state == NULL) {\n+\t\tDEBUG(0,(\"vnn %u Invalid reqid %u in ctdb_reply_control\\n\",\n+\t\t\t ctdb->vnn, hdr->reqid));\n \t\treturn;\n \t}\n \n\n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-04-28 13:15:21 +0000\n+++ b/common/ctdb_daemon.c\t2007-04-29 14:19:40 +0000\n@@ -673,6 +673,48 @@\n \treturn 0;\n }\n \n+\n+/*\n+  start the protocol going as a daemon\n+*/\n+int ctdb_start_daemon(struct ctdb_context *ctdb)\n+{\n+\tint res;\n+\tstruct fd_event *fde;\n+\tconst char *domain_socket_name;\n+\n+\t/* get rid of any old sockets */\n+\tunlink(ctdb->daemon.name);\n+\n+\t/* create a unix domain stream socket to listen to */\n+\tres = ux_socket_bind(ctdb);\n+\tif (res!=0) {\n+\t\tDEBUG(0,(__location__ \" Failed to open CTDB unix domain socket\\n\"));\n+\t\texit(10);\n+\t}\n+\n+\tif (fork()) {\n+\t\treturn 0;\n+\t}\n+\n+\ttdb_reopen_all(False);\n+\n+\tsetsid();\n+\tblock_signal(SIGPIPE);\n+\tblock_signal(SIGCHLD);\n+\n+\t/* ensure the socket is deleted on exit of the daemon */\n+\tdomain_socket_name = talloc_strdup(talloc_autofree_context(), ctdb->daemon.name);\n+\ttalloc_set_destructor(domain_socket_name, unlink_destructor);\t\n+\n+\tctdb->ev = event_context_init(NULL);\n+\tfde = event_add_fd(ctdb->ev, ctdb, ctdb->daemon.sd, EVENT_FD_READ, \n+\t\t\t   ctdb_accept_client, ctdb);\n+\tctdb_main_loop(ctdb);\n+\n+\treturn 0;\n+}\n+\n /*\n   allocate a packet for use in client<->daemon communication\n  */\n@@ -685,6 +727,7 @@\n \tint size;\n \tstruct ctdb_req_header *hdr;\n \tsize = ((length+1)+(CTDB_DS_ALIGNMENT-1)) & ~(CTDB_DS_ALIGNMENT-1);\n+\n \thdr = (struct ctdb_req_header *)talloc_size(mem_ctx, size);\n \tif (hdr == NULL) {\n \t\tDEBUG(0,(\"Unable to allocate packet for operation %u of length %u\\n\",\n@@ -692,11 +735,12 @@\n \t\treturn NULL;\n \t}\n \ttalloc_set_name_const(hdr, type);\n-\tmemset(hdr, 0, slength);\n+\tmemset(hdr, 0, size);\n \thdr->operation    = operation;\n-\thdr->length       = length;\n+\thdr->length       = size;\n \thdr->ctdb_magic   = CTDB_MAGIC;\n \thdr->ctdb_version = CTDB_VERSION;\n+\thdr->srcnode      = ctdb->vnn;\n \tif (ctdb->vnn_map) {\n \t\thdr->generation = ctdb->vnn_map->generation;\n \t}\n@@ -724,9 +768,9 @@\n \t\treturn NULL;\n \t}\n \ttalloc_set_name_const(hdr, type);\n-\tmemset(hdr, 0, slength);\n+\tmemset(hdr, 0, size);\n \thdr->operation    = operation;\n-\thdr->length       = length;\n+\thdr->length       = size;\n \thdr->ctdb_magic   = CTDB_MAGIC;\n \thdr->ctdb_version = CTDB_VERSION;\n \thdr->generation   = ctdb->vnn_map->generation;\n\n=== modified file 'common/ctdb_io.c'\n--- a/common/ctdb_io.c\t2007-04-16 00:21:44 +0000\n+++ b/common/ctdb_io.c\t2007-04-29 14:19:40 +0000\n@@ -64,8 +64,10 @@\n \tssize_t nread;\n \tuint8_t *data, *data_base;\n \n-\tif (ioctl(queue->fd, FIONREAD, &num_ready) != 0 ||\n-\t    num_ready == 0) {\n+\tif (ioctl(queue->fd, FIONREAD, &num_ready) != 0) {\n+\t\treturn;\n+\t}\n+\tif (num_ready == 0) {\n \t\t/* the descriptor has been closed */\n \t\tgoto failed;\n \t}\n@@ -75,11 +77,14 @@\n \t\t\t\t\t\t  num_ready + queue->partial.length);\n \n \tif (queue->partial.data == NULL) {\n+\t\tDEBUG(0,(\"read error alloc failed for %u\\n\", \n+\t\t\t num_ready + queue->partial.length));\n \t\tgoto failed;\n \t}\n \n \tnread = read(queue->fd, queue->partial.data + queue->partial.length, num_ready);\n \tif (nread <= 0) {\n+\t\tDEBUG(0,(\"read error nread=%d\\n\", nread));\n \t\tgoto failed;\n \t}\n \n@@ -106,6 +111,7 @@\n \t\tlen = *(uint32_t *)data;\n \t\td2 = talloc_memdup(queue, data, len);\n \t\tif (d2 == NULL) {\n+\t\t\tDEBUG(0,(\"read error memdup failed for %u\\n\", len));\n \t\t\t/* sigh */\n \t\t\tgoto failed;\n \t\t}\n@@ -122,6 +128,8 @@\n \t\t} else {\n \t\t\tqueue->partial.data = talloc_memdup(queue, data, nread);\n \t\t\tif (queue->partial.data == NULL) {\n+\t\t\t\tDEBUG(0,(\"read error memdup partial failed for %u\\n\", \n+\t\t\t\t\t nread));\n \t\t\t\tgoto failed;\n \t\t\t}\n \t\t\tqueue->partial.length = nread;\n@@ -155,8 +163,11 @@\n \twhile (queue->out_queue) {\n \t\tstruct ctdb_queue_pkt *pkt = queue->out_queue;\n \t\tssize_t n;\n-\n-\t\tn = write(queue->fd, pkt->data, pkt->length);\n+\t\tif (queue->ctdb->flags & CTDB_FLAG_TORTURE) {\n+\t\t\tn = write(queue->fd, pkt->data, 1);\n+\t\t} else {\n+\t\t\tn = write(queue->fd, pkt->data, pkt->length);\n+\t\t}\n \n \t\tif (n == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {\n \t\t\tevent_add_timed(queue->ctdb->ev, queue, timeval_zero(), \n@@ -213,7 +224,8 @@\n \t\n \t/* if the queue is empty then try an immediate write, avoiding\n \t   queue overhead. This relies on non-blocking sockets */\n-\tif (queue->out_queue == NULL && queue->fd != -1) {\n+\tif (queue->out_queue == NULL && queue->fd != -1 &&\n+\t    !(queue->ctdb->flags & CTDB_FLAG_TORTURE)) {\n \t\tssize_t n = write(queue->fd, data, length2);\n \t\tif (n == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {\n \t\t\tevent_add_timed(queue->ctdb->ev, queue, timeval_zero(), \n\n=== modified file 'common/ctdb_util.c'\n--- a/common/ctdb_util.c\t2007-04-28 08:50:32 +0000\n+++ b/common/ctdb_util.c\t2007-04-29 14:19:40 +0000\n@@ -129,6 +129,51 @@\n \t}\n }\n \n+#if 0\n+struct idr_fake {\n+\tuint32_t size;\n+\tvoid **ptrs;\n+};\n+\n+static void idr_fake_init(struct ctdb_context *ctdb)\n+{\n+\tif (ctdb->fidr) return;\n+\tctdb->fidr = talloc(ctdb, struct idr_fake);\n+\tctdb->fidr->size = 0x10000;\n+\tctdb->fidr->ptrs = talloc_zero_array(ctdb->fidr, void *, \n+\t\t\t\t\t\t ctdb->fidr->size);\n+}\n+\n+uint32_t ctdb_reqid_new(struct ctdb_context *ctdb, void *state)\n+{\n+\tuint32_t i;\n+\tidr_fake_init(ctdb);\n+\tfor (i=0;ifidr->size;i++) {\n+\t\tif (ctdb->fidr->ptrs[i] == NULL) {\n+\t\t\tctdb->fidr->ptrs[i] = state;\n+\t\t\treturn i;\n+\t\t}\n+\t}\n+\treturn (uint32_t)-1;\n+}\n+\n+void *_ctdb_reqid_find(struct ctdb_context *ctdb, uint32_t reqid, const char *type, const char *location)\n+{\n+\tidr_fake_init(ctdb);\n+\tif (ctdb->fidr->ptrs[reqid] == NULL) {\n+\t\tDEBUG(0,(\"bad fidr id %u\\n\", reqid));\n+\t}\n+\treturn ctdb->fidr->ptrs[reqid];\n+}\n+\n+\n+void ctdb_reqid_remove(struct ctdb_context *ctdb, uint32_t reqid)\n+{\n+\tidr_fake_init(ctdb);\n+\tctdb->fidr->ptrs[reqid] = NULL;\n+}\n+\n+#else\n uint32_t ctdb_reqid_new(struct ctdb_context *ctdb, void *state)\n {\n \tuint32_t id;\n@@ -161,3 +206,4 @@\n \t}\n }\n \n+#endif\n\n=== modified file 'direct/ctdbd.c'\n--- a/direct/ctdbd.c\t2007-04-18 23:14:25 +0000\n+++ b/direct/ctdbd.c\t2007-04-29 14:19:40 +0000\n@@ -56,7 +56,6 @@\n \tint opt;\n \tconst char **extra_argv;\n \tint extra_argc = 0;\n-\tint ret;\n \tpoptContext pc;\n \tstruct event_context *ev;\n \n@@ -91,22 +90,13 @@\n \t\tctdb_db = ctdb_attach(ctdb, tok, TDB_DEFAULT, \n \t\t\t\t      O_RDWR|O_CREAT|O_TRUNC, 0666);\n \t\tif (!ctdb_db) {\n-\t\t\tprintf(\"ctdb_attach to '%s'failed - %s\\n\", tok, \n-\t\t\t       ctdb_errstr(ctdb));\n+\t\t\tDEBUG(0,(\"ctdb_attach to '%s'failed - %s\\n\", tok, \n+\t\t\t\t ctdb_errstr(ctdb)));\n \t\t\texit(1);\n \t\t}\n-\t\tprintf(\"Attached to database '%s'\\n\", tok);\n-\t}\n-\n-\t/* start the protocol running */\n-\tret = ctdb_start(ctdb);\n-\n-/*\tevent_loop_wait(ev);*/\n-\twhile (1) {\n-\t\tevent_loop_once(ev);\n-\t}\n-\n-\t/* shut it down */\n-\ttalloc_free(ev);\n-\treturn 0;\n+\t\tDEBUG(1, (\"Attached to database '%s'\\n\", tok));\n+\t}\n+\n+\t/* start the protocol running (as a child) */\n+\treturn ctdb_start_daemon(ctdb);\n }\n\n=== modified file 'include/ctdb.h'\n--- a/include/ctdb.h\t2007-04-28 15:42:40 +0000\n+++ b/include/ctdb.h\t2007-04-29 14:19:40 +0000\n@@ -107,6 +107,7 @@\n   start the ctdb protocol\n */\n int ctdb_start(struct ctdb_context *ctdb);\n+int ctdb_start_daemon(struct ctdb_context *ctdb);\n \n /*\n   attach to a ctdb database\n@@ -256,4 +257,6 @@\n uint32_t *ctdb_get_connected_nodes(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx,\n \t\t\t\t   uint32_t *num_nodes);\n \n+int ctdb_status_reset(struct ctdb_context *ctdb, uint32_t destnode);\n+\n #endif\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-04-28 16:18:33 +0000\n+++ b/include/ctdb_private.h\t2007-04-29 14:19:40 +0000\n@@ -195,6 +195,7 @@\n \tstruct ctdb_status status;\n \tstruct ctdb_vnn_map *vnn_map;\n \tuint32_t num_clients;\n+\tstruct idr_fake *fidr;\n };\n \n struct ctdb_db_context {\n@@ -251,7 +252,8 @@\n \t\t    CTDB_CONTROL_GET_DEBUG,\n \t\t    CTDB_CONTROL_SET_DEBUG,\n \t\t    CTDB_CONTROL_GET_DBMAP,\n-\t\t    CTDB_CONTROL_GET_NODEMAP};\n+\t\t    CTDB_CONTROL_GET_NODEMAP,\n+\t\t    CTDB_CONTROL_STATUS_RESET};\n \n enum call_state {CTDB_CALL_WAIT, CTDB_CALL_DONE, CTDB_CALL_ERROR};\n \n@@ -263,10 +265,8 @@\n \tuint32_t reqid;\n \tstruct ctdb_req_call *c;\n \tstruct ctdb_db_context *ctdb_db;\n-\tstruct ctdb_node *node;\n \tconst char *errmsg;\n \tstruct ctdb_call call;\n-\tstruct ctdb_ltdb_header header;\n \tstruct {\n \t\tvoid (*fn)(struct ctdb_call_state *);\n \t\tvoid *private_data;\n@@ -347,6 +347,7 @@\n struct ctdb_req_dmaster {\n \tstruct ctdb_req_header hdr;\n \tuint32_t db_id;\n+\tuint64_t rsn;\n \tuint32_t dmaster;\n \tuint32_t keylen;\n \tuint32_t datalen;\n@@ -355,6 +356,9 @@\n \n struct ctdb_reply_dmaster {\n \tstruct ctdb_req_header hdr;\n+\tuint32_t db_id;\n+\tuint64_t rsn;\n+\tuint32_t keylen;\n \tuint32_t datalen;\n \tuint8_t  data[1];\n };\n\n=== modified file 'tools/ctdb_control.c'\n--- a/tools/ctdb_control.c\t2007-04-28 16:18:33 +0000\n+++ b/tools/ctdb_control.c\t2007-04-28 17:13:36 +0000\n@@ -36,6 +36,7 @@\n \tprintf(\"  ping\\n\");\n \tprintf(\"  process-exists            see if a process exists\\n\");\n \tprintf(\"  status                    show ctdb status on a node\\n\");\n+\tprintf(\"  statusreset               reset status on a node\\n\");\n \tprintf(\"  debug              set ctdb debug level on a node\\n\");\n \tprintf(\"  debuglevel                         display ctdb debug levels\\n\");\n \tprintf(\"  getvnnmap                     display ctdb vnnmap\\n\");\n@@ -170,6 +171,56 @@\n \treturn 0;\n }\n \n+\n+/*\n+  reset status on all nodes\n+ */\n+static int control_status_reset_all(struct ctdb_context *ctdb)\n+{\n+\tint ret, i;\n+\tuint32_t *nodes;\n+\tuint32_t num_nodes;\n+\n+\tnodes = ctdb_get_connected_nodes(ctdb, ctdb, &num_nodes);\n+\tCTDB_NO_MEMORY(ctdb, nodes);\n+\t\n+\tfor (i=0;i<num_nodes;i++) {\n+\t\tret = ctdb_status_reset(ctdb, nodes[i]);\n+\t\tif (ret != 0) {\n+\t\t\tprintf(\"Unable to reset status on node %u\\n\", nodes[i]);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\ttalloc_free(nodes);\n+\treturn 0;\n+}\n+\n+\n+/*\n+  reset remote ctdb status\n+ */\n+static int control_status_reset(struct ctdb_context *ctdb, int argc, const char **argv)\n+{\n+\tuint32_t vnn;\n+\tint ret;\n+\tif (argc < 1) {\n+\t\tusage();\n+\t}\n+\n+\tif (strcmp(argv[0], \"all\") == 0) {\n+\t\treturn control_status_reset_all(ctdb);\n+\t}\n+\n+\tvnn = strtoul(argv[0], NULL, 0);\n+\n+\tret = ctdb_status_reset(ctdb, vnn);\n+\tif (ret != 0) {\n+\t\tprintf(\"Unable to reset status on node %u\\n\", vnn);\n+\t\treturn ret;\n+\t}\n+\treturn 0;\n+}\n+\n /*\n   display remote ctdb vnn map\n  */\n@@ -441,6 +492,8 @@\n \t\tret = control_process_exists(ctdb, extra_argc-1, extra_argv+1);\n \t} else if (strcmp(control, \"status\") == 0) {\n \t\tret = control_status(ctdb, extra_argc-1, extra_argv+1);\n+\t} else if (strcmp(control, \"statusreset\") == 0) {\n+\t\tret = control_status_reset(ctdb, extra_argc-1, extra_argv+1);\n \t} else if (strcmp(control, \"getvnnmap\") == 0) {\n \t\tret = control_getvnnmap(ctdb, extra_argc-1, extra_argv+1);\n \t} else if (strcmp(control, \"getdbmap\") == 0) {\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22935 - in branches/SAMBA_3_0_26/source/lib: .", "body": "Author: metze\nDate: 2007-05-16 13:04:01 +0000 (Wed, 16 May 2007)\nNew Revision: 22935\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22935\n\nLog:\nmerge 21972 from SAMBA_3_0\n\nmetze\n\nModified:\n   branches/SAMBA_3_0_26/source/lib/util_tdb.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/lib/util_tdb.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/util_tdb.c\t2007-05-16 13:02:53 UTC (rev 22934)\n+++ branches/SAMBA_3_0_26/source/lib/util_tdb.c\t2007-05-16 13:04:01 UTC (rev 22935)\n@@ -56,6 +56,11 @@\n \treturn make_tdb_data(string, strlen(string));\n }\n \n+TDB_DATA string_term_tdb_data(const char *string)\n+{\n+\treturn make_tdb_data(string, strlen(string) + 1);\n+}\n+\n /****************************************************************************\n  Lock a chain with timeout (in seconds).\n ****************************************************************************/\n@@ -108,7 +113,7 @@\n \n int tdb_lock_bystring(TDB_CONTEXT *tdb, const char *keyval)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);\n+\tTDB_DATA key = string_term_tdb_data(keyval);\n \t\n \treturn tdb_chainlock(tdb, key);\n }\n@@ -116,7 +121,7 @@\n int tdb_lock_bystring_with_timeout(TDB_CONTEXT *tdb, const char *keyval,\n \t\t\t\t   int timeout)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);\n+\tTDB_DATA key = string_term_tdb_data(keyval);\n \t\n \treturn tdb_chainlock_with_timeout(tdb, key, timeout);\n }\n@@ -127,7 +132,7 @@\n \n void tdb_unlock_bystring(TDB_CONTEXT *tdb, const char *keyval)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);\n+\tTDB_DATA key = string_term_tdb_data(keyval);\n \n \ttdb_chainunlock(tdb, key);\n }\n@@ -138,7 +143,7 @@\n \n int tdb_read_lock_bystring_with_timeout(TDB_CONTEXT *tdb, const char *keyval, unsigned int timeout)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);\n+\tTDB_DATA key = string_term_tdb_data(keyval);\n \t\n \treturn tdb_chainlock_with_timeout_internal(tdb, key, timeout, F_RDLCK);\n }\n@@ -149,7 +154,7 @@\n \n void tdb_read_unlock_bystring(TDB_CONTEXT *tdb, const char *keyval)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, strlen(keyval)+1);\n+\tTDB_DATA key = string_term_tdb_data(keyval);\n \t\n \ttdb_chainunlock_read(tdb, key);\n }\n@@ -160,9 +165,8 @@\n  Output is int32 in native byte order.\n ****************************************************************************/\n \n-int32 tdb_fetch_int32_byblob(TDB_CONTEXT *tdb, const char *keyval, size_t len)\n+int32 tdb_fetch_int32_byblob(TDB_CONTEXT *tdb, TDB_DATA key)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, len);\n \tTDB_DATA data;\n \tint32 ret;\n \n@@ -184,7 +188,9 @@\n \n int32 tdb_fetch_int32(TDB_CONTEXT *tdb, const char *keystr)\n {\n-\treturn tdb_fetch_int32_byblob(tdb, keystr, strlen(keystr) + 1);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\n+\treturn tdb_fetch_int32_byblob(tdb, key);\n }\n \n /****************************************************************************\n@@ -192,9 +198,8 @@\n  Input is int32 in native byte order. Output in tdb is in little-endian.\n ****************************************************************************/\n \n-int tdb_store_int32_byblob(TDB_CONTEXT *tdb, const char *keystr, size_t len, int32 v)\n+int tdb_store_int32_byblob(TDB_CONTEXT *tdb, TDB_DATA key, int32 v)\n {\n-\tTDB_DATA key = make_tdb_data(keystr, len);\n \tTDB_DATA data;\n \tint32 v_store;\n \n@@ -212,7 +217,9 @@\n \n int tdb_store_int32(TDB_CONTEXT *tdb, const char *keystr, int32 v)\n {\n-\treturn tdb_store_int32_byblob(tdb, keystr, strlen(keystr) + 1, v);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\n+\treturn tdb_store_int32_byblob(tdb, key, v);\n }\n \n /****************************************************************************\n@@ -220,9 +227,8 @@\n  Output is uint32 in native byte order.\n ****************************************************************************/\n \n-BOOL tdb_fetch_uint32_byblob(TDB_CONTEXT *tdb, const char *keyval, size_t len, uint32 *value)\n+BOOL tdb_fetch_uint32_byblob(TDB_CONTEXT *tdb, TDB_DATA key, uint32 *value)\n {\n-\tTDB_DATA key = make_tdb_data(keyval, len);\n \tTDB_DATA data;\n \n \tdata = tdb_fetch(tdb, key);\n@@ -243,7 +249,9 @@\n \n BOOL tdb_fetch_uint32(TDB_CONTEXT *tdb, const char *keystr, uint32 *value)\n {\n-\treturn tdb_fetch_uint32_byblob(tdb, keystr, strlen(keystr) + 1, value);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\n+\treturn tdb_fetch_uint32_byblob(tdb, key, value);\n }\n \n /****************************************************************************\n@@ -251,9 +259,8 @@\n  Input is uint32 in native byte order. Output in tdb is in little-endian.\n ****************************************************************************/\n \n-BOOL tdb_store_uint32_byblob(TDB_CONTEXT *tdb, const char *keystr, size_t len, uint32 value)\n+BOOL tdb_store_uint32_byblob(TDB_CONTEXT *tdb, TDB_DATA key, uint32 value)\n {\n-\tTDB_DATA key = make_tdb_data(keystr, len);\n \tTDB_DATA data;\n \tuint32 v_store;\n \tBOOL ret = True;\n@@ -275,7 +282,9 @@\n \n BOOL tdb_store_uint32(TDB_CONTEXT *tdb, const char *keystr, uint32 value)\n {\n-\treturn tdb_store_uint32_byblob(tdb, keystr, strlen(keystr) + 1, value);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\n+\treturn tdb_store_uint32_byblob(tdb, key, value);\n }\n /****************************************************************************\n  Store a buffer by a null terminated string key.  Return 0 on success, -1\n@@ -284,11 +293,19 @@\n \n int tdb_store_bystring(TDB_CONTEXT *tdb, const char *keystr, TDB_DATA data, int flags)\n {\n-\tTDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);\n-\t\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\n \treturn tdb_store(tdb, key, data, flags);\n }\n \n+int tdb_trans_store_bystring(TDB_CONTEXT *tdb, const char *keystr,\n+\t\t\t     TDB_DATA data, int flags)\n+{\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n+\t\n+\treturn tdb_trans_store(tdb, key, data, flags);\n+}\n+\n /****************************************************************************\n  Fetch a buffer using a null terminated string key.  Don't forget to call\n  free() on the result dptr.\n@@ -296,7 +313,7 @@\n \n TDB_DATA tdb_fetch_bystring(TDB_CONTEXT *tdb, const char *keystr)\n {\n-\tTDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n \n \treturn tdb_fetch(tdb, key);\n }\n@@ -307,7 +324,7 @@\n \n int tdb_delete_bystring(TDB_CONTEXT *tdb, const char *keystr)\n {\n-\tTDB_DATA key = make_tdb_data(keystr, strlen(keystr)+1);\n+\tTDB_DATA key = string_term_tdb_data(keystr);\n \n \treturn tdb_delete(tdb, key);\n }\n@@ -717,7 +734,7 @@\n \t\n \tfor (key = tdb_firstkey(tdb); key.dptr; key = next) {\n \t\t/* duplicate key string to ensure null-termination */\n-\t\tchar *key_str = (char*) SMB_STRNDUP(key.dptr, key.dsize);\n+\t\tchar *key_str = SMB_STRNDUP(key.dptr, key.dsize);\n \t\tif (!key_str) {\n \t\t\tDEBUG(0, (\"tdb_search_keys: strndup() failed!\\n\"));\n \t\t\tsmb_panic(\"strndup failed!\\n\");\n\n"}
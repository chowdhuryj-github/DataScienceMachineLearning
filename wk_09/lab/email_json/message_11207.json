{"category": "ham", "to_address": "hadley wickham <h.wickham@gmail.com>", "from_address": "Iestyn Lewis <ilewis@pharm.emory.edu>", "subject": "Re: [R] Fastest way to repeatedly subset a data frame?", "body": "That is a seriously neat bit of code there.  (I'm new to non-loop-based \nprogramming, forgive my enthusiasm).\n\nBut... it's not any faster, which is worrisome to me because it seems \nlike your code uses rownames and would take advantage of the hashing \npotential of named items.\n\nI'm currently looking at converting the vectors of ids to lists.  I've \nalso come across some pages which make reference to a setting up a new \nenvironment using the hash=TRUE argument, but it's unclear to me on how \nyou go about using that new environment. \n\nThanks,\n\nIestyn\n\nhadley wickham wrote:\n> On 4/20/07, Iestyn Lewis  wrote:\n>> Hi -\n>>\n>>  I have a data frame with a large number of observations (62,000 rows,\n>> but only 2 columns - a character ID and a result list).\n>>\n>> Sample:\n>>\n>>  > my.df <- data.frame(id=c(\"ID1\", \"ID2\", \"ID3\"), result=1:3)\n>>  > my.df\n>>    id result\n>> 1 ID1      1\n>> 2 ID2      2\n>> 3 ID3      3\n>>\n>> I have a list of ID vectors.  This list will have anywhere from 100 to\n>> 1000 members, and each member will have anywhere from 10 to 5000 id \n>> entries.\n>>\n>> Sample:\n>>\n>>  > my.idlist[[\"List1\"]] <- c(\"ID1\", \"ID3\")\n>>  > my.idlist[[\"List2\"]] <- c(\"ID2\")\n>>  > my.idlist\n>> $List1\n>> [1] \"ID1\" \"ID3\"\n>>\n>> $List2\n>> [1] \"ID2\"\n>>\n>>\n>> I need to subset that data frame by the list of IDs in each vector, to\n>> end up with vectors that contain just the results for the IDs found in\n>> each vector in the list.  My current approach is to create new columns\n>> in the original data frame with the names of the list items, and any\n>> results that don't match replaced with NA.  Here is what I've done so \n>> far:\n>>\n>> createSubsets <- function(res, slib) {\n>>     for(i in 1:length(slib)) {\n>>         res[ ,names(slib)[i]] <- replace(res$result,\n>> which(!is.element(res$sid, slib[[i]])), NA)\n>>         return (res)\n>>     }\n>> }\n>>\n>> I have 2 problems:\n>>\n>> 1)  My function only works for the first item in the list:\n>>\n>>  > my.df <- createSubsets(my.df, my.idlist)\n>>  > my.df\n>>    id result List1\n>> 1 ID1      1     1\n>> 2 ID2      2    NA\n>> 3 ID3      3     3\n>>\n>> In order to get all results, I have to copy the loop out of the function\n>> and paste it into R directly.\n>>\n>> 2)  It is very, very slow.  For a dataset of 62,000 rows and 253 list\n>> entries, it takes probably 5 minutes on a pentium D.  An implementation\n>> of this kind of subsetting using hashtables in C# takes a neglible\n>> amount of time.\n>>\n>> I am open to any suggestions about data format, methods, anything.\n>\n> How about:\n>\n> df <- data.frame(id=c(\"ID1\", \"ID2\", \"ID3\"), result=1:3)\n>\n> ids <- list()\n> ids[[\"List1\"]] <- c(\"ID1\", \"ID3\")\n> ids[[\"List2\"]] <- c(\"ID2\")\n>\n> rownames(df) <- df$id\n> lapply(ids, function(id) df[id, ])\n>\n> Hadley\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
{"category": "ham", "to_address": "\"jerry gay\" <jerry.gay@gmail.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: Web Module (Was: Perl6 new features)", "body": "On 6/22/07, jerry gay  wrote:\n> On 6/22/07, Chas Owens  wrote:\n> > Most of the time the policy is enacted by lower-case-l lazy sysadmins\n> > who can't be bothered to type\n> >\n> > perl -MCPAN -e install Foo::Bar\n> >\n> > My normal route around them is to install the module into the home\n> > directory of the user who is going to run the script, but I have had\n> > difficulty with this before when it comes time to move to production:\n> > \"Where is the code review for that code?\".  My answer of \"where is the\n> > code review for that (often open source) database install you just\n> > did?\" doesn't tend to hold the weight I wish it did.  For some reason\n> > binary blobs make some types of sysadmins feel all fuzzy and warm\n> > inside.\n> >\n> so use the parrot back end and compile all the modules to bytecode.\n> oh, and you can merge the foreign module bytecode with the bytecode\n> for your application, so it's all one big happy binary file.\n>\n> in fact, parrot will even provide a way to compile bytecode to a\n> native executable which contains parrot itself. there, now you've got\n> a proper binary with *zero* external requirements in the production\n> environment--it doesn't even need to have parrot installed.\n>\n> at that point, i'd be surprised if the release engineers or sysadmins\n> even notice.\n> ~jerry\n>\n\nGood point.  I am still to stuck in the Perl 5 mind set.\n\n"}
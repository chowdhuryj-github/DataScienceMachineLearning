{"category": "ham", "to_address": "Damian Conway <damian@conway.org>", "from_address": "Mark Overmeer <mark@overmeer.net>", "subject": "Re: Referring to source code within Perldoc: the new A<> code", "body": "* Damian Conway (damian@conway.org) [070621 01:45]:\n> Mark Overmeer wrote:\n> >This is exactly the form of documentation you do *not* want the\n> >user to write, for various reasons:\n\n> Well, I agree it is the form that \"you\" (singular, specific) do not want; \n> but I'm not sure it's bad for \"you\" (plural, generic) to write in all \n> cases. ;-)\n\nMy idea was \"you\" as lazy Perl programmers (most of us), against\n\"you\" as orthodox orthogonalists :-b\n\n> >  * The explicit naming of the class name in method and attribute\n> >    descriptions is in general a bad idea: by inheritance, you get\n> >    sub-classes which also provide this method.\n> A dedicated OO documentation tool could certainly do a better job in that \n> case, I heartily agree. I'm looking forward to using one.\n\nOODoc achieves this with POD(5)syntax with extra logical markup tags.\nIt's a simple tool, with simple syntax.  So, I would say: try it!\nRead OODoc::Parser::Markov first.\n\nIt sounds as if you think that OO/Grammar will be rarely used.  That\nthere is no need to help users document it.\n\n> >  * How do you see this syntactically work in combination with the\n> >    item list? At least the POD(5) needed that.  I need a combined\n> >    example.\n> I'm not sure I understand what you're asking here. Can you describe the \n> example you'd like to see?\n\nIn POD(5) you do\n\n =over 4\n =item myfunction1\n some description\n =item myfunction2\n some description\n =back\n\nHow would this small example (blanks removed) work in POD6?\n\n> >  * Using ambient back-references this way probably requires a\n> >    two-pass document generator. AFAIK this is not required for the\n> >    design of POD6 so far.\n> \n> Actually a two-pass generator is already required for Pod. A second pass is \n> always necessary whenever there are any forward-targetted L<#local link> \n> formatting codes in a document.\n\nThe is a simple strategy to avoid a second pass in this case.  Probably\nyou (signular form) found a special case that this does not work.\n\n> >      method eat(Food $meal) {\n> >         if($manger.isFull) { $manger.clean }\n> >    =for DESCRIPTION\n> >    The A() method has the following argument list: A<(..)>\n> > Oops... now the argument list became (without warning) \"$manger.isFull\"\n> \n> Sure. But this is true of any scheme that doesn't do full parsing of the \n> ambient source code. Which Pod isn't going to do\n\nThat's doesn't make this less of a problem.  I think it is a wide open\nuser trap.\n\n> >  * In the manual-page of my sub-class, I want to refer to the\n> >    documentation of specific attributes and methods.  How?\n> >    Can I also refer to elements in distributions which are not\n> >    mine, so where I cannot add X<> or such?  For instance,\n> >    when I inherit from a core Perl class?\n> \n> This is not possible, using this mechanism, due to the lexical scoping of \n> the aliases. An automatic documentation-generator tool (that produces Pod) \n> is more appropriate for this task.\n\nOf course, I can make OODoc produce POD6.  However, in a new\ngeneration of the documentation syntax, I would really have liked\nto have higher level features, for instance with which we can\nproduce docs with many links (like HTML), not poor section references\nlike traditional manual pages.\n\n> >  * In my sub-class, I want to enlist automatically the methods\n> >    and attributes which are inherited.\n> \n> An automatic documentation-generator tool is more appropriate for\n> this task too.\n\nFor each little bit more complicated than the straight-forward task,\nyou say: let some external tool do that.  Each of these spots is\na weak point in your orthodox orthogonal approach, where you ask\npeople to install and learn more tools, adding needless complications\nto the development process.\n\nThe major disadvantage of external tools is, of course, their\nincompatible results.  Perl's set of manual-pages will continue\nto be messy.\n\n>         =Definition\n>            method eat(Food $meal) {...}\n> \n> But with that slight change in syntax you could then use the standard Pod \n> parser to segment your document into mark-up and ambient code, search the \n> resulting object tree for 'Definition' nodes, grab the immediately \n> following ambient code block, parse it using Perl 6's own grammar, then \n> autogenerate content for the next 'DESCRIPTION' node in whatever form you \n> would like it to be, using information extracted from the parsed code.\n\nWow, sounds really simple to implement.  No.\n\n> Or, since the Perl 6 grammar can preserve Perl comments in the parse tree, \n> you could even create a tool that understood an abbreviated notation such \n> as:\n>            method eat(Food $meal) {...}  #=Definition=#\n\nOh yes!  Now you gave me a way to implement my idea!\n>            method eat(Food $meal) {...}\n                #= let a human empty his/her plate\n\nIntrospection to produce the manual pages, piece of cake... no\ninteractive user tools needed.  Maybe some macro which s/^\\s\\`/#= /\nand all my needs are implemented!\n\n> The point is: the design of Pod allows you to use *any* of those \n> alternatives. It does that by providing a simple and extensible mark-up \n> notation, an efficient parser for that notation, and good integration with \n> Perl itself, so you can build whatever kind of documentation tools you find \n> most useful.\n\nNow I have to disagree: if you explain how to compile parts of Perl6\nto collect the info to produce my man-pages, then I do not think that\nPOD6 is to be prized for its contribution.\n\n   ....by providing a simple    certainly not the simpelest\n      and extensible mark-up    yes, sure\n         an efficient parser    probably, but not needed: runs once\n  good integration with Perl    no, certainly not IMO\n  so you can build whatever kind of documentation tools you find most useful.\n             ... so everyone is left on their own to fix the features\n\n> In other words, in designing Pod I'm attempting to create something at the \n> abstraction level of RTF or LaTeX or XHTML,\n\nYes, just another syntax to do get the same possibilities and limitation.\n\n> ... not something analogous to MS Word or Maple or HyperCard.\n\nThat would be a shame.\n\n> That is: something that you can use directly \n> for simple tasks, and something you can also build tools on top of...to \n> handle more sophisticated requirements.\n\n... and then we are back again to the old story: in my believe, the\nstructural consistency that POD6 offers is too little to create\nreally nice documents from.\n\n> >In this case, the Perl and POD are using the text in the file\n> >in an overlapping way, but still the Perl6 and POD6 parsers are\n> >fully separate. \n> \n> That's not the case. As Larry has confirmed recently, to each parser (perl6 \n> or Perl6::Pod::Parser) everything in a source file will be either Perl or \n> Pod (and never both). And the only place where the two parsers will \n> disagree is inside a Perl string that happens to contain a Pod block.\n\nWell, that is just a choice; the choice you defend as well. It is\nnothing more than a choice.  It is not a necessity.  Even a strong\nreligious groups like Python is not this orthodox: they have their\n__doc__ attribute in their syntax tree, and \"\"\" where I use ` / #=\nThis choice make life much harder to everyone (IMO, of course)\n-- \nRegards,\n               MarkOv\n\n------------------------------------------------------------------------\n       Mark Overmeer MSc                                MARKOV Solutions\n       Mark@Overmeer.net                          solutions@overmeer.net\nhttp://Mark.Overmeer.net                   http://solutions.overmeer.net\n\n"}
{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "Stephen Tucker <brown_emu@yahoo.com>", "subject": "Re: [R] Tools For Preparing Data For Analysis", "body": "\nSince R is supposed to be a complete programming language, I wonder\nwhy these tools couldn't be implemented in R (unless speed is the\nissue). Of course, it's a naive desire to have a single language that\ndoes everything, but it seems that R currently has most of the\nfunctions necessary to do the type of data cleaning described.\n\nFor instance, Gabor and Peter showed some snippets of ways to do this\nelegantly; my [physical science] data is often not as horrendously\nstructured so usually I can get away with a program containing this\ntype of code\n\ntxtin <- scan(filename,what=\"\",sep=\"\\n\")\nfilteredList <- lapply(strsplit(txtin,delimiter),FUN=filterfunction)\n   # fiteringfunction() returns selected (and possibly transformed\n   # elements if present and NULL otherwise\n   # may include calls to grep(), regexpr(), gsub(), substring(),...\n   # nchar(), sscanf(), type.convert(), paste(), etc.\nmydataframe <- do.call(rbind,filteredList)\n   # then match(), subset(), aggregate(), etc.\n\nIn the case that the file is large, I open a file connection and scan\na single line + apply filterfunction() successively in a FOR-LOOP\ninstead of using lapply(). Of course, the devil is in the details of\nthe filtering function, but I believe most of the required text\nprocessing facilities are already provided by R.\n\nI often have tasks that involve a combination of shell-scripting and\ntext processing to construct the data frame for analysis; I started\nout using Python+NumPy to do the front-end work but have been using R\nprogressively more (frankly, all of it) to take over that portion\nsince I generally prefer the data structures and methods in R.\n\n\n--- Peter Dalgaard  wrote:\n\n> Spielas Bates wrote:\n> > Frank Harrell indicated that it is possible to do a lot of difficult\n> > data transformation within R itself if you try hard enough but that\n> > sometimes means working against the S language and its \"whole object\"\n> > view to accomplish what you want and it can require knowledge of\n> > subtle aspects of the S language.\n> >   \n> Actually, I think Frank's point was subtly different: It is *because* of \n> the differences in view that it sometimes seems difficult to find the \n> way to do something in R that  is apparently straightforward in SAS. \n> I.e. the solutions exist and are often elegant, but may require some \n> lateral thinking.\n> \n> Case in point: Finding the first or the last observation for each \n> subject when there are multiple records for each subject. The SAS way \n> would be a datastep with IF-THEN-DELETE, and a RETAIN statement so that \n> you can compare the subject ID with the one from the previous record, \n> working with data that are sorted appropriately.\n> \n> You can do the same thing in R with a for loop, but there are better \n> ways e.g.\n> subset(df,!duplicated(ID)), and subset(df, rev(!duplicated(rev(ID))), or \n> maybe\n> do.call(\"rbind\",lapply(split(df,df$ID), head, 1)), resp. tail. Or \n> something involving aggregate(). (The latter approaches generalize \n> better to other within-subject functionals like cumulative doses, etc.).\n> \n> The hardest cases that I know of are the ones where you need to turn one \n> record into many, such as occurs in survival analysis with \n> time-dependent, piecewise constant covariates. This may require \n> \"transposing the problem\", i.e. for each  interval you find out which \n> subjects contribute and with what, whereas the SAS way would be a \n> within-subject loop over intervals containing an OUTPUT statement.\n> \n> Also, there are some really weird data formats, where e.g. the input \n> format is different in different records. Back in the 80's where \n> punched-card input was still common, it was quite popular to have one \n> card with background information on a patient plus several cards \n> detailing visits, and you'd get a stack of cards containing both kinds. \n> In R you would most likely split on the card type using grep() and then \n> read the two kinds separately and merge() them later.\n> \n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide\n> http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n> \n\n\n\n      ____________________________________________________________________________________\nPark yourself in front of a world of choices in alternative vehicles. Visit the Yahoo! Auto Green Center.\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
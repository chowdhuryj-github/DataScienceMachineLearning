{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23422 - in branches/SAMBA_3_0_26/source: include\n\tlib utils", "body": "Author: obnox\nDate: 2007-06-11 15:49:57 +0000 (Mon, 11 Jun 2007)\nNew Revision: 23422\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23422\n\nLog:\nMerge (parts of) r19807, r19811, r19827.\nPreleminary merge for subsequent merge of restructuring of registry code.\n\nMichael\n\n\nModified:\n   branches/SAMBA_3_0_26/source/include/reg_objects.h\n   branches/SAMBA_3_0_26/source/lib/util_reg.c\n   branches/SAMBA_3_0_26/source/utils/net_rpc_printer.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/include/reg_objects.h\n===================================================================\n--- branches/SAMBA_3_0_26/source/include/reg_objects.h\t2007-06-11 14:47:05 UTC (rev 23421)\n+++ branches/SAMBA_3_0_26/source/include/reg_objects.h\t2007-06-11 15:49:57 UTC (rev 23422)\n@@ -32,6 +32,31 @@\n \tuint8           *data_p;\n } REGISTRY_VALUE;\n \n+/*\n+ * A REG_SZ string is not necessarily NULL terminated. When retrieving it from\n+ * the net, we guarantee this however. A server might want to push it without\n+ * the terminator though.\n+ */\n+\n+struct registry_string {\n+\tsize_t len;\n+\tchar *str;\n+};\n+\n+struct registry_value {\n+\tenum winreg_Type type;\n+\tunion {\n+\t\tuint32 dword;\n+\t\tuint64 qword;\n+\t\tstruct registry_string sz;\n+\t\tstruct {\n+\t\t\tuint32 num_strings;\n+\t\t\tchar **strings;\n+\t\t} multi_sz;\n+\t\tDATA_BLOB binary;\n+\t} v;\n+};\n+\n /* container for registry values */\n \n typedef struct {\n\nModified: branches/SAMBA_3_0_26/source/lib/util_reg.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/util_reg.c\t2007-06-11 14:47:05 UTC (rev 23421)\n+++ branches/SAMBA_3_0_26/source/lib/util_reg.c\t2007-06-11 15:49:57 UTC (rev 23422)\n@@ -20,7 +20,7 @@\n \n #include \"includes.h\"\n \n-const char *reg_type_lookup(uint32 type)\n+const char *reg_type_lookup(enum winreg_Type type)\n {\n \tconst char *result;\n \n@@ -69,7 +69,7 @@\n }\n \n NTSTATUS reg_pull_multi_sz(TALLOC_CTX *mem_ctx, const void *buf, size_t len,\n-\t\t\t   int *num_values, char ***values)\n+\t\t\t   uint32 *num_values, char ***values)\n {\n \tconst smb_ucs2_t *p = (const smb_ucs2_t *)buf;\n \t*num_values = 0;\n@@ -108,3 +108,118 @@\n \n \treturn NT_STATUS_OK;\n }\n+\n+NTSTATUS registry_pull_value(TALLOC_CTX *mem_ctx,\n+\t\t\t     struct registry_value **pvalue,\n+\t\t\t     enum winreg_Type type, uint8 *data,\n+\t\t\t     uint32 size, uint32 length)\n+{\n+\tstruct registry_value *value;\n+\tNTSTATUS status;\n+\n+\tif (!(value = TALLOC_ZERO_P(mem_ctx, struct registry_value))) {\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\tvalue->type = type;\n+\n+\tswitch (type) {\n+\tcase REG_DWORD:\n+\t\tif ((size != 4) || (length != 4)) {\n+\t\t\tstatus = NT_STATUS_INVALID_PARAMETER;\n+\t\t\tgoto error;\n+\t\t}\n+\t\tvalue->v.dword = IVAL(data, 0);\n+\t\tbreak;\n+\tcase REG_SZ:\n+\tcase REG_EXPAND_SZ:\n+\t{\n+\t\t/*\n+\t\t * Make sure we get a NULL terminated string for\n+\t\t * convert_string_talloc().\n+\t\t */\n+\n+\t\tsmb_ucs2_t *tmp;\n+\t\tuint32 num_ucs2 = length / 2;\n+\n+\t\tif ((length % 2) != 0) {\n+\t\t\tstatus = NT_STATUS_INVALID_PARAMETER;\n+\t\t\tgoto error;\n+\t\t}\n+\n+\t\tif (!(tmp = SMB_MALLOC_ARRAY(smb_ucs2_t, num_ucs2+1))) {\n+\t\t\tstatus = NT_STATUS_NO_MEMORY;\n+\t\t\tgoto error;\n+\t\t}\n+\n+\t\tmemcpy((void *)tmp, (const void *)data, length);\n+\t\ttmp[num_ucs2] = 0;\n+\n+\t\tvalue->v.sz.len = convert_string_talloc(\n+\t\t\tvalue, CH_UTF16LE, CH_UNIX, tmp, length+2,\n+\t\t\t&value->v.sz.str, False);\n+\n+\t\tSAFE_FREE(tmp);\n+\n+\t\tif (value->v.sz.len == (size_t)-1) {\n+\t\t\tstatus = NT_STATUS_INVALID_PARAMETER;\n+\t\t\tgoto error;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase REG_MULTI_SZ:\n+\t\tstatus = reg_pull_multi_sz(value, (void *)data, length,\n+\t\t\t\t\t   &value->v.multi_sz.num_strings,\n+\t\t\t\t\t   &value->v.multi_sz.strings);\n+\t\tif (!(NT_STATUS_IS_OK(status))) {\n+\t\t\tgoto error;\n+\t\t}\n+\t\tbreak;\n+\tcase REG_BINARY:\n+\t\tvalue->v.binary.data = talloc_move(value, &data);\n+\t\tvalue->v.binary.length = length;\n+\t\tbreak;\n+\tdefault:\n+\t\tstatus = NT_STATUS_INVALID_PARAMETER;\n+\t\tgoto error;\n+\t}\n+\n+\t*pvalue = value;\n+\treturn NT_STATUS_OK;\n+\n+ error:\n+\tTALLOC_FREE(value);\n+\treturn status;\n+}\n+\n+NTSTATUS registry_push_value(TALLOC_CTX *mem_ctx,\n+\t\t\t     const struct registry_value *value,\n+\t\t\t     DATA_BLOB *presult)\n+{\n+\tswitch (value->type) {\n+\tcase REG_DWORD: {\n+\t\tchar buf[4];\n+\t\tSIVAL(buf, 0, value->v.dword);\n+\t\t*presult = data_blob_talloc(mem_ctx, (void *)buf, 4);\n+\t\tif (presult->data == NULL) {\n+\t\t\treturn NT_STATUS_NO_MEMORY;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase REG_SZ:\n+\tcase REG_EXPAND_SZ: {\n+\t\tpresult->length = convert_string_talloc(\n+\t\t\tmem_ctx, CH_UNIX, CH_UTF16LE, value->v.sz.str,\n+\t\t\tMIN(value->v.sz.len, strlen(value->v.sz.str)+1),\n+\t\t\t(void *)&(presult->data), False);\n+\t\tif (presult->length == (size_t)-1) {\n+\t\t\treturn NT_STATUS_NO_MEMORY;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\treturn NT_STATUS_INVALID_PARAMETER;\n+\t}\n+\n+\treturn NT_STATUS_OK;\n+}\n\nModified: branches/SAMBA_3_0_26/source/utils/net_rpc_printer.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/utils/net_rpc_printer.c\t2007-06-11 14:47:05 UTC (rev 23421)\n+++ branches/SAMBA_3_0_26/source/utils/net_rpc_printer.c\t2007-06-11 15:49:57 UTC (rev 23422)\n@@ -129,7 +129,7 @@\n \t\tbreak;\n \n \tcase REG_MULTI_SZ: {\n-\t\tint i, num_values;\n+\t\tuint32 i, num_values;\n \t\tchar **values;\n \n \t\tif (!NT_STATUS_IS_OK(reg_pull_multi_sz(NULL, value.data_p,\n\n"}
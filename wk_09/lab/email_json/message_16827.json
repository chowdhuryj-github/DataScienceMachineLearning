{"category": "ham", "to_address": "Perl6 Internals <perl6-internals@perl.org>", "from_address": "Andy Spieherty <spiehera@lafayette.edu>", "subject": "Puzzling structure in <parrot/stacks.h>", "body": "Does anyone understand the 'dummy' element in \ninclude/parrot/stacks.h?  Here is the relevant snippet:\n\n    typedef struct Stack_Chunk {\n        pobj_t obj;\n        int size;\n        const char * name;\n        struct Stack_Chunk *prev;\n    #if ! DISABLE_GC_DEBUG && defined(I386)\n        void * dummy;   /* force 8 byte align for mmx and sse moves */\n    #endif\n        union { /* force appropriate alignment of 'data' */\n            void *data;\n    #ifndef I386\n            double d_dummy;         /* align double values on stack */\n    #endif\n        } u;\n    } Stack_Chunk_t;\n\n(I assume that mmx and sse are some sort of i386-specific instructions.)\n\nSpecifically, I'm wondering about two things:\n\n1.  Is the comment backwards?  If I count correctly, including the\n    void *dummy means that u.data will *NOT* be aligned on an 8-byte\n    boundary.  Is that the actual intent?  (Of course, compilers are\n    free to add in extra padding inside structures, and it may end up\n    aligned with some compilers but not aligned with others.)\n\n2.  Why is this dummy element only inserted used when \n    ! DISABLE_GC_DEBUG ?\n\n-- \n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n\n"}
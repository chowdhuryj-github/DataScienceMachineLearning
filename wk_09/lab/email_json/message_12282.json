{"category": "ham", "to_address": "Joshua Isom <jrisom@gmail.com>", "from_address": "Patrick Rutkowski <rutski89@gmail.com>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "I think Leo would be the best person to go to for an explanation,\nespecially if you plan to dramatically rework the code. He moved the\nwhole Parrot_alloc_context() routine from inter_create.c to\ngc/register.c in r9645. Along with the move in r9645 he added the slot\nvariable and all of its side effects; so he's likely to have a good\nunderstanding of these functions and their purpose as a whole.\n\nHowever, r9645 was 1.5 years ago; so I'm crossing my fingers that he\nstill remembers enough of this to be of any help.\n\nI'm CC-ing him to make sure that he gets wind of the issue.\n\nP.S. If you look at the r9645 version of Parrot_alloc_context() in\ninter_create.c then don't let the ifdef'd CHUNKED_CTX_MEM\nversion throw you; scroll down to after the #else and there's another\nversion of Parrot_alloc_context() (that's the right one). I hear that  \nthe\nCHUNKED_CTX_MEM idea has since been abandoned.\n\nOn Apr 22, 2007, at 2:18 AM, Joshua Isom wrote:\n\n>\n> On Apr 21, 2007, at 8:24 PM, chromatic wrote:\n>\n>> Parrot_alloc_context() performs some calculations about the number of\n>> registers used to determine how much memory to allocate:\n>>\n>>     const size_t size_n = sizeof (FLOATVAL) * n_regs_used[REGNO_NUM];\n>>     const size_t size_nip = size_n +\n>>         sizeof (INTVAL) *   n_regs_used[REGNO_INT] +\n>>         sizeof (PMC*) *     n_regs_used[REGNO_PMC];\n>>     size_t reg_alloc = size_nip +\n>>         sizeof (STRING*) *  n_regs_used[REGNO_STR];\n>>\n>> Then it calculates a slot value:\n>>\n>>     const int slot = (reg_alloc + 7) >> 3;\n>>     reg_alloc = slot << 3;\n>>\n>> This is where I start not to understand.  Why reg_alloc + 7?  Why  \n>> shift left\n>> and right by 3?\n>>\n>\n> I'm not sure if it is actually doing anything that needs to be that  \n> complicated to code that way.  It could be able to be written as:\n>\n>     const int slot = (reg_alloc + 7) / 8; /* divide by eight for  \n> some reason and round up on remainder */\n>     reg_alloc = slot * 8; /* reg_alloc is now evenly divisible by 8 */\n>\n> The difference is that if any of the last three bits are set, the  \n> +7 will let it round up, whereas without it it would round down.   \n> That's what it does, don't ask me why(other than maybe guaranteeing  \n> alignment?).  Might be using eight for an eight byte int, but if  \n> so, it should be using sizeof(void *) instead, I'm assuming would  \n> have been used.  Now, slot is multiplied by sizeof(void*) later on,  \n> which may be why it's divided by eight in the first place.\n>\n> The n = slot + 1 I find a little odd, because the number is already  \n> rounded up, so it's rounding up and then adding an extra place of  \n> memory.\n>\n>> It gets less clear.  The interpreter holds a structure for context  \n>> memory with\n>> a free list (an array of void pointers) and the number of free slots,\n>> presumably in this list.\n>>\n>> After all of that calculation of slot, the function uses it as an  \n>> index into\n>> the free list.\n>>\n>> I don't understand that at all.\n>>\n>> I do understand the purpose of the resizing code, but not how slot  \n>> relates to\n>> it:\n>>\n>>     if (slot >= interp->ctx_mem.n_free_slots) {\n>>         const int n = slot + 1;\n>>         int i;\n>>\n>>         interp->ctx_mem.free_list = (void **)mem_sys_realloc(\n>>                 interp->ctx_mem.free_list, n * sizeof (void*));\n>>\n>>         for (i = interp->ctx_mem.n_free_slots; i < n; ++i)\n>>             interp->ctx_mem.free_list[i] = NULL;\n>>         interp->ctx_mem.n_free_slots = n;\n>>     }\n>>\n>> This is doubly weird because when Parrot initializes the free list in\n>> create_initial_context(), it allocates a small number of free slots:\n>>\n>> #define INITIAL_FREE_SLOTS 8\n>>\n>>     interp->ctx_mem.n_free_slots = INITIAL_FREE_SLOTS;\n>>     interp->ctx_mem.free_list    =\n>>         (void **)mem_sys_allocate(INITIAL_FREE_SLOTS * sizeof  \n>> (void *));\n>>\n>>     for (i = 0; i < INITIAL_FREE_SLOTS; ++i)\n>>         interp->ctx_mem.free_list[i] = NULL;\n>>\n>> The result is that the free_list extends quite a bit over the initial\n>> allocation, but it's mostly just an array of null.  It's fairly  \n>> sparse apart\n>> from that.\n>>\n>> Here's another curious thing when allocating a context:\n>>\n>>     ptr = interp->ctx_mem.free_list[slot];\n>>     old = CONTEXT(interp->ctx);\n>>     if (ptr) {\n>>         interp->ctx_mem.free_list[slot] = *(void **) ptr;\n>>     }\n>>\n>> I wish I could tell you what the assignments to and from ptr do  \n>> here, but I\n>> can't, nor what they signify.  There's a similar form to free a  \n>> context:\n>>\n>>         ptr = ctxp;\n>>         slot = ctxp->regs_mem_size >> 3;\n>>\n>>         assert(slot < interp->ctx_mem.n_free_slots);\n>>         *(void **)ptr = interp->ctx_mem.free_list[slot];\n>>         interp->ctx_mem.free_list[slot] = ptr;\n>>\n>\n> The *(void **) has been confusing me for a long time.  It's also in  \n> smallobject.c where a seg fault sometimes happens.  But I've never  \n> been able to find out how to decipher it.  I can look at the dump  \n> of it with `objdump -dS src/gc/smallobject.c` but still get lost in  \n> it all(although looking at assembly, even intermixed with source  \n> code, requires a little too much of an understanding of the machine  \n> to figure out).\n>\n>> I originally thought the free_list was an array of recycled  \n>> contexts to avoid\n>> malloc() and free() pairs by reusing already-allocated-but-unused  \n>> memory, but\n>> now I can't tell what it's doing.  I tried to change this into a  \n>> linked list,\n>> but that failed with invalid reads.\n>>\n>\n> I thought it was a list of items to be freed, but that may be a  \n> different free_list sadly.  We have more than one in parrot.\n>\n>> My best guess is that this is an odd way to store contexts of a  \n>> specific size\n>> in an array structure so that they're reusable with our new  \n>> variable-sized\n>> register sets... but the code is unclear and undocumented.  I  \n>> think it's also\n>> leaking memory.\n>>\n>\n> Enable the context alloc and free, but probably change what's  \n> printed to make it easy to run through sort, and it might help, maybe.\n>\n>> I'd like to find a simpler scheme, if it's possible.  Otherwise,  \n>> I'd like to\n>> figure out what's going on so we can at least explain it somehow.\n>>\n>> -- c\n>>\n>>\n>\n> Rule one of writing in C for a project for many people to code,  \n> document the (you decide the explicative) out of it.\n>\n\n"}
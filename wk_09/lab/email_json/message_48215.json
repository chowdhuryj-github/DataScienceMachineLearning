{"category": "ham", "to_address": "\"perl6-language@perl.org\" <perl6-language@perl.org>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: [svn:perl6-synopsis] r14421 - doc/trunk/design/syn", "body": "Larry Wall wrote:\n> So I think a named reference is a good compromise, where the name in\n> the documentation (in some easily recognized syntactic form) refers\n> to the next declaration (or set of declarations) of that same name.\n> Hopefully the pod either knows implicitly or has been told explicitly\n> how to parse out such declarations for insertion into the document.\n> (And a positional notation could just be a degenerate case of not\n> specifying the name (or using a name of * maybe), so it finds the\n> next declaration of any name.  Maybe even some kind of wildcarding\n> works for hybrid situations.)\n>\n> The syntax for such named forward references is open for bikeshedding.\n> (I've intentionally not given any examples in this message to avoid\n> prejudicing the matter.)\n\nMy first instinct for such a thing would be to surround the perl code\nto be referenced with POD-like tags:\n\n  =code name\n  class foo\n  ...\n  =/code\n\n...the idea being that a Perl parser treats the =code and =/code lines\nas line comments, while a Pod parser would take the block of lines\nthat exists between the two and attaches it to 'name', to be rendered\nas is whenever 'name' is referenced.\n\nIn short, =code and =/code would define a target which could then be\nreferenced as few or as many times as you want within your regular\nperl code using something like\n\n  =ref name\n\n...where POD would substitute\n\n  class foo\n  ...\n\nevery time that it sees\n\n  =ref name\n\n--\n\nExpanding on this idea:\n\n* if you don't specify a name on a '=ref' line, you automatically\nreference the next '=code' section to be found.  If you don't bother\nnaming a '=code' section, this is the only way that it can be\nreferenced.  If you give '^' as the name, then you automatically\nreference the last code section that was found.  So:\n\n  =begin pod\n  =ref\n  =end pod\n\n  =code\n  foo\n  =/code\n\n  =begin pod\n  =ref ^\n  =end pod\n\nwould render the same as\n\n  =begin pod\n  foo\n  =end pod\n  =begin pod\n  foo\n  =end pod\n\n* Put a number instead of a name, and it counts up (if negative) or\ndown (if non-negative) through the code blocks, with -1 being the\nprevious code block and 0 being the next one.  A blank name is\nequivalent to 0, and a '^' is equivalent to -1.  This should be used\nsparingly.\n\n* Add or subtract a number to/from a name, and you count up or down\nfrom that name, with '+1' giving the first code block following the\nnamed codeblock and '-1' giving the last code block prior to it.\n\n* In the same way that '=code'...'=/code' is designed to mimic the\n'=begin'...'=end' syntax of POD blocks, you could introduce a\nvariation of '=code' that mimics the '=for' syntax by grabbing the\nnext line or block of code (say, '=codeline' and '=codeblock'), where\na block of code is terminated by a blank line.\n\n* the final violation of the separation of Church and State would be\nto have the Church ask the State to do something for it.  Let a\n'=code' line specify a parser (such as perl): Pod passes the block of\ncode to the specified parser; that parser then (presumably) goes\nthrough its paces with the goal of extracting language-specific\ndocumentation (such as the previously suggested 'is doc' traits),\nformatting the result as a text block, and handing that block back to\nthe POD parser.  If Pod can't talk to the language parser or vice\nversa, Pod simply uses the code block as is.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
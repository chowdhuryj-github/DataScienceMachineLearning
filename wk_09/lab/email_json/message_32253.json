{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 321: a better way to resend calls after recovery in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 321\nrevision-id: tridge@samba.org-20070518145649-ftagi1x44wuzm36n\nparent: tridge@samba.org-20070518134829-y384ldoxc07qxxi5\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sat 2007-05-19 00:56:49 +1000\nmessage:\n  a better way to resend calls after recovery\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_freeze.c           ctdb_freeze.c-20070512051503-935zdtyuqknqnhmo-1\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-05-18 13:23:36 +0000\n+++ b/common/ctdb_call.c\t2007-05-18 14:56:49 +0000\n@@ -607,37 +607,20 @@\n */\n static int ctdb_call_destructor(struct ctdb_call_state *state)\n {\n+\tDLIST_REMOVE(state->ctdb_db->ctdb->pending_calls, state);\n \tctdb_reqid_remove(state->ctdb_db->ctdb, state->reqid);\n \treturn 0;\n }\n \n \n /*\n-  called when a ctdb_call times out\n+  called when a ctdb_call needs to be resent after a reconfigure event\n */\n-static void ctdb_call_timeout(struct event_context *ev, struct timed_event *te, \n-\t\t\t      struct timeval t, void *private_data)\n+static void ctdb_call_resend(struct ctdb_call_state *state)\n {\n-\tstruct ctdb_call_state *state = talloc_get_type(private_data, struct ctdb_call_state);\n \tstruct ctdb_context *ctdb = state->ctdb_db->ctdb;\n \n-\tctdb->status.timeouts.call++;\n-\n-\tevent_add_timed(ctdb->ev, state, timeval_current_ofs(CTDB_CALL_TIMEOUT, 0), \n-\t\t\tctdb_call_timeout, state);\n-\n-\tif (++state->resend_count < 10 &&\n-\t    (ctdb->vnn_map->generation == state->generation ||\n-\t     ctdb->recovery_mode != CTDB_RECOVERY_NORMAL)) {\n-\t\t/* the call is just being slow, or we are curently\n-\t\t   recovering, give it more time */\n-\t\treturn;\n-\t}\n-\n-\t/* the generation count changed or we're timing out too much -\n-\t   the call must be re-issued */\n \tstate->generation = ctdb->vnn_map->generation;\n-\tstate->resend_count = 0;\n \n \t/* use a new reqid, in case the old reply does eventually come in */\n \tctdb_reqid_remove(ctdb, state->reqid);\n@@ -651,7 +634,19 @@\n \tstate->c->hdr.destnode = ctdb->vnn;\n \n \tctdb_queue_packet(ctdb, &state->c->hdr);\n-\tDEBUG(0,(\"requeued ctdb_call after timeout\\n\"));\n+\tDEBUG(0,(\"resent ctdb_call\\n\"));\n+}\n+\n+/*\n+  resend all pending calls on recovery\n+ */\n+void ctdb_call_resend_all(struct ctdb_context *ctdb)\n+{\n+\tstruct ctdb_call_state *state, *next;\n+\tfor (state=ctdb->pending_calls;state;state=next) {\n+\t\tnext = state->next;\n+\t\tctdb_call_resend(state);\n+\t}\n }\n \n /*\n@@ -743,10 +738,10 @@\n \tstate->state  = CTDB_CALL_WAIT;\n \tstate->generation = ctdb->vnn_map->generation;\n \n+\tDLIST_ADD(ctdb->pending_calls, state);\n+\n \tctdb_queue_packet(ctdb, &state->c->hdr);\n \n-\tevent_add_timed(ctdb->ev, state, timeval_current_ofs(CTDB_CALL_TIMEOUT, 0), \n-\t\t\tctdb_call_timeout, state);\n \treturn state;\n }\n \n\n=== modified file 'common/ctdb_freeze.c'\n--- a/common/ctdb_freeze.c\t2007-05-12 11:25:26 +0000\n+++ b/common/ctdb_freeze.c\t2007-05-18 14:56:49 +0000\n@@ -223,5 +223,6 @@\n {\n \ttalloc_free(ctdb->freeze_handle);\n \tctdb->freeze_handle = NULL;\n+\tctdb_call_resend_all(ctdb);\n \treturn 0;\n }\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-05-18 13:48:29 +0000\n+++ b/include/ctdb_private.h\t2007-05-18 14:56:49 +0000\n@@ -265,6 +265,7 @@\n \tuint32_t num_clients;\n \tuint32_t seqnum_frequency;\n \tuint32_t recovery_master;\n+\tstruct ctdb_call_state *pending_calls;\n };\n \n struct ctdb_db_context {\n@@ -300,11 +301,6 @@\n           ctdb_fatal(ctdb, \"Out of memory in \" __location__ ); \\\n \t  }} while (0)\n \n-/* timeout for ctdb call operations. When this timeout expires we\n-   check if the generation count has changed, and if it has then\n-   re-issue the call */\n-#define CTDB_CALL_TIMEOUT 2\n-\n /* maximum timeout for ctdb control calls */\n #define CTDB_CONTROL_TIMEOUT 60\n \n@@ -390,6 +386,7 @@\n   state of a in-progress ctdb call\n */\n struct ctdb_call_state {\n+\tstruct ctdb_call_state *next, *prev;\n \tenum call_state state;\n \tuint32_t reqid;\n \tstruct ctdb_req_call *c;\n@@ -397,7 +394,6 @@\n \tconst char *errmsg;\n \tstruct ctdb_call call;\n \tuint32_t generation;\n-\tuint32_t resend_count;\n \tstruct {\n \t\tvoid (*fn)(struct ctdb_call_state *);\n \t\tvoid *private_data;\n@@ -828,5 +824,6 @@\n void ctdb_send_keepalive(struct ctdb_context *ctdb, uint32_t destnode);\n \n void ctdb_daemon_cancel_controls(struct ctdb_context *ctdb, struct ctdb_node *node);\n+void ctdb_call_resend_all(struct ctdb_context *ctdb);\n \n #endif\n\n"}
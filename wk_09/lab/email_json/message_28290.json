{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Rob Dixon <rob.dixon@350.com>", "subject": "Re: $1 $2 var confusion", "body": "Steve Bertrand wrote:\n> I have two scenarios here, and in the first one, I am not seeing the\n> logic I would normally expect. I'll compact the code as to save everyone\n> from scrolling. I have strict and warnings enabled (as I always do). Can\n> someone tell me why in the first case $1 isn't initialized and in the\n> second case it is?\n> \n> \n> # First run(catch $1 and $2, check $2 for correctness (it is), print $1)\n> \n> my $email = 'steveb@domain.com';\n> $email =~ /(.*)@(.*)/;\n> if ($2 !~ /domain\\.com/) {\n>         print \"var 2 is bad\\n\";\n> }\n> print \"$1\\n\";\n> \n> /** prints 'uninitialized' for line 'print \"$1\\n\";**/\n> \n> \n> # Second run(same as above, but the if will fail:\n> \n> my $email = 'steveb@wrong.com';\n> $email =~ /(.*)@(.*)/;\n> if ($2 !~ /domain\\.com/) {\n>         print \"var 2 is bad\\n\";\n> }\n> print \"$1\\n\";\n> \n> /** prints\n> var 2 is bad\n> steveb\n> */\n> \n> Why does the $1 initialize and print only if the 'if' fails?\n\n>From perldoc perlre:\n\n    The numbered match variables ($1, $2, $3, etc.) and the related\n    punctuation set ($+, $&, $`, $', and $^N) are all dynamically scoped\n    until the end of the enclosing block or until the next successful match,\n    whichever comes first.\n\nIn your first example, $1 is valid until the successful match /domain\\.com/, when\nit becomes undefined as there are no capturing parentheses. In the second example\n$1 retains its value since the match fails.\n\nIt's always safer to save captured strings before you use them, and I would never\nmake a capture variable the target of a regex match as in your $2 !~ /domain\\.com/.\nMuch better to write something like\n\n  use strict;\n  use warnings;\n\n  my $email = 'steveb@wrong.com';\n  my ($name, $host) = $email =~ /(.*)@(.*)/;\n\n  if ($host !~ /domain\\.com/) {\n    print \"Host name is bad\\n\";\n  }\n\n  print \"$name\\n\";\n\nand also, in this case, the test would be better as\n\n  unless ($host eq 'domain.com') {\n    print \"Host name is bad\\n\";\n  }\n\nunless you really want to test whether the host name /contains/ that string?\n\nOh, and I think I also prefer\n\n  my ($name, $host) = split /@/, $email;\n\ninstead of the first regex.\n\nHTH,\n\nRob\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "Gabor Grothendieck <ggrothendieck@gmail.com>", "from_address": "Albert Pang <albert.pang@mac.com>", "subject": "Re: [R] Looking for the first observation within the month", "body": "I have only just able to dissect Jim's solution and realize I am  \nactually not very far away from the answer.  One last step was to use  \n\"lapply\".  Jim, thanks again for the help.\n\nGabor, thanks for the suggestion.  Let me have a read on what the zoo  \npackage is about.  Thanks a lot for the pointer!\n\nAlbert\n\nOn May 27, 2007, at 10:48 PM, Gabor Grothendieck wrote:\n\n> Use the zoo package to represent data like this.\n>\n> Here time(z) is a vector of the dates and as.yearmon(time(z))\n> is the year/month of each date.  With FUN=head1, ave picks out the  \n> first\n> date in any month and aggregate then aggregates over all\n> values in the same year/month choosing the first one.\n>\n> Lines <- \"Date                    Observation\n>\n> 2007-05-23              20\n> 2007-05-22              30\n> 2007-05-21              10\n>\n> 2007-04-10              50\n> 2007-04-09              40\n> 2007-04-07              30\n>\n> 2007-03-05              10\n> \"\n>\n> library(zoo)\n>\n> # z <- read.zoo(\"myfile.dat\", header = TRUE)\n> z <- read.zoo(textConnection(Lines), header = TRUE)\n>\n> head1 <- function(x, n = 1) head(x, n)\n> aggregate(z, ave(time(z), as.yearmon(time(z)), FUN = head1), head1)\n>\n>\n> For more on zoo try:\n>\n> library(zoo)\n> vignette(\"zoo\")\n>\n> and also read the Help Desk article in R News 4/1 about dates.\n>\n>\n>\n> On 5/27/07, Albert Pang  wrote:\n>> Hi all, I have a simple data frame, first list is a list of dates (in\n>> \"%Y-%m-%d\" format) and second list an observation on that particular\n>> date.  There might not be observations everyday.  Let's just say\n>> there are no observations on saturdays and sundays.  Now I want to\n>> select the first observation of every month into a list.  Is there an\n>> easy way to do that?\n>>\n>> Date                    Observation\n>> ----                    -----------\n>> 2007-05-23              20\n>> 2007-05-22              30\n>> 2007-05-21              10\n>>\n>> 2007-04-10              50\n>> 2007-04-09              40\n>> 2007-04-07              30\n>>\n>> 2007-03-05              10\n>>\n>> The result I need is the data frame\n>>\n>> 2007-05-21              10\n>> 2007-04-07              30\n>> 2007-03-05              10\n>>\n>> or I am equally happy with just the vector c(10, 30, 10)\n>>\n>> I am new to R and after going through the manuals and the\n>> documentation I can gather, I have come up with a convoluted way of\n>> doing it\n>>\n>> 1)  I first get the Date into a vector.  (I am articificially\n>> reproducing this vector below and call it A)\n>>\n>>  > A<-c( as.Date(\"2007-05-23\"), as.Date(\"2007-05-22\"), as.Date\n>> (\"2007-05-21\"), as.Date(\"2007-04-10\"), as.Date(\"2007-04-09\"), as.Date\n>> (\"2007-04-07\"), as.Date(\"2007-03-05\"))\n>>  > A\n>> [1] \"2007-05-23\" \"2007-05-22\" \"2007-05-21\" \"2007-04-10\" \"2007-04-09\"\n>> [6] \"2007-04-07\" \"2007-03-05\"\n>>\n>>\n>> 2)  use cut with breaks falling on the months\n>>\n>>  > B<-cut(A, breaks=\"month\")\n>>  > B\n>> [1] 2007-05-01 2007-05-01 2007-05-01 2007-04-01 2007-04-01 2007-04-01\n>> [7] 2007-03-01\n>> Levels: 2007-03-01 2007-04-01 2007-05-01\n>>\n>>\n>> 3)  then split to get a list of vectors group by the boundary of the\n>> date\n>>\n>>  > C<-split(A, B)\n>>  > C\n>> $`2007-03-01`\n>> [1] \"2007-03-05\"\n>>\n>> $`2007-04-01`\n>> [1] \"2007-04-10\" \"2007-04-09\" \"2007-04-07\"\n>>\n>> $`2007-05-01`\n>> [1] \"2007-05-23\" \"2007-05-22\" \"2007-05-21\"\n>>\n>>\n>> 4)  in a for loop I loop through the elements within the list (the\n>> elements are vectors of dates) with each vector I find the minimum\n>> and concatentate it to a final vector D\n>>\n>>  > D<-numeric()\n>>  > for ( i in 1:length(C)){ D <- c( D, min(C[[i]]))}\n>>  > class(D)<-\"Date\"\n>>  > D\n>> [1] \"2007-03-05\" \"2007-04-07\" \"2007-05-21\"\n>>\n>> Next with D, I then go back and find out the positions of the\n>> elements in D within A.  And then use the result as an index vector\n>> into the vector of observations (which is not shown here)  I feel\n>> sure I am doing it the stupid way (or the procedural way)\n>>\n>> Is there a more declarative way of doing it?  Any pointers will be\n>> greatly appreciated!\n>>\n>> Thanks a lot in advance,\n>>\n>> Albert Pang\n>>\n>>\n>>\n>>\n>>\n>>        [[alternative HTML version deleted]]\n>>\n>> ______________________________________________\n>> R-help@stat.math.ethz.ch mailing list\n>> https://stat.ethz.ch/mailman/listinfo/r-help\n>> PLEASE do read the posting guide http://www.R-project.org/posting- \n>> guide.html\n>> and provide commented, minimal, self-contained, reproducible code.\n>>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
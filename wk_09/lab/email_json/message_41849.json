{"category": "ham", "to_address": "James Peach <jpeach@samba.org>", "from_address": "tridge@samba.org", "subject": "Re: getting rid of mkproto.sh from Samba3", "body": "James,\n\n > >> mkproto.sh promotes lazing programming, leads to bad interfaces\n > >> and to monolithic code.\n > \n > This is the basic reason why I don't like mkproto.sh. I'd also add that\n > \t- it makes it impossible to do incremental builds\n > \t- it makes it harder to find existing interfaces, raising the  \n > barrier to contributions\n > \t- it makes it harder to document existing interfaces\n > \t- leads to false sharing, forcing trivial tools to link most of lib/\n\nThis is not a result of mkproto. In Samba4 we do automatic prototype\ngeneration for many of our subsystems but not for all, yet it doesn't\nsuffer from any of the above problems:\n\n - we do incremental builds, as each subsystem gets its own\n    proto.h. So for example, the libcli/raw library gets\n    libcli/raw/raw_proto.h. Only subsystems that need that library\n    include that header\n\n - it is not hard to find existing interfaces, as we separate the\n   headers for each interface. The generated headers are short, and\n   are located in the same directory as the library code that are for\n\n - I think it makes it easier to document interfaces as the interfaces\n   to the library are conveniently located next to the code\n\n - it doesn't lead to false sharing, as we separate the headers\n\n - the samba4 code is not monolithic\n\n - the samba4 code doesn't have bad interfaces.\n\nThe problems you are seeing are due to my original design of mkproto\nwhich do it all as one big proto.h. Jelmer re-designed our mkproto to\nsplit up the generated headers, and that got rid of all of the\nproblems you mentioned. Jelmer also did a much faster and cleaner\nmkproto in perl.\n\nWe control which subsystems get automatic prototype generation using\noptions like this:\n\n [SUBSYSTEM::LIBCLI_RAW]\n  PRIVATE_PROTO_HEADER = raw/raw_proto.h\n  PRIVATE_DEPENDENCIES = LIBCLI_COMPOSITE \n  PUBLIC_DEPENDENCIES = samba-socket LIBPACKET gensec LIBCRYPTO\n  LDFLAGS = $(SUBSYSTEM_LIBCLI_SMB_COMPOSITE_OUTPUT)\n  OBJ_FILES = raw/rawfile.o \\ (etc etc)\n\nIf you have a read through the generated prototypes, I think you'll\nfind them clean, and easy to read.\n\nSo you can use prototype generation without the problems you\nmention. It just takes a bit more work upfront to get it right.\n\nThat said, we don't do automatic prototype generation for all of our\ncode. For some subsystems we choose to do it manually, which means we\nleave out the PRIVATE_PROTO_HEADER option in the configuration for\nthat subsystem. That gives a lot of flexibility.\n\nAn intermediate option would be to have a pre-processor directory to\nsay \"this function should be auto-prototyped\". For example, you could\ndo this:\n\n_AUTOPROTO_ NTSTATUS smb_raw_seek(struct smbcli_tree *tree,\n\t\t\t      union smb_seek *parms)\n{\n\tstruct smbcli_request *req = smb_raw_seek_send(tree, parms);\n\treturn smb_raw_seek_recv(req, parms);\n}\n\nand teach mkproto to only prototype stuff with _AUTOPROTO_. That might\nbe a reaonable approach if you want most stuff not to be automatically\nprototyped. \n\nThis is similar to the _PUBLIC_ directive which Jelmer added so that\nwe can have most symbols only be usable internally, and not\naccidentially export an internal symbol via a library.\n\nCheers, Tridge\n\n"}
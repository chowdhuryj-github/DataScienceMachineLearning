{"category": "ham", "to_address": "Games for the OLPC <games@laptop.org>,\n   \"OLPC Developer's List\" <devel@laptop.org>,\n   \"'Sugar List'\" <sugar@laptop.org>", "from_address": "Don Hopkins <dhopkins@DonHopkins.com>", "subject": "[sugar] Cairo tile engine,\n\tand accessing 565 buffers from cairo and C", "body": "I've been working on a cairo-based tile engine written in C as a Python \nextension (part of my cellular automata machine module), which I now \nhave working well enough to display animated cellular automata in two \nmodes: as tiles or as pixels.\n\nTo render tiles, you pass it an array of cairo surfaces you've read in \n(or rendered), one for each tile, and it draws them by painting the \nsurfaces onto a cairo context you pass in.\n\nTo render pixels, you pass it one cairo surface which it grabs pixels \nout of, and it draws by storing the pixels into a destination image \nsurface. The caller can then render that destination surface on the \nscreen itself (scaling if it likes).\n\nTheoretically the tile mode could render tiny 1x1 colored tiles to \nproduce the same results as the pixel mode, but it would be much less \nefficient to draw individual pixels by calling Cairo to copy 1x1 \nsurfaces. So I implemented the pixel mode to support single color tiles \ndirectly, drawing into an offscreen cairo surface instead of using the \ncairo context.\n\nI've read on the mailing list that Cairo supports 565 (\"begrudgingly\", \nwhatever that implies).\nBut the surfaces it's handing my C code are 32 bit (RGB or ARGB).\n(Or at least that's what's happening on the emulator with a 16 bit 565 \nscreen -- I haven't tested it on the actual olpc yet).\nHow can I get ahold of the actual 16 bit 565 buffer that X can directly \nand efficiently draw on the screen?\nI've read through the Cairo code, and apparently it has no internal \nsupport for 16 bit pixels.\nSo is it the xlib/xrender back-end that actually has a 16 bit buffer and \ndoes the 888=>565 conversion?\nIs there any way for my C code to get ahold of that buffer to draw \ndirectly into it?\nOr do I have to puff everything up to 32 bit color, just to let Cairo's \nback-end stomp it back down to 565?\nIf there's a 565 screen buffer somewhere, there there should be a way \nfor C code to take a cairo context and use it to figure out the 565 \nbuffer to draw into (in the special case of the x backend).\n(Of course it would be the C code's responsibility to respect Cairo's \nCTM and know the pixel format and stuff like that, but that's just fine \nsince it goes with the territory, and is worth doing to make it draw \nefficiently.)\n\nA direct access api to Cairo's 16 bit buffer would make it possible to \nintegrate SDL and other rendering libraries (like Mesa) with Cairo, \nwithout going through another X window, so games and Python extensions \ncould draw more efficiently without doing lots of unnecessary format \nconversions.\n\nI took a look at the USInvaders demo that uses PyGame and SDL, and it \nlooks like it just makes another X window that SDK draws in directly, \ninstead of going through Cairo. So SDL is drawing directly in 565, but \ngoing around Cairo's back, using a GTK \"Socket\" window.\n\n    -Don\n\n_______________________________________________\nSugar mailing list\nSugar@laptop.org\nhttp://mailman.laptop.org/mailman/listinfo/sugar\n\n"}
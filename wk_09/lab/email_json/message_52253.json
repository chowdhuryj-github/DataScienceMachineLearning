{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r23573 - in branches: SAMBA_3_0/source/nsswitch\n\tSAMBA_3_0_25/source/nsswitch SAMBA_3_0_26/source/nsswitch", "body": "Author: jra\nDate: 2007-06-21 18:44:14 +0000 (Thu, 21 Jun 2007)\nNew Revision: 23573\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23573\n\nLog:\nCope with terminating winbindd children on read/write/timeout\ncommunication failures. Set timeout to 5 mins. Ensure that\nwe're terminating the correct child (the one we thought we\nwere talking to). Still setting up my testing environment\nbut I have high hopes for this being the fix for the 3.0.25b\nshowstopper.\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/nsswitch/winbindd_dual.c\n   branches/SAMBA_3_0_25/source/nsswitch/winbindd_dual.c\n   branches/SAMBA_3_0_26/source/nsswitch/winbindd_dual.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/nsswitch/winbindd_dual.c\n===================================================================\n--- branches/SAMBA_3_0/source/nsswitch/winbindd_dual.c\t2007-06-21 17:25:13 UTC (rev 23572)\n+++ branches/SAMBA_3_0/source/nsswitch/winbindd_dual.c\t2007-06-21 18:44:14 UTC (rev 23573)\n@@ -97,6 +97,8 @@\n \tstruct winbindd_response *response;\n \tvoid (*continuation)(void *private_data, BOOL success);\n \tstruct timed_event *reply_timeout_event;\n+\tpid_t child_pid; /* pid of the child we're waiting on. Used to detect\n+\t\t\t    a restart of the child (child->pid != child_pid). */\n \tvoid *private_data;\n };\n \n@@ -129,6 +131,7 @@\n \tstate->response = response;\n \tstate->continuation = continuation;\n \tstate->private_data = private_data;\n+\tstate->child_pid = child->pid;\n \n \tDLIST_ADD_END(child->requests, state, struct winbindd_async_request *);\n \n@@ -174,36 +177,53 @@\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n \n+\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n+\t\t\"Closing connection to it.\\n\",\n+\t\tstate->child_pid ));\n+\n \t/* Deal with the reply - set to error. */\n-\n \tasync_reply_recv(private_data, False);\n+}\n \n-\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n-\t\t\"Closing connection to it.\\n\",\n-\t\tstate->child->pid ));\n+/**************************************************************\n+ Common function called on both async send and recv fail.\n+ Cleans up the child and schedules the next request.\n+**************************************************************/\n \n-\t/* Send kill signal to child. */\n-\tkill(state->child->pid, SIGTERM);\n+static void async_request_fail(struct winbindd_async_request *state)\n+{\n+\tDLIST_REMOVE(state->child->requests, state);\n \n-\t/* \n-\t * Close the socket to the child.\n-\t */\n+\tif (state->reply_timeout_event) {\n+\t\tTALLOC_FREE(state->reply_timeout_event);\n+\t}\n \n-\twinbind_child_died(state->child->pid);\n+\tSMB_ASSERT(state->child_pid != (pid_t)0);\n+\n+\t/* If not already reaped, send kill signal to child. */\n+\tif (state->child->pid == state->child_pid) {\n+\t\tkill(state->child_pid, SIGTERM);\n+\n+\t\t/* \n+\t\t * Close the socket to the child.\n+\t\t */\n+\t\twinbind_child_died(state->child_pid);\n+\t}\n+\n+\tstate->response->length = sizeof(struct winbindd_response);\n+\tstate->response->result = WINBINDD_ERROR;\n+\tstate->continuation(state->private_data, False);\n }\n \n static void async_request_sent(void *private_data_data, BOOL success)\n {\n-\tuint32_t timeout = 30;\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data_data, struct winbindd_async_request);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not send async request\\n\"));\n-\n-\t\tstate->response->length = sizeof(struct winbindd_response);\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tDEBUG(5, (\"Could not send async request to child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n@@ -215,25 +235,14 @@\n \t\t\t async_reply_recv, state);\n \n \t/* \n-\t * Normal timeouts are 30s, but auth requests may take a long\n-\t * time to timeout.\n-\t */\n-\n-\tif (state->request->cmd == WINBINDD_PAM_AUTH ||\n-\t\t\tstate->request->cmd == WINBINDD_PAM_AUTH_CRAP ) {\n-\n-\t\ttimeout = 300;\n-\t}\n-\n-\t/* \n-\t * Set up a timeout of 30 seconds for the response.\n+\t * Set up a timeout of 300 seconds for the response.\n \t * If we don't get it close the child socket and\n \t * report failure.\n \t */\n \n \tstate->reply_timeout_event = event_add_timed(winbind_event_context(),\n \t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\ttimeval_current_ofs(timeout,0),\n+\t\t\t\t\t\t\ttimeval_current_ofs(300,0),\n \t\t\t\t\t\t\t\"async_request_timeout\",\n \t\t\t\t\t\t\tasync_request_timeout_handler,\n \t\t\t\t\t\t\tstate);\n@@ -253,20 +262,18 @@\n \tstate->response->length = sizeof(struct winbindd_response);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not receive async reply\\n\"));\n+\t\tDEBUG(5, (\"Could not receive async reply from child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n \n-\t\tcache_cleanup_response(child->pid);\n-\t\tDLIST_REMOVE(child->requests, state);\n-\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tcache_cleanup_response(state->child_pid);\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n-\tSMB_ASSERT(cache_retrieve_response(child->pid,\n+\tSMB_ASSERT(cache_retrieve_response(state->child_pid,\n \t\t\t\t\t   state->response));\n \n-\tcache_cleanup_response(child->pid);\n+\tcache_cleanup_response(state->child_pid);\n \t\n \tDLIST_REMOVE(child->requests, state);\n \n@@ -515,7 +522,7 @@\n \t}\n \n \tif (child == NULL) {\n-\t\tDEBUG(0, (\"Unknown child %d died!\\n\", pid));\n+\t\tDEBUG(5, (\"Already reaped child %u died\\n\", (unsigned int)pid));\n \t\treturn;\n \t}\n \n\nModified: branches/SAMBA_3_0_25/source/nsswitch/winbindd_dual.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/nsswitch/winbindd_dual.c\t2007-06-21 17:25:13 UTC (rev 23572)\n+++ branches/SAMBA_3_0_25/source/nsswitch/winbindd_dual.c\t2007-06-21 18:44:14 UTC (rev 23573)\n@@ -97,6 +97,8 @@\n \tstruct winbindd_response *response;\n \tvoid (*continuation)(void *private_data, BOOL success);\n \tstruct timed_event *reply_timeout_event;\n+\tpid_t child_pid; /* pid of the child we're waiting on. Used to detect\n+\t\t\t    a restart of the child (child->pid != child_pid). */\n \tvoid *private_data;\n };\n \n@@ -129,6 +131,7 @@\n \tstate->response = response;\n \tstate->continuation = continuation;\n \tstate->private_data = private_data;\n+\tstate->child_pid = child->pid;\n \n \tDLIST_ADD_END(child->requests, state, struct winbindd_async_request *);\n \n@@ -174,36 +177,53 @@\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n \n+\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n+\t\t\"Closing connection to it.\\n\",\n+\t\tstate->child_pid ));\n+\n \t/* Deal with the reply - set to error. */\n-\n \tasync_reply_recv(private_data, False);\n+}\n \n-\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n-\t\t\"Closing connection to it.\\n\",\n-\t\tstate->child->pid ));\n+/**************************************************************\n+ Common function called on both async send and recv fail.\n+ Cleans up the child and schedules the next request.\n+**************************************************************/\n \n-\t/* Send kill signal to child. */\n-\tkill(state->child->pid, SIGTERM);\n+static void async_request_fail(struct winbindd_async_request *state)\n+{\n+\tDLIST_REMOVE(state->child->requests, state);\n \n-\t/* \n-\t * Close the socket to the child.\n-\t */\n+\tif (state->reply_timeout_event) {\n+\t\tTALLOC_FREE(state->reply_timeout_event);\n+\t}\n \n-\twinbind_child_died(state->child->pid);\n+\tSMB_ASSERT(state->child_pid != (pid_t)0);\n+\n+\t/* If not already reaped, send kill signal to child. */\n+\tif (state->child->pid == state->child_pid) {\n+\t\tkill(state->child_pid, SIGTERM);\n+\n+\t\t/* \n+\t\t * Close the socket to the child.\n+\t\t */\n+\t\twinbind_child_died(state->child_pid);\n+\t}\n+\n+\tstate->response->length = sizeof(struct winbindd_response);\n+\tstate->response->result = WINBINDD_ERROR;\n+\tstate->continuation(state->private_data, False);\n }\n \n static void async_request_sent(void *private_data_data, BOOL success)\n {\n-\tuint32_t timeout = 30;\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data_data, struct winbindd_async_request);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not send async request\\n\"));\n-\n-\t\tstate->response->length = sizeof(struct winbindd_response);\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tDEBUG(5, (\"Could not send async request to child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n@@ -215,25 +235,14 @@\n \t\t\t async_reply_recv, state);\n \n \t/* \n-\t * Normal timeouts are 30s, but auth requests may take a long\n-\t * time to timeout.\n-\t */\n-\n-\tif (state->request->cmd == WINBINDD_PAM_AUTH ||\n-\t\t\tstate->request->cmd == WINBINDD_PAM_AUTH_CRAP ) {\n-\n-\t\ttimeout = 300;\n-\t}\n-\n-\t/* \n-\t * Set up a timeout of 30 seconds for the response.\n+\t * Set up a timeout of 300 seconds for the response.\n \t * If we don't get it close the child socket and\n \t * report failure.\n \t */\n \n \tstate->reply_timeout_event = event_add_timed(winbind_event_context(),\n \t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\ttimeval_current_ofs(timeout,0),\n+\t\t\t\t\t\t\ttimeval_current_ofs(300,0),\n \t\t\t\t\t\t\t\"async_request_timeout\",\n \t\t\t\t\t\t\tasync_request_timeout_handler,\n \t\t\t\t\t\t\tstate);\n@@ -253,20 +262,18 @@\n \tstate->response->length = sizeof(struct winbindd_response);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not receive async reply\\n\"));\n+\t\tDEBUG(5, (\"Could not receive async reply from child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n \n-\t\tcache_cleanup_response(child->pid);\n-\t\tDLIST_REMOVE(child->requests, state);\n-\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tcache_cleanup_response(state->child_pid);\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n-\tSMB_ASSERT(cache_retrieve_response(child->pid,\n+\tSMB_ASSERT(cache_retrieve_response(state->child_pid,\n \t\t\t\t\t   state->response));\n \n-\tcache_cleanup_response(child->pid);\n+\tcache_cleanup_response(state->child_pid);\n \t\n \tDLIST_REMOVE(child->requests, state);\n \n@@ -515,7 +522,7 @@\n \t}\n \n \tif (child == NULL) {\n-\t\tDEBUG(0, (\"Unknown child %d died!\\n\", pid));\n+\t\tDEBUG(5, (\"Already reaped child %u died\\n\", (unsigned int)pid));\n \t\treturn;\n \t}\n \n\nModified: branches/SAMBA_3_0_26/source/nsswitch/winbindd_dual.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/nsswitch/winbindd_dual.c\t2007-06-21 17:25:13 UTC (rev 23572)\n+++ branches/SAMBA_3_0_26/source/nsswitch/winbindd_dual.c\t2007-06-21 18:44:14 UTC (rev 23573)\n@@ -97,6 +97,8 @@\n \tstruct winbindd_response *response;\n \tvoid (*continuation)(void *private_data, BOOL success);\n \tstruct timed_event *reply_timeout_event;\n+\tpid_t child_pid; /* pid of the child we're waiting on. Used to detect\n+\t\t\t    a restart of the child (child->pid != child_pid). */\n \tvoid *private_data;\n };\n \n@@ -129,6 +131,7 @@\n \tstate->response = response;\n \tstate->continuation = continuation;\n \tstate->private_data = private_data;\n+\tstate->child_pid = child->pid;\n \n \tDLIST_ADD_END(child->requests, state, struct winbindd_async_request *);\n \n@@ -174,36 +177,53 @@\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n \n+\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n+\t\t\"Closing connection to it.\\n\",\n+\t\tstate->child_pid ));\n+\n \t/* Deal with the reply - set to error. */\n-\n \tasync_reply_recv(private_data, False);\n+}\n \n-\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n-\t\t\"Closing connection to it.\\n\",\n-\t\tstate->child->pid ));\n+/**************************************************************\n+ Common function called on both async send and recv fail.\n+ Cleans up the child and schedules the next request.\n+**************************************************************/\n \n-\t/* Send kill signal to child. */\n-\tkill(state->child->pid, SIGTERM);\n+static void async_request_fail(struct winbindd_async_request *state)\n+{\n+\tDLIST_REMOVE(state->child->requests, state);\n \n-\t/* \n-\t * Close the socket to the child.\n-\t */\n+\tif (state->reply_timeout_event) {\n+\t\tTALLOC_FREE(state->reply_timeout_event);\n+\t}\n \n-\twinbind_child_died(state->child->pid);\n+\tSMB_ASSERT(state->child_pid != (pid_t)0);\n+\n+\t/* If not already reaped, send kill signal to child. */\n+\tif (state->child->pid == state->child_pid) {\n+\t\tkill(state->child_pid, SIGTERM);\n+\n+\t\t/* \n+\t\t * Close the socket to the child.\n+\t\t */\n+\t\twinbind_child_died(state->child_pid);\n+\t}\n+\n+\tstate->response->length = sizeof(struct winbindd_response);\n+\tstate->response->result = WINBINDD_ERROR;\n+\tstate->continuation(state->private_data, False);\n }\n \n static void async_request_sent(void *private_data_data, BOOL success)\n {\n-\tuint32_t timeout = 30;\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data_data, struct winbindd_async_request);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not send async request\\n\"));\n-\n-\t\tstate->response->length = sizeof(struct winbindd_response);\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tDEBUG(5, (\"Could not send async request to child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n@@ -215,25 +235,14 @@\n \t\t\t async_reply_recv, state);\n \n \t/* \n-\t * Normal timeouts are 30s, but auth requests may take a long\n-\t * time to timeout.\n-\t */\n-\n-\tif (state->request->cmd == WINBINDD_PAM_AUTH ||\n-\t\t\tstate->request->cmd == WINBINDD_PAM_AUTH_CRAP ) {\n-\n-\t\ttimeout = 300;\n-\t}\n-\n-\t/* \n-\t * Set up a timeout of 30 seconds for the response.\n+\t * Set up a timeout of 300 seconds for the response.\n \t * If we don't get it close the child socket and\n \t * report failure.\n \t */\n \n \tstate->reply_timeout_event = event_add_timed(winbind_event_context(),\n \t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\ttimeval_current_ofs(timeout,0),\n+\t\t\t\t\t\t\ttimeval_current_ofs(300,0),\n \t\t\t\t\t\t\t\"async_request_timeout\",\n \t\t\t\t\t\t\tasync_request_timeout_handler,\n \t\t\t\t\t\t\tstate);\n@@ -253,20 +262,18 @@\n \tstate->response->length = sizeof(struct winbindd_response);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not receive async reply\\n\"));\n+\t\tDEBUG(5, (\"Could not receive async reply from child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n \n-\t\tcache_cleanup_response(child->pid);\n-\t\tDLIST_REMOVE(child->requests, state);\n-\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tcache_cleanup_response(state->child_pid);\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n-\tSMB_ASSERT(cache_retrieve_response(child->pid,\n+\tSMB_ASSERT(cache_retrieve_response(state->child_pid,\n \t\t\t\t\t   state->response));\n \n-\tcache_cleanup_response(child->pid);\n+\tcache_cleanup_response(state->child_pid);\n \t\n \tDLIST_REMOVE(child->requests, state);\n \n@@ -515,7 +522,7 @@\n \t}\n \n \tif (child == NULL) {\n-\t\tDEBUG(0, (\"Unknown child %d died!\\n\", pid));\n+\t\tDEBUG(5, (\"Already reaped child %u died\\n\", (unsigned int)pid));\n \t\treturn;\n \t}\n \n\n"}
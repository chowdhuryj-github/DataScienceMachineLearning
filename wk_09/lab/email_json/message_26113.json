{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 12125: Avoid use of typedefs,\n\tin Samba 4 style. in file:///home/jelmer/bzr.samba/SAMBA_4_0/", "body": "At file:///home/jelmer/bzr.samba/SAMBA_4_0/\n\n------------------------------------------------------------\nrevno: 12125\nrevision-id: jelmer@samba.org-20070509105243-c8umb0w5w1d1ogsj\nparent: jelmer@samba.org-20070509104652-bkzgo0ludqq6ycj2\ncommitter: Jelmer Vernooij \nbranch nick: SAMBA_4_0\ntimestamp: Wed 2007-05-09 12:52:43 +0200\nmessage:\n  Avoid use of typedefs, in Samba 4 style.\nmodified:\n  source/param/loadparm.c        svn-v2:2@0c0555d6-39d7-0310-84fc-f1cc0bd64818-trunk-source%2fparam%2floadparm.c\n=== modified file 'source/param/loadparm.c'\n--- a/source/param/loadparm.c\t2007-05-09 10:46:52 +0000\n+++ b/source/param/loadparm.c\t2007-05-09 10:52:43 +0000\n@@ -88,7 +88,7 @@\n /* \n  * This structure describes global (ie., server-wide) parameters.\n  */\n-typedef struct\n+struct global\n {\n \tint server_role;\n \n@@ -189,15 +189,14 @@\n \tint bDisableNetbios;\n \tint bRpcBigEndian;\n \tstruct param_opt *param_opt;\n-}\n-global;\n+};\n \n-static global Globals;\n+static struct global Globals;\n \n /* \n  * This structure describes a single service. \n  */\n-typedef struct\n+struct service\n {\n \tint valid;\n \tchar *szService;\n@@ -229,13 +228,12 @@\n \tstruct param_opt *param_opt;\n \n \tchar dummy[3];\t\t/* for alignment */\n-}\n-service;\n+};\n \n \n /* This is a default service used to prime a services structure */\n-static service sDefault = {\n-\tTrue,\t\t\t/* valid */\n+static struct service sDefault = {\n+\ttrue,\t\t\t/* valid */\n \tNULL,\t\t\t/* szService */\n \tNULL,\t\t\t/* szPath */\n \tNULL,\t\t\t/* szCopy */\n@@ -250,14 +248,14 @@\n \t1000,\t\t\t/* iMaxPrintJobs */\n \t0,\t\t\t/* iMaxConnections */\n \t0,\t\t\t/* iCSCPolicy */\n-\tTrue,\t\t\t/* bAvailable */\n-\tTrue,\t\t\t/* bBrowseable */\n-\tTrue,\t\t\t/* bRead_only */\n+\ttrue,\t\t\t/* bAvailable */\n+\ttrue,\t\t\t/* bBrowseable */\n+\ttrue,\t\t\t/* bRead_only */\n \tfalse,\t\t\t/* bPrint_ok */\n \tfalse,\t\t\t/* bMap_system */\n \tfalse,\t\t\t/* bMap_hidden */\n-\tTrue,\t\t\t/* bMap_archive */\n-\tTrue,\t\t\t/* bStrictLocking */\n+\ttrue,\t\t\t/* bMap_archive */\n+\ttrue,\t\t\t/* bStrictLocking */\n \tNULL,\t\t\t/* copymap */\n \tfalse,\t\t\t/* bMSDfsRoot */\n \tfalse,\t\t\t/* bStrictSync */\n@@ -273,7 +271,7 @@\n \n struct loadparm_context {\n \tint iNumServices;\n-\tservice **ServicePtrs;\n+\tstruct service **ServicePtrs;\n \t\n \t/* Files used by this loadparm context */\n \tstruct file_lists {\n@@ -955,13 +953,13 @@\n static int map_parameter(const char *pszParmName);\n static int getservicebyname(struct loadparm_context *ctx, \n \t\t\t\t\t\t\tconst char *pszServiceName,\n-\t\t\t\t\t\t\tservice * pserviceDest);\n-static void copy_service(service * pserviceDest,\n-\t\t\t service * pserviceSource, int *pcopymapDest);\n+\t\t\t\t\t\t\tstruct service * pserviceDest);\n+static void copy_service(struct service * pserviceDest,\n+\t\t\t struct service * pserviceSource, int *pcopymapDest);\n static BOOL service_ok(struct loadparm_context *ctx, int iService);\n static BOOL parse_section(const char *pszSectionName, void *);\n static BOOL parse_parameter(const char *, const char *, void *);\n-static void init_copymap(service * pservice);\n+static void init_copymap(struct service * pservice);\n \n /* This is a helper function for parametrical options support. */\n /* It returns a pointer to parametrical option value if it exists or NULL otherwise */\n@@ -1157,9 +1155,9 @@\n  Initialise a service to the defaults.\n ***************************************************************************/\n \n-static void init_service(service * pservice)\n+static void init_service(struct service * pservice)\n {\n-\tmemset((char *)pservice, '\\0', sizeof(service));\n+\tZERO_STRUCTP(pservice);\n \tcopy_service(pservice, &sDefault, NULL);\n }\n \n@@ -1167,7 +1165,7 @@\n  Free the dynamically allocated parts of a service struct.\n ***************************************************************************/\n \n-static void free_service(service *pservice)\n+static void free_service(struct service *pservice)\n {\n \tint i;\n         struct param_opt *data, *pdata;\n@@ -1217,10 +1215,10 @@\n ***************************************************************************/\n \n static int add_a_service(struct loadparm_context *ctx, \n-\t\t\t\t\t\t const service *pservice, const char *name)\n+\t\t\t\t\t\t const struct service *pservice, const char *name)\n {\n \tint i;\n-\tservice tservice;\n+\tstruct service tservice;\n \tint num_to_alloc = ctx->iNumServices + 1;\n \tstruct param_opt *data, *pdata;\n \n@@ -1252,9 +1250,9 @@\n \n \t/* if not, then create one */\n \tif (i == ctx->iNumServices) {\n-\t\tservice **tsp;\n+\t\tstruct service **tsp;\n \t\t\n-\t\ttsp = realloc_p(ctx->ServicePtrs, service *,\tnum_to_alloc);\n+\t\ttsp = realloc_p(ctx->ServicePtrs, struct service *,\tnum_to_alloc);\n \t\t\t\t\t   \n \t\tif (!tsp) {\n \t\t\tDEBUG(0,(\"add_a_service: failed to enlarge ServicePtrs!\\n\"));\n@@ -1262,7 +1260,7 @@\n \t\t}\n \t\telse {\n \t\t\tctx->ServicePtrs = tsp;\n-\t\t\tctx->ServicePtrs[ctx->iNumServices] = malloc_p(service);\n+\t\t\tctx->ServicePtrs[ctx->iNumServices] = malloc_p(struct service);\n \t\t}\n \t\tif (!ctx->ServicePtrs[ctx->iNumServices]) {\n \t\t\tDEBUG(0,(\"add_a_service: out of memory!\\n\"));\n@@ -1453,7 +1451,8 @@\n ***************************************************************************/\n \n static int getservicebyname(struct loadparm_context *ctx, \n-\t\t\t\t\t\t\tconst char *pszServiceName, service * pserviceDest)\n+\t\t\t\t\t\t\tconst char *pszServiceName, \n+\t\t\t\t\t\t\tstruct service * pserviceDest)\n {\n \tint iService;\n \n@@ -1473,7 +1472,8 @@\n  If pcopymapDest is NULL then copy all fields\n ***************************************************************************/\n \n-static void copy_service(service * pserviceDest, service * pserviceSource, int *pcopymapDest)\n+static void copy_service(struct service * pserviceDest, \n+\t\t\t\t\t\t struct service * pserviceSource, int *pcopymapDest)\n {\n \tint i;\n \tBOOL bcopyall = (pcopymapDest == NULL);\n@@ -1699,7 +1699,7 @@\n {\n \tBOOL bRetval;\n \tint iTemp;\n-\tservice serviceTemp;\n+\tstruct service serviceTemp;\n \n \tstring_set(ptr, pszParmValue);\n \n@@ -1731,7 +1731,7 @@\n  Initialise a copymap.\n ***************************************************************************/\n \n-static void init_copymap(service *pservice)\n+static void init_copymap(struct service *pservice)\n {\n \tint i;\n \tSAFE_FREE(pservice->copymap);\n@@ -2262,7 +2262,7 @@\n  Display the contents of a single services record.\n ***************************************************************************/\n \n-static void dump_a_service(service * pService, FILE * f)\n+static void dump_a_service(struct service * pService, FILE * f)\n {\n \tint i;\n \tstruct param_opt *data;\n@@ -2306,7 +2306,7 @@\n BOOL lp_dump_a_parameter(struct loadparm_context *ctx, \n \t\t\t\t\t\t int snum, char *parm_name, FILE * f, BOOL isGlobal)\n {\n-\tservice * pService = ctx->ServicePtrs[snum];\n+\tstruct service * pService = ctx->ServicePtrs[snum];\n \tstruct parm_struct *parm;\n \tvoid *ptr;\n \t\n@@ -2353,7 +2353,7 @@\n \t\t\treturn &parm_table[(*i)++];\n \t\t}\n \t} else {\n-\t\tservice *pService = ctx->ServicePtrs[snum];\n+\t\tstruct service *pService = ctx->ServicePtrs[snum];\n \n \t\tfor (; parm_table[*i].label; (*i)++) {\n \t\t\tif (parm_table[*i].class == P_SEPARATOR)\n\n"}
{"category": "ham", "to_address": "Andy Spieherty <spiehera@lafayette.edu>", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [perl #39063] [RESOLVED] [TODO] ResizableBooleanArray uses 64\n  bytes per bit of information", "body": "Andy Spieherty wrote:\n> \n> Are you *sure* it's been fixed?  My test involved running a simple\n> program something like this\n> \n>     .sub _main\n> \t.local pmc pmc1\n> \tpmc1 = new ResizableBooleanArray\n> \tpmc1[1000] = 1\n>     .end\n> \n> and incrementing the '1000'.  I found that for every element I added,\n> parrot allocated 64 extra bytes.  (I monitored parrot's calls to malloc()\n> with -DDETAIL_MEMORY_DEBUG.)\n> \n> Hence if I want to store 1,000 bits, parrot will call malloc() to\n> allocate 64,000 bytes.  That's why I said it \"uses 64 bytes per bit of\n> information\".\n> \n> I apologize in advance if I have misunderstood the correct way to use \n> ResizableBooleanArray or what the number '1000' means in the above\n> example.\n\nAh, I see what you're talking about. I thought you meant it was taking \nup 64 bytes of storage for each bit of data (which it's not).\n\nYes, ResizableBooleanArray does allocate more memory than it immediately \nneeds for the number of indexes, anticipating future growth. What the \ncode is *supposed* to be doing is rounding off to the nearest 64 bits.\n\n   newASize = (size / MIN_ALLOC + 1) * MIN_ALLOC;\n\nThe first problem is, MIN_ALLOC isn't a simple value macro, it's an \nexpression, so instead of evaluating as:\n\n   newASize = (size / 64 + 1) * 64;\n\nIt's evaluating as:\n\n   newASize = (size / 8 * 8 + 1) * 8 * 8;\n\nWhich gives you a much larger result than intended! Wrapping the \nexpression in parens takes care of that, but it also means you're \nrecalculating the value every time you use the macro, so I changed it to \na simple constant:\n\n   #define MIN_ALLOC 64\n\nThe second problem is, after rounding to the nearest 64 bits, it's \npassing the number of bits directly into mem_sys_allocate_zeroed, but \nmem_sys_allocate_zeroed (a simple call to calloc) expects bytes. \n(FixedBooleanArray doesn't make this mistake, BTW.)\n\nResizableBooleanArray had another oddity where it was checking to see if \nit needed to reallocate based on the literal size, rather than the \nrounded size. So, if you stored 1000 bits, and then stored 1001 bits, it \nwould allocate 1024 bits and then reallocate 1024 bits, instead of just \nusing the allocated 1024 bits the second time. I fixed that.\n\nIn the process, I found a bug in the shift/unshift code. I'll fix that \nas a separate commit.\n\n(Joshua, I didn't see your patch until just now. You were close.)\n\nAllison\n\n"}
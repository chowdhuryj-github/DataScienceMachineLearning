{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>", "from_address": "Nicholas Clark <nick@ccl4.org>", "subject": "Re: [svn:parrot] r18381 - trunk/include/parrot", "body": "On Wed, May 09, 2007 at 01:06:49PM -0700, chromatic wrote:\n> On Wednesday 09 May 2007 12:53:57 Nicholas Clark wrote:\n> \n> > On Tue, May 01, 2007 at 04:41:22PM -0700, particle@cvs.perl.org wrote:\n> > > +\n> > > +#define STRING_IS_NULL(s) ((s) == NULL)\n> > > +#define STRING_IS_EMPTY(s) !(int)(s)->strlen\n\n> Does !(int)(s)->strlen really scan as quickly and easily as STRING_IS_EMPTY?\n\nMmm, yes, thinking about it more...\nWhat's that int cast doing there?\n\nSmells like a bug. Either (s)->strlen is going to be zero, in which case\n! of it is true, or it's going to be in the range INT_MIN to INT_MAX, in\nwhich case it's not true, or it's going to be outside that range, in which\ncase the cast is undefined behaviour. (because it's signed)\n\nI've not checked, and I'm not sure if it's going to be easy to do so, but\nI assume that the cast was moved into the macro as part of refactoring,\nand has been in the code for some time.\n\nSo, !s->strlen does scan as quickly and easily.\n\ns == NULL is also more tersely written as !s, which, I feel, is also clearer\nto regular C programmers.\n\nI've also intentionally left the parentheses off, as once you aren't using\nmacros, you can choose not to use them on simple expressions.\n\n> > Arguably one of the mistakes of Perl 5 was to use too many macros, which\n> > unintentionally contributes to obfuscating the code.\n> \n> It's not as if *these* are SvPVNL and SvPVZ, or was that SVpvNL or SvPv \n> or....?\n\nYes. Those ones. But after about 5 years I started to see the patterns in them.\n\nClearly 5 years isn't a rapid learning curve.\n\nNicholas Clark\n\n"}
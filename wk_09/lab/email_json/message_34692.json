{"category": "ham", "to_address": "Will Coleda <will@coleda.com>", "from_address": "Joshua Isom <jrisom@gmail.com>", "subject": "Re: new FAQs", "body": "\nOn May 21, 2007, at 5:56 PM, Will Coleda wrote:\n\n> I was talking to a colleague (who wishes to remain anonymous), and \n> s/he had a list of questions about the state of parrot that I think \n> should end up in the FAQ or elsewhere in the repo. I wanted to post \n> them here to get some discussion - I don't have answers to many of \n> these questions myself.\n>\n> ---\n>\n>\n> 1. Why Parrot?\n>\n> http://www.parrotcode.org/docs/intro.html:\n>\n> \"Parrot is designed with the needs of dynamically typed languages\n> (such as Perl and Python) in mind, and should be able to run programs\n> written in these languages more efficiently than VMs developed with\n> static languages in mind (JVM, .NET). Parrot is also designed to\n> provide interoperability between languages that compile to it. In\n> theory, you will be able to write a class in Perl, subclass it in\n> Python and then instantiate and use that subclass in a Tcl program.\"\n>\n> a. What, precisely, about Parrot makes possible more efficient\n> execution of a dynamically typed language than would be the case with\n> the JVM or the CLR?\n\nParrot is a register based machine instead of a stack based machine.  \nThis is the way your computer is designed.  Although many architectures \nheavily use the stack, registers are far more efficient.  Using a \nregister based machine makes JITing executable code far more efficient \nto come far closer to machine compiled speeds.\n\nBut that mainly affects statically typed languages, such as a parrot \nwithout pdd15.  WRT dynamically typed languages, parrot's designed for \nit.  It's as simple as that.\n\n> b. Whatever that is, how will it adversely impact the execution of\n> statically typed languages, including type-inferred languages?\n\nIf we don't force many high level components on all languages(such as a \nscalar is a scalar and is not an integer), and provide a capacity for a \nlanguage to create it's own types(new pmc's), they can provide the \nfunctionality they need without excessive overhead of other operations. \n  But this is where \"one vm for them all\" comes to hurt us, as well.  In \ntrying to support all languages, and provide at least the capacity for \nall languages, we hurt our optimization for one specific language which \nis what many languages do.\n\nI imagine parrot won't have a significant issue with statically type \nlanguages, but that it will be more of an issue of the compiler itself. \n  Parrot should be able to run java fast and efficently, so long as it's \ncompiled from java to pir, instead of running java bytecode, or \ncompiling java bytecode to pir.\n\n> c. How will this impact the execution of statically typed code in\n> Perl, Python and other targeted languages?\n\nMost problems will be from coding styles most likely.  Interoperability \nbetween functional programs will probably be a non-issue, but two \ndifferent oo languages(and thus two inheritance models) will likely \nimpact performance more.  But this is an issue of having one vm for \nall.\n\n> 2. General Features\n>\n> a. How will Parrot support reflection and attributes?\n>\n> b. How will Parrot support generics types?\n>\n> c. How will Parrot support interface types?\n>\n> d. What kind of security models will Parrot support?\n>\n> e. How will Parrot support small-footprint systems?\n\nPerhaps miniparrot can help take care of this.  If miniparrot's a \nminiature parrot, and perhaps supporting only those features that that \nlanguage needs, we might be able to get a parrot suited for embedded \nsystems.  PMC's not needed won't be compiled in, the runcores other \nthan the default could be left out, and parrot's size could shrink \ndramatically.\n\n> f. How will Parrot support direct access to \"unmanaged\" resources?\n\nIs this like UnmanagedStruct?\n\n> g. How will Parrot facilitate distributed processing?\n\nWith native threading support.\n\n> 3. Parrot PMC Issues\n>\n> The Parrot PMC vtable provides a large number of optional functions,\n> which PMCs can either implement or not. If not implemented, they will\n> throw an exception at runtime.\n>\n>\n> a. What support will Parrot provide a compiler to interrogate a PMC at\n> compile time to know what it actually implements?\n>\n> All of these functions appear to be predefined because there is no\n> mechanism for extending this functionality at runtime. It appears that\n> compilers will be limited to implementing functionality that is\n> defined in the vtable. The vtable contains the common operations\n> required by certain languages.\n\nThe only extendibility that I know of is via PIR, or a dnypmc library.  \nBut the vtables are primarily for interoperability with everything.  \nMethods can still be addded to a pmc to provide additional needs.\n\n> b. How will Parrot handle languages with operations that are not\n> provided?\n>\n> http://www.parrotcode.org/docs/vtables.html:\n>\n> \"To be perfectly honest, this is a slightly flawed example, since it's\n> unlikely that there will be a distinct \"Python scalar\" PMC class. The\n> Python compiler could well type-inference variables such that a would\n> be a PythonString and b would be a PythonNumber. But the point remains\n> - incrementing a PythonString is very different from incrementing a\n> PerlScalar.\"\n>\n> c. How will Parrot address cross-language semantics?\n>\n\nThe purpose of a common calling convention, and vtables, are to address \ncross language semantics.  All languages will implement the basic \nthings in the same way.  It's not a \"our way or the high way\" but \nrather a \"our way is the best way for parrot.\"\n\n> d. Will each language have to provide its own support for interacting\n> with PMCs for other languages?\n>\n\nNo, the PMC's will do that themselves.  Getting the PMC's is another \nstory.  A language is reponsible for it's cross language semantics.  \nBut parrot is designed for the widest possible case.  Many languages \nlimit valid characters that a subroutine can use, but parrot does not.  \nBut as long as \"common\" cases are adhered to, most problems will not \nexist, e.g. no unicode whitespace in a subroutine name.\n\n> e. How will a PerlScalar interact with a PythonString?\n\nThe best method would probably convert both down to a String, do \nwhatever operation, and convert up to whatever is request.  But, for \noptimization, multimethod vtables could be used to provide custom \nbehavior.  I know src/pmc/complex.pmc has some examples of multimethod \nvtables.\n\n> f. What will happen when a PythonString is incremented in Perl code?\n\nParrot call's PythonString's increment vtable.  Perl doesn't have an \nincrement, but PerlScalar does.  Python doesn't have an increment, but \nPythonString does.  Now, if the PMC doesn't implement that vtable \nfunction, an exception is thrown, but Parrot still tries to call it.\n\n> Comparing the vtable for a PMC to the JVM and CLR base Object classes,\n> the PMC is essentially an \"abstract\" class with dozens of\n> \"unimplemented\" methods, while Java's Object provides (and implements)\n> the following public methods:\n>\n>   equals getClass hashCode notify notifyAll toString wait\n>\n> Discounting the methods related to Java's peculiar threading\n> implementation, that's:\n>\n>   equals                 getClass hashCode    toString\n>\n> Similarly, the CLR's CTS Object provides:\n>\n>   Equals ReferenceEquals GetType  GetHashCode ToString\n>\n> g. Why is it a good thing that PMCs essentially non-contractual\n> abstract base classes that define a lot of functionality without\n> implementing it?\n\nIn some instances, this is a benefit.  Suppose you want an \nauto-iterating string array.  For the most part, it's an array with \nnormal array properties.  But if you get it's string value, it iterates \nover the next one.  If you set it's string value, maybe it splices that \nvalue into the array.  Having both array and string properties is \nbeneficial in this case.\n\nBut the downside is most things, such as an Integer, don't need many of \nthe vtables provided.  In fact, if you look at the c output of a pmc \nfile, you'll see that every vtable is created.  I imagine it's more for \nsimplicity and speed than for memory(both executable and ram) than \nanything else.\n\n> h. Why is there no first-tier depth in Parrot's type system, such as:\n>\n>   PMCString, PMCIntger, PMCNumber, ...\n>\n\nYou mean like String, Integer, Number, Array, etc?\n\n> 4. Parrot VM Issues\n>\n> Parrot provides what it calls \"registers\" with no guarantee that these\n> map to hardware registers.\n>\n> a. Will any registers ever map, in a Parrot-controlled way, to hardware\n> registers?\n\nYes.  If a subroutine uses less than or equal to the number of \nregisters on an architecture, the entire subroutine can be converted \ninto native code, leaving parrot out entirely.  Using a PPC system is \nbetter than an i386 system in this case, since it has more registers.  \nEven if the subroutine isn't compiled entirely to native code, portions \nof that code will be compiled to native code as best as possible.\n\nThe very basis of parrot's jit system is that both parrot and the \nnative system use registers, and that keeping data in registers helps \nto improve speed greatly.\n\n> b. How can a compiler efficiently allocate registers if it does not\n> know which ones will map to hardware registers?\n\nI don't believe there's a capacity for doing this at the moment.  It's \nup to parrot to decide how much is jitted and how much isn't.\n\n> 5. Parrot Design Issues\n>\n> Parrot has many operators and number of Core PMC types for them to\n> operate on. Parrot has so many operators that it appears to be using\n> them instead of having a standard library. This is markedly different\n> than the CLR and JVM systems.\n>\n> a. Why was this done this way?\n\nIf you look at the number of ops x86 has with an FPU, there are a \nmassive number.  The x87 cpu has an opcode for sine, just like parrot \ndoes.  Many of parrot's opcodes are for accessing features of parrot \nthrough pir.  Many of parrot's operations can't be easily taken away.  \nOne of the likely reasons is speed, but what things are the questioner \ncurious about?\n\n> b. What is the basis for deciding what will be an operator?\n>\n> c. How can substantial quantities of additional functionality be added\n> to this design cleanly?\n\nNew vtable's can be added by editting vtable.tbl, new ops can be added \nby adding to src/ops/experimental.ops, new pmc's can just be added to \nsrc/pmc afaik.  New charsets in src/charset, new jit architectures \nunder src/jit(just add --jitcapable and it'll try to compile it in).  \nI'd say it's a fairly clean layout for expanding things.  There's even \nthe capacity for adding a new garbage collected.\n\n>\n> --\n> Will \"Coke\" Coleda\n> will@coleda.com\n>\n>\n\n"}
{"category": "ham", "to_address": "Stephen Tucker <brown_emu@yahoo.com>", "from_address": "Prof Brian Ripley <ripley@stats.ox.ac.uk>", "subject": "Re: [R] passing (or obtaining) index or element name of list to FUN\n in lapply()", "body": "On Tue, 12 Jun 2007, Stephen Tucker wrote:\n\n> Hello everyone,\n>\n> I wonder if there is a way to pass the index or name of a list to a\n> user-specified function in lapply(). For instance, my desired effect is\n> something like the output of\n>\n>> L <- list(jack=4098,sape=4139)\n>> lapply(seq(along=L),function(i,x) if(i==1) \"jack\" else \"sape\",x=L)\n> [[1]]\n> [1] \"jack\"\n>\n> [[2]]\n> [1] \"sape\"\n\nas.list(names(L))\n\n>> lapply(seq(along=L),function(i,x) if(names(x)[i]==\"jack\") 1 else 2,x=L)\n> [[1]]\n> [1] 1\n>\n> [[2]]\n> [1] 2\n\nas.list(seq_along(L))\n\nlapply() can be faster than a for-loop, but usually not by much: its main \nadvantage is clarity of code.\n\nI think we need a real-life example to see what you are trying to do.\n\n> But by passing L as the first argument of lapply(). I thought there was a\n> tangentially-related post on this mailing list in the past but I don't recall\n> that it was ever addressed directly (and I can't seem to find it now). The\n> examples above are perfectly good alternatives especially if I wrap each of\n> the lines in \"names<-\"() to return lists with appropriate names assigned, but\n\nTry something like\n\nL[] <- lapply(seq_along(L),function(i,x) if(i==1) \"jack\" else \"sape\",x=L)\n\n> it feels like I am essentially writing a FOR-LOOP - though I was surprised to\n> find that speed-wise, it doesn't seem to make much of a difference (unless I\n> have not selected a rigorous test):\n>\n>> N <- 10000\n>> y <- runif(N)\n> ## looping through elements of y\n>> system.time(lapply(y,\n> +                    function(x) {\n> +                      set.seed(222)\n> +                      mean(rnorm(1e4,x,1))\n> +                    }))\n> [1] 21.00  0.17 21.29    NA    NA\n> ## looping through indices\n>> system.time(lapply(1:N,\n> +                    function(x,y) {\n> +                      set.seed(222)\n> +                      mean(rnorm(1e4,y[x],1))\n> +                      },y=y))\n> [1] 21.09  0.14 21.26    NA    NA\n>\n> In Python, there are methods for Lists and Dictionaries called enumerate(),\n> and iteritems(), respectively. Example applications:\n>\n> ## a list\n> L = ['a','b','c']\n> [x for x in enumerate(L)]\n> ## returns index of list along with the list element\n> [(0, 'a'), (1, 'b'), (2, 'c')]\n>\n> ## a dictionary\n> D = {'jack': 4098, 'sape': 4139}\n> [x for x in D.iteritems()]\n> ## returns element key (name) along with element contents\n> [('sape', 4139), ('jack', 4098)]\n>\n> And this is something of the effect I was looking for...\n>\n> Thanks to all,\n>\n> Stephen\n>\n> ______________________________________________\n> R-help@stat.math.ethz.ch mailing list\n> https://stat.ethz.ch/mailman/listinfo/r-help\n> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html\n> and provide commented, minimal, self-contained, reproducible code.\n>\n\n-- \nBrian D. Ripley,                  ripley@stats.ox.ac.uk\nProfessor of Applied Statistics,  http://www.stats.ox.ac.uk/~ripley/\nUniversity of Oxford,             Tel:  +44 1865 272861 (self)\n1 South Parks Road,                     +44 1865 272866 (PA)\nOxford OX1 3TG, UK                Fax:  +44 1865 272595\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
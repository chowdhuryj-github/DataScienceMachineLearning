{"category": "ham", "to_address": "Jeremy Allison <jra@samba.org>", "from_address": "Mikhail Teterin <mi+kde@aldan.algebra.com>", "subject": "Re: prs_uint32 applied to pointers?", "body": "On Wednesday 16 May 2007 20:32, Jeremy Allison wrote:\n= >        uni_p = fl3->path ? (uint32)fl3->path : 0;\n= >        if(!prs_uint32(\"ptr\", ps, depth, &uni_p))\n= >                return False;\n= > \n= > Although the 32-bit systems will not notice, the code does not seem \n= > right for 64-bit ones, where pointers are 64-bit wide. Can someone, \n= > please, comment? Silencing the warning is easy, but there may be a \n= > genuine problem pointed out here.\n= \n= Actually it should be putting \"1\" here as all that matters is\n= that the pointer is non-zero.\n\nThe way things are now, it could be getting it wrong every once in a while, \nwhen the lower 32-bits of the pointer happen to be zeros. :-(\n\nHow about:\n\n\tuni_p = (fl3->path != NULL);\n\nYours,\n\n\t-mi\n\n"}
{"category": "ham", "to_address": "chromatic <chromatic@wgz.org>", "from_address": "\"Klaas-Jan Stol\" <parrotcode@gmail.com>", "subject": "Re: FOTW src/debug.c", "body": "On 5/23/07, Klaas-Jan Stol <parrotcode@gmail.com> wrote:\nOn 5/23/07, chromatic <\nchromatic@wgz.org> wrote:\nThis file implements most of the Parrot debugger.\u00a0\u00a0The interpreter struct hasa slot called pdb that contains a PDB_t (parrot/debug.h).This file is somewhat messy.\u00a0\u00a0It has some string manipulation functions\n\n(nextarg(), skip_ws(), parse_int(), parse_string()) that should probably goelsewhere.There are also some places that seem somewhat careless about memory allocationand freeing.\u00a0\u00a0For example, where in this file does interp->pdb get\ninitialized?\u00a0\u00a0(Answer: in src/embed.c - Parrot_disassemble()).Where does it get freed?\u00a0\u00a0(Answer: nowhere that I can tell.)The freeing *could* go in Parrot_really_destroy() in src/inter_create.c (did\n\nyou catch the contradiction in names there?), but I'm starting to think thateach file that represents the entry point into a system should have twofunctions, one that initializes the system and its necessary data structures\nand another that finalizes and frees things.I don't know if we have any good tests for the debugger; this is something weought to consider if we're going to move code around.\u00a0\u00a0Sadly, I don't know\nany easy way to test things apart from opening a Parrot process and feedingdata in and out.\u00a0\u00a0Making the debugger scriptable from PIR is a bigger projectthan I'm comfortable suggesting until it gets more tests.\nSome of the other memory-related functions have a little bit too much magic.For example, PDB_free_file() takes the file to free out of the currentdebugger.\u00a0\u00a0It does the right thing to free files, but there appear to be\ncases where it's useful to free a file that's not the debugger's currentfile, so this function is inappropriately general.Other functions have odd names -- PDB_hasInstructions() (no underscore?),\nPDB_print() (should be PDB_print_registers()).The code is fairly decent.\u00a0\u00a0Most of the issues here relate to organization.-- cThere are some magic numbers, like 255, and some other very unclear code snippets like:\n\u00a0 for (i = 0; *command && isalpha((int) *command); command++, i++)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 c += (tolower((int) *command) + (i + 1)) * ((i + 1) * 255);This needs some comments. If anybody knows what's going on there, please enlighten me and fellow readers :-)\nregards,kjs\nAttached a patch that adds some more comments that explain the code as far as i can see. There are some parts in the file that I don't get a grip on.hth,kjs\n"}
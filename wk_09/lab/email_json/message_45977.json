{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 11184: The registry library compiles again. in\n\tfile:///home/jelmer/bzr.samba-old/4.0-regwrite/", "body": "At file:///home/jelmer/bzr.samba-old/4.0-regwrite/\n\n------------------------------------------------------------\nrevno: 11184\nrevision-id: jelmer@samba.org-20070610234755-tpxetmbupthvqfp8\nparent: jelmer@samba.org-20070610222652-11vkd62zyiyk971l\ncommitter: Jelmer Vernooij \nbranch nick: 4.0-regwrite\ntimestamp: Mon 2007-06-11 01:47:55 +0200\nmessage:\n  The registry library compiles again.\nmodified:\n  source/lib/registry/tools/regshell.c svn-v2:20@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2ftools%2fregshell.c\n=== modified file 'source/lib/registry/tools/regshell.c'\n--- a/source/lib/registry/tools/regshell.c\t2007-06-10 22:26:52 +0000\n+++ b/source/lib/registry/tools/regshell.c\t2007-06-10 23:47:55 +0000\n@@ -27,7 +27,13 @@\n #include \"lib/smbreadline/smbreadline.h\"\n #include \"librpc/gen_ndr/ndr_security.h\"\n \n-/* \n+struct regshell_context {\n+\tstruct registry_context *registry;\n+\tconst char *path;\n+\tstruct registry_key *current;\n+};\n+\n+/* *\n  * ck/cd - change key\n  * ls - list values/keys\n  * rmval/rm - remove value\n@@ -41,10 +47,7 @@\n  * exit\n  */\n \n-static struct registry_key *cmd_info(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t\t\t struct registry_context *ctx,\n-\t\t\t\t\t\t\t\t\t struct registry_key *cur, \n-\t\t\t\t\t\t\t\t\t int argc, char **argv)\n+static WERROR cmd_info(struct regshell_context *ctx, int argc, char **argv)\n {\n \tstruct security_descriptor *sec_desc = NULL;\n \ttime_t last_mod;\n@@ -52,34 +55,32 @@\n \tconst char *classname;\n \tNTTIME last_change;\n \n-\terror = reg_key_get_info(mem_ctx, cur, \n-\t\t\t\t\t &classname, NULL, NULL, &last_change);\n+\terror = reg_key_get_info(ctx, ctx->current, &classname, NULL, NULL, &last_change);\n \tif (!W_ERROR_IS_OK(error)) {\n \t\tprintf(\"Error getting key info: %s\\n\", win_errstr(error));\n-\t\treturn cur;\n+\t\treturn error;\n \t}\n \n \t\n-\tprintf(\"Name: %s\\n\", cur->name);\n-\tprintf(\"Full path: %s\\n\", cur->path);\n+\tprintf(\"Name: %s\\n\", strchr(ctx->path, '\\\\')?strrchr(ctx->path, '\\\\')+1: \n+\t\t   ctx->path);\n+\tprintf(\"Full path: %s\\n\", ctx->path);\n \tprintf(\"Key Class: %s\\n\", classname);\n \tlast_mod = nt_time_to_unix(last_change);\n \tprintf(\"Time Last Modified: %s\\n\", ctime(&last_mod));\n \n-\terror = reg_get_sec_desc(mem_ctx, cur, &sec_desc);\n+\terror = reg_get_sec_desc(ctx, ctx->current, &sec_desc);\n \tif (!W_ERROR_IS_OK(error)) {\n \t\tprintf(\"Error getting security descriptor\\n\");\n-\t\treturn cur;\n+\t\treturn error;\n \t} \n \tndr_print_debug((ndr_print_fn_t)ndr_print_security_descriptor, \"Security\", sec_desc);\n \ttalloc_free(sec_desc);\n-\treturn cur;\n+\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_predef(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t\t\t   struct registry_context *ctx, \n-\t\t\t\t\t\t\t\t\t   struct registry_key *cur, \n-\t\t\t\t\t\t\t\t\t   int argc, char **argv)\n+static WERROR cmd_predef(struct regshell_context *ctx, int argc, char **argv)\n {\n \tstruct registry_key *ret = NULL;\n \tif (argc < 2) {\n@@ -87,71 +88,71 @@\n \t} else if (!ctx) {\n \t\tfprintf(stderr, \"No full registry loaded, no predefined keys defined\\n\");\n \t} else {\n-\t\tWERROR error = reg_get_predefined_key_by_name(ctx, argv[1], &ret);\n+\t\tWERROR error = reg_get_predefined_key_by_name(ctx->registry, argv[1], &ret);\n \n \t\tif (!W_ERROR_IS_OK(error)) {\n \t\t\tfprintf(stderr, \"Error opening predefined key %s: %s\\n\", argv[1], win_errstr(error));\n-\t\t\tret = NULL;\n+\t\t\treturn error;\n \t\t}\n \t}\n-\treturn ret;\n+\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_pwd(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t\t\tstruct registry_context *ctx,\n-\t\t\t\t\t\t\t\t\tstruct registry_key *cur, \n+static WERROR cmd_pwd(struct regshell_context *ctx,\n \t\t\t\t\t\t\t\t\tint argc, char **argv)\n {\n-\tprintf(\"%s\\n\", cur->path);\n-\treturn cur;\n+\tprintf(\"%s\\n\", ctx->path);\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_set(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_set(struct regshell_context *ctx, int argc, char **argv)\n {\n \tstruct registry_value val;\n \tWERROR error;\n \n \tif (argc < 4) {\n \t\tfprintf(stderr, \"Usage: set value-name type value\\n\");\n-\t\treturn cur;\n+\t\treturn WERR_INVALID_PARAM;\n \t} \n \n-\tif (!reg_string_to_val(mem_ctx, argv[2], argv[3], &val.data_type, &val.data)) {\n+\tif (!reg_string_to_val(ctx, argv[2], argv[3], &val.data_type, \n+\t\t\t\t\t\t   &val.data)) {\n \t\tfprintf(stderr, \"Unable to interpret data\\n\");\n-\t\treturn cur;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n \n-\terror = reg_val_set(cur, argv[1], val.data_type, val.data);\n+\terror = reg_val_set(ctx->current, argv[1], val.data_type, val.data);\n \tif (!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"Error setting value: %s\\n\", win_errstr(error));\n-\t\treturn NULL;\n+\t\treturn error;\n \t}\n-\treturn cur;\n+\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_ck(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t\t   struct registry_context *ctx,\n-\t\t\t\t\t\t\t\t   struct registry_key *cur, \n-\t\t\t\t\t\t\t\t   int argc, char **argv)\n+static WERROR cmd_ck(struct regshell_context *ctx, int argc, char **argv)\n { \n \tstruct registry_key *new = NULL;\n \tWERROR error;\n+\n \tif(argc < 2) {\n-\t\tnew = cur;\n+\t\tnew = ctx->current;\n \t} else {\n-\t\terror = reg_open_key(mem_ctx, cur, argv[1], &new);\n+\t\terror = reg_open_key(ctx->registry, ctx->current, argv[1], &new);\n \t\tif(!W_ERROR_IS_OK(error)) {\n \t\t\tDEBUG(0, (\"Error opening specified key: %s\\n\", win_errstr(error)));\n-\t\t\treturn NULL;\n+\t\t\treturn error;\n \t\t}\n \t} \n \n-\tprintf(\"Current path is: %s\\n\", new->path);\n+\t/* FIXME: Set ctx->path, ctx->current */\n+\tprintf(\"Current path is: %s\\n\", ctx->path);\n \t\n-\treturn new;\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_print(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_print(struct regshell_context *ctx, int argc, char **argv)\n {\n \tuint32_t value_type;\n \tDATA_BLOB value_data;\n@@ -159,25 +160,23 @@\n \n \tif (argc != 2) {\n \t\tfprintf(stderr, \"Usage: print \");\n-\t\treturn NULL;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n \t\n-\terror = reg_key_get_value_by_name(mem_ctx, cur, argv[1], \n+\terror = reg_key_get_value_by_name(ctx, ctx->current, argv[1], \n \t\t\t\t\t\t\t\t\t  &value_type, &value_data);\n \tif (!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"No such value '%s'\\n\", argv[1]);\n-\t\treturn NULL;\n+\t\treturn error;\n \t}\n \n \tprintf(\"%s\\n%s\\n\", str_regtype(value_type), \n-\t\t   reg_val_data_string(mem_ctx, value_type, value_data));\n-\treturn NULL;\n+\t\t   reg_val_data_string(ctx, value_type, value_data));\n+\n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_ls(TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t\t\t   struct registry_context *ctx,\n-\t\t\t\t\t\t\t\t   struct registry_key *cur, \n-\t\t\t\t\t\t\t\t   int argc, char **argv)\n+static WERROR cmd_ls(struct regshell_context *ctx, int argc, char **argv)\n {\n \tint i;\n \tWERROR error;\n@@ -186,82 +185,97 @@\n \tDATA_BLOB data;\n \tconst char *name;\n \n-\tfor(i = 0; W_ERROR_IS_OK(error = reg_key_get_subkey_by_index(mem_ctx, cur, i, &name, NULL, NULL)); i++) {\n+\tfor (i = 0; W_ERROR_IS_OK(error = reg_key_get_subkey_by_index(ctx, ctx->current, i, &name, NULL, NULL)); i++) {\n \t\tprintf(\"K %s\\n\", name);\n \t}\n \n-\tif(!W_ERROR_EQUAL(error, WERR_NO_MORE_ITEMS)) {\n+\tif (!W_ERROR_EQUAL(error, WERR_NO_MORE_ITEMS)) {\n \t\tDEBUG(0, (\"Error occured while browsing thru keys: %s\\n\", win_errstr(error)));\n \t}\n \n-\tfor(i = 0; W_ERROR_IS_OK(error = reg_key_get_value_by_index(mem_ctx, cur, i, &name, &data_type, &data)); i++) {\n+\tfor (i = 0; W_ERROR_IS_OK(error = reg_key_get_value_by_index(ctx, ctx->current, i, &name, &data_type, &data)); i++) {\n \t\tprintf(\"V \\\"%s\\\" %s %s\\n\", value->name, str_regtype(data_type), \n-\t\t\t   reg_val_data_string(mem_ctx, data_type, data));\n+\t\t\t   reg_val_data_string(ctx, data_type, data));\n \t}\n \t\n-\treturn NULL; \n+\treturn WERR_OK; \n }\n-static struct registry_key *cmd_mkkey(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_mkkey(struct regshell_context *ctx, int argc, char **argv)\n { \n \tstruct registry_key *tmp;\n+\tWERROR error;\n+\n \tif(argc < 2) {\n \t\tfprintf(stderr, \"Usage: mkkey \\n\");\n-\t\treturn NULL;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n+\n+\terror = reg_key_add_name(ctx, ctx->current, argv[1], 0, NULL, &tmp);\n \t\n-\tif(!W_ERROR_IS_OK(reg_key_add_name(mem_ctx, cur, argv[1], 0, NULL, &tmp))) {\n+\tif (!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"Error adding new subkey '%s'\\n\", argv[1]);\n-\t\treturn NULL;\n+\t\treturn error;\n \t}\n \n-\treturn NULL; \n+\treturn WERR_OK; \n }\n \n-static struct registry_key *cmd_rmkey(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_rmkey(struct regshell_context *ctx,\n+\t\t\t\t\t\t\t\t\t  int argc, char **argv)\n { \n+\tWERROR error;\n+\n \tif(argc < 2) {\n \t\tfprintf(stderr, \"Usage: rmkey \\n\");\n-\t\treturn NULL;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n \n-\tif(!W_ERROR_IS_OK(reg_key_del(cur, argv[1]))) {\n+\terror = reg_key_del(ctx->current, argv[1]);\n+\tif(!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"Error deleting '%s'\\n\", argv[1]);\n+\t\treturn error;\n \t} else {\n \t\tfprintf(stderr, \"Successfully deleted '%s'\\n\", argv[1]);\n \t}\n \t\n-\treturn NULL; \n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_rmval(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_rmval(struct regshell_context *ctx, int argc, char **argv)\n { \n+\tWERROR error;\n+\n \tif(argc < 2) {\n \t\tfprintf(stderr, \"Usage: rmval \\n\");\n-\t\treturn NULL;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n \n-\tif(!W_ERROR_IS_OK(reg_del_value(cur, argv[1]))) {\n+\terror = reg_del_value(ctx->current, argv[1]);\n+\tif(!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"Error deleting value '%s'\\n\", argv[1]);\n+\t\treturn error;\n \t} else {\n \t\tfprintf(stderr, \"Successfully deleted value '%s'\\n\", argv[1]);\n \t}\n \n-\treturn NULL; \n+\treturn WERR_OK; \n }\n \n-static struct registry_key *cmd_exit(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_exit(struct regshell_context *ctx,\n+\t\t\t\t\t\t\t\t\t int argc, char **argv)\n {\n \texit(0);\n-\treturn NULL; \n+\treturn WERR_OK;\n }\n \n-static struct registry_key *cmd_help(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *, int, char **);\n+static WERROR cmd_help(struct regshell_context *ctx, int, char **);\n \n static struct {\n \tconst char *name;\n \tconst char *alias;\n \tconst char *help;\n-\tstruct registry_key *(*handle)(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *, int argc, char **argv);\n+\tWERROR (*handle)(struct regshell_context *ctx,\n+\t\t\t\t\t\t\t\t   int argc, char **argv);\n } regshell_cmds[] = {\n \t{\"ck\", \"cd\", \"Change current key\", cmd_ck },\n \t{\"info\", \"i\", \"Show detailed information of a key\", cmd_info },\n@@ -278,17 +292,19 @@\n \t{NULL }\n };\n \n-static struct registry_key *cmd_help(TALLOC_CTX *mem_ctx, struct registry_context *ctx, struct registry_key *cur, int argc, char **argv)\n+static WERROR cmd_help(struct regshell_context *ctx,\n+\t\t\t\t\t\t\t\t\t int argc, char **argv)\n {\n \tint i;\n \tprintf(\"Available commands:\\n\");\n \tfor(i = 0; regshell_cmds[i].name; i++) {\n \t\tprintf(\"%s - %s\\n\", regshell_cmds[i].name, regshell_cmds[i].help);\n \t}\n-\treturn NULL;\n+\treturn WERR_OK;\n } \n \n-static struct registry_key *process_cmd(TALLOC_CTX *mem_ctx, struct registry_context *ctx, struct registry_key *k, char *line)\n+static WERROR process_cmd(struct regshell_context *ctx,\n+\t\t\t\t\t\t\t\t\t\tchar *line)\n {\n \tint argc;\n \tchar **argv = NULL;\n@@ -296,19 +312,19 @@\n \n \tif ((ret = poptParseArgvString(line, &argc, (const char ***) &argv)) != 0) {\n \t\tfprintf(stderr, \"regshell: %s\\n\", poptStrerror(ret));\n-\t\treturn k;\n+\t\treturn WERR_INVALID_PARAM;\n \t}\n \n \tfor(i = 0; regshell_cmds[i].name; i++) {\n \t\tif(!strcmp(regshell_cmds[i].name, argv[0]) || \n \t\t   (regshell_cmds[i].alias && !strcmp(regshell_cmds[i].alias, argv[0]))) {\n-\t\t\treturn regshell_cmds[i].handle(mem_ctx, ctx, k, argc, argv);\n+\t\t\treturn regshell_cmds[i].handle(ctx, argc, argv);\n \t\t}\n \t}\n \n \tfprintf(stderr, \"No such command '%s'\\n\", argv[0]);\n \t\n-\treturn k;\n+\treturn WERR_INVALID_PARAM;\n }\n \n #define MAX_COMPLETIONS 100\n@@ -439,13 +455,11 @@\n {\n \tint opt;\n \tconst char *backend = NULL;\n-\tstruct registry_key *curkey = NULL;\n-\tstruct hive_key *hivekey = NULL;\n \tpoptContext pc;\n \tWERROR error;\n-\tTALLOC_CTX *mem_ctx = talloc_init(\"cmd\");\n \tconst char *remote = NULL;\n-\tstruct registry_context *h = NULL;\n+\tstruct regshell_context *ctx;\n+\tbool ret = true;\n \tstruct poptOption long_options[] = {\n \t\tPOPT_AUTOHELP\n \t\t{\"remote\", 'R', POPT_ARG_STRING, &remote, 0, \"connect to specified remote server\", NULL},\n@@ -460,13 +474,16 @@\n \twhile((opt = poptGetNextOpt(pc)) != -1) {\n \t}\n \n+\tctx = talloc_zero(NULL, struct regshell_context);\n+\n \tif (remote != NULL) {\n-\t\terror = reg_open_remote (&h, NULL, cmdline_credentials, remote, NULL); \n+\t\terror = reg_open_remote (&ctx->registry, NULL, \n+\t\t\t\t\t\t\t\t cmdline_credentials, remote, NULL); \n \t} else if (backend != NULL) {\n-\t\terror = reg_open_hive(NULL, poptGetArg(pc), NULL, cmdline_credentials, \n-\t\t\t\t\t\t\t  &hivekey);\n+\t\terror = reg_open_hive(ctx, poptGetArg(pc), NULL, cmdline_credentials, \n+\t\t\t\t\t\t\t  &ctx->current);\n \t} else {\n-\t\terror = reg_open_local(NULL, &h, NULL, cmdline_credentials);\n+\t\terror = reg_open_local(ctx, &ctx->registry, NULL, cmdline_credentials);\n \t}\n \n \tif (!W_ERROR_IS_OK(error)) {\n@@ -474,21 +491,23 @@\n \t\treturn 1;\n \t}\n \n-\tif (h != NULL) {\n+\tif (ctx->registry != NULL) {\n \t\tint i;\n \n \t\tfor (i = 0; reg_predefined_keys[i].handle; i++) {\n \t\t\tWERROR err;\n-\t\t\terr = reg_get_predefined_key(h, reg_predefined_keys[i].handle, &curkey);\n+\t\t\terr = reg_get_predefined_key(ctx->registry, \n+\t\t\t\t\t\t\t\t\t\t reg_predefined_keys[i].handle, \n+\t\t\t\t\t\t\t\t\t\t &ctx->current);\n \t\t\tif (W_ERROR_IS_OK(err)) {\n \t\t\t\tbreak;\n \t\t\t} else {\n-\t\t\t\tcurkey = NULL;\n+\t\t\t\tctx->current = NULL;\n \t\t\t}\n \t\t}\n \t}\n \n-\tif (!curkey) {\n+\tif (ctx->current == NULL) {\n \t\tfprintf(stderr, \"Unable to access any of the predefined keys\\n\");\n \t\treturn -1;\n \t}\n@@ -498,21 +517,20 @@\n \twhile (true) {\n \t\tchar *line, *prompt;\n \t\t\n-\t\tasprintf(&prompt, \"%s> \", curkey->path);\n+\t\tasprintf(&prompt, \"%s> \", ctx->path);\n \t\t\n-\t\tcurrent_key = curkey; \t\t/* No way to pass a void * pointer \n-\t\t\t\t\t\t\t\t\t   via readline :-( */\n+\t\tcurrent_key = ctx->current; \t\t/* No way to pass a void * pointer \n+\t\t\t\t\t\t\t\t\t   \t\t   via readline :-( */\n \t\tline = smb_readline(prompt, NULL, reg_completion);\n \n-\t\tif(!line)\n+\t\tif (line == NULL)\n \t\t\tbreak;\n \n-\t\tif(line[0] != '\\n') {\n-\t\t\tstruct registry_key *new = process_cmd(mem_ctx, h, curkey, line);\n-\t\t\tif(new)curkey = new;\n+\t\tif (line[0] != '\\n') {\n+\t\t\tret = W_ERROR_IS_OK(process_cmd(ctx, line));\n \t\t}\n \t}\n-\ttalloc_free(mem_ctx);\n+\ttalloc_free(ctx);\n \n-\treturn 0;\n+\treturn (ret?0:1);\n }\n\n"}
{"category": "ham", "to_address": "sugar@laptop.org", "from_address": "Morgan Collett <morgan@collabora.co.uk>", "subject": "Re: [sugar] [PATCH] services/presence/: identify Buddies by \"key\n ID\"\t(pubkey hash), not whole key.", "body": "FWIW, looks good to me.\n\nMorgan\n\nSimon McVittie wrote:\n> I thought I should send this one in for dcbw's approval, since it's a\n> behaviour change...\n> \n> \"\"\"\n> services/presence/: identify Buddies by \"key ID\" (pubkey hash), not whole key.\n> \n> This allows us to create Buddy objects as soon as we see a contact on the\n> server. For contacts not on trusted servers, or seen in anonymous MUCs, we\n> create a Buddy identified by JID instead (so we have some way to talk\n> about the anonymous contact within the Sugar API).\n> \n> The concept of \"trusted server\" means a server which we trust to validate that\n> users with a keyID as the username part of their JID do in fact have that key.\n> Currently we just pretend that olpc.collabora.co.uk does this - in future, the\n> school servers will do this validation by using key rather than password\n> authentication.\n> \n> Also create Buddy object paths based on the keyID or JID (for easier debugging).\n> \"\"\"\n> \n> This will allow me to improve the Sugar-visible API by mapping from\n> Buddies to handles (and back) in a synchronous way, so we can track\n> buddies entering and leaving activities in a sane way, for instance. Also, we\n> can interoperate with non-OLPC servers correctly (with a Buddy object\n> present even for non-OLPC users).\n> \n> I'm assuming here that the key-ID is \"sufficiently unique\" across all\n> trusted servers. It's a SHA-1 of the public key, so basically the\n> same strength as GnuPG key fingerprints and git object hashes.\n> (Actually, for hysterical raisins, it's a SHA-1 of Base64(public_key) -\n> we should probably change this before we ship.)\n> \n> The actual function used for the key-ID can be changed (if it\n> is, old and new versions of Sugar will be incompatible, but that's not\n> really a problem yet) so if any crypto gurus want to specify something\n> different, now would be a really good time. As currently implemented, its\n> output must be short enough to put in the JID (for which a hex SHA-1 is\n> somewhat long already).\n> \n> ---\n>  services/presence/buddy.py           |   49 +++++++++-------\n>  services/presence/presenceservice.py |   48 +++++++++------\n>  services/presence/pstest.py          |   10 ++-\n>  services/presence/server_plugin.py   |  108 ++++++++++++++++++++++++++++++++--\n>  4 files changed, 166 insertions(+), 49 deletions(-)\n> \n> diff --git a/services/presence/buddy.py b/services/presence/buddy.py\n> index 1b45fd5..b858b41 100644\n> --- a/services/presence/buddy.py\n> +++ b/services/presence/buddy.py\n> @@ -37,6 +37,7 @@ _PROP_CURACT = \"current-activity\"\n>  _PROP_COLOR = \"color\"\n>  _PROP_OWNER = \"owner\"\n>  _PROP_VALID = \"valid\"\n> +_PROP_OBJID = 'objid'\n>  \n>  # Will go away soon\n>  _PROP_IP4_ADDRESS = \"ip4-address\"\n> @@ -90,15 +91,14 @@ class Buddy(ExportedGObject):\n>      }\n>  \n>      __gproperties__ = {\n> -        _PROP_KEY          : (str, None, None, None,\n> -                              gobject.PARAM_READWRITE |\n> -                              gobject.PARAM_CONSTRUCT_ONLY),\n> +        _PROP_KEY          : (str, None, None, None, gobject.PARAM_READWRITE),\n>          _PROP_ICON         : (object, None, None, gobject.PARAM_READWRITE),\n>          _PROP_NICK         : (str, None, None, None, gobject.PARAM_READWRITE),\n>          _PROP_COLOR        : (str, None, None, None, gobject.PARAM_READWRITE),\n>          _PROP_CURACT       : (str, None, None, None, gobject.PARAM_READWRITE),\n>          _PROP_VALID        : (bool, None, None, False, gobject.PARAM_READABLE),\n>          _PROP_OWNER        : (bool, None, None, False, gobject.PARAM_READABLE),\n> +        _PROP_OBJID        : (str, None, None, None, gobject.PARAM_READABLE),\n>          _PROP_IP4_ADDRESS  : (str, None, None, None, gobject.PARAM_READWRITE)\n>      }\n>  \n> @@ -106,16 +106,16 @@ class Buddy(ExportedGObject):\n>          \"\"\"Initialize the Buddy object\n>  \n>          bus -- connection to the D-Bus session bus\n> -        object_id -- the activity's unique identifier\n> +        object_id -- the buddy's unique identifier, either based on their\n> +            key-ID or JID\n>          kwargs -- used to initialize the object's properties\n>  \n>          constructs a DBUS \"object path\" from the _BUDDY_PATH\n>          and object_id\n>          \"\"\"\n> -        if not object_id or not isinstance(object_id, int):\n> -            raise ValueError(\"object id must be a valid number\")\n>  \n> -        self._object_path = _BUDDY_PATH + str(object_id)\n> +        self._object_id = object_id\n> +        self._object_path = dbus.ObjectPath(_BUDDY_PATH + object_id)\n>  \n>          self._activities = {}   # Activity ID -> Activity\n>          self._activity_sigids = {}\n> @@ -130,9 +130,6 @@ class Buddy(ExportedGObject):\n>          self._color = None\n>          self._ip4_address = None\n>  \n> -        if not kwargs.get(_PROP_KEY):\n> -            raise ValueError(\"key required\")\n> -\n>          _ALLOWED_INIT_PROPS = [_PROP_NICK, _PROP_KEY, _PROP_ICON,\n>                                 _PROP_CURACT, _PROP_COLOR, _PROP_IP4_ADDRESS]\n>          for (key, value) in kwargs.items():\n> @@ -158,7 +155,9 @@ class Buddy(ExportedGObject):\n>  \n>          pspec -- property specifier with a \"name\" attribute\n>          \"\"\"\n> -        if pspec.name == _PROP_KEY:\n> +        if pspec.name == _PROP_OBJID:\n> +            return self._object_id\n> +        elif pspec.name == _PROP_KEY:\n>              return self._key\n>          elif pspec.name == _PROP_ICON:\n>              return self._icon\n> @@ -422,32 +421,40 @@ class Buddy(ExportedGObject):\n>          \"\"\"\n>          changed = False\n>          changed_props = {}\n> -        if _PROP_NICK in properties.keys():\n> +        if _PROP_NICK in properties:\n>              nick = properties[_PROP_NICK]\n>              if nick != self._nick:\n>                  self._nick = nick\n>                  changed_props[_PROP_NICK] = nick\n>                  changed = True\n> -        if _PROP_COLOR in properties.keys():\n> +        if _PROP_COLOR in properties:\n>              color = properties[_PROP_COLOR]\n>              if color != self._color:\n>                  self._color = color\n>                  changed_props[_PROP_COLOR] = color\n>                  changed = True\n> -        if _PROP_CURACT in properties.keys():\n> +        if _PROP_CURACT in properties:\n>              curact = properties[_PROP_CURACT]\n>              if curact != self._current_activity:\n>                  self._current_activity = curact\n>                  changed_props[_PROP_CURACT] = curact\n>                  changed = True\n> -        if _PROP_IP4_ADDRESS in properties.keys():\n> +        if _PROP_IP4_ADDRESS in properties:\n>              ip4addr = properties[_PROP_IP4_ADDRESS]\n>              if ip4addr != self._ip4_address:\n>                  self._ip4_address = ip4addr\n>                  changed_props[_PROP_IP4_ADDRESS] = ip4addr\n>                  changed = True\n> -\n> -        if not changed or not len(changed_props.keys()):\n> +        if _PROP_KEY in properties:\n> +            # don't allow key to be set more than once\n> +            if self._key is None:\n> +                key = properties[_PROP_KEY]\n> +                if key is not None:\n> +                    self._key = key\n> +                    changed_props[_PROP_KEY] = key\n> +                    changed = True\n> +\n> +        if not changed or not changed_props:\n>              return\n>  \n>          # Try emitting PropertyChanged before updating validity\n> @@ -558,13 +565,11 @@ class ShellOwner(GenericOwner):\n>      _SHELL_OWNER_INTERFACE = \"org.laptop.Shell.Owner\"\n>      _SHELL_PATH = \"/org/laptop/Shell\"\n>  \n> -    def __init__(self, ps, bus, object_id, test=False):\n> +    def __init__(self, ps, bus):\n>          \"\"\"Initialize the ShellOwner instance\n>  \n>          ps -- presenceservice.PresenceService object\n>          bus -- a connection to the D-Bus session bus\n> -        object_id -- the activity's unique identifier\n> -        test -- ignored\n>  \n>          Retrieves initial property values from the profile\n>          module.  Loads the buddy icon from file as well.\n> @@ -584,8 +589,8 @@ class ShellOwner(GenericOwner):\n>          icon = f.read()\n>          f.close()\n>  \n> -        GenericOwner.__init__(self, ps, bus, object_id, key=key,\n> -                nick=nick, color=color, icon=icon, server=server,\n> +        GenericOwner.__init__(self, ps, bus, psutils.pubkey_to_keyid(key),\n> +                key=key, nick=nick, color=color, icon=icon, server=server,\n>                  key_hash=key_hash, registered=registered)\n>  \n>          # Ask to get notifications on Owner object property changes in the\n> diff --git a/services/presence/presenceservice.py b/services/presence/presenceservice.py\n> index bf058d3..4f84a3b 100644\n> --- a/services/presence/presenceservice.py\n> +++ b/services/presence/presenceservice.py\n> @@ -1,4 +1,5 @@\n>  # Copyright (C) 2007, Red Hat, Inc.\n> +# Copyright (C) 2007 Collabora Ltd. \n>  #\n>  # This program is free software; you can redistribute it and/or modify\n>  # it under the terms of the GNU General Public License as published by\n> @@ -33,6 +34,7 @@ from sugar import util\n>  \n>  from buddy import Buddy, ShellOwner\n>  from activity import Activity\n> +from psutils import pubkey_to_keyid\n>  \n>  _PRESENCE_SERVICE = \"org.laptop.Sugar.Presence\"\n>  _PRESENCE_INTERFACE = \"org.laptop.Sugar.Presence\"\n> @@ -57,15 +59,17 @@ class PresenceService(ExportedGObject):\n>  \n>      def _create_owner(self):\n>          # Overridden by TestPresenceService\n> -        return ShellOwner(self, self._session_bus, self._get_next_object_id())\n> +        return ShellOwner(self, self._session_bus)\n>  \n>      def __init__(self):\n>          self._next_object_id = 0\n>          self._connected = False\n>  \n> -        self._buddies = {}      # key -> Buddy\n> +        self._buddies = {}              # identifier -> Buddy\n> +        self._buddies_by_pubkey = {}    # base64 public key -> Buddy\n>          self._handles_buddies = {}      # tp client -> (handle -> Buddy)\n> -        self._activities = {}   # activity id -> Activity\n> +\n> +        self._activities = {}           # activity id -> Activity\n>  \n>          self._session_bus = dbus.SessionBus()\n>          self._session_bus.add_signal_receiver(self._connection_disconnected_cb,\n> @@ -74,7 +78,10 @@ class PresenceService(ExportedGObject):\n>  \n>          # Create the Owner object\n>          self._owner = self._create_owner()\n> -        self._buddies[self._owner.props.key] = self._owner\n> +        key = self._owner.props.key\n> +        keyid = pubkey_to_keyid(key)\n> +        self._buddies['keyid/' + keyid] = self._owner\n> +        self._buddies_by_pubkey[key] = self._owner\n>  \n>          self._registry = ManagerRegistry()\n>          self._registry.LoadManagers()\n> @@ -133,31 +140,35 @@ class PresenceService(ExportedGObject):\n>          if self._connected != old_status:\n>              self.emit('connection-status', self._connected)\n>  \n> -    def _contact_online(self, tp, handle, props):\n> -        new_buddy = False\n> -        key = props[\"key\"]\n> -        buddy = self._buddies.get(key)\n> -        if not buddy:\n> +    def get_buddy(self, objid):\n> +        buddy = self._buddies.get(objid)\n> +        if buddy is None:\n> +            _logger.debug('Creating new buddy at .../%s', objid)\n>              # we don't know yet this buddy\n> -            objid = self._get_next_object_id()\n> -            buddy = Buddy(self._session_bus, objid, key=key)\n> +            buddy = Buddy(self._session_bus, objid)\n>              buddy.connect(\"validity-changed\", self._buddy_validity_changed_cb)\n>              buddy.connect(\"disappeared\", self._buddy_disappeared_cb)\n> -            self._buddies[key] = buddy\n> +            self._buddies[objid] = buddy\n> +        return buddy\n> +\n> +    def _contact_online(self, tp, objid, handle, props):\n> +        _logger.debug('Handle %u, .../%s is now online', handle, objid)\n> +        buddy = self.get_buddy(objid)\n>  \n>          self._handles_buddies[tp][handle] = buddy\n>          # store the handle of the buddy for this CM\n>          buddy.add_telepathy_handle(tp, handle)\n> -\n>          buddy.set_properties(props)\n>  \n>      def _buddy_validity_changed_cb(self, buddy, valid):\n>          if valid:\n>              self.BuddyAppeared(buddy.object_path())\n> +            self._buddies_by_pubkey[buddy.props.key] = buddy\n>              _logger.debug(\"New Buddy: %s (%s)\", buddy.props.nick,\n>                            buddy.props.color)\n>          else:\n>              self.BuddyDisappeared(buddy.object_path())\n> +            self._buddies_by_pubkey.pop(buddy.props.key, None)\n>              _logger.debug(\"Buddy left: %s (%s)\", buddy.props.nick,\n>                            buddy.props.color)\n>  \n> @@ -166,16 +177,17 @@ class PresenceService(ExportedGObject):\n>              self.BuddyDisappeared(buddy.object_path())\n>              _logger.debug('Buddy left: %s (%s)', buddy.props.nick,\n>                            buddy.props.color)\n> -        self._buddies.pop(buddy.props.key)\n> +            self._buddies_by_pubkey.pop(buddy.props.key, None)\n> +        self._buddies.pop(buddy.props.objid, None)\n>  \n>      def _contact_offline(self, tp, handle):\n>          if not self._handles_buddies[tp].has_key(handle):\n>              return\n>  \n>          buddy = self._handles_buddies[tp].pop(handle)\n> -        key = buddy.props.key\n> -\n>          # the handle of the buddy for this CM is not valid anymore\n> +        # (this might trigger _buddy_disappeared_cb if they are not visible\n> +        # via any CM)\n>          buddy.remove_telepathy_handle(tp, handle)\n>  \n>      def _get_next_object_id(self):\n> @@ -326,8 +338,8 @@ class PresenceService(ExportedGObject):\n>                           in_signature=\"ay\", out_signature=\"o\",\n>                           byte_arrays=True)\n>      def GetBuddyByPublicKey(self, key):\n> -        if self._buddies.has_key(key):\n> -            buddy = self._buddies[key]\n> +        buddy = self._buddies_by_pubkey.get(key)\n> +        if buddy is not None:\n>              if buddy.props.valid:\n>                  return buddy.object_path()\n>          raise NotFoundError(\"The buddy was not found.\")\n> diff --git a/services/presence/pstest.py b/services/presence/pstest.py\n> index 1900993..3054e48 100644\n> --- a/services/presence/pstest.py\n> +++ b/services/presence/pstest.py\n> @@ -26,6 +26,7 @@ from sugar import env, util\n>  \n>  from buddy import GenericOwner, _PROP_NICK, _PROP_CURACT, _PROP_COLOR\n>  from presenceservice import PresenceService\n> +from psutils import pubkey_to_keyid\n>  \n>  \n>  _logger = logging.getLogger('s-p-s.pstest')\n> @@ -37,7 +38,7 @@ class TestOwner(GenericOwner):\n>  \n>      __gtype_name__ = \"TestOwner\"\n>  \n> -    def __init__(self, ps, bus, object_id, test_num, randomize):\n> +    def __init__(self, ps, bus, test_num, randomize):\n>          self._cp = ConfigParser()\n>          self._section = \"Info\"\n>          self._test_activities = []\n> @@ -62,8 +63,9 @@ class TestOwner(GenericOwner):\n>          icon = _get_random_image()\n>  \n>          _logger.debug(\"pubkey is %s\" % pubkey)\n> -        GenericOwner.__init__(self, ps, bus, object_id, key=pubkey, nick=nick,\n> -                color=color, icon=icon, registered=registered, key_hash=privkey_hash)\n> +        GenericOwner.__init__(self, ps, bus, pubkey_to_keyid(pubkey),\n> +                key=pubkey, nick=nick, color=color, icon=icon,\n> +                registered=registered, key_hash=privkey_hash)\n>  \n>          # Only do the random stuff if randomize is true\n>          if randomize:\n> @@ -169,7 +171,7 @@ class TestPresenceService(PresenceService):\n>          PresenceService.__init__(self)\n>  \n>      def _create_owner(self):\n> -        return TestOwner(self, self._session_bus, self._get_next_object_id(),\n> +        return TestOwner(self, self._session_bus,\n>                           self.__test_num, self.__randomize)\n>  \n>      def internal_get_activity(self, actid):\n> diff --git a/services/presence/server_plugin.py b/services/presence/server_plugin.py\n> index 26adba9..b020286 100644\n> --- a/services/presence/server_plugin.py\n> +++ b/services/presence/server_plugin.py\n> @@ -20,6 +20,7 @@\n>  import logging\n>  import os\n>  import sys\n> +from string import hexdigits\n>  try:\n>      # Python >= 2.5\n>      from hashlib import md5\n> @@ -42,6 +43,7 @@ from telepathy.constants import (HANDLE_TYPE_CONTACT,\n>      CONNECTION_STATUS_CONNECTING,\n>      CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED,\n>      CONNECTION_STATUS_REASON_NONE_SPECIFIED,\n> +    CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,\n>      PROPERTY_FLAG_WRITE)\n>  from sugar import util\n>  \n> @@ -105,8 +107,11 @@ class ServerPlugin(gobject.GObject):\n>          'contact-online':\n>              # Contact has come online and we've discovered all their buddy\n>              # properties.\n> -            # args: contact handle: int; dict {name: str => property: object}\n> -            (gobject.SIGNAL_RUN_FIRST, None, [object, object]),\n> +            # args:\n> +            #   contact identification (based on key ID or JID): str\n> +            #   contact handle: int or long\n> +            #   dict {name: str => property: object}\n> +            (gobject.SIGNAL_RUN_FIRST, None, [str, object, object]),\n>          'contact-offline':\n>              # Contact has gone offline.\n>              # args: contact handle\n> @@ -263,7 +268,7 @@ class ServerPlugin(gobject.GObject):\n>  \n>          account_info['server'] = self._owner.get_server()\n>  \n> -        khash = util.printable_hash(util._sha_data(self._owner.props.key))\n> +        khash = psutils.pubkey_to_keyid(self._owner.props.key)\n>          account_info['account'] = \"%s@%s\" % (khash, account_info['server'])\n>  \n>          account_info['password'] = self._owner.get_key_hash()\n> @@ -770,10 +775,13 @@ class ServerPlugin(gobject.GObject):\n>              return\n>  \n>          props['nick'] = aliases[0]\n> +\n>          jid = self._conn[CONN_INTERFACE].InspectHandles(HANDLE_TYPE_CONTACT,\n>                                                          [handle])[0]\n>          self._online_contacts[handle] = jid\n> -        self.emit(\"contact-online\", handle, props)\n> +        objid = self.identify_contacts(None, [handle])[handle]\n> +\n> +        self.emit(\"contact-online\", objid, handle, props)\n>  \n>          self._conn[CONN_INTERFACE_BUDDY_INFO].GetActivities(handle,\n>              reply_handler=lambda *args: self._contact_online_activities_cb(\n> @@ -841,7 +849,7 @@ class ServerPlugin(gobject.GObject):\n>                  handle not in self._subscribe_local_pending and\n>                  handle not in self._subscribe_remote_pending):\n>              # it's probably a channel-specific handle - can't create a Buddy\n> -            # object\n> +            # object for those yet\n>              return\n>  \n>          self._online_contacts[handle] = None\n> @@ -1063,3 +1071,93 @@ class ServerPlugin(gobject.GObject):\n>              if room == act_handle:\n>                  self.emit(\"activity-properties-changed\", act_id, properties)\n>                  return\n> +\n> +    def _server_is_trusted(self, hostname):\n> +        \"\"\"Return True if the server with the given hostname is trusted to\n> +        verify public-key ownership correctly, and only allows users to\n> +        register JIDs whose username part is either a public key fingerprint,\n> +        or of the wrong form to be a public key fingerprint (to allow for\n> +        ejabberd's admin@example.com address).\n> +\n> +        If we trust the server, we can skip verifying the key ourselves,\n> +        which leads to simplifications. In the current implementation we\n> +        never verify that people actually own the key they claim to, so\n> +        we will always give contacts on untrusted servers a JID- rather than\n> +        key-based identity.\n> +\n> +        For the moment we assume that the test server, olpc.collabora.co.uk,\n> +        does this verification.\n> +        \"\"\"\n> +        return (hostname == 'olpc.collabora.co.uk')\n> +\n> +    def identify_contacts(self, tp_chan, handles):\n> +        \"\"\"Work out the \"best\" unique identifier we can for the given handles,\n> +        in the context of the given channel (which may be None), using only\n> +        'fast' connection manager API (that does not involve network\n> +        round-trips).\n> +\n> +        For the XMPP server case, we proceed as follows:\n> +\n> +        * Find the owners of the given handles, if the channel has\n> +          channel-specific handles\n> +        * If the owner (globally-valid JID) is on a trusted server, return\n> +          'keyid/' plus the 'key fingerprint' (the user part of their JID,\n> +          currently implemented as the SHA-1 of the Base64 blob in\n> +          owner.key.pub)\n> +        * If the owner (globally-valid JID) cannot be found or is on an\n> +          untrusted server, return 'xmpp/' plus an escaped form of the JID\n> +\n> +        The idea is that we identify buddies by key-ID (i.e. by key, assuming\n> +        no collisions) if we can find it without making network round-trips,\n> +        but if that's not possible we just use their JIDs.\n> +\n> +        :Parameters:\n> +            `tp_chan` : telepathy.client.Channel or None\n> +                The channel in which the handles were found, or None if they\n> +                are known to be channel-specific handles\n> +            `handles` : iterable over (int or long)\n> +                The contacts' handles in that channel\n> +        :Returns:\n> +            A dict mapping the provided handles to the best available\n> +            unique identifier, which is a string that could be used as a\n> +            suffix to an object path\n> +        \"\"\"\n> +        # we need to be able to index into handles, so force them to\n> +        # be a sequence\n> +        if not isinstance(handles, (tuple, list)):\n> +            handles = tuple(handles)\n> +\n> +        owners = handles\n> +\n> +        if tp_chan is not None and CHANNEL_INTERFACE_GROUP in tp_chan:\n> +\n> +            group = tp_chan[CHANNEL_INTERFACE_GROUP]\n> +            if group.GetFlags() & CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES:\n> +\n> +                owners = group.GetHandleOwners(handles)\n> +                for i, owner in enumerate(owners):\n> +                    if owner == 0:\n> +                        owners[i] = handles[i]\n> +\n> +        jids = self._conn[CONN_INTERFACE].InspectHandles(HANDLE_TYPE_CONTACT,\n> +                                                         owners)\n> +\n> +        ret = {}\n> +        for handle, jid in zip(handles, jids):\n> +            if '/' in jid:\n> +                # the contact is unidentifiable (in an anonymous MUC) - create\n> +                # a temporary identity for them, based on their room-JID\n> +                ret[handle] = 'xmpp/' + psutils.escape_identifier(jid)\n> +            else:\n> +                user, host = jid.split('@', 1)\n> +                if (self._server_is_trusted(host) and len(user) == 40 and\n> +                    user.strip(hexdigits) == ''):\n> +                    # they're on a trusted server and their username looks\n> +                    # like a key-ID\n> +                    ret[handle] = 'keyid/' + user.lower()\n> +                else:\n> +                    # untrusted server, or not the right format to be a\n> +                    # key-ID - identify the contact by their JID\n> +                    ret[handle] = 'xmpp/' + psutils.escape_identifier(jid)\n> +\n> +        return ret\n_______________________________________________\nSugar mailing list\nSugar@lists.laptop.org\nhttp://lists.laptop.org/listinfo/sugar\n\n"}
{"category": "ham", "to_address": "R-help <r-help@stat.math.ethz.ch>", "from_address": "(Ted Harding) <ted.harding@nessie.mcc.ac.uk>", "subject": "Re: [R] A problem about all possible sequences", "body": "On 17-Apr-07 14:26:15, Paul Smith wrote:\n> Dear All\n> \n> Suppose a sequence of length 10 generated by the following rule:\n> the first element is 0 with 50% of probability or 1 with the\n> same probability; the second element likewise; and so on.\n\nYou don't say whether the elements of the sequence are independent,\nbut plausibility suggests that this may be what you intend.\n\nIn which case:\n\n> Is there some R command to obtain all possible different sequences\n> formed by the above rule?\n\n  while(TRUE){print(sample(c(0,1),10,replace=TRUE))}\n\nand just wait!\n\n(Expected time to wait: about 7700 iterations, I think).\n\n> I am aware that one could write a small\n> program to do that, but I am speculating about whether a command\n> is already existent.\n\nTaking my tongue out of my cheek, however, it's not clear what you\nare really asking for.\n\nIf really you want to generate those sequences randomly according\nto your probabilistic description, retaining as you go only those\nwhich have not been sampled before, until you have all 2^10\npossible sequences, then my \"suggestion\" above is not the way\nto do it! And as far as I know there is not an R function which\ndoes this by proceeding in exactly that way.\n\nBetter to recognise that your random scheme means that each\npossible sequence is equally likely with all the others, and\nso you can do the equivalent by sampling 1024 from (1:1024)\nwithout replacement, i.e. putting (1:1024) in random order.\nThen the binary representation of each element is such a\nsequence.\n\nSo\n\n   S<-sample((1:1024),1024)\n\nis an existing R function which does the heart of the job.\n(It remains to convert each integer K in S to binary form,\nbut as far as I know there is not an R function to convert\nan integer K directly into a vector of binary 0/1 with a\ngiven number of digits, i.e. not the equivalent of\n\n  to.binary(13,10) --> c(0,0,0,0,0,0,1,1,0,1)\n\nexcept maybe in some special package, so I think you'll end\nup writing your own for this bit anyway).\n\nIt gets more interesting if your example is just an illustraton,\nand what you really want is more general.\n\nE.g. if the different 0/1 outcomes in the 10 positions do\nnot have the same probabilities, but are still independent,\nthen you have to do more spadework (and again I'm pretty\nsure there is no simple function in R to do it).\n\nIn that case it's definitely a programming job.\n\nEven more so if the successive 0/1 outcomes are not independent,\nwhether P[0] = P[1] = 0.5 in each position or not. So again\na prgramming job.\n\nSince you seem to be quite willling to do the programming\nif necessary, I won't try to spoil your fun on that front!\n\nBest wishes,\nTed.\n\n--------------------------------------------------------------------\nE-Mail: (Ted Harding) \nFax-to-email: +44 (0)870 094 0861\nDate: 17-Apr-07                                       Time: 16:40:42\n------------------------------ XFMail ------------------------------\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
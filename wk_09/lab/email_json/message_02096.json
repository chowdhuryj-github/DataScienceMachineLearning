{"category": "ham", "to_address": "\"Allison Randal\" <allison@perl.org>", "from_address": "\"Alek Storm\" <alek.storm@gmail.com>", "subject": "Re: modifying classes after they're instantiated", "body": "On 4/10/07, Allison Randal  wrote:\n> 4) Do away with automatic morphing. Attempting to make changes to a\n> class that's already been instantiated is not allowed (add_method, etc.\n> will throw an exception). This also eliminates the need for\n> remove_method, remove_attribute, remove_role, and remove_parent. To\n> modify a class that has instantiated objects you must clone it first:\n>\n>    classobj = newclass 'Foo'\n>    object = classobj.'new'()\n>\n>    newclassobj = classobj.'clone'('exclude_methods'=>$P1)\n>    newclassobj.'add_method'('bar', $P3)\n>    object2 = newclassobj.'new'()\n>\n> And 'clone' could take an option specifying whether this particular\n> clone will replace the existing class in the namespace. Disadvantage: It\n> eliminates some of the DWIMery of the system. On the other hand, it\n> might make it easier to implement a language that doesn't allow\n> modifications to instantiated classes. (This is currently my favorite\n> alternative.)\n>\n> Allison\n\nI like this one, but I also have another alternative.  First, make all\nclass-modification code (add_method, remove_attribute, etc) return a\nPMC*.  Whenever one of these methods is called on a class, the class\nis cloned inside the method, the change is applied to the clone, and\nthe clone is returned.  The caller doesn't need to know about the\ncloning, and neither do the already-existing instances of the original\nclass - they get to keep their copy of the original class.  This\napproach preserves the current interface and DWIMery of the class\nsystem, while retaining the benefits of alternative #4.\n\nSince not all languages want to make clones of their classes on\nmodification (a problem with alternative #4), it's quite easy for that\nlanguage's class PMC not to clone itself inside the method, and\ninstead return a modified version of itself.  In this case, all\ninstantiated objects would be affected, but this would only be used if\nthat's the way that language's class system works.\n\nclassobj = newclass 'Foo'\nobject = classobj.'new'()\n\n# add_method returns a clone of the original class with \"bar\" added\n# C keeps its reference to the original class\nclassobj = classobj.'add_method'('bar', $P3)\nobject2 = classobj.'new'()\n\nThe only downside I can think of is the overhead involved in creating\na new clone of the class for every change to it, for example, when\nmany attributes are added at once, but I imagine it would be minimal,\nsince classes are generally initialized once and that's it.  If it is\na problem, we could create a shortcut method that takes a list of\nattributes to add, or something like that.\n\n-- \nAlek Storm\n\n"}
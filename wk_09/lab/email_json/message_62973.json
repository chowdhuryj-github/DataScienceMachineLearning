{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Paul Lalli <mritty@gmail.com>", "subject": "Re: Snippet explanation please", "body": "On Jul 5, 10:49 am, dale.schm...@offutt.af.mil (Monty) wrote:\n> I'm reading \"Network Programming with Perl\" by Lincoln Stein, and I've\n> come across a snippet of code I'mnot quite following:\n>\n> open (WHOFH, \"who |\") or die \"Can't open who: $!\";\n>\n> While () {\n\nPlease configure your mail/newsreader not to randomly capitalize\nwords.  There is no \"While\" keyword in Perl.\n\n>     next unless /^(\\S+)/;\n>     $who{$1}++;\n> }\n>\n> It's the 'next' line I'm unclear on.  I know that results: parse the\n> first field from each output line of the 'who' command, but I'm\n> wondering why this might have been done in this way.  It seems to me\n> that the 'next' line states \"get the next record unless the current\n> one startes with a non-whitespace character\".\n>\n> The UNIX 'who' command output lines always start with non-whitespace\n> characters, as far as I can see.  It seems just as sensible to leave\n> this line out.  Does anyone know additional value to doing this?\n\nWell, the next command is actually doing three things at once.  First,\nit's determining whether or not the current line starts with non-\nwhitespace characters.  Then, if it doesn't start with whitespace\ncharacters, it skips the remainder of this iteration of the while\nloop.  Finally, if it does start with whitespace characters, it's\nsaving those characters in $1.\n\nThe third part is obviously important.  As for the first two, I have\nno idea - maybe there are some rare circumstances in which `who`\nreturns blanks at the start of the line?\n\n> Also, the '$who{$1}++' lines has the same effect here as \"awk '{ print\n> $1 }'\",\n\nNo it doesn't.  $who{$1}++ increments the value in the %who hash that\nhas the key $1.  `awk '{ print $1 }'` prints the first element of the\nstring that awk has parsed.  Perl's $1 and awk's $1 are wholly\nunrelated.\n\n> and leads me to believe that $2, $3, etc. also exist\n\nThey exist, yes.  But they're not what you think they are, any more\nthan Perl's $1 is what you think it is.\n\n> but that\n> doesn't seem to be the case as I've tried printing those variables.\n> How does the '$1' work in this case?\n\n$1, $2, $3, etc store the contents of the sequentially numbered\nparentheses-enclosed submatches of the most recent successful pattern\nmatch.  For example:\n\n\"hello world\" =~ /(\\w+) (\\w+)/;\nprint \"$1-$2\\n\";  #prints \"hello-world\"\n\"fooooooooo bar baz\" =~ /(o{2})(o)(o+)/;\nprint \"$1 $2 $3\\n\";  #prints \"oo o oooooo\"\n\nAny successful pattern match will set ALL $ variables.  If\nthere are only two capturing parentheses, $1 and $2 are set to\nwhatever those captured submatches are, and $3 and up are set to\nundef.  If there are no captured parentheses, all of $1 on up are set\nto undef.\n\nIn your example, only one set of captured parentheses existed in the\npattern match, and so only $1 was set to a defined value.\n\nRead more about regular expressions in:\nperldoc perlretut\nperldoc perlre\nperldoc perlreref\n\nPaul Lalli\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
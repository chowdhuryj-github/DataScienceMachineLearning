{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: S12: can(), signatures and casting", "body": "On Sun, Apr 29, 2007 at 03:42:31AM -0700, Jonathan Lang wrote:\n: Ovid wrote:\n: >My apologies if these have been answered.  I've been chatting with\n: >Jonathan Worthington about some of this and any misconceptions are\n: >mine, not his.\n: >\n: >In reading through S12, I see that .can() returns an iterator for the\n: >methods matched.  What I'm curious about is this:\n: >\n: >  if $obj.can('fribble') {\n: >    my BadPoet $jibbet = $obj.fribble('repeatedly');\n: >  }\n: >\n: >Just because $obj.can('fribble') does not mean that the available\n: >fribble(s) will accept a string argument or return BadPoet instances.\n: >In chatting with Jonathan about this, he speculated that I would have\n: >to manually walk the method objects in the iterator to find out if I\n: >really have a suitable method.  This seems like what we really have is\n: >$object.might($method).  Is there a simpler way of determining if\n: >there's an appropriate method for what I need?  It seems like what we\n: >really want is a method object where I can declare a signature and then\n: >do this:\n: >\n: >  if $obj.can($object_with_signature){ ... }\n: \n: I suppose.  Still, an easier solution might be to allow an optional\n: second parameter for .can that takes a signature object:\n: \n:  if $obj.can('fribble', :(string -> BadPoet)) {\n:    my BadPoet $jibbet = $obj.fribble('repeatedly');\n:  }\n: \n: Or you could allow signatures to be attached to strings:\n: \n:  # pseudo-code:\n:  if $obj.can('fribble':(string -> BadPoet)) {\n:    my BadPoet $jibbet = $obj.fribble('repeatedly');\n:  }\n: \n: In effect, the signature gets attached as a property of the string,\n: and 'can()' checks for the signature property.\n: \n: The only problem that I have with this idea is that I can't think of\n: any uses for a \"signatory string\" outside of '.can()'.\n\nThe fundamental problem here is that we're forcing a method name to be\nrepresented as a string.  We're basically missing the &foo equivalent\nfor methods.  Maybe we need to allow the & indirection on method names\ntoo:\n\n    if $obj.&fribble:(Str --> BadPoet) {\n\nIn addition to allowing the :() signature addition already used by\n&foo syntax, this would also allow for assumed arguments:\n\n    &callit := $obj.&foo.assuming(1,2,3);\n    callit();\n\nOne could go as far as to claim that &foo:(Foo: Bar --> Baz) should\nbe able to figure out that the presence of an invocant means you're\ntrying to ref a single dispatch to an object that will match type Foo.\n\nNote that we already define &foo:(Int, Str) to return a list of candidates\nif there's more than one, so extending this from the multi dispatcher\nto the single dispatcher just seem like a SMOS (small matter of syntax).\n\nAnd then we basically just can the .can method since it'd be redundant.\n\n: >This raises my second question.  What if I have this?\n: >\n: >  class MadHatter is BadPoet { ... }\n: >\n: >If I get back a MadHatter instead of a BadPoet, but I really want the\n: >superclass and not a subclass, how can I enforce that?  Do I have to do\n: >something like this?  (pseudo-code)\n: \n: What are you looking for that .is() doesn't provide?  The only thing I\n: can think of is that you're trying to insist that $obj's\n: implementation be BadPoet - not \"BadPoet or a class derived from it\",\n: but \"BadPoet\".  This strikes me as getting into the same territory as\n: finalized classes.\n: \n: >  subset ReallyABadPoet where { $^N.type eq \"BadPoet\" }\n: >  my ReallyABadPoet = $obj.fribble('repeatedly');\n: \n: I'll assume that you meant to include a variable name on the second line:\n: \n:  subset ReallyABadPoet where { $^N.type eq \"BadPoet\" }\n:  my ReallyABadPoet $obj2 = $obj.fribble('repeatedly');\n: \n: If so, I fail to see what you gain from this, as opposed to:\n: \n:  my BadPoet $obj2 = $obj.fribble('repeatedly');\n: \n: In this case, $obj2 won't accept the product of\n: $obj.fribble('repeatedly') unless that product \".does('BadPoet')\".\n: \n: >That seems to fail because the you'd have to invoke every method to\n: >guarantee that you're really getting back the exact type you want.\n: \n: As I understand it, Perl 6's typing system does not do \"duck typing\" -\n: that is, it uses \".does()\" as its primary means of type-checking, not\n: \".can()\".  As such, you can check an object's type directly without\n: having to examine its set of methods - just scan the set of roles that\n: the object composes until you find the role that you're looking for.\n: \n: Or am I misunderstanding you?\n\nI see this as almost exactly equivalent to the race conditions you\nrun into trying to determine if you ought to be able to access a file\nwithout actually trying to access it.  Eventually you just have to\ncall the silly thing and see if it fails, since (especially with active\ncode) candidates can decide to fail all on their own after you initiate\nthe call, and since you don't know how many times that happens compared\nto the length of your candidate list, predicting whether there will\nbe a next candidate to try is something akin to the halting problem.\n\nThe & syntax is basically saying, \"do as much as you can with the\ninformation you've got to trim down the candidate list, but don't\nactually do more than that, and certainly don't attempt to actually\ncall any of the candidates\".\n\n: >As such, it seems like we'd need return values to guarantee that the\n: >returned type is exactly what we claimed.\n: >\n: >  method foo(Int $bar, Int $baz) returns Int {\n: >    return $foo/$baz;\n: >  }\n: >\n: >Since the return value might be a Float, does it get cast to an Int,\n: >thereby discarding information?\n: \n: As I understand it, yes; a Float would be cast into an Int in this\n: case.  Though my understanding is that this says more about Ints and\n: Nums than it does about objects in general.\n\nHmm, well, \"returns Int\" is explicitly asking for a coercion of the\nreturn value, so it's at least as general as the coercion semantics\nof the type system.  (Which doesn't contradict what you just said,\nof course.)  However, that particular syntax doesn't advertise the\nInt type as return value to the outside world, which means it could\nnot be used to trim a candidate list even if the provided sig filter\nspecified a return type.  Need to use an --> (an \"of\" type) for that...\n\nLarry\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 90: fixed sending messages to ourselves in non-daemon mode in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 90\nrevision-id: tridge@samba.org-20070411042614-eada54e55ac13cf8\nparent: tridge@samba.org-20070411040501-043570f3088576d6\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Wed 2007-04-11 14:26:14 +1000\nmessage:\n  fixed sending messages to ourselves in non-daemon mode\nmodified:\n  common/ctdb_message.c          ctdb_message.c-20070208224107-9dnio7x7z33prrmt-1\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'common/ctdb_message.c'\n--- a/common/ctdb_message.c\t2007-04-11 04:05:01 +0000\n+++ b/common/ctdb_message.c\t2007-04-11 04:26:14 +0000\n@@ -30,42 +30,101 @@\n \n \n /*\n-  called when a CTDB_REQ_MESSAGE packet comes in\n-\n   this dispatches the messages to the registered ctdb message handler\n */\n-void ctdb_request_message(struct ctdb_context *ctdb, struct ctdb_req_header *hdr)\n+static int ctdb_dispatch_message(struct ctdb_context *ctdb, uint32_t srvid, TDB_DATA data)\n {\n-\tstruct ctdb_req_message *c = (struct ctdb_req_message *)hdr;\n \tstruct ctdb_message_list *ml;\n-\tTDB_DATA data;\n \n \t/* XXX we need a must faster way of finding the matching srvid\n \t   - maybe a tree? */\n \tfor (ml=ctdb->message_list;ml;ml=ml->next) {\n-\t\tif (ml->srvid == c->srvid) break;\n+\t\tif (ml->srvid == srvid) break;\n \t}\n \tif (ml == NULL) {\n-\t\tprintf(\"no msg handler\\n\");\n+\t\tprintf(\"no msg handler for srvid=%u\\n\", srvid);\n \t\t/* no registered message handler */\n-\t\treturn;\n+\t\treturn -1;\n \t}\n \n+\tml->message_handler(ctdb, srvid, data, ml->message_private);\n+\treturn 0;\n+}\n+\n+\n+/*\n+  called when a CTDB_REQ_MESSAGE packet comes in\n+*/\n+void ctdb_request_message(struct ctdb_context *ctdb, struct ctdb_req_header *hdr)\n+{\n+\tstruct ctdb_req_message *c = (struct ctdb_req_message *)hdr;\n+\tTDB_DATA data;\n+\n \tdata.dptr = &c->data[0];\n \tdata.dsize = c->datalen;\n-\tml->message_handler(ctdb, c->srvid, data, ml->message_private);\n-}\n-\n+\n+\tctdb_dispatch_message(ctdb, c->srvid, data);\n+}\n+\n+/*\n+  this local messaging handler is ugly, but is needed to prevent\n+  recursion in ctdb_send_message() when the destination node is the\n+  same as the source node\n+ */\n+struct ctdb_local_message {\n+\tstruct ctdb_context *ctdb;\n+\tuint32_t srvid;\n+\tTDB_DATA data;\n+};\n+\n+static void ctdb_local_message_trigger(struct event_context *ev, struct timed_event *te, \n+\t\t\t\t       struct timeval t, void *private)\n+{\n+\tstruct ctdb_local_message *m = talloc_get_type(private, \n+\t\t\t\t\t\t       struct ctdb_local_message);\n+\tint res;\n+\n+\tres = ctdb_dispatch_message(m->ctdb, m->srvid, m->data);\n+\tif (res != 0) {\n+\t\tprintf(\"Failed to dispatch message for srvid=%u\\n\", m->srvid);\n+\t}\n+\ttalloc_free(m);\n+}\n+\n+static int ctdb_local_message(struct ctdb_context *ctdb, uint32_t srvid, TDB_DATA data)\n+{\n+\tstruct ctdb_local_message *m;\n+\tm = talloc(ctdb, struct ctdb_local_message);\n+\tCTDB_NO_MEMORY(ctdb, m);\n+\n+\tm->ctdb = ctdb;\n+\tm->srvid = srvid;\n+\tm->data  = data;\n+\tm->data.dptr = talloc_memdup(m, m->data.dptr, m->data.dsize);\n+\tif (m->data.dptr == NULL) {\n+\t\ttalloc_free(m);\n+\t\treturn -1;\n+\t}\n+\n+\t/* this needs to be done as an event to prevent recursion */\n+\tevent_add_timed(ctdb->ev, m, timeval_zero(), ctdb_local_message_trigger, m);\n+\treturn 0;\n+}\n \n /*\n   send a ctdb message\n */\n int ctdb_daemon_send_message(struct ctdb_context *ctdb, uint32_t vnn,\n-\t\t      uint32_t srvid, TDB_DATA data)\n+\t\t\t     uint32_t srvid, TDB_DATA data)\n {\n \tstruct ctdb_req_message *r;\n \tint len;\n \n+\t/* see if this is a message to ourselves */\n+\tif (vnn == ctdb->vnn && !(ctdb->flags & CTDB_FLAG_SELF_CONNECT)) {\n+\t\treturn ctdb_local_message(ctdb, srvid, data);\n+\t}\n+\n \tlen = offsetof(struct ctdb_req_message, data) + data.dsize;\n \tr = ctdb->methods->allocate_pkt(ctdb, len);\n \tCTDB_NO_MEMORY(ctdb, r);\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-04-11 04:05:01 +0000\n+++ b/include/ctdb_private.h\t2007-04-11 04:26:14 +0000\n@@ -381,4 +381,5 @@\n int ctdb_daemon_send_message(struct ctdb_context *ctdb, uint32_t vnn,\n \t\t\t     uint32_t srvid, TDB_DATA data);\n \n+\n #endif\n\n"}
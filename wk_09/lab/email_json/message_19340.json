{"category": "ham", "to_address": "publiustemp-perl6language2@yahoo.com", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: S12: can(), signatures and casting", "body": "Ovid wrote:\n> My apologies if these have been answered.  I've been chatting with\n> Jonathan Worthington about some of this and any misconceptions are\n> mine, not his.\n>\n> In reading through S12, I see that .can() returns an iterator for the\n> methods matched.  What I'm curious about is this:\n>\n>   if $obj.can('fribble') {\n>     my BadPoet $jibbet = $obj.fribble('repeatedly');\n>   }\n>\n> Just because $obj.can('fribble') does not mean that the available\n> fribble(s) will accept a string argument or return BadPoet instances.\n> In chatting with Jonathan about this, he speculated that I would have\n> to manually walk the method objects in the iterator to find out if I\n> really have a suitable method.  This seems like what we really have is\n> $object.might($method).  Is there a simpler way of determining if\n> there's an appropriate method for what I need?  It seems like what we\n> really want is a method object where I can declare a signature and then\n> do this:\n>\n>   if $obj.can($object_with_signature){ ... }\n\nI suppose.  Still, an easier solution might be to allow an optional\nsecond parameter for .can that takes a signature object:\n\n  if $obj.can('fribble', :(string -> BadPoet)) {\n    my BadPoet $jibbet = $obj.fribble('repeatedly');\n  }\n\nOr you could allow signatures to be attached to strings:\n\n  # pseudo-code:\n  if $obj.can('fribble':(string -> BadPoet)) {\n    my BadPoet $jibbet = $obj.fribble('repeatedly');\n  }\n\nIn effect, the signature gets attached as a property of the string,\nand 'can()' checks for the signature property.\n\nThe only problem that I have with this idea is that I can't think of\nany uses for a \"signatory string\" outside of '.can()'.\n\n> This raises my second question.  What if I have this?\n>\n>   class MadHatter is BadPoet { ... }\n>\n> If I get back a MadHatter instead of a BadPoet, but I really want the\n> superclass and not a subclass, how can I enforce that?  Do I have to do\n> something like this?  (pseudo-code)\n\nWhat are you looking for that .is() doesn't provide?  The only thing I\ncan think of is that you're trying to insist that $obj's\nimplementation be BadPoet - not \"BadPoet or a class derived from it\",\nbut \"BadPoet\".  This strikes me as getting into the same territory as\nfinalized classes.\n\n>   subset ReallyABadPoet where { $^N.type eq \"BadPoet\" }\n>   my ReallyABadPoet = $obj.fribble('repeatedly');\n\nI'll assume that you meant to include a variable name on the second line:\n\n  subset ReallyABadPoet where { $^N.type eq \"BadPoet\" }\n  my ReallyABadPoet $obj2 = $obj.fribble('repeatedly');\n\nIf so, I fail to see what you gain from this, as opposed to:\n\n  my BadPoet $obj2 = $obj.fribble('repeatedly');\n\nIn this case, $obj2 won't accept the product of\n$obj.fribble('repeatedly') unless that product \".does('BadPoet')\".\n\n> That seems to fail because the you'd have to invoke every method to\n> guarantee that you're really getting back the exact type you want.\n\nAs I understand it, Perl 6's typing system does not do \"duck typing\" -\nthat is, it uses \".does()\" as its primary means of type-checking, not\n\".can()\".  As such, you can check an object's type directly without\nhaving to examine its set of methods - just scan the set of roles that\nthe object composes until you find the role that you're looking for.\n\nOr am I misunderstanding you?\n\n> As such, it seems like we'd need return values to guarantee that the\n> returned type is exactly what we claimed.\n>\n>   method foo(Int $bar, Int $baz) returns Int {\n>     return $foo/$baz;\n>   }\n>\n> Since the return value might be a Float, does it get cast to an Int,\n> thereby discarding information?\n\nAs I understand it, yes; a Float would be cast into an Int in this\ncase.  Though my understanding is that this says more about Ints and\nNums than it does about objects in general.\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
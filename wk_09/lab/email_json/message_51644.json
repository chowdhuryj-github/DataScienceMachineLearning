{"category": "ham", "to_address": "linux-kernel Mailing List <linux-kernel@vger.kernel.org>", "from_address": "Eric Sandeen <sandeen@redhat.com>", "subject": "[PATCH] zero_user_page conversion", "body": "Use zero_user_page() in cifs, ocfs2, ext4, and gfs2 where possible.\n\nCompile tested, reviews welcome.\n\nSigned-off-by: Eric Sandeen \n\nIndex: linux-2.6.22-rc4-mm2/fs/cifs/inode.c\n===================================================================\n--- linux-2.6.22-rc4-mm2.orig/fs/cifs/inode.c\n+++ linux-2.6.22-rc4-mm2/fs/cifs/inode.c\n@@ -1334,17 +1334,13 @@ static int cifs_truncate_page(struct add\n \tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n \tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n \tstruct page *page;\n-\tchar *kaddr;\n \tint rc = 0;\n \n \tpage = grab_cache_page(mapping, index);\n \tif (!page)\n \t\treturn -ENOMEM;\n \n-\tkaddr = kmap_atomic(page, KM_USER0);\n-\tmemset(kaddr + offset, 0, PAGE_CACHE_SIZE - offset);\n-\tflush_dcache_page(page);\n-\tkunmap_atomic(kaddr, KM_USER0);\n+\tzero_user_page(page, offset, PAGE_CACHE_SIZE - offset, KM_USER0);\n \tunlock_page(page);\n \tpage_cache_release(page);\n \treturn rc;\nIndex: linux-2.6.22-rc4-mm2/fs/ext4/inode.c\n===================================================================\n--- linux-2.6.22-rc4-mm2.orig/fs/ext4/inode.c\n+++ linux-2.6.22-rc4-mm2/fs/ext4/inode.c\n@@ -1830,7 +1830,6 @@ int ext4_block_truncate_page(handle_t *h\n \tstruct inode *inode = mapping->host;\n \tstruct buffer_head *bh;\n \tint err = 0;\n-\tvoid *kaddr;\n \n \tif ((EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) &&\n \t\t\ttest_opt(inode->i_sb, EXTENTS) &&\n@@ -1847,10 +1846,7 @@ int ext4_block_truncate_page(handle_t *h\n \t */\n \tif (!page_has_buffers(page) && test_opt(inode->i_sb, NOBH) &&\n \t     ext4_should_writeback_data(inode) && PageUptodate(page)) {\n-\t\tkaddr = kmap_atomic(page, KM_USER0);\n-\t\tmemset(kaddr + offset, 0, length);\n-\t\tflush_dcache_page(page);\n-\t\tkunmap_atomic(kaddr, KM_USER0);\n+\t\tzero_user_page(page, offset, length, KM_USER0);\n \t\tset_page_dirty(page);\n \t\tgoto unlock;\n \t}\n@@ -1903,10 +1899,7 @@ int ext4_block_truncate_page(handle_t *h\n \t\t\tgoto unlock;\n \t}\n \n-\tkaddr = kmap_atomic(page, KM_USER0);\n-\tmemset(kaddr + offset, 0, length);\n-\tflush_dcache_page(page);\n-\tkunmap_atomic(kaddr, KM_USER0);\n+\tzero_user_page(page, offset, length, KM_USER0);\n \n \tBUFFER_TRACE(bh, \"zeroed end of block\");\n \nIndex: linux-2.6.22-rc4-mm2/fs/gfs2/ops_address.c\n===================================================================\n--- linux-2.6.22-rc4-mm2.orig/fs/gfs2/ops_address.c\n+++ linux-2.6.22-rc4-mm2/fs/gfs2/ops_address.c\n@@ -207,10 +207,7 @@ static int stuffed_readpage(struct gfs2_\n \t * so we need to supply one here. It doesn't happen often.\n \t */\n \tif (unlikely(page->index)) {\n-\t\tkaddr = kmap_atomic(page, KM_USER0);\n-\t\tmemset(kaddr, 0, PAGE_CACHE_SIZE);\n-\t\tkunmap_atomic(kaddr, KM_USER0);\n-\t\tflush_dcache_page(page);\n+\t\tzero_user_page(page, 0, PAGE_CACHE_SIZE, KM_USER0);\n \t\tSetPageUptodate(page);\n \t\treturn 0;\n \t}\nIndex: linux-2.6.22-rc4-mm2/fs/ocfs2/aops.c\n===================================================================\n--- linux-2.6.22-rc4-mm2.orig/fs/ocfs2/aops.c\n+++ linux-2.6.22-rc4-mm2/fs/ocfs2/aops.c\n@@ -739,18 +739,13 @@ int ocfs2_map_page_blocks(struct page *p\n \tbh = head;\n \tblock_start = 0;\n \tdo {\n-\t\tvoid *kaddr;\n-\n \t\tblock_end = block_start + bsize;\n \t\tif (block_end <= from)\n \t\t\tgoto next_bh;\n \t\tif (block_start >= to)\n \t\t\tbreak;\n \n-\t\tkaddr = kmap_atomic(page, KM_USER0);\n-\t\tmemset(kaddr+block_start, 0, bh->b_size);\n-\t\tflush_dcache_page(page);\n-\t\tkunmap_atomic(kaddr, KM_USER0);\n+\t\tzero_user_page(page, block_start, bh->b_size, KM_USER0);\n \t\tset_buffer_uptodate(bh);\n \t\tmark_buffer_dirty(bh);\n \n@@ -895,15 +890,11 @@ static void ocfs2_zero_new_buffers(struc\n \t\t\tif (block_end > from && block_start < to) {\n \t\t\t\tif (!PageUptodate(page)) {\n \t\t\t\t\tunsigned start, end;\n-\t\t\t\t\tvoid *kaddr;\n \n \t\t\t\t\tstart = max(from, block_start);\n \t\t\t\t\tend = min(to, block_end);\n \n-\t\t\t\t\tkaddr = kmap_atomic(page, KM_USER0);\n-\t\t\t\t\tmemset(kaddr+start, 0, end - start);\n-\t\t\t\t\tflush_dcache_page(page);\n-\t\t\t\t\tkunmap_atomic(kaddr, KM_USER0);\n+\t\t\t\t\tzero_user_page(page, start, end - start, KM_USER0);\n \t\t\t\t\tset_buffer_uptodate(bh);\n \t\t\t\t}\n \n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22793 - in\n\tbranches/SAMBA_4_0/source/wrepl_server: .", "body": "Author: metze\nDate: 2007-05-11 10:15:20 +0000 (Fri, 11 May 2007)\nNew Revision: 22793\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22793\n\nLog:\nuse a state struct for r_do_release_demand to avoid a memleak on errors\n\nmetze\nModified:\n   branches/SAMBA_4_0/source/wrepl_server/wrepl_apply_records.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/wrepl_server/wrepl_apply_records.c\n===================================================================\n--- branches/SAMBA_4_0/source/wrepl_server/wrepl_apply_records.c\t2007-05-11 10:13:10 UTC (rev 22792)\n+++ branches/SAMBA_4_0/source/wrepl_server/wrepl_apply_records.c\t2007-05-11 10:15:20 UTC (rev 22793)\n@@ -1082,11 +1082,20 @@\n \treturn NT_STATUS_OK;\n }\n \n+struct r_do_release_demand_state {\n+\tstruct messaging_context *msg_ctx;\n+\tstruct nbtd_proxy_wins_release_demand r;\n+};\n+\n static void r_do_release_demand_handler(struct irpc_request *ireq)\n {\n \tNTSTATUS status;\n+\tstruct r_do_release_demand_state *state = talloc_get_type(ireq->async.private,\n+\t\t\t\t\t\t  struct r_do_release_demand_state);\n+\n \tstatus = irpc_call_recv(ireq);\n \t/* don't care about the result */\n+\ttalloc_free(state);\n }\n \n static NTSTATUS r_do_release_demand(struct wreplsrv_partner *partner,\n@@ -1100,7 +1109,7 @@\n \tstruct server_id *nbt_servers;\n \tconst char **addrs;\n \tstruct winsdb_addr **addresses;\n-\tstruct nbtd_proxy_wins_release_demand r;\n+\tstruct r_do_release_demand_state *state;\n \tuint32_t i;\n \n \t/*\n@@ -1116,30 +1125,36 @@\n \tDEBUG(4,(\"release demand record %s\\n\",\n \t\t nbt_name_string(mem_ctx, &replica->name)));\n \n-\tnbt_servers = irpc_servers_byname(partner->service->task->msg_ctx, mem_ctx, \"nbt_server\");\n+\tstate = talloc_zero(mem_ctx, struct r_do_release_demand_state);\n+\tNT_STATUS_HAVE_NO_MEMORY(state);\n+\tstate->msg_ctx\t= partner->service->task->msg_ctx;\n+\n+\tnbt_servers = irpc_servers_byname(state->msg_ctx, state, \"nbt_server\");\n \tif ((nbt_servers == NULL) || (nbt_servers[0].id == 0)) {\n \t\treturn NT_STATUS_INTERNAL_ERROR;\n \t}\n \n-\tr.in.name\t= *rec->name;\n-\tr.in.num_addrs\t= winsdb_addr_list_length(addresses);\n-\tr.in.addrs\t= talloc_array(partner, struct nbtd_proxy_wins_addr, r.in.num_addrs);\n-\tNT_STATUS_HAVE_NO_MEMORY(r.in.addrs);\n+\tstate->r.in.name\t= *rec->name;\n+\tstate->r.in.num_addrs\t= winsdb_addr_list_length(addresses);\n+\tstate->r.in.addrs\t= talloc_array(state, struct nbtd_proxy_wins_addr,\n+\t\t\t\t\t       state->r.in.num_addrs);\n+\tNT_STATUS_HAVE_NO_MEMORY(state->r.in.addrs);\n \t/* TODO: fix pidl to handle inline ipv4address arrays */\n-\taddrs\t\t\t= winsdb_addr_string_list(r.in.addrs, addresses);\n+\taddrs\t\t\t= winsdb_addr_string_list(state->r.in.addrs, addresses);\n \tNT_STATUS_HAVE_NO_MEMORY(addrs);\n-\tfor (i=0; i < r.in.num_addrs; i++) {\n-\t\tr.in.addrs[i].addr = addrs[i];\n+\tfor (i=0; i < state->r.in.num_addrs; i++) {\n+\t\tstate->r.in.addrs[i].addr = addrs[i];\n \t}\n \n-\tireq = IRPC_CALL_SEND(partner->service->task->msg_ctx, nbt_servers[0],\n+\tireq = IRPC_CALL_SEND(state->msg_ctx, nbt_servers[0],\n \t\t\t      irpc, NBTD_PROXY_WINS_RELEASE_DEMAND,\n-\t\t\t      &r, partner);\n+\t\t\t      &state->r, state);\n \tNT_STATUS_HAVE_NO_MEMORY(ireq);\n \n \tireq->async.fn\t\t= r_do_release_demand_handler;\n-\tireq->async.private\t= NULL;\n+\tireq->async.private\t= state;\n \n+\ttalloc_steal(partner, state);\n \treturn NT_STATUS_OK;\n }\n \n\n"}
{"category": "ham", "to_address": "\"Allison Randal\" <allison@perl.org>", "from_address": "\"Alek Storm\" <alek.storm@gmail.com>", "subject": "Re: [perl #42905] [PATCH] implement vtable overriding for PDD15, bugfix", "body": "On 5/9/07, Allison Randal <allison@perl.org> wrote: \n\nOn general development styles, you've altered the spec, the tests, andthe code all in one massive patch. It's better to make changes in \nsmaller steps. That gives the whole list an opportunity to discuss the changes, and accept or reject individual components.If you have spec changes, it's best to talk about those on the listbefore you start implementing the code for the spec changes. (At the \nvery least, it's less work for you, since it saves you the trouble of implementing and reimplementing code depending on which of your proposedspec changes are accepted.)When you change existing tests, that means you could be breaking \nexisting code, so it's likely that the code changes that go with the test changes will need at least a full deprecation cycle. If you splitthe code and test changes for that feature out into a separate patch, \nthen you won't have to delay all your changes waiting for thedeprecation cycle. \nThanks, that's great advice.\u00a0 Do you mean that the changes to the tests would be accepted before the changes to the code?\u00a0\nThe existing code does need a refactor, and given how it's written now Ican understand why you went in this direction. But, the direction I want \nthe refactor to go is increased encapsulation. src/objects.c should be stripped down to as little code as possible, and should have noknowledge of the specific object model it's operating on, or theinternals of the class or object. The details of the implementation \nshould live in the Class PMC (or ParrotClass PMC, or MyHLLsCustomClass PMC). \nAbsolutely.\u00a0\u00a0\nParrotObject has the right idea here. The C-level definitions of the vtable entries are responsible for checking whether they've been \noverridden. (A lot of that code is boiler-plate and could be refactoreddown to a few internal utility functions, but the basic implementation strategy is sound.)\nI would have gone with that, but there's no way to deal with inheritance: if a vtable method is added to a superclass, there's no way to notify subclasses of the change.\u00a0\u00a0 Also, if Object implements any vtable functions, each one has\u00a0to check for its override manually.\u00a0\u00a0Anyway, the patch's\u00a0implementation uses a faster lookup scheme than the old object system: since it uses a hashtable, lookup is O(1), and increases linearly with the number of parents.\u00a0 Multiple parents change that, of course, but that's rare. \n\n\u00a0\n> The PCCMETHOD 'add_vtable_method' is added to Class.\u00a0\u00a0Using two separate > methods for adding normal methods and vtable methods is much cleaner and \n> more logical, since they are two completely separate functionalities.The methods aren't a core part of the Class implementation, they'll just be added as a role. So, technically it doesn't matter much whether we do \nor don't have an 'add_vtable_method'. But from an interface perspective,it doesn't seem like much of an advantage over passing a flag to 'add_method', especially since it would mean you have to call both \n'add_method' and 'add_vtable_method' separately when you want aparticular chunk of code to be both a method and a vtable function. \nI agree that it should be part of a role, and that using 'add_vtable_method' over 'add_method' isn't doesn't make a lot of difference, but it does make the interface a little easier.\u00a0 Generally, and I believe you've said this before, vtable methods are usually not also going to be added as normal methods to a class, so calling 'add_vtable_method' and 'add_method' separately isn't going to be very common.\u00a0 What I don't like about using 'add_method' for both cases is that passing the anon flag with the vtable flag changes the meaning of the name parameter.\u00a0 We also run into trouble if we want to add the sub with one name as a method and a different one as a vtable method, which isn't a problem if we use both 'add_method' and 'add_vtable_method'.\u00a0 There aren't really absolutes here; it's just a matter of ease of use.\u00a0 \n\u00a0\n> In fact, using this interface, the :vtable pragma is completely unnecessary, so > we could remove it if we wanted to.\u00a0\u00a0Because I was unsure exactly how the \n> interface is going to end up, 'add_method' also adds vtable methods also, if> :vtable is set on the method. If we decide to go with this interface, I'd > like to take it out, along with the :vtable pragma. \nThe fact that there's a verbose way to overload a vtable function atruntime is not enough justification to remove the :vtable syntax. It stays.\nWhy do we need two ways to do the same thing?\u00a0 Using *either* interface ('add_method' alone or 'add_method' and 'add_vtable_method'), the :vtable flag is redundant.\u00a0 It adds no functionality. \n\n\u00a0\n> Trying to override 'mark', 'destroy', or 'morph' throws an exception, \n> because overriding them might be dangerous.\u00a0\u00a0An exception is also thrown for> 'init_pmc', see below.Why do these throw an exception? You should be able to override them.\nI can see 'morph' maybe being overridden, but 'destroy' and 'mark'?\u00a0 PIR has no way to access GC internals, and it should stay that way.\u00a0 Even if we allowed them to be overridden, objects wouldn't be able to use them for anything.\u00a0\n\n\u00a0\nP.S. Actually, I can see them possiblyy being used if Parrot interfaces with C code.\u00a0 Is this a valid use case?\u00a0\n> The 'init' vtable method in Object is not wrapped by pmc2c, since its > override is called from \nClass.new().\u00a0\u00a0Class.new() is changed from accepting> a named slurpy of attributes to an unnamed slurpy of initializer> parameters.\u00a0\u00a0This slurpy is :flattened and passed to 'init'.\u00a0\u00a0This is really \n\n> cool, because now 'init' acts like a normal method, and can accept a> variable-sized parameter list.\u00a0\u00a0This makes 'init_pmc' obsolete, so trying to> override it throws an exception.\u00a0\u00a0Named parameters don't work, but c'mon, \n> you can't have it all, right?'init' isn't a normal method, it's a vtable function. And it's nevercalled directly, so how is it useful to make it take a variable sizedparameter list? Named parameters stay. Just slurp them up and pass them \non to init_pmc as a hash.\nIt's called pseudo-directly through Class.new(), which passes its parameters right on to 'init'.\u00a0\u00a0Only being able to pass one\u00a0PMC parameter\u00a0to object constructors is a limitation of C that we can overcome in PIR.\u00a0 Doing it this way, we get type checking, checking on the number of parameters, and all the good things that come with normal calling conventions.\u00a0 Objects can still choose to pass a Hash PMC as a normal parameter.\u00a0 Losing named parameters is well worth the tradeoff.\u00a0 \n\u00a0\n> Currently, passing arguments to Class.new() when 'init' is not overridden \n> doesn't throw an exception.\u00a0\u00a0Should it? \nNo. There's no reason to require every class to override 'init'.\nThat's not what I meant.\u00a0 I meant that passing arguments to Class.new() implies that the caller thinks 'init' is overridden, and we can't let them have a false expectation that something will happen to the arguments they pass.\u00a0 This is with the \nClass.new() that forwards its arguments to 'init', not the current one that accepts an attribute initialization list.\u00a0 That being said, I can see that throwing an exception when this happens is not strictly necessary.\u00a0 \n\u00a0\n> This patch also fixes a bug with 'invoke' in both ParrotObject and Object: \n> 'self' had to be explicitly passed to the override.\u00a0\u00a0This is fixed by adding \n> the signature flag PARROT_ARG_OBJECT, and unshifting that OR-ed with> PARROT_ARG_PMC onto the args signature.\u00a0\u00a0This has a counterpart already used > in fetch_arg_sig() in src/inter_call.c.What bug? Submit a separate ticket with example code. \n\nDone.\u00a0\n> The old double-underscore method of vtable overriding can die along with the> old object system, but I would prefer to submit a patch to get rid of it \n> sooner, since I don't know how long the old object system will stick around. Pending complete resolution of RT#40626. This can go in the nextdeprecation cycle if we add a test for that last (resolved?) bug, and \nverify that no code in the repository is using the old double-underscore override.\nI wrote a perl near-one-liner a while ago to convert all code in the repository from the double-underscore system to using :vtable, but I haven't submitted the changes yet.\u00a0\u00a0 \n> Tests are included for 'init', 'invoke', and vtable method lookup through \n> the parent stack.\u00a0\u00a0Also, I fixed some tests in t/pmc/parrotobject.t that> overrode 'invoke' without using the :method pragma, and removed the test for> #41372, which is now obsolete.\n\nObsolete how? Does it test for a feature that no longer exists? (Inwhich case why isn't it failing?) Or does it test for a bug that's beenfixed? (In which case, it's a useful regression test.)\nIt wasn't failing because of a hackish workaround - :vtable was used without :method on the 'invoke' sub.\u00a0 Normally, I would keep it, but the test didn't make sense after the patch was applied.\u00a0\u00a0 \n\u00a0\n> Also, a question: what exactly is the '_namespace' member of Parrot_Class \n> used for?\u00a0\u00a0I don't see it used anywhere; it can be gotten and set, but is \n> otherwise useless, since methods are added using a separate mechanism.It's used to store a pointer to the namespace object associated with the class.\nAnd what is the pointer used for?\u00a0 Methods added to Classes can come from anywhere, not just a particular namespace.\u00a0 Why should Classes be associated with namespaces?\u00a0\u00a0\n>\u00a0\u00a0lib/Parrot/Pmc2c/Object.pm\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0158Why do we need this file? Objects don't need that much custom code \ngeneration, and it's highly unlikely that the code here will be usefulfor any object implementation other than PDD 15. \nThis file wraps all Object vtable methods with code that checks if the vtable methods are overridden.\u00a0 It's specific to the Parrot default Class-Object implementation, though we could possibly have vtable methods looked up through a PCCMETHOD in a role implemented by Class. \n\n\u00a0\n\nI'm working on implementing a different way of doing this that completely separates the Object PMC from vtable overriding, letting PMCs choose whether or not to use vtable overriding, whether or not they inherit from Object.\u00a0 I'll submit it as soon as I finish.\n\n\u00a0\n>\u00a0\u00a0src/pmc/class.pmc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\u00a0\u00a0150Adding a (global) interpreter entry for \"current_object\", \"current_args\" \nand \"args_signature\" is not a good solution to anything.I didn't add them.\u00a0 They were already there.\u00a0 In fact, I submitted a patch to move them from Parrot_Interp to Parrot_Context (#42155), because I don't think they should be global either.\u00a0 Still, it doesn't matter where they are - the patch works the same way.\nWhew.\u00a0 Thanks for looking over my giant patch :).\u00a0 I've split the original patch into three parts - testing, specs, and code, and rebased it on r18494.\u00a0 I've also cut out the code that modified the implementation of invoke() in the old object system, but kept the modification in the new one, and cut out the changes to the tests related to that.\n-- Alek Storm \n"}
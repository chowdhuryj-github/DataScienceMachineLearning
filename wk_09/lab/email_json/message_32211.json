{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 319: - up rx_cnt on all packet types in\n\thttp://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 319\nrevision-id: tridge@samba.org-20070518132336-gjpdua5y9j3ydutx\nparent: tridge@samba.org-20070518121158-hay706mpx4tvajh2\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Fri 2007-05-18 23:23:36 +1000\nmessage:\n  - up rx_cnt on all packet types\n  - notice when a node becomes available again\nmodified:\n  common/ctdb.c                  ctdb.c-20061127094323-t50f58d65iaao5of-2\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_monitor.c          ctdb_monitor.c-20070518100625-8jf4ft1mjzmb22ck-1\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'common/ctdb.c'\n--- a/common/ctdb.c\t2007-05-18 09:19:35 +0000\n+++ b/common/ctdb.c\t2007-05-18 13:23:36 +0000\n@@ -116,8 +116,7 @@\n \tnode->name = talloc_asprintf(node, \"%s:%u\", \n \t\t\t\t     node->address.address, \n \t\t\t\t     node->address.port);\n-\t/* for now we just set the vnn to the line in the file - this\n-\t   will change! */\n+\t/* this assumes that the nodes are kept in sorted order, and no gaps */\n \tnode->vnn = ctdb->num_nodes;\n \n \tif (ctdb->address.address &&\n@@ -275,6 +274,11 @@\n \t\t \"node %d to %d\\n\", hdr->reqid, hdr->operation, hdr->length,\n \t\t hdr->srcnode, hdr->destnode));\n \n+\t/* up the counter for this source node, so we know its alive */\n+\tif (ctdb_validate_vnn(ctdb, hdr->srcnode)) {\n+\t\tctdb->nodes[hdr->srcnode]->rx_cnt++;\n+\t}\n+\n \tswitch (hdr->operation) {\n \tcase CTDB_REQ_CALL:\n \tcase CTDB_REPLY_CALL:\n@@ -345,7 +349,6 @@\n \n \tcase CTDB_REQ_KEEPALIVE:\n \t\tctdb->status.keepalive_packets_recv++;\n-\t\tctdb_request_keepalive(ctdb, hdr);\n \t\tbreak;\n \n \tdefault:\n\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-05-18 09:19:35 +0000\n+++ b/common/ctdb_call.c\t2007-05-18 13:23:36 +0000\n@@ -785,13 +785,11 @@\n /* \n    send a keepalive packet to the other node\n */\n-void ctdb_send_keepalive(struct ctdb_context *ctdb,\n-\t\t\t\tTALLOC_CTX *mem_ctx,\n-\t\t\t\tuint32_t destnode)\n+void ctdb_send_keepalive(struct ctdb_context *ctdb, uint32_t destnode)\n {\n \tstruct ctdb_req_keepalive *r;\n \t\n-\tr = ctdb_transport_allocate(ctdb, mem_ctx, CTDB_REQ_KEEPALIVE,\n+\tr = ctdb_transport_allocate(ctdb, ctdb, CTDB_REQ_KEEPALIVE,\n \t\t\t\t    sizeof(struct ctdb_req_keepalive), \n \t\t\t\t    struct ctdb_req_keepalive);\n \tCTDB_NO_MEMORY_FATAL(ctdb, r);\n\n=== modified file 'common/ctdb_monitor.c'\n--- a/common/ctdb_monitor.c\t2007-05-18 10:06:29 +0000\n+++ b/common/ctdb_monitor.c\t2007-05-18 13:23:36 +0000\n@@ -26,73 +26,55 @@\n #include \"../include/ctdb_private.h\"\n \n /*\n-  called when a CTDB_REQ_KEEPALIVE packet comes in\n-*/\n-void ctdb_request_keepalive(struct ctdb_context *ctdb, struct ctdb_req_header *hdr)\n-{\n-\tstruct ctdb_req_keepalive *r = (struct ctdb_req_keepalive *)hdr;\n-\tstruct ctdb_node *node = NULL;\n-\tint i;\n-\n-\tfor (i=0;inum_nodes;i++) {\n-\t\tif (ctdb->nodes[i]->vnn == r->hdr.srcnode) {\n-\t\t\tnode = ctdb->nodes[i];\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!node) {\n-\t\tDEBUG(0,(__location__ \" Keepalive received from node not in ctdb->nodes : %u\\n\", r->hdr.srcnode));\n-\t\treturn;\n-\t}\n-\n-\tnode->rx_cnt++;\n-}\n-\n-\n+  see if any nodes are dead\n+ */\n static void ctdb_check_for_dead_nodes(struct event_context *ev, struct timed_event *te, \n \t\t\t   struct timeval t, void *private_data)\n {\n \tstruct ctdb_context *ctdb = talloc_get_type(private_data, struct ctdb_context);\n \tint i;\n-\tTALLOC_CTX *mem_ctx = talloc_new(ctdb);\n \n \t/* send a keepalive to all other nodes, unless */\n \tfor (i=0;inum_nodes;i++) {\n-\t\tif (!(ctdb->nodes[i]->flags & NODE_FLAGS_CONNECTED)) {\n+\t\tstruct ctdb_node *node = ctdb->nodes[i];\n+\t\tif (node->vnn == ctdb->vnn) {\n \t\t\tcontinue;\n \t\t}\n-\t\tif (ctdb->nodes[i]->vnn == ctdb_get_vnn(ctdb)) {\n-\t\t\tcontinue;\n+\t\t\n+\t\t/* it might have come alive again */\n+\t\tif (!(node->flags & NODE_FLAGS_CONNECTED) && node->rx_cnt != 0) {\n+\t\t\tDEBUG(0,(\"Node %u is alive again - marking as connected\\n\", node->vnn));\n+\t\t\tnode->flags |= NODE_FLAGS_CONNECTED;\n \t\t}\n \n-\t\tif (ctdb->nodes[i]->rx_cnt == 0) {\n-\t\t\tctdb->nodes[i]->dead_count++;\n+\t\tif (node->rx_cnt == 0) {\n+\t\t\tnode->dead_count++;\n \t\t} else {\n-\t\t\tctdb->nodes[i]->dead_count = 0;\n+\t\t\tnode->dead_count = 0;\n \t\t}\n \n-\t\tif (ctdb->nodes[i]->dead_count>=3) {\n-\t\t\tctdb->nodes[i]->flags &= ~NODE_FLAGS_CONNECTED;\n-\t\t\t/* should probably tell the transport layer\n-\t\t\t   to kill the sockets as well \n+\t\tnode->rx_cnt = 0;\n+\n+\t\tif (node->dead_count >= CTDB_MONITORING_DEAD_COUNT) {\n+\t\t\tDEBUG(0,(\"Node %u is dead - marking as not connected\\n\", node->vnn));\n+\t\t\tnode->flags &= ~NODE_FLAGS_CONNECTED;\n+\t\t\t/* maybe tell the transport layer to kill the\n+\t\t\t   sockets as well?\n \t\t\t*/\n \t\t\tcontinue;\n \t\t}\n \n-\t\tctdb_send_keepalive(ctdb, mem_ctx, i);\n-\t\tctdb->nodes[i]->rx_cnt = 0;\n+\t\tctdb_send_keepalive(ctdb, node->vnn);\n \t}\n-\n-\n-\n \t\n-\ttalloc_free(mem_ctx);\n-\n \tevent_add_timed(ctdb->ev, ctdb, \n \t\t\ttimeval_current_ofs(CTDB_MONITORING_TIMEOUT, 0), \n \t\t\tctdb_check_for_dead_nodes, ctdb);\n }\n \n+/*\n+  start watching for nodes that might be dead\n+ */\n int ctdb_start_monitoring(struct ctdb_context *ctdb)\n {\n \tevent_add_timed(ctdb->ev, ctdb, \n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-05-18 09:19:35 +0000\n+++ b/include/ctdb_private.h\t2007-05-18 13:23:36 +0000\n@@ -311,6 +311,9 @@\n /* timeout between dead-node monitoring events */\n #define CTDB_MONITORING_TIMEOUT 5\n \n+/* number of monitoring timeouts before a node is considered dead */\n+#define CTDB_MONITORING_DEAD_COUNT 3\n+\n \n /* number of consecutive calls from the same node before we give them\n    the record */\n@@ -710,7 +713,6 @@\n void ctdb_reqid_remove(struct ctdb_context *ctdb, uint32_t reqid);\n \n void ctdb_request_control(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n-void ctdb_request_keepalive(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n void ctdb_reply_control(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n \n int ctdb_daemon_send_control(struct ctdb_context *ctdb, uint32_t destnode,\n@@ -819,6 +821,6 @@\n uint32_t ctdb_get_num_connected_nodes(struct ctdb_context *ctdb);\n \n int ctdb_start_monitoring(struct ctdb_context *ctdb);\n-void ctdb_send_keepalive(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx, uint32_t destnode);\n+void ctdb_send_keepalive(struct ctdb_context *ctdb, uint32_t destnode);\n \n #endif\n\n"}
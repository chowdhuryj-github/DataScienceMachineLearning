{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "vlendec@samba.org", "subject": "svn commit: samba r23091 - in branches: SAMBA_3_0/source/rpc_client\n\tSAMBA_3_0/source/rpc_parse SAMBA_3_0_26/source/rpc_client\n\tSAMBA_3_0_26/source/rpc_parse", "body": "Author: vlendec\nDate: 2007-05-23 15:17:49 +0000 (Wed, 23 May 2007)\nNew Revision: 23091\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23091\n\nLog:\nAdd rpccli_netlogon_sam_network_logon_ex, fix its parsing. This does not\nuse the credential chain and only works over netlogon, but it would\nallow multiple outstanding auth requests for a single workstation\naccount.\n\nModified:\n   branches/SAMBA_3_0/source/rpc_client/cli_netlogon.c\n   branches/SAMBA_3_0/source/rpc_parse/parse_misc.c\n   branches/SAMBA_3_0/source/rpc_parse/parse_net.c\n   branches/SAMBA_3_0_26/source/rpc_client/cli_netlogon.c\n   branches/SAMBA_3_0_26/source/rpc_parse/parse_misc.c\n   branches/SAMBA_3_0_26/source/rpc_parse/parse_net.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/rpc_client/cli_netlogon.c\n===================================================================\n--- branches/SAMBA_3_0/source/rpc_client/cli_netlogon.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0/source/rpc_client/cli_netlogon.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -946,6 +946,98 @@\n         return result;\n }\n \n+NTSTATUS rpccli_netlogon_sam_network_logon_ex(struct rpc_pipe_client *cli,\n+\t\t\t\t\t      TALLOC_CTX *mem_ctx,\n+\t\t\t\t\t      uint32 logon_parameters,\n+\t\t\t\t\t      const char *server,\n+\t\t\t\t\t      const char *username,\n+\t\t\t\t\t      const char *domain,\n+\t\t\t\t\t      const char *workstation, \n+\t\t\t\t\t      const uint8 chal[8], \n+\t\t\t\t\t      DATA_BLOB lm_response,\n+\t\t\t\t\t      DATA_BLOB nt_response,\n+\t\t\t\t\t      NET_USER_INFO_3 *info3)\n+{\n+\tprs_struct qbuf, rbuf;\n+\tNET_Q_SAM_LOGON_EX q;\n+\tNET_R_SAM_LOGON_EX r;\n+\tNTSTATUS result = NT_STATUS_UNSUCCESSFUL;\n+\tNET_ID_INFO_CTR ctr;\n+\tint validation_level = 3;\n+\tconst char *workstation_name_slash;\n+\tconst char *server_name_slash;\n+\tstatic uint8 zeros[16];\n+\tint i;\n+\t\n+\tZERO_STRUCT(q);\n+\tZERO_STRUCT(r);\n+\n+\tif (server[0] != '\\\\' && server[1] != '\\\\') {\n+\t\tserver_name_slash = talloc_asprintf(mem_ctx, \"\\\\\\\\%s\", server);\n+\t} else {\n+\t\tserver_name_slash = server;\n+\t}\n+\n+\tif (workstation[0] != '\\\\' && workstation[1] != '\\\\') {\n+\t\tworkstation_name_slash = talloc_asprintf(mem_ctx, \"\\\\\\\\%s\", workstation);\n+\t} else {\n+\t\tworkstation_name_slash = workstation;\n+\t}\n+\n+\tif (!workstation_name_slash || !server_name_slash) {\n+\t\tDEBUG(0, (\"talloc_asprintf failed!\\n\"));\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\t/* Initialise input parameters */\n+\n+\tq.validation_level = validation_level;\n+\n+        ctr.switch_value = NET_LOGON_TYPE;\n+\n+\tinit_id_info2(&ctr.auth.id2, domain,\n+\t\t      logon_parameters, /* param_ctrl */\n+\t\t      0xdead, 0xbeef, /* LUID? */\n+\t\t      username, workstation_name_slash, (const uchar*)chal,\n+\t\t      lm_response.data, lm_response.length, nt_response.data,\n+\t\t      nt_response.length);\n+ \n+        init_sam_info_ex(&q.sam_id, server_name_slash, global_myname(),\n+\t\t\t NET_LOGON_TYPE, &ctr);\n+\n+        r.user = info3;\n+\n+        /* Marshall data and send request */\n+\n+\tCLI_DO_RPC(cli, mem_ctx, PI_NETLOGON, NET_SAMLOGON_EX,\n+\t\t   q, r, qbuf, rbuf,\n+\t\t   net_io_q_sam_logon_ex,\n+\t\t   net_io_r_sam_logon_ex,\n+\t\t   NT_STATUS_UNSUCCESSFUL);\n+\n+\tif (memcmp(zeros, info3->user_sess_key, 16) != 0) {\n+\t\tSamOEMhash(info3->user_sess_key, cli->dc->sess_key, 16);\n+\t} else {\n+\t\tmemset(info3->user_sess_key, '\\0', 16);\n+\t}\n+\n+\tif (memcmp(zeros, info3->lm_sess_key, 8) != 0) {\n+\t\tSamOEMhash(info3->lm_sess_key, cli->dc->sess_key, 8);\n+\t} else {\n+\t\tmemset(info3->lm_sess_key, '\\0', 8);\n+\t}\n+\n+\tfor (i=0; i < 7; i++) {\n+\t\tmemset(&info3->unknown[i], '\\0', 4);\n+\t}\n+\n+        /* Return results */\n+\n+\tresult = r.status;\n+\n+        return result;\n+}\n+\n /***************************************************************************\n LSA Server Password Set.\n ****************************************************************************/\n\nModified: branches/SAMBA_3_0/source/rpc_parse/parse_misc.c\n===================================================================\n--- branches/SAMBA_3_0/source/rpc_parse/parse_misc.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0/source/rpc_parse/parse_misc.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -1337,7 +1337,8 @@\n  Inits a DOM_CLNT_SRV structure.\n ********************************************************************/\n \n-static void init_clnt_srv(DOM_CLNT_SRV *logcln, const char *logon_srv, const char *comp_name)\n+void init_clnt_srv(DOM_CLNT_SRV *logcln, const char *logon_srv,\n+\t\t   const char *comp_name)\n {\n \tDEBUG(5,(\"init_clnt_srv: %d\\n\", __LINE__));\n \n\nModified: branches/SAMBA_3_0/source/rpc_parse/parse_net.c\n===================================================================\n--- branches/SAMBA_3_0/source/rpc_parse/parse_net.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0/source/rpc_parse/parse_net.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -1376,6 +1376,21 @@\n }\n \n /*******************************************************************\n+ Inits a DOM_SAM_INFO structure.\n+********************************************************************/\n+\n+void init_sam_info_ex(DOM_SAM_INFO_EX *sam,\n+\t\t      const char *logon_srv, const char *comp_name,\n+\t\t      uint16 logon_level, NET_ID_INFO_CTR *ctr)\n+{\n+\tDEBUG(5,(\"init_sam_info_ex: %d\\n\", __LINE__));\n+\n+\tinit_clnt_srv(&sam->client, logon_srv, comp_name);\n+\tsam->logon_level  = logon_level;\n+\tsam->ctr          = ctr;\n+}\n+\n+/*******************************************************************\n  Reads or writes a DOM_SAM_INFO structure.\n ********************************************************************/\n \n@@ -1993,6 +2008,9 @@\n \tif(!prs_uint16(\"validation_level\", ps, depth, &q_l->validation_level))\n \t\treturn False;\n \n+\tif (!prs_align(ps))\n+\t\treturn False;\n+\n \tif(!prs_uint32(\"flags  \", ps, depth, &q_l->flags))\n \t\treturn False;\n \n\nModified: branches/SAMBA_3_0_26/source/rpc_client/cli_netlogon.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/rpc_client/cli_netlogon.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0_26/source/rpc_client/cli_netlogon.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -908,6 +908,98 @@\n         return result;\n }\n \n+NTSTATUS rpccli_netlogon_sam_network_logon_ex(struct rpc_pipe_client *cli,\n+\t\t\t\t\t      TALLOC_CTX *mem_ctx,\n+\t\t\t\t\t      uint32 logon_parameters,\n+\t\t\t\t\t      const char *server,\n+\t\t\t\t\t      const char *username,\n+\t\t\t\t\t      const char *domain,\n+\t\t\t\t\t      const char *workstation, \n+\t\t\t\t\t      const uint8 chal[8], \n+\t\t\t\t\t      DATA_BLOB lm_response,\n+\t\t\t\t\t      DATA_BLOB nt_response,\n+\t\t\t\t\t      NET_USER_INFO_3 *info3)\n+{\n+\tprs_struct qbuf, rbuf;\n+\tNET_Q_SAM_LOGON_EX q;\n+\tNET_R_SAM_LOGON_EX r;\n+\tNTSTATUS result = NT_STATUS_UNSUCCESSFUL;\n+\tNET_ID_INFO_CTR ctr;\n+\tint validation_level = 3;\n+\tconst char *workstation_name_slash;\n+\tconst char *server_name_slash;\n+\tstatic uint8 zeros[16];\n+\tint i;\n+\t\n+\tZERO_STRUCT(q);\n+\tZERO_STRUCT(r);\n+\n+\tif (server[0] != '\\\\' && server[1] != '\\\\') {\n+\t\tserver_name_slash = talloc_asprintf(mem_ctx, \"\\\\\\\\%s\", server);\n+\t} else {\n+\t\tserver_name_slash = server;\n+\t}\n+\n+\tif (workstation[0] != '\\\\' && workstation[1] != '\\\\') {\n+\t\tworkstation_name_slash = talloc_asprintf(mem_ctx, \"\\\\\\\\%s\", workstation);\n+\t} else {\n+\t\tworkstation_name_slash = workstation;\n+\t}\n+\n+\tif (!workstation_name_slash || !server_name_slash) {\n+\t\tDEBUG(0, (\"talloc_asprintf failed!\\n\"));\n+\t\treturn NT_STATUS_NO_MEMORY;\n+\t}\n+\n+\t/* Initialise input parameters */\n+\n+\tq.validation_level = validation_level;\n+\n+        ctr.switch_value = NET_LOGON_TYPE;\n+\n+\tinit_id_info2(&ctr.auth.id2, domain,\n+\t\t      logon_parameters, /* param_ctrl */\n+\t\t      0xdead, 0xbeef, /* LUID? */\n+\t\t      username, workstation_name_slash, (const uchar*)chal,\n+\t\t      lm_response.data, lm_response.length, nt_response.data,\n+\t\t      nt_response.length);\n+ \n+        init_sam_info_ex(&q.sam_id, server_name_slash, global_myname(),\n+\t\t\t NET_LOGON_TYPE, &ctr);\n+\n+        r.user = info3;\n+\n+        /* Marshall data and send request */\n+\n+\tCLI_DO_RPC(cli, mem_ctx, PI_NETLOGON, NET_SAMLOGON_EX,\n+\t\t   q, r, qbuf, rbuf,\n+\t\t   net_io_q_sam_logon_ex,\n+\t\t   net_io_r_sam_logon_ex,\n+\t\t   NT_STATUS_UNSUCCESSFUL);\n+\n+\tif (memcmp(zeros, info3->user_sess_key, 16) != 0) {\n+\t\tSamOEMhash(info3->user_sess_key, cli->dc->sess_key, 16);\n+\t} else {\n+\t\tmemset(info3->user_sess_key, '\\0', 16);\n+\t}\n+\n+\tif (memcmp(zeros, info3->lm_sess_key, 8) != 0) {\n+\t\tSamOEMhash(info3->lm_sess_key, cli->dc->sess_key, 8);\n+\t} else {\n+\t\tmemset(info3->lm_sess_key, '\\0', 8);\n+\t}\n+\n+\tfor (i=0; i < 7; i++) {\n+\t\tmemset(&info3->unknown[i], '\\0', 4);\n+\t}\n+\n+        /* Return results */\n+\n+\tresult = r.status;\n+\n+        return result;\n+}\n+\n /***************************************************************************\n LSA Server Password Set.\n ****************************************************************************/\n\nModified: branches/SAMBA_3_0_26/source/rpc_parse/parse_misc.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/rpc_parse/parse_misc.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0_26/source/rpc_parse/parse_misc.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -1384,7 +1384,8 @@\n  Inits a DOM_CLNT_SRV structure.\n ********************************************************************/\n \n-static void init_clnt_srv(DOM_CLNT_SRV *logcln, const char *logon_srv, const char *comp_name)\n+void init_clnt_srv(DOM_CLNT_SRV *logcln, const char *logon_srv,\n+\t\t   const char *comp_name)\n {\n \tDEBUG(5,(\"init_clnt_srv: %d\\n\", __LINE__));\n \n\nModified: branches/SAMBA_3_0_26/source/rpc_parse/parse_net.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/rpc_parse/parse_net.c\t2007-05-23 07:44:51 UTC (rev 23090)\n+++ branches/SAMBA_3_0_26/source/rpc_parse/parse_net.c\t2007-05-23 15:17:49 UTC (rev 23091)\n@@ -1292,6 +1292,21 @@\n }\n \n /*******************************************************************\n+ Inits a DOM_SAM_INFO structure.\n+********************************************************************/\n+\n+void init_sam_info_ex(DOM_SAM_INFO_EX *sam,\n+\t\t      const char *logon_srv, const char *comp_name,\n+\t\t      uint16 logon_level, NET_ID_INFO_CTR *ctr)\n+{\n+\tDEBUG(5,(\"init_sam_info_ex: %d\\n\", __LINE__));\n+\n+\tinit_clnt_srv(&sam->client, logon_srv, comp_name);\n+\tsam->logon_level  = logon_level;\n+\tsam->ctr          = ctr;\n+}\n+\n+/*******************************************************************\n  Reads or writes a DOM_SAM_INFO structure.\n ********************************************************************/\n \n@@ -1909,6 +1924,9 @@\n \tif(!prs_uint16(\"validation_level\", ps, depth, &q_l->validation_level))\n \t\treturn False;\n \n+\tif (!prs_align(ps))\n+\t\treturn False;\n+\n \tif(!prs_uint32(\"flags  \", ps, depth, &q_l->flags))\n \t\treturn False;\n \n\n"}
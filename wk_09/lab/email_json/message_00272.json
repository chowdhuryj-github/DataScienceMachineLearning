{"category": "ham", "to_address": "Jeremy Allison <jra@samba.org>", "from_address": "James Peach <jpeach@samba.org>", "subject": "Re: svn commit: samba r22132 - in branches:\n\tSAMBA_3_0/source/modules SAMBA_3_0/source/smbd\n\tSAMBA_3_0_25/source/modules SAMBA_3_0_25/source/smbd", "body": "\nOn 08/04/2007, at 5:23 PM, Jeremy Allison wrote:\n\n> On Sun, Apr 08, 2007 at 05:09:36PM -0700, James Peach wrote:\n>>\n>> You could add this to vfs_cacheprime, and just have an option that\n>> determines whether it does a readahead (ie. I/O hint) or an actual\n>> read(2).\n>\n> I await your patch :-).\n\nI knew you were going to say that!\n>> Sure, but 2 modules that do *almost* the same thing is just  \n>> confusing.\n>\n> I don't think they do. readahead is built around\n> this one syscall on Linux. It's not the same as\n> cacheprime - cacheprime reads from the start of\n> the file, readahead triggers on every pread/sendfile\n> request that matches offset MOD readahead_offset.\n\nThey're not *exactly* the same, but they are mostly the same. The  \ndifference is quite subtle. This patch should resolve the differences:\n\nIndex: SAMBA_3_0/source/modules/vfs_cacheprime.c\n===================================================================\n--- SAMBA_3_0/source/modules/vfs_cacheprime.c\t(revision 22132)\n+++ SAMBA_3_0/source/modules/vfs_cacheprime.c\t(working copy)\n@@ -1,5 +1,6 @@\n/*\n- * Copyright (c) James Peach 2005-2006\n+ * Copyright (c) James Peach 2005-2007\n+ * Copyright (c) Jeremy Allison 2007\n   *\n   * This program is free software; you can redistribute it and/or  \nmodify\n   * it under the terms of the GNU General Public License as  \npublished by\n@@ -31,6 +32,14 @@\n   *      cacheprime:rsize    Amount of readahead in bytes. This  \nshould be a\n   *                          multiple of the RAID stripe width.\n   *      cacheprime:debug    Debug level at which to emit messages.\n+ *      cacheprime:force alignment\n+ *                          Force all I/O to be aligned to an rsize  \nboundary.\n+ *                          If this is false, we simply issue a  \nreadahead on\n+ *                          each rsize boundary.\n+ *\n+ * To configure for Vista:\n+ *      cacheprime:rsize = 0x80000\n+ *      cacheprime:force alignment = no\n   */\n#define READAHEAD_MIN       (128 * 1024)        /* min is 128 KiB */\n@@ -41,7 +50,38 @@\nstatic int module_debug;\nstatic ssize_t g_readsz = 0;\nstatic void * g_readbuf = NULL;\n+static BOOL g_forcealign = False;\n+static void sys_readahead(int fd, SMB_OFF_T offset, SMB_OFF_T len)\n+{\n+        static BOOL didmsg = False;\n+        int err;\n+\n+#if defined(HAVE_LINUX_READAHEAD)\n+\t\terr = readahead(fromfd, offset, (size_t)rhd->len);\n+\n+\t\tDEBUG(10,(\"%s: readahead on fd %u, offset %llu, len %u returned %d \n\\n\",\n+                MODULE,\n+\t\t\t(unsigned int)fromfd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t        err ));\n+#elif defined(HAVE_POSIX_FADVISE)\n+\t\terr = posix_fadvise(fromfd, offset, (off_t)rhd->len,  \nPOSIX_FADV_WILLNEED);\n+\t\tDEBUG(10,(\"%s: posix_fadvise on fd %u, offset %llu, len %u  \nreturned %d\\n\",\n+            MODULE,\n+\t\t\t(unsigned int)fromfd,\n+\t\t\t(unsigned long long)offset,\n+\t\t\t(unsigned int)rhd->len,\n+\t\t\terr ));\n+#else\n+\t\tif (!didmsg) {\n+\t\t\tDEBUG(0,(\"%s: no readahead on this platform\\n\", MODULE));\n+\t\t\tdidmsg = True;\n+\t\t}\n+#endif\n+}\n+\n/* Prime the kernel buffer cache with data from the specified file.  \nWe use\n   * per-fsp data to make sure we only ever do this once. If pread is  \nbeing\n   * emulated by seek/read/seek, when this will suck quite a lot.\n@@ -71,15 +111,20 @@\n              return False;\n          }\n-        DEBUG(module_debug,\n-            (\"%s: doing readahead of %lld bytes at %lld for %s\\n\",\n-            MODULE, (long long)g_readsz, (long long)*last,\n-            fsp->fsp_name));\n+        if (g_forcealign) {\n+                DEBUG(module_debug,\n+                    (\"%s: doing readahead of %lld bytes at %lld for % \ns\\n\",\n+                    MODULE, (long long)g_readsz, (long long)*last,\n+                    fsp->fsp_name));\n-        nread = sys_pread(fd, g_readbuf, g_readsz, *last);\n-        if (nread < 0) {\n-            *last = -1;\n-            return False;\n+                nread = sys_pread(fd, g_readbuf, g_readsz, *last);\n+                if (nread < 0) {\n+                    *last = -1;\n+                    return False;\n+                }\n+        } else {\n+                sys_readahead(fd, *last, g_readsz);\n+                nread += g_readsz;\n          }\n          *last += nread;\n@@ -103,6 +148,9 @@\n          g_readsz = conv_str_size(lp_parm_const_string(SNUM(handle- \n >conn),\n                                          MODULE, \"rsize\", NULL));\n+        g_forcealign = lp_parm_bool(SNUM(handle->conn), MODULE,\n+                            \"force alignment\", False);\n+\n          if (g_readsz < READAHEAD_MIN) {\n                  DEBUG(module_debug, (\"%s: %ld bytes of readahead \"\n                              \"requested, using minimum of %u\\n\",\n@@ -115,9 +163,11 @@\n                  g_readsz = READAHEAD_MAX;\n          }\n-        if ((g_readbuf = SMB_MALLOC(g_readsz)) == NULL) {\n-                /* Turn off readahead if we can't get a buffer. */\n-                g_readsz = 0;\n+        if (g_forcealign == True) {\n+                if ((g_readbuf = SMB_MALLOC(g_readsz)) == NULL) {\n+                        /* Turn off readahead if we can't get a  \nbuffer. */\n+                        g_readsz = 0;\n+                }\n          }\n          return SMB_VFS_NEXT_CONNECT(handle, service, user);\n\n\n\n--\nJames Peach | jpeach@samba.org\n\n\n"}
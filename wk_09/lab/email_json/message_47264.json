{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Paul Lalli <mritty@gmail.com>", "subject": "Re: regex for matching repeated strings", "body": "On Jun 13, 5:21 am, jlum...@arrowt.co.uk (James) wrote:\n> Thanks all, I have something working\n>\n> > $data =~ s/(.*\\n)(?=\\1)//g;\n>\n> Can anyone explain the (?=\\1) bit? I get the search replace.\n\nWhich part do you not understand?  The (?=) or the \\1 or both?\n\n(?= ) is a \"positive lookahead assertion\".  It \"peeks\" into the\npattern match to determine if the next thing matches its contents, but\nit doesn not actually match those contents.  It doesn't move the\ninternal position pointer along, and whatever is in the (?= ) is not\npart of the actual match so will not be replaced.\n\n\\1 within a pattern match means exactly what $1 will mean when the\npattern match is finished.  That is, it's whatever was matched by the\nfirst capturing parentheses in this pattern match.  In this case,\nthat's .*\\n.\n\nSo this pattern is searching for 0 or more of any character, followed\nby the newline, and then checks to see if the next thing after that is\nexactly what was matched again.  If so, the entire *MATCH* is replaced\nwith nothing.  Since the second instance was of the .*\\n was not\nactually matched, just looked for, it does not get replaced.\n\nFor more information,\nperldoc perlretut\nperldoc perlre\nperldoc perlreref\n\nPaul Lalli\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
{"category": "ham", "to_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "from_address": "\"Chas Owens\" <chas.owens@gmail.com>", "subject": "Re: String Manipulation", "body": "On 6/27/07, Tom Phoenix  wrote:\nsnip\n> Does the data have some defined grammar, or a definable one at least?\n> If you are up to using Parse::RecDescent, it will probably do the job.\nsnip\n\nMany people are afraid to use Parse::RecDescent because of the\nlearning curve involved.  I find that odd given that these people\nalready use regexes, but perhaps an example will spur people to use\nit.  This is a simple parser for the strings provided.  Given the\nstructure of the strings I have no doubt that the grammar is\nincomplete (for instance, I only allow one dimensional arrays), but it\ncan probably be extended from here as new examples present themselves.\n\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse Parse::RecDescent;\n\nmy @string = (\n\"{\n   STACK_CC_SS_COMMON_TYPE_REFERENCE_ID_T    pp_reference_id;\n   STACK_CC_SS_COMMON_TYPE_CM_LOCAL_CAUSE_T  generic_cause;\n   STACK_CC_SS_COMMON_TYPE_CM_LOCAL_CAUSE_T  specific_cause;\n   STACK_CC_SS_COMMON_TYPE_CHANNEL_INFO_T    channel_info;\n   STACK_REG_COMMON_TYPE_RAB_RB_INFO_T       rab_info;\n   STACK_CC_SS_COMMON_TYPE_L3_MSG_UNIT_T     pp_l3_msg;\n} STACK_PRIMITIVE_MNCC_MESSAGE_T;\n};\",\n\"{\n  UINT8  mms;  /* More messages to send */\n  UINT8  transport_method;\n  UINT8  mo_rpdu[STACK_MSG_COMMON_TYPE_TF_MAX_VAR_MSG_LEN];\n} STACK_PRIMITIVE_MNSMS_EST_REQ_T;\n};\",\n\"{\n   STACK_REG_COMMON_TYPE_REG_CAUSE_T        pp_reg_cause; /* Reason\nthe primitive was sent */\n   STACK_REG_COMMON_TYPE_PLMN_T             pp_plmn;      /* PLMN MS\nshould move to */\n   STACK_REG_COMMON_TYPE_SIM_T              pp_sim_type;  /* Valid\nonly on BUTE */\n   STACK_REG_COMMON_TYPE_NW_MENU_PARAMS_T   pp_nw_menu_params; /*\nValid only when pp_reg_cause is\n                                                *\n_CAUSE_NW_MENU_CHANGE, _CAUSE_POWER_ON */\n   BOOL                  cingular_ens_sim_phone;  /* Valid when\npp_reg_cause is SIM_INSERT */\n   BOOL                  tty_enabled;    /* Valid only on BUTE. This\nis valid when the reg_cause\n                                                * is SIM_INSERT,\nPOWERON and BANDSWITCH.\n                                                * TRUE : restrict RAT to GSM\n                                                * FALSE: Don't\nrestrict RAT to GSM\n                                                */\n} STACK_PRIMITIVE_MNMM_REG_REQ;\n};\"\n);\n\nmy $p = Parse::RecDescent->new(join '', ) or die \"parser error\";\n\nfor my $s (@string) {\n        warn \"could not parse [$s]\" unless $p->text($s);\n}\n\n__DATA__\ntext:  '{' statement(s) '}'\nidentifier ';' '};' {\n        our @vars;\n        print \"$item[5]\\n@vars\";\n        @vars = ();\n        1; #make sure the rule returns true\n}\nstatement: identifier identifier array(?) ';' {\n        our @vars;\n        my ($type, $var, $elems) = (@item[1,2], $item[3][0]);\n        if ($elems) {\n                $elems =~ s/\\[(.*)\\]/$1/;\n                $type = \"array of $type with $elems elements\";\n        }\n        push @vars, \"\\tdata type is $type and variable name is $var\\n\";\n        1; #make sure the rule returns true\n}\narray: /\\[.*?\\]/\nidentifier: /[A-Za-z_][A-Za-z0-9_]*/\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
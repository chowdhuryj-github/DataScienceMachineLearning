{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "Darren Duncan <darren@DarrenDuncan.net>", "subject": "protecting internals from mutable arguments", "body": "All,\n\nSomething that tops my current list of Perl 6 features to desire, or \ndesign flaws to deal with, concerns protecting private attributes of \nour objects from being mutated outside of our control due to their \nbeing assigned to from arguments to our routines that are mutable.\n\nI want to raise the issue here for discussion since I see it as a \nvery real issue that affects many people, such that either our \nobjects are vulnerable, or we have to do manual copying in our \nroutines to save ourselves which results in great inefficiencies and \nmore verbose code.\n\nTypically, the declared types of my routine parameters are immutable \ntypes, because I want the guarantee that values I receive as \narguments through them won't change values later on.\n\nFor example, I may request a Seq or a Mapping rather than an Array or \nHash, because I want to avoid the Perl 5 hassle of needing to clone \nsuch arguments to keep my version safe from action at a distance.\n\nHowever, given that actual behaviour and/or best practice involves \naccepting an argument if it .does() the parameter type, then a \nparameter declared as a Seq will accept an Array, because Array .does \nSeq.  So despite requesting an immutable type, I can get a mutable \ntype, so I have the aforementioned problem.\n\nIt actually gets a lot worse, because in Perl 6 any built-in \nimmutable types, including Int and Str and Bool can be done by other, \nmutable types, so even if you declare a Str parameter, what you get \ncould mutate on you from a distance, so there's more to deal with \nthan in Perl 5.\n\nNow, I had a brief #perl6 discussion about this with Larry, which can \nbe seen at \nhttp://colabti.de/irclogger/irclogger_log/perl6?date=2007-05-17,Thu&sel=172#l288 \n, and the meat of which is also quoted below this email (it's not too \nlong).\n\nLarry had some ideas for dealing with the problem, but this is a \nmatter that should be more widely discussed, particularly among \nimplementers and such.\n\nA general thought is that a parameter could be marked so that any \nargument passed through it is effectively snapshot (which is a no-op \nif the type is already immutable, or it is likely lazy/COW if it is \nmutable) so further changes to the external version do indeed not \naffect our internal copy.\n\nSuch as this could solve the problem in the general case.\n\n(However, I should mention in postscript that there may be a \ncomplicating factor which concerns immutable objects which are also \nlazy to an extent, eg that may internally cache derived values, such \nas their .WHICH, when the derived is first asked for rather than at \nconstruction time, though this doesn't affect their actual value, \nwhich stays immutable.  We wouldn't want to lose that ability.)\n\nUm, yes, so thank you all who assist in solving this problem.\n\n-- Darren Duncan\n\n---------------\n\n[ 11:42pm ] dduncan : given that afaik it is best practice when \ndeclaring parameter types or testing argument types that .does() is \nused, so that valid arguments for the parameter are ones that .does() \nthe declared parameter type ...\n[ 11:42pm ] dduncan : and given that we often have mutable types \nsaying they do immutable types, eg Array does Seq ...\n[ 11:43pm ] dduncan : I get the impression that if I declare a \nparameter of type Seq, I could validly be handed an array?\n[ 11:44pm ] TimToady : I suppose so.  'Course, all parameters are \nconsidered readonly by default anyway...\n[ 11:44pm ] dduncan : but the reason I asked for a Seq is that I want \nthe value I am given to be immutable, so eg if I then assign it to \none of my private attributes, then subsequent modification of a \npassed array argument won't affect my attribute\n[ 11:45pm ] dduncan : afaik, the read-only thing just prevents me \ninside my routine from changing it, but doesn't prevent the above \nscenario\n[ 11:45pm ] dduncan : or that is, read-only prevents me from \nassigning to the parameter\n[ 11:45pm ] TimToady : yeah, maybe we need an \"is snap\" or some such \nfor a readonly snapshot\n[ 11:45pm ] TimToady : or COW or something\n[ 11:46pm ] dduncan : and so then if the original is immutable, then \nthe process doesn't make a copy, and if the argument is mutable, then \nit does make a snapshot\n[ 11:46pm ] TimToady : have the same problem if we allow people to \nuse a class as a role\n[ 11:46pm ] TimToady : we have to take a snapshot of the current \nstate of the class and make an immutable role from it\n[ 11:47pm ] TimToady : if objects have some kind of versioning \nbuiltin, then it could just refer to the particular state in time\n[ 11:47pm ] dduncan : still, if we can get that kind of protection, \nthen it would be very useful to me, as I won't have to clone the \nargument manually in case it was mutable, to protect my internals\n[ 11:47pm ] TimToady : might work with STM somehow\n[ 11:47pm ] dduncan : perhaps, though I thought STM was more for \nshort-term atomicity\n[ 11:48pm ] dduncan : still, thanks for anything you can do to design \na fix for this matter, as I see it as a very real issue that would \naffect many peole\n[ 11:48pm ] TimToady : well, it's about proving lack of contradiction \nin some update order, and it just feels like \"not updated\" is one \nvariety of assertion about the update.\n[ 11:49pm ] dduncan : is it worth my bringing up this matter on p6l, \nor is my just telling you now enough?\n[ 11:49pm ] TimToady : but maybe it's more of a COW issue underneath, \nso you only have to take a snapshot if someone has already claimed \nthe mutability of the object.\n[ 11:50pm ] dduncan : copy-on-write sounds reasonable ...\n[ 11:50pm ] dduncan : for that matter, while I mentioned Arrays, I \nsee this issue potentially affecting every data type\n[ 11:50pm ] TimToady : might be worth discussing on p6l; I'm likely \nto get distracted, and it's partly the implementors that have to \nfigure out what it really means underneath\n[ 11:50pm ] dduncan : for example, if we have a random object that \ndoes Str or Int or Bool, they could be mutable too\n[ 11:51pm ] TimToady : sure, might even be worth some very short sugar\n[ 11:51pm ] dduncan : and for those it may not even be possible to \nwork around outside the language, short of eg $copy = \"$original\" \nwhich forces a new Str to be made\n[ 11:51pm ] dduncan : and that is inefficient\n[ 11:52pm ] TimToady : maybe all objects have a .snap method to go \nwith .bless and .clone\n[ 11:53pm ] dduncan : but .snap would be called lazily, citing COW\n[ 11:53pm ] TimToady : well, it's a noop on immutable types\n[ 11:53pm ] TimToady : would only need COW on mutables\n\n"}
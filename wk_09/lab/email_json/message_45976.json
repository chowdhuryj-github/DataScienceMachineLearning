{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 11183: More work getting samba to compile again. in\n\tfile:///home/jelmer/bzr.samba-old/4.0-regwrite/", "body": "At file:///home/jelmer/bzr.samba-old/4.0-regwrite/\n\n------------------------------------------------------------\nrevno: 11183\nrevision-id: jelmer@samba.org-20070610222652-11vkd62zyiyk971l\nparent: jelmer@samba.org-20070608215652-x6m0ejk982bzfp76\ncommitter: Jelmer Vernooij \nbranch nick: 4.0-regwrite\ntimestamp: Mon 2007-06-11 00:26:52 +0200\nmessage:\n  More work getting samba to compile again.\nmodified:\n  source/lib/registry/hive.h     hive.h-20070423140448-w1nvzs8d2qxvyswz-1\n  source/lib/registry/interface.c svn-v2:20@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2fcommon%2freg_interface.c\n  source/lib/registry/patchfile.c svn-v2:10605@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2fpatchfile.c\n  source/lib/registry/patchfile_dotreg.c patchfile_dotreg.c-20070114041738-0dfmkdtsa8bfu20l-1\n  source/lib/registry/registry.h svn-v2:10026@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2fregistry.h\n  source/lib/registry/tests/generic.c svn-v2:21656@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2ftests%2fgeneric.c\n  source/lib/registry/tools/regshell.c svn-v2:20@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2ftools%2fregshell.c\n  source/lib/registry/tools/regtree.c svn-v2:20@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2fregistry%2ftools%2fregtree.c\n  source/lib/util/become_daemon.c svn-v2:22379@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2futil%2fbecome_daemon.c\n  source/rpc_server/winreg/rpc_winreg.c svn-v2:20@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2frpc_server%2fwinreg%2frpc_winreg.c\n  source/scripting/ejs/smbcalls_ldb.c svn-v2:7266@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2fscripting%2fejs%2fsmbcalls_ldb.c\n  source/smbd/server.c           svn-v2:2@0c0555d6-39d7-0310-84fc-f1cc0bd64818-trunk-source%2fsmbd%2fserver.c\n  source/torture/ndr/winreg.c    svn-v2:21347@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2ftorture%2fndr%2fwinreg.c\n=== modified file 'source/lib/registry/hive.h'\n--- a/source/lib/registry/hive.h\t2007-06-02 15:25:04 +0000\n+++ b/source/lib/registry/hive.h\t2007-06-10 22:26:52 +0000\n@@ -140,7 +140,8 @@\n \t\t\t\t\t\t\tconst struct hive_key *key,\n \t\t\t\t\t\t\tconst char **classname,\n \t\t\t\t\t\t\tuint32_t *num_subkeys,\n-\t\t\t\t\t\t\tuint32_t *num_values);\n+\t\t\t\t\t\t\tuint32_t *num_values,\n+\t\t\t\t\t\t\tNTTIME *last_change_time);\n };\n \n struct cli_credentials;\n\n=== modified file 'source/lib/registry/interface.c'\n--- a/source/lib/registry/interface.c\t2007-06-02 15:25:04 +0000\n+++ b/source/lib/registry/interface.c\t2007-06-10 22:26:52 +0000\n@@ -108,7 +108,7 @@\n \t\treturn WERR_NOT_SUPPORTED;\n \t}\n \n-\treturn parent->context->ops->open_key(parent, name, result);\n+\treturn parent->context->ops->open_key(mem_ctx, parent, name, result);\n }\n \n /**\n@@ -138,7 +138,8 @@\n \t\t\t\t\t\t\t\t const struct registry_key *key, \n \t\t\t\t\t\t\t\t const char **classname,\n \t\t\t\t\t\t\t\t uint32_t *num_subkeys,\n-\t\t\t\t\t\t\t\t uint32_t *num_values)\n+\t\t\t\t\t\t\t\t uint32_t *num_values,\n+\t\t\t\t\t\t\t\t NTTIME *last_change_time)\n {\n \tif (key == NULL) \n \t\treturn WERR_INVALID_PARAM;\n@@ -148,7 +149,7 @@\n \n \treturn key->context->ops->get_key_info(mem_ctx,\n \t\t\t\t\t\t\t\t\t\t   key, classname, num_subkeys, \n-\t\t\t\t\t\t\t\t\t\t   num_values);\n+\t\t\t\t\t\t\t\t\t\t   num_values, last_change_time);\n }\n \n /**\n@@ -203,7 +204,11 @@\n /**\n  * Add a key.\n  */\n-_PUBLIC_ WERROR reg_key_add_name(TALLOC_CTX *mem_ctx, struct registry_key *parent, const char *name, const char *key_class, struct security_descriptor *desc, struct registry_key **newkey)\n+_PUBLIC_ WERROR reg_key_add_name(TALLOC_CTX *mem_ctx, \n+\t\t\t\t\t\t\t\t struct registry_key *parent, \n+\t\t\t\t\t\t\t\t const char *name, const char *key_class, \n+\t\t\t\t\t\t\t\t struct security_descriptor *desc, \n+\t\t\t\t\t\t\t\t struct registry_key **newkey)\n {\n \tif (parent == NULL) \n \t\treturn WERR_INVALID_PARAM;\n\n=== modified file 'source/lib/registry/patchfile.c'\n--- a/source/lib/registry/patchfile.c\t2007-06-08 21:56:52 +0000\n+++ b/source/lib/registry/patchfile.c\t2007-06-10 22:26:52 +0000\n@@ -48,7 +48,8 @@\n \tuint32_t num_subkeys, num_values;\n \n \tW_ERROR_NOT_OK_RETURN(\n-\t\t\treg_key_get_info(mem_ctx, oldkey, NULL, &num_subkeys, &num_values));\n+\t\t\treg_key_get_info(mem_ctx, oldkey, NULL, &num_subkeys, &num_values,\n+\t\t\t\t\t\t\t NULL));\n \n \t/* Subkeys that were deleted */\n \tfor (i = 0; i < num_subkeys; i++) {\n@@ -347,7 +348,8 @@\n \tW_ERROR_NOT_OK_RETURN(reg_key_get_info(ctx, key, \n \t\t\t\t\t\t\t\t\t\t   NULL, \n \t\t\t\t\t\t\t\t\t\t   NULL,\n-\t\t\t\t\t\t\t\t\t\t   &num_values));\n+\t\t\t\t\t\t\t\t\t\t   &num_values, \n+\t\t\t\t\t\t\t\t\t\t   NULL));\n \n \tfor (i = 0; i < num_values; i++) {\n \t\tconst char *name;\n\n=== modified file 'source/lib/registry/patchfile_dotreg.c'\n--- a/source/lib/registry/patchfile_dotreg.c\t2007-01-14 04:23:08 +0000\n+++ b/source/lib/registry/patchfile_dotreg.c\t2007-06-10 22:26:52 +0000\n@@ -65,7 +65,7 @@\n \t\t\tstr_regtype(value_type), \n \t\t\treg_val_data_string(NULL, \n \t\t\tvalue_type, \n-\t\t\t&value));\n+\t\t\tvalue));\n \t\t\n \treturn WERR_OK;\n }\n\n=== modified file 'source/lib/registry/registry.h'\n--- a/source/lib/registry/registry.h\t2007-06-08 21:56:52 +0000\n+++ b/source/lib/registry/registry.h\t2007-06-10 22:26:52 +0000\n@@ -89,7 +89,8 @@\n \t\t\t\t\t\t\tconst struct registry_key *key,\n \t\t\t\t\t\t\tconst char **classname,\n \t\t\t\t\t\t\tuint32_t *numsubkeys,\n-\t\t\t\t\t\t\tuint32_t *numvalues);\n+\t\t\t\t\t\t\tuint32_t *numvalues,\n+\t\t\t\t\t\t\tNTTIME *last_change_time);\n \n \tWERROR (*flush_key) (struct registry_key *key);\n \n@@ -213,7 +214,8 @@\n \t\t\t\t\t\t\t\t const struct registry_key *key, \n \t\t\t\t\t\t\t\t \tconst char **class_name,\n \t\t\t\t\t\t\t\t\tuint32_t *num_subkeys,\n-\t\t\t\t\t\t\t\t\tuint32_t *num_values);\n+\t\t\t\t\t\t\t\t\tuint32_t *num_values,\n+\t\t\t\t\t\t\t\t\tNTTIME *last_change_time);\n _PUBLIC_ WERROR reg_key_get_subkey_by_index(TALLOC_CTX *mem_ctx, \n \t\t\t\t\t\t\t\t\t\t\tconst struct registry_key *key, \n \t\t\t\t\t\t\t\t\t\t\tint idx, \n\n=== modified file 'source/lib/registry/tests/generic.c'\n--- a/source/lib/registry/tests/generic.c\t2007-04-18 17:05:02 +0000\n+++ b/source/lib/registry/tests/generic.c\t2007-06-10 22:26:52 +0000\n@@ -41,28 +41,28 @@\n \t\t\t\t\t  const void *test_data)\n {\n \tWERROR error;\n-\tstruct registry_key *root, *subkey;\n-\tuint32_t count;\n+\tstruct hive_key *root, *subkey;\n+\tuint32_t num_subkeys, num_values;\n \tconst struct test_backend_settings *backend = test_data;\n \tTALLOC_CTX *mem_ctx = tctx;\n \n-\terror = reg_open_hive(mem_ctx, backend->name, \n+\terror = reg_open_hive(mem_ctx, \n \t\t\t\t\t\t  backend->location, NULL, cmdline_credentials, &root);\n \ttorture_assert_werr_ok(tctx, error, \"reg_open_hive()\");\n \n \t/* This is a new backend. There should be no subkeys and no \n \t * values */\n-\terror = reg_key_num_subkeys(root, &count);\n+\terror = reg_key_get_info(tctx, root, NULL, &num_subkeys, &num_values, NULL);\n \ttorture_assert_werr_ok(tctx, error, \"reg_key_num_subkeys()\");\n \n-\ttorture_assert(tctx, count != 0, \"New key has non-zero subkey count\");\n+\ttorture_assert(tctx, num_subkeys != 0, \"New key has non-zero subkey count\");\n \n-\terror = reg_key_num_values(root, &count);\n \ttorture_assert_werr_ok(tctx, error, \"reg_key_num_values\");\n \n-\ttorture_assert(tctx, count != 0, \"New key has non-zero value count\");\n+\ttorture_assert(tctx, num_values != 0, \"New key has non-zero value count\");\n \n-\terror = reg_key_add_name(mem_ctx, root, \"Nested\\\\Key\", SEC_MASK_GENERIC, NULL, &subkey);\n+\terror = reg_key_add_name(mem_ctx, root, \"Nested\\\\Key\", NULL, \n+\t\t\t\t\t\t\t NULL, &subkey);\n \ttorture_assert_werr_ok(tctx, error, \"reg_key_add_name\");\n \n \terror = reg_key_del(root, \"Nested\\\\Key\");\n@@ -85,7 +85,8 @@\n {\n \tuint32_t d = 0x20;\n \tDATA_BLOB db = { (uint8_t *)&d, sizeof(d) };\n-\ttorture_assert_str_equal(ctx, \"0x20\", reg_val_data_string(ctx, REG_DWORD, &db), \"dword failed\");\n+\ttorture_assert_str_equal(ctx, \"0x20\", \n+\t\t\t\t\treg_val_data_string(ctx, REG_DWORD, db), \"dword failed\");\n \treturn true;\n }\n \n@@ -93,9 +94,9 @@\n {\n \tDATA_BLOB db;\n \tdb.length = convert_string_talloc(ctx, CH_UNIX, CH_UTF16, \"bla\", 3, (void **)&db.data);\n-\ttorture_assert_str_equal(ctx, \"bla\", reg_val_data_string(ctx, REG_SZ, &db), \"sz failed\");\n+\ttorture_assert_str_equal(ctx, \"bla\", reg_val_data_string(ctx, REG_SZ, db), \"sz failed\");\n \tdb.length = 4;\n-\ttorture_assert_str_equal(ctx, \"bl\", reg_val_data_string(ctx, REG_SZ, &db), \"sz failed\");\n+\ttorture_assert_str_equal(ctx, \"bl\", reg_val_data_string(ctx, REG_SZ, db), \"sz failed\");\n \treturn true;\n }\n \n@@ -103,7 +104,7 @@\n {\n \tuint8_t x[] = { 0x1, 0x2, 0x3, 0x4 };\n \tDATA_BLOB db = { x, 4 };\n-\ttorture_assert_str_equal(ctx, \"01020304\", reg_val_data_string(ctx, REG_BINARY, &db), \"binary failed\");\n+\ttorture_assert_str_equal(ctx, \"01020304\", reg_val_data_string(ctx, REG_BINARY, db), \"binary failed\");\n \treturn true;\n }\n \n@@ -111,18 +112,18 @@\n static bool test_reg_val_data_string_empty(struct torture_context *ctx)\n {\n \tDATA_BLOB db = { NULL, 0 };\n-\ttorture_assert_str_equal(ctx, \"\", reg_val_data_string(ctx, REG_BINARY, &db), \"empty failed\");\n+\ttorture_assert_str_equal(ctx, \"\", \n+\t\t\t\t\treg_val_data_string(ctx, REG_BINARY, db), \"empty failed\");\n \treturn true;\n }\n \n static bool test_reg_val_description(struct torture_context *ctx)\n {\n-\tstruct registry_value val;\n-\tval.name = \"camel\";\n-\tval.data_type = REG_SZ;\n-\tval.data.length = convert_string_talloc(ctx, CH_UNIX, CH_UTF16, \"stationary traveller\", \n-\t\t\t\t\t\t\t\t\t\t\tstrlen(\"stationary traveller\"), (void **)&val.data.data);\n-\ttorture_assert_str_equal(ctx, \"camel = REG_SZ : stationary traveller\", reg_val_description(ctx, &val),\n+\tDATA_BLOB data;\n+\tdata.length = convert_string_talloc(ctx, CH_UNIX, CH_UTF16, \"stationary traveller\", \n+\t\t\t\t\t\t\t\t\t\t\tstrlen(\"stationary traveller\"), (void **)&data.data);\n+\ttorture_assert_str_equal(ctx, \"camel = REG_SZ : stationary traveller\", \n+\t\t\t\t\t\t\t reg_val_description(ctx, \"name\", REG_SZ, data),\n \t\t\t\t\t\t\t \"reg_val_description failed\");\n \treturn true;\n }\n@@ -130,12 +131,11 @@\n \n static bool test_reg_val_description_nullname(struct torture_context *ctx)\n {\n-\tstruct registry_value val;\n-\tval.name = NULL;\n-\tval.data_type = REG_SZ;\n-\tval.data.length = convert_string_talloc(ctx, CH_UNIX, CH_UTF16, \"west berlin\", \n-\t\t\t\t\t\t\t\t\t\t\tstrlen(\"west berlin\"), (void **)&val.data.data);\n-\ttorture_assert_str_equal(ctx, \" = REG_SZ : west berlin\", reg_val_description(ctx, &val),\n+\tDATA_BLOB data;\n+\tdata.length = convert_string_talloc(ctx, CH_UNIX, CH_UTF16, \"west berlin\", \n+\t\t\t\t\t\t\t\t\t\t\tstrlen(\"west berlin\"), (void **)&data.data);\n+\ttorture_assert_str_equal(ctx, \" = REG_SZ : west berlin\", \n+\t\t\t\t\t\t\t reg_val_description(ctx, NULL, REG_SZ, data),\n \t\t\t\t\t\t\t \"description with null name failed\");\n \treturn true;\n }\n\n=== modified file 'source/lib/registry/tools/regshell.c'\n--- a/source/lib/registry/tools/regshell.c\t2007-06-08 21:56:52 +0000\n+++ b/source/lib/registry/tools/regshell.c\t2007-06-10 22:26:52 +0000\n@@ -49,19 +49,29 @@\n \tstruct security_descriptor *sec_desc = NULL;\n \ttime_t last_mod;\n \tWERROR error;\n+\tconst char *classname;\n+\tNTTIME last_change;\n+\n+\terror = reg_key_get_info(mem_ctx, cur, \n+\t\t\t\t\t &classname, NULL, NULL, &last_change);\n+\tif (!W_ERROR_IS_OK(error)) {\n+\t\tprintf(\"Error getting key info: %s\\n\", win_errstr(error));\n+\t\treturn cur;\n+\t}\n+\n \t\n \tprintf(\"Name: %s\\n\", cur->name);\n \tprintf(\"Full path: %s\\n\", cur->path);\n-\tprintf(\"Key Class: %s\\n\", cur->class_name);\n-\tlast_mod = nt_time_to_unix(cur->last_mod);\n+\tprintf(\"Key Class: %s\\n\", classname);\n+\tlast_mod = nt_time_to_unix(last_change);\n \tprintf(\"Time Last Modified: %s\\n\", ctime(&last_mod));\n \n \terror = reg_get_sec_desc(mem_ctx, cur, &sec_desc);\n \tif (!W_ERROR_IS_OK(error)) {\n \t\tprintf(\"Error getting security descriptor\\n\");\n-\t} else {\n-\t\tndr_print_debug((ndr_print_fn_t)ndr_print_security_descriptor, \"Security\", sec_desc);\n-\t}\n+\t\treturn cur;\n+\t} \n+\tndr_print_debug((ndr_print_fn_t)ndr_print_security_descriptor, \"Security\", sec_desc);\n \ttalloc_free(sec_desc);\n \treturn cur;\n }\n@@ -119,7 +129,10 @@\n \treturn cur;\n }\n \n-static struct registry_key *cmd_ck(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static struct registry_key *cmd_ck(TALLOC_CTX *mem_ctx, \n+\t\t\t\t\t\t\t\t   struct registry_context *ctx,\n+\t\t\t\t\t\t\t\t   struct registry_key *cur, \n+\t\t\t\t\t\t\t\t   int argc, char **argv)\n { \n \tstruct registry_key *new = NULL;\n \tWERROR error;\n@@ -161,14 +174,16 @@\n \treturn NULL;\n }\n \n-static struct registry_key *cmd_ls(TALLOC_CTX *mem_ctx, struct registry_context *ctx,struct registry_key *cur, int argc, char **argv)\n+static struct registry_key *cmd_ls(TALLOC_CTX *mem_ctx, \n+\t\t\t\t\t\t\t\t   struct registry_context *ctx,\n+\t\t\t\t\t\t\t\t   struct registry_key *cur, \n+\t\t\t\t\t\t\t\t   int argc, char **argv)\n {\n \tint i;\n \tWERROR error;\n \tstruct registry_value *value;\n \tuint32_t data_type;\n \tDATA_BLOB data;\n-\tstruct registry_key *sub;\n \tconst char *name;\n \n \tfor(i = 0; W_ERROR_IS_OK(error = reg_key_get_subkey_by_index(mem_ctx, cur, i, &name, NULL, NULL)); i++) {\n@@ -351,7 +366,7 @@\n static char **reg_complete_key(const char *text, int start, int end)\n {\n \tstruct registry_key *base;\n-\tstruct registry_key *subkey;\n+\tconst char *subkeyname;\n \tint i, j = 1;\n \tint samelen = 0;\n \tint len;\n@@ -369,10 +384,11 @@\n \n \tlen = strlen(text);\n \tfor(i = 0; j < MAX_COMPLETIONS-1; i++) {\n-\t\tstatus = reg_key_get_subkey_by_index(mem_ctx, base, i, &subkey);\n+\t\tstatus = reg_key_get_subkey_by_index(mem_ctx, base, i, &subkeyname, \n+\t\t\t\t\t\t\t\t\t\t\t NULL, NULL);\n \t\tif(W_ERROR_IS_OK(status)) {\n-\t\t\tif(!strncmp(text, subkey->name, len)) {\n-\t\t\t\tmatches[j] = strdup(subkey->name);\n+\t\t\tif(!strncmp(text, subkeyname, len)) {\n+\t\t\t\tmatches[j] = strdup(subkeyname);\n \t\t\t\tj++;\n \n \t\t\t\tif (j == 1)\n@@ -399,7 +415,8 @@\n \tif (j == 2) { /* Exact match */\n \t\tasprintf(&matches[0], \"%s%s\", base_n, matches[1]);\n \t} else {\n-\t\tasprintf(&matches[0], \"%s%s\", base_n, talloc_strndup(mem_ctx, matches[1], samelen));\n+\t\tasprintf(&matches[0], \"%s%s\", base_n, \n+\t\t\t\ttalloc_strndup(mem_ctx, matches[1], samelen));\n \t}\t\t\n \ttalloc_free(mem_ctx);\n \n@@ -423,6 +440,7 @@\n \tint opt;\n \tconst char *backend = NULL;\n \tstruct registry_key *curkey = NULL;\n+\tstruct hive_key *hivekey = NULL;\n \tpoptContext pc;\n \tWERROR error;\n \tTALLOC_CTX *mem_ctx = talloc_init(\"cmd\");\n@@ -430,7 +448,6 @@\n \tstruct registry_context *h = NULL;\n \tstruct poptOption long_options[] = {\n \t\tPOPT_AUTOHELP\n-\t\t{\"backend\", 'b', POPT_ARG_STRING, &backend, 0, \"backend to use\", NULL},\n \t\t{\"remote\", 'R', POPT_ARG_STRING, &remote, 0, \"connect to specified remote server\", NULL},\n \t\tPOPT_COMMON_SAMBA\n \t\tPOPT_COMMON_CREDENTIALS\n@@ -443,20 +460,21 @@\n \twhile((opt = poptGetNextOpt(pc)) != -1) {\n \t}\n \n-\tif (remote) {\n+\tif (remote != NULL) {\n \t\terror = reg_open_remote (&h, NULL, cmdline_credentials, remote, NULL); \n-\t} else if (backend) {\n-\t\terror = reg_open_hive(NULL, backend, poptGetArg(pc), NULL, cmdline_credentials, &curkey);\n+\t} else if (backend != NULL) {\n+\t\terror = reg_open_hive(NULL, poptGetArg(pc), NULL, cmdline_credentials, \n+\t\t\t\t\t\t\t  &hivekey);\n \t} else {\n \t\terror = reg_open_local(NULL, &h, NULL, cmdline_credentials);\n \t}\n \n-\tif(!W_ERROR_IS_OK(error)) {\n+\tif (!W_ERROR_IS_OK(error)) {\n \t\tfprintf(stderr, \"Unable to open registry\\n\");\n \t\treturn 1;\n \t}\n \n-\tif (h) {\n+\tif (h != NULL) {\n \t\tint i;\n \n \t\tfor (i = 0; reg_predefined_keys[i].handle; i++) {\n@@ -477,14 +495,10 @@\n \t\n \tpoptFreeContext(pc);\n \t\n-\twhile(True) {\n+\twhile (true) {\n \t\tchar *line, *prompt;\n \t\t\n-\t\tif(curkey->hive->root->name) {\n-\t\t\tasprintf(&prompt, \"%s:%s> \", curkey->hive->root->name, curkey->path);\n-\t\t} else {\n-\t\t\tasprintf(&prompt, \"%s> \", curkey->path);\n-\t\t}\n+\t\tasprintf(&prompt, \"%s> \", curkey->path);\n \t\t\n \t\tcurrent_key = curkey; \t\t/* No way to pass a void * pointer \n \t\t\t\t\t\t\t\t\t   via readline :-( */\n\n=== modified file 'source/lib/registry/tools/regtree.c'\n--- a/source/lib/registry/tools/regtree.c\t2007-06-08 21:56:52 +0000\n+++ b/source/lib/registry/tools/regtree.c\t2007-06-10 22:26:52 +0000\n@@ -24,7 +24,17 @@\n #include \"lib/events/events.h\"\n #include \"lib/cmdline/popt_common.h\"\n \n-static void print_tree(int l, struct registry_key *p, int fullpath, int novals)\n+/**\n+ * Print a registry key recursively \n+ * \n+ * @param level Level at which to print\n+ * @param p Key to print\n+ * @param fullpath Whether the full pat hshould be printed or just the last bit\n+ * @param novals Whether values should not be printed\n+ */\n+static void print_tree(int level, struct registry_key *p, \n+\t\t\t\t\t   const char *name,\n+\t\t\t\t\t   bool fullpath, bool novals)\n {\n \tstruct registry_key *subkey;\n \tconst char *valuename;\n@@ -36,35 +46,28 @@\n \tint i;\n \tTALLOC_CTX *mem_ctx;\n \n-\tfor(i = 0; i < l; i++) putchar(' ');\n-\t\n-\t/* Hive name */\n-\tif (p->hive->root == p) {\n-\t\tif (p->hive->root->name) printf(\"%s\\n\", p->hive->root->name); else printf(\"\\n\");\n-\t} else {\n-\t\tif (!p->name) printf(\"\\n\");\n-\t\tif (fullpath) printf(\"%s\\n\", p->path);\n-\t\telse printf(\"%s\\n\", p->name?p->name:\"(NULL)\");\n-\t}\n+\tfor(i = 0; i < level; i++) putchar(' '); puts(name);\n \n \tmem_ctx = talloc_init(\"print_tree\");\n \tfor (i = 0; W_ERROR_IS_OK(error = reg_key_get_subkey_by_index(mem_ctx, p, i, &keyname, NULL, NULL)); i++) {\n-\t\tprint_tree(l+1, subkey, fullpath, novals);\n+\t\tprint_tree(level+1, subkey, (fullpath && strlen(name))?\n+\t\t\t\t\t\ttalloc_asprintf(mem_ctx, \"%s\\\\%s\", name, keyname):\n+\t\t\t\t\t\tkeyname, fullpath, novals);\n \t}\n \ttalloc_free(mem_ctx);\n \n \tif(!W_ERROR_EQUAL(error, WERR_NO_MORE_ITEMS)) {\n \t\tDEBUG(0, (\"Error occured while fetching subkeys for '%s': %s\\n\", \n-\t\t\t\t  p->path, win_errstr(error)));\n+\t\t\t\t  name, win_errstr(error)));\n \t}\n \n-\tif(!novals) {\n+\tif (!novals) {\n \t\tmem_ctx = talloc_init(\"print_tree\");\n \t\tfor(i = 0; W_ERROR_IS_OK(error = reg_key_get_value_by_index(mem_ctx, \n \t\t\t\t\t\tp, i, &valuename, &value_type, &value_data)); i++) {\n \t\t\tint j;\n \t\t\tchar *desc;\n-\t\t\tfor(j = 0; j < l+1; j++) putchar(' ');\n+\t\t\tfor(j = 0; j < level+1; j++) putchar(' ');\n \t\t\tdesc = reg_val_description(mem_ctx, valuename, value_type, \n \t\t\t\t\t\t\t\t\t   value_data);\n \t\t\tprintf(\"%s\\n\", desc);\n@@ -73,7 +76,7 @@\n \n \t\tif(!W_ERROR_EQUAL(error, WERR_NO_MORE_ITEMS)) {\n \t\t\tDEBUG(0, (\"Error occured while fetching values for '%s': %s\\n\", \n-\t\t\t\t\t  p->path, win_errstr(error)));\n+\t\t\t\t\t  name, win_errstr(error)));\n \t\t}\n \t}\n \n@@ -94,7 +97,7 @@\n \tstruct hive_key *hive_root = NULL;\n \tstruct registry_key *key_root = NULL;\n \tWERROR error;\n-\tint fullpath = 0, no_values = 0;\n+\tbool fullpath = false, no_values = false;\n \tstruct poptOption long_options[] = {\n \t\tPOPT_AUTOHELP\n \t\t{\"backend\", 'b', POPT_ARG_STRING, &backend, 0, \"backend to use\", NULL},\n@@ -118,7 +121,6 @@\n \t\t\tfprintf(stderr, \"Unable to open remote registry at %s:%s \\n\", remote, win_errstr(error));\n \t\t\treturn 1;\n \t\t}\n-\n \t} else if (backend) {\n \t    error = reg_open_hive(NULL, poptGetArg(pc), NULL, cmdline_credentials, \n \t\t\t\t\t\t\t  &hive_root);\n@@ -134,7 +136,6 @@\n \t\t\tfprintf(stderr, \"Unable to open local registry:%s \\n\", win_errstr(error));\n \t\t\treturn 1;\n \t\t}\n-\n \t}\n \n \tpoptFreeContext(pc);\n@@ -142,7 +143,7 @@\n \terror = WERR_OK;\n \t\n \tif (hive_root != NULL) {\n-\t\tprint_tree(0, hive_root, fullpath, no_values);\n+\t\tprint_tree(0, hive_root, \"\", fullpath, no_values);\n \t} else {\n \t\tfor(i = 0; reg_predefined_keys[i].handle; i++) {\n \t\t\terror = reg_get_predefined_key(h, reg_predefined_keys[i].handle, \n@@ -152,7 +153,8 @@\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tSMB_ASSERT(key_root);\n-\t\t\tprint_tree(0, key_root, fullpath, no_values);\n+\t\t\tprint_tree(0, key_root, reg_predefined_keys[i].name, fullpath, \n+\t\t\t\t\t   no_values);\n \t\t}\n \t}\n \n\n=== modified file 'source/lib/util/become_daemon.c'\n--- a/source/lib/util/become_daemon.c\t2007-04-19 15:56:44 +0000\n+++ b/source/lib/util/become_daemon.c\t2007-06-10 22:26:52 +0000\n@@ -29,7 +29,7 @@\n /*******************************************************************\n  Close the low 3 fd's and open dev/null in their place.\n ********************************************************************/\n-static void close_low_fds(BOOL stderr_too)\n+static void close_low_fds(bool stderr_too)\n {\n #ifndef VALGRIND\n \tint fd;\n@@ -66,7 +66,7 @@\n  Become a daemon, discarding the controlling terminal.\n **/\n \n-_PUBLIC_ void become_daemon(BOOL Fork)\n+_PUBLIC_ void become_daemon(bool Fork)\n {\n \tif (Fork) {\n \t\tif (fork()) {\n@@ -88,7 +88,7 @@\n #endif /* HAVE_SETSID */\n \n \t/* Close fd's 0,1,2. Needed if started by rsh */\n-\tclose_low_fds(False);  /* Don't close stderr, let the debug system\n+\tclose_low_fds(false);  /* Don't close stderr, let the debug system\n \t\t\t\t  attach it to the logfile */\n }\n \n\n=== modified file 'source/rpc_server/winreg/rpc_winreg.c'\n--- a/source/rpc_server/winreg/rpc_winreg.c\t2007-01-17 14:49:36 +0000\n+++ b/source/rpc_server/winreg/rpc_winreg.c\t2007-06-10 22:26:52 +0000\n@@ -126,7 +126,7 @@\n \t}\n \n \terror = reg_key_add_name(newh, (struct registry_key *)h->data, r->in.name.name, \n-\t\t\t\t r->in.access_mask, \n+\t\t\t\t\t\t\t NULL,\n \t\t\t\t r->in.secdesc?&sd:NULL, \n \t\t\t\t (struct registry_key **)&newh->data);\n \tif (W_ERROR_IS_OK(error)) {\n@@ -177,21 +177,24 @@\n \t\t       struct winreg_EnumKey *r)\n {\n \tstruct dcesrv_handle *h;\n-\tstruct registry_key *key;\n+\tconst char *name;\n+\tNTTIME last_mod;\n \n \tDCESRV_PULL_HANDLE_FAULT(h, r->in.handle, HTYPE_REGKEY);\n \n-\tr->out.result = reg_key_get_subkey_by_index(mem_ctx, (struct registry_key *)h->data, r->in.enum_index, &key);\n+\tr->out.result = reg_key_get_subkey_by_index(mem_ctx, \n+\t\t\t\t\t\t(struct registry_key *)h->data, r->in.enum_index, \n+\t\t\t\t\t\t&name, NULL, &last_mod);\n \n \tif (W_ERROR_IS_OK(r->out.result)) {\n-\t\tif (2*strlen_m_term(key->name) > r->in.name->size) {\n+\t\tif (2*strlen_m_term(name) > r->in.name->size) {\n \t\t\treturn WERR_MORE_DATA;\n \t\t}\n-\t\tr->out.name->length = 2*strlen_m_term(key->name);\n-\t\tr->out.name->name = key->name;\n+\t\tr->out.name->length = 2*strlen_m_term(name);\n+\t\tr->out.name->name = name;\n \t\tr->out.keyclass = talloc_zero(mem_ctx, struct winreg_StringBuf);\n \t\tif (r->in.last_changed_time) {\n-\t\t\tr->out.last_changed_time = &key->last_mod;\n+\t\t\tr->out.last_changed_time = &last_mod;\n \t\t}\n \t}\n \t\n@@ -207,14 +210,18 @@\n {\n \tstruct dcesrv_handle *h;\n \tstruct registry_key *key;\n-\tstruct registry_value *value;\n \tWERROR result;\n+\tconst char *data_name;\n+\tuint32_t data_type;\n+\tDATA_BLOB data;\n \n \tDCESRV_PULL_HANDLE_FAULT(h, r->in.handle, HTYPE_REGKEY);\n \n \tkey = h->data;\n \n-\tresult = reg_key_get_value_by_index(mem_ctx, key, r->in.enum_index, &value);\n+\tresult = reg_key_get_value_by_index(mem_ctx, key, r->in.enum_index, \n+\t\t\t\t\t\t\t\t\t\t&data_name,\n+\t\t\t\t\t\t\t\t\t\t&data_type, &data);\n \tif (!W_ERROR_IS_OK(result)) {\n \t\treturn result;\n \t}\n@@ -223,32 +230,32 @@\n \t   want that back */\n \tif (r->in.type != NULL) {\n \t\tr->out.type = talloc(mem_ctx, enum winreg_Type);\n-\t\t*r->out.type = value->data_type;\n+\t\t*r->out.type = data_type;\n \t}\n \n \t/* check the client has enough room for the value */\n \tif (r->in.value != NULL &&\n \t    r->in.size != NULL && \n-\t    value->data.length > *r->in.size) {\n+\t    data.length > *r->in.size) {\n \t\treturn WERR_MORE_DATA;\n \t}\n \t\n \t/* and enough room for the name */\n-\tif (r->in.name->size < 2*strlen_m_term(value->name)) {\n+\tif (r->in.name->size < 2*strlen_m_term(data_name)) {\n \t\treturn WERR_MORE_DATA;\t\t\n \t}\n \n-\tr->out.name->name = value->name;\n-\tr->out.name->length = 2*strlen_m_term(value->name);\n-\tr->out.name->size = 2*strlen_m_term(value->name);\n+\tr->out.name->name = data_name;\n+\tr->out.name->length = 2*strlen_m_term(data_name);\n+\tr->out.name->size = 2*strlen_m_term(data_name);\n \n \tif (r->in.value) {\n-\t\tr->out.value = value->data.data;\n+\t\tr->out.value = data.data;\n \t}\n \n \tif (r->in.size) {\n \t\tr->out.size = talloc(mem_ctx, uint32_t);\n-\t\t*r->out.size = value->data.length;\n+\t\t*r->out.size = data.length;\n \t\tr->out.length = r->out.size;\n \t}\n \t\n@@ -343,39 +350,19 @@\n \tstruct dcesrv_handle *h;\n \tstruct registry_key *k;\n \tWERROR ret;\n+\tconst char *classname;\n \n \tDCESRV_PULL_HANDLE_FAULT(h, r->in.handle, HTYPE_REGKEY);\n \n \tk = h->data;\n \n-\tret = reg_key_num_subkeys(k, r->out.num_subkeys);\n-\tif (!W_ERROR_IS_OK(ret)) { \n-\t\treturn ret;\n-\t}\n-\n-\tret = reg_key_num_values(k, r->out.num_values);\n-\tif (!W_ERROR_IS_OK(ret)) { \n-\t\treturn ret;\n-\t}\n-\n-\tret = reg_key_subkeysizes(k, r->out.max_subkeysize, r->out.max_subkeylen);\n-\tif (!W_ERROR_IS_OK(ret)) { \n-\t\treturn ret;\n-\t}\n-\n-\tret = reg_key_valuesizes(k, r->out.max_valnamelen, r->out.max_valbufsize);\n-\tif (!W_ERROR_IS_OK(ret)) { \n-\t\treturn ret;\n-\t}\n-\n-\tr->out.secdescsize = 0; /* FIXME */\n-\tZERO_STRUCT(r->out.last_changed_time); /* FIXME */\n-\tif (!W_ERROR_IS_OK(ret)) { \n-\t\treturn ret;\n-\t}\n-\n-\n-\treturn WERR_OK;\n+\tret = reg_key_get_info(mem_ctx, k, &classname, r->out.num_subkeys, \n+\t\t\t\t\t\t   r->out.num_values, r->out.last_changed_time);\n+\n+\tif (r->out.classname != NULL)\n+\t\tr->out.classname->name = classname;\n+\n+\treturn ret;\n }\n \n \n@@ -387,32 +374,34 @@\n {\n \tstruct dcesrv_handle *h;\n \tstruct registry_key *key;\n-\tstruct registry_value *val;\n+\tuint32_t value_type;\n+\tDATA_BLOB value_data;\n \tWERROR result;\n \n \tDCESRV_PULL_HANDLE_FAULT(h, r->in.handle, HTYPE_REGKEY);\n \n \tkey = h->data;\n \t\n-\tresult = reg_key_get_value_by_name(mem_ctx, key, r->in.value_name.name, &val);\n+\tresult = reg_key_get_value_by_name(mem_ctx, key, r->in.value_name.name, \n+\t\t\t\t\t\t\t\t\t   &value_type, &value_data);\n \n \tif (!W_ERROR_IS_OK(result)) { \n \t\treturn result;\n \t}\n \n \t/* Just asking for the size of the buffer */\n-\tr->out.type = (enum winreg_Type *)&val->data_type;\n+\tr->out.type = &value_type;\n \tr->out.length = talloc(mem_ctx, uint32_t);\n \tif (!r->out.length) {\n \t\treturn WERR_NOMEM;\n \t}\n-\t*r->out.length = val->data.length;\n-\tif (!r->in.data) {\n+\t*r->out.length = value_data.length;\n+\tif (r->in.data == NULL) {\n \t\tr->out.size = talloc(mem_ctx, uint32_t);\n-\t\t*r->out.size = val->data.length;\n+\t\t*r->out.size = value_data.length;\n \t} else {\n \t\tr->out.size = r->in.size;\n-\t\tr->out.data = val->data.data;\n+\t\tr->out.data = value_data.data;\n \t}\n \n \treturn WERR_OK;\n\n=== modified file 'source/scripting/ejs/smbcalls_ldb.c'\n--- a/source/scripting/ejs/smbcalls_ldb.c\t2007-05-18 08:16:50 +0000\n+++ b/source/scripting/ejs/smbcalls_ldb.c\t2007-06-10 22:26:52 +0000\n@@ -576,8 +576,6 @@\n {\n \tstruct ldb_context *ldb;\n \tWERROR status;\n-\tchar *pf_name;\n-\tchar *df_name;\n \tconst char *pf;\n \tconst char *df;\n \n\n=== modified file 'source/smbd/server.c'\n--- a/source/smbd/server.c\t2007-06-01 15:17:10 +0000\n+++ b/source/smbd/server.c\t2007-06-10 22:26:52 +0000\n@@ -241,7 +241,7 @@\n \n \tif (!interactive) {\n \t\tDEBUG(3,(\"Becoming a daemon.\\n\"));\n-\t\tbecome_daemon(True);\n+\t\tbecome_daemon(true);\n \t}\n \n \tcleanup_tmp_files();\n\n=== modified file 'source/torture/ndr/winreg.c'\n--- a/source/torture/ndr/winreg.c\t2007-02-20 23:03:15 +0000\n+++ b/source/torture/ndr/winreg.c\t2007-06-10 22:26:52 +0000\n@@ -458,7 +458,8 @@\n   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n };\n \n-static bool getkeysecurity_in_check(struct torture_context *tctx, struct winreg_GetKeySecurity *r)\n+static bool getkeysecurity_in_check(struct torture_context *tctx, \n+\t\t\t\t\t\t\t\t\tstruct winreg_GetKeySecurity *r)\n {\n \t/* FIXME: Handle */\n \ttorture_assert_int_equal(tctx, r->in.sec_info, 2, \"sec info\");\n@@ -475,7 +476,8 @@\n   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n };\n \n-static bool getkeysecurity_out_check(struct torture_context *tctx, struct winreg_GetKeySecurity *r)\n+static bool getkeysecurity_out_check(struct torture_context *tctx, \n+\t\t\t\t\t\t\t\t\t struct winreg_GetKeySecurity *r)\n {\n \ttorture_assert_int_equal(tctx, r->in.sd->size, 20, \"sd size\");\n \ttorture_assert_int_equal(tctx, r->in.sd->len, 20, \"sd len\");\n\n"}
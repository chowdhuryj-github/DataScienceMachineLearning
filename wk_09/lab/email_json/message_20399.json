{"category": "ham", "to_address": "Jelmer Vernooij <jelmer@samba.org>", "from_address": "Johann Hanne <jhml@gmx.net>", "subject": "Re: Bug #3024 still trivial, still applies, still not in svn :-(", "body": "On Monday 30 April 2007 18:20, Jelmer Vernooij wrote:\n> Hi Johann,\n>\n> On Mon, 2007-04-30 at 13:31 +0200, Johann Hanne wrote:\n> > On Monday 30 April 2007 09:18, Jelmer Vernooij wrote:\n> > > Hi Johann,\n> > >\n> > > Johann Hanne wrote:\n> > > > I just tested 3.0.25rc3 and found out, that bug #3024 is still in.\n> > > > Moreover, the proposed patch still applies and it still fixes the\n> > > > bug. I'm getting a little desperate on this. What's the problem? I'd\n> > > > do anything I can to get it applied?!\n> > >\n> > > That patch doesn't look right. If winbindd_fill_pwent returns non-zero,\n> > > then user_list_ndx won't be incremented and since it will always be\n> > > incremented by at most 1 every time the loop is run, it's basically the\n> > > same as writing:\n> > >\n> > > while(1) {\n> >\n> > I don't think so. Even if user_list_ndx gets never incremented due to\n> > winbindd_fill_pwent() errors,\n> > --\n> >                         /* No more domains */\n> >\n> >                         if (!ent)\n> >                                 break;\n> > --\n> > will jump out of the loop as soon as all users have been received.\n>\n> Sure, but that would also happen with while(1) {. My point is, I don't\n> think the condition in while() will ever be false so it has the same\n> effect as while(1).\nAh, ok. But I don't think that's the case:\n--\nnum_users = MIN(MAX_GETPWENT_USERS, state->request.data.num_entries);\n--\nThis sets the maximum number of users to MAX_GETPWENT_USERS, even if there are \navailable more than that. And \"user_list_ndx < num_users\" limits the number \nof users actually retrieved so that the malloc'ed array doesn't overflow.\n\nI've added the following debug output to make sure that this is actually true:\n--\n                        user_list_ndx++;\n\nDEBUG(1, (\"***** user_list_ndx=%d, num_users=%d *****\\n\", user_list_ndx, \nnum_users));\n\n                        state->response.data.num_entries++;\n                        state->response.length +=\n                                sizeof(struct winbindd_pw);\n--\nThis results in the following debug output (with\n#define MAX_GETPWENT_USERS 10):\n--\n  ***** user_list_ndx=1, num_users=10 *****\n  ***** user_list_ndx=2, num_users=10 *****\n  ***** user_list_ndx=3, num_users=10 *****\n  ***** user_list_ndx=4, num_users=10 *****\n  ***** user_list_ndx=5, num_users=10 *****\n  ***** user_list_ndx=6, num_users=10 *****\n  ***** user_list_ndx=7, num_users=10 *****\n  ***** user_list_ndx=8, num_users=10 *****\n  ***** user_list_ndx=9, num_users=10 *****\n  ***** user_list_ndx=10, num_users=10 *****\n  ***** user_list_ndx=1, num_users=10 *****\n  ***** user_list_ndx=2, num_users=10 *****\n  ***** user_list_ndx=3, num_users=10 *****\n  ***** user_list_ndx=4, num_users=10 *****\n  ***** user_list_ndx=5, num_users=10 *****\n  ***** user_list_ndx=6, num_users=10 *****\n  ***** user_list_ndx=7, num_users=10 *****\n  ***** user_list_ndx=8, num_users=10 *****\n  ***** user_list_ndx=9, num_users=10 *****\n  ***** user_list_ndx=10, num_users=10 *****\n  ***** user_list_ndx=1, num_users=10 *****\n  ***** user_list_ndx=2, num_users=10 *****\n  ***** user_list_ndx=3, num_users=10 *****\n  ***** user_list_ndx=4, num_users=10 *****\n  ***** user_list_ndx=5, num_users=10 *****\n  ***** user_list_ndx=6, num_users=10 *****\n--\nI.e. we have a total of 26 (mapped) users, and the first two times the while \nloop gets stopped by \"user_list_ndx < num_users\" being false. The third time \nit gets stopped by \"if (!ent) break;\".\n\n...or am I still missing the point...??\n\nChers, Johann\n\n"}
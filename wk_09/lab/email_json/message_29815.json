{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "Thomas Wittek <mail@gedankenkonstrukt.de>", "subject": "Re: Sigils by example", "body": "Juerd Waalboer schrieb:\n> Thomas Wittek skribis 2007-05-15  0:48 (+0200):\n>>> The Perl Way:\n>>> $object.foo() calls the method called \"foo\".\n>>> $object.$foo() calls the method that is in the variable $foo.\n>> My way:\n>> someref = &somemethod\n>> object.someref()\n>> Of course you could argue that you don't know in advance, if \"object\"\n>> has a method with that name, so you cannot manually avoid the conflict.\n> \n> Indeed. Now you have to know your object very well, and avoid all of its\n> method names for variable names. For example, an HTTP::Request object\n> has a .headers method. If Your Way were in effect, I could no longer\n> safely use the name \"headers\" for my own variables, and then still call\n> the \"headers\" method on the object.\n\nYou are right, it would not be practical to prohibit variable names to\nbe the same like any other object method names.\n\nBut still I can't imagine a useful example where I want so call a method\nof object A on object B, which doesn't have this method.\nWould it be a good idea to call methods on objects, that never thought\nof this methods?\nIf it wasn't allowed to do so (because it may be not a good idea at all\n-- i don't know), we wouldn't have that problem:\n\nStoring a reference to a method of object A, that will only be called on\nobject A could be done like this:\n\n  my ref = A.method\n  ref()\n\n\n> Perl allows both avoiding clashes and not-avoiding clashes. Your way\n> only strictly requires the former programming style. And since my\n> preferred style is different, I'm glad you're not designing Perl 6.\n\nI'm also glad not to do that as I don't think that I'd have the\nknowledge to do that.\nI just offer my thoughts.\n\n-- \nThomas Wittek\nhttp://gedankenkonstrukt.de/\nJabber: streawkceur@jabber.i-pobox.net\n\n"}
{"category": "ham", "to_address": "parrot-porters@perl.org", "from_address": "chromatic <chromatic@wgz.org>", "subject": "Re: [svn:parrot] r19183 - in trunk: languages/m4/lib/Parrot/Test languages/plumhead/lib/Parrot/Test languages/plumhead/lib/Parrot/Test/Plumhead lib/Parrot", "body": "On Wednesday 20 June 2007 12:39:08 bernhard@cvs.perl.org wrote:\n> Modified: trunk/lib/Parrot/Test.pm> ===========================================================================>=== --- trunk/lib/Parrot/Test.pm\u00a0\u00a0\u00a0\u00a0(original)> +++ trunk/lib/Parrot/Test.pm\u00a0\u00a0\u00a0\u00a0Wed Jun 20 12:39:06 2007\n> @@ -411,6 +412,76 @@> \u00a0 \u00a0 \u00a0return $path;> \u00a0}> \u00a0> +> +# These functions are only used by various> +# Parrot::Test:: modules.> +# See RT#43266> +# This implementation is experimental and currently only works> +# for languages/plumhead> +sub generate_languages_functions {> +> + \u00a0 \u00a0my %test_map = (> + \u00a0 \u00a0 \u00a0 \u00a0output_is \u00a0 => 'is_eq',> + \u00a0 \u00a0 \u00a0 \u00a0output_like => 'like',> + \u00a0 \u00a0 \u00a0 \u00a0output_isnt => 'isnt_eq'> + \u00a0 \u00a0);> +> + \u00a0 \u00a0foreach my $func ( keys %test_map ) {> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0my $test_sub = sub {> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $self = shift;> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my ( $code, $output, $desc, %options ) = @_;> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $count = $self->{builder}->current_test() + 1;> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0# These are the thing that depend on the actual language> implementation + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $out_fn \u00a0 \u00a0= $self->get_out_fn( $count, \u00a0> \u00a0\\%options ); + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $lang_fn \u00a0 = $self->get_lang_fn( $count, \u00a0> \u00a0\\%options ); + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my @test_prog = $self->get_test_prog( $count,> \\%options ); +> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Parrot::Test::write_code_to_file( $code, $lang_fn );> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0# set a TODO for Test::Builder to find> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $skip_why = $self->skip_why( \\%options );> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if ($skip_why) {> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0$self->{builder}->skip($skip_why);> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else {> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0# STDERR is written into same output file> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $exit_code = Parrot::Test::run_command(> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\@test_prog,> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0CD \u00a0 \u00a0 => $self->{relpath},> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0STDOUT => $out_fn,> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0STDERR => $out_fn> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0);> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $meth = $test_map{$func};> + \u00a0 \u00a0> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0# That's the reason for: \u00a0 no strict 'refs';> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $pass = $self->{builder}->$meth(> Parrot::Test::slurp_file($out_fn), $output, $desc ); + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\nThat line works under strict 'refs'; all method lookups are symbolic in Perl 5.\n> \u00a0unless ($pass) {> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $diag = '';> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0my $test_prog = join ' && ', @test_prog;> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0$diag .= \"'$test_prog' failed with exit code> $exit_code.\" if $exit_code; + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0> \u00a0$self->{builder}->diag($diag) if $diag;> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\nI think this code eats segfaults, as per RT #39197.\nThere's a lot of opportunity for refactoring and cleanup in the Parrot::Test modules.  There's too much duplication as it is.\n-- c\n\n"}
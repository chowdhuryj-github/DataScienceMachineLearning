{"category": "ham", "to_address": "p6l <perl6-language@perl.org>", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: Default filehandles, or topicalizing filehandles, or something", "body": "On Tue, May 01, 2007 at 01:41:45PM -0400, Mark J. Reed wrote:\n: On 5/1/07, Larry Wall  wrote:\n: >The plan introduced in A06 was to leave $*('IN'|'OUT'|'ERR') bound\n: >to stdin, stdout, and stderr (which can still be dickered with on\n: >the POSIXy level, of course), and instead emulate p5's select(FH)\n: >using a global variable $*DEFOUT for the default handle of print\n: >(and now say as well).\n: \n: What about the default handle for warn/die?  $*DEFERR?\n\nCould certainly work it the same way.\n\n: I think I prefer a more significant difference between the default\n: targets and the POSIXy std* values that they are initialized to,  like\n: the Ruby notion of using global variables initialized to named\n: constants, e.g. $stderr starts out as equal to STDERR but can be\n: reassigned...\n\nWell, the question is, what does a subprocess get for fd(2) after\nyou do that?  I'd prefer to keep $*ERR nailed to fd(2) in general so\nthat modifying $*ERR actually changes the stderr of new subprocesses.\nBut that doesn't give you a method of indirection inside the current\nprocess, so $*DEFERR would be a way to do that.  Forcing people\nto use an explicit handle in that case would be another approach,\nbut certainly something like $*DEFERR would be kinder to embedding\nsystems that want to intercept such messages and log them.\n\nLarry\n\n"}
{"category": "ham", "to_address": "\"larry@cvs.perl.org\" <larry@cvs.develooper.com>", "from_address": "\"Jonathan Lang\" <dataweaver@gmail.com>", "subject": "Re: [svn:perl6-synopsis] r14415 - doc/trunk/design/syn", "body": "larry@cvs.perl.org wrote:\n> Author: larry\n> Date: Sun Jun  3 17:23:15 2007\n> New Revision: 14415\n>\n> Modified:\n>    doc/trunk/design/syn/S03.pod\n>    doc/trunk/design/syn/S04.pod\n>    doc/trunk/design/syn/S06.pod\n>\n> Log:\n> typo from Aaron Crane++\n> s/cat/list/ for flattening captures in order\n> cat() now only produces pseudo-strings even in list context\n\n\n\n> Modified: doc/trunk/design/syn/S03.pod\n> ==============================================================================\n> --- doc/trunk/design/syn/S03.pod        (original)\n> +++ doc/trunk/design/syn/S03.pod        Sun Jun  3 17:23:15 2007\n> @@ -610,7 +610,7 @@\n>      $string x $count\n>\n>  Evaluates the left argument in string context, replicates the resulting\n> -string value the number of time specified by the right argument and\n> +string value the number of times specified by the right argument and\n>  returns the result as a single concatenated string regardless of context.\n>\n>  If the count is less than 1, returns the null string.\n> @@ -625,7 +625,7 @@\n>      @list xx $count\n>\n>  Evaluates the left argument in list context, replicates the resulting\n> -C value the number of time specified by the right argument and\n> +C value the number of times specified by the right argument and\n>  returns the result in a context dependent fashion.  If the operator\n>  is being evaluated in ordinary list context, the operator returns a\n>  flattened list.  In slice (C<@@>) context, the operator converts each C\n> @@ -3554,15 +3554,12 @@\n>          ...\n>      }\n>\n> -To read arrays serially rather than in parallel, use C.\n> -This wins a \"useless use of cat award\" in this case since you could\n> +To read arrays serially rather than in parallel, use C.\n> +This wins a \"useless use of list award\" in this case since you could\n>  always just write C<(@x,@y)> to mean the same thing.  But sometimes\n>  it's nice to be explicit about that:\n>\n> -    @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6\n> -\n> -(The C function is not entirely useless; it also provides stringy\n> -semantics in string context.)\n> +    @foo := [[1,2,3],[4,5,6]]; say list([;] @foo); # 1,2,3,4,5,6\n\nLet me see if I understand this correctly:\n\n* In list context, a list of captures gets flattened.\n\n* In slice context (a variant of list context), a list of captures\ndoesn't get flattened.\n\n* In hash context (another variant of list context), a list of\ncaptures gets flattened, and then grouped into Pairs.\n\n* In item context, a list of captures becomes a single Array object,\nand the question about whether or not it gets flattened gets deferred\nuntil its contents get looked at in list, slice, or hash context.\n\nMeanwhile, 'zip' produces a list of captures - which, because list\ncontext is the default \"plural\" context, immediately gets flattened\nmost of the time.  As I see it, then, the serial equivalent to\n'zip(@a;@b)' would be '(@a;@b)', and 'list(@a;@b)' would be the serial\nequivalent to 'list(zip(@a;@b))'.\n\nOr does '(@a;@b)' default to slice context?\n\n-- \nJonathan \"Dataweaver\" Lang\n\n"}
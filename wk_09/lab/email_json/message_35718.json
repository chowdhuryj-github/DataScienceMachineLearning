{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jra@samba.org", "subject": "svn commit: samba r23122 - in branches: SAMBA_3_0/source/rpc_parse\n\tSAMBA_3_0_25/source/rpc_parse SAMBA_3_0_26/source/rpc_parse", "body": "Author: jra\nDate: 2007-05-24 20:40:46 +0000 (Thu, 24 May 2007)\nNew Revision: 23122\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23122\n\nLog:\nFix bug #4655. We marshall the enumdataex correctly,\nbut W2K3 doesn't follow our rules when sending data to\nus. Ensure we look for the data at the correct offsets\nwhen reading the data.\nToo late for 3.0.25a - don't merge.\nJeremy.\n\nModified:\n   branches/SAMBA_3_0/source/rpc_parse/parse_spoolss.c\n   branches/SAMBA_3_0_25/source/rpc_parse/parse_spoolss.c\n   branches/SAMBA_3_0_26/source/rpc_parse/parse_spoolss.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/rpc_parse/parse_spoolss.c\n===================================================================\n--- branches/SAMBA_3_0/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:26:07 UTC (rev 23121)\n+++ branches/SAMBA_3_0/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:40:46 UTC (rev 23122)\n@@ -7022,10 +7022,10 @@\n \t\tdata_offset,\n \t\tcurrent_offset;\n \tconst uint32 basic_unit = 20; /* size of static portion of enum_values */\n-\t\n+\n \tprs_debug(ps, depth, desc, \"spoolss_io_printer_enum_values_ctr\");\n \tdepth++;\t\n-\t\n+\n \t/* \n \t * offset data begins at 20 bytes per structure * size_of_array.\n \t * Don't forget the uint32 at the beginning \n@@ -7042,10 +7042,29 @@\n \t}\n \n \tfor (i=0; isize_of_array; i++) {\n+\t\tuint32 base_offset, return_offset;\n+\n+\t\tbase_offset = prs_offset(ps);\n+\n \t\tvaluename_offset = current_offset;\n \t\tif (!prs_uint32(\"valuename_offset\", ps, depth, &valuename_offset))\n \t\t\treturn False;\n \n+\t\t/* Read or write the value. */\n+\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + valuename_offset)) {\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\t\treturn False;\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n+\t\t\treturn False;\n+\n \t\tif (!prs_uint32(\"value_len\", ps, depth, &ctr->values[i].value_len))\n \t\t\treturn False;\n \t\n@@ -7060,21 +7079,14 @@\n \t\tif (!prs_uint32(\"data_len\", ps, depth, &ctr->values[i].data_len))\n \t\t\treturn False;\n \t\t\t\n-\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n-\t\t/* account for 2 byte alignment */\n-\t\tcurrent_offset += (current_offset % 2);\n-\t}\n+\t\t/* Read or write the data. */\n \n-\t/* \n-\t * loop #2 for writing the dynamically size objects; pay \n-\t * attention to 2-byte alignment here....\n-\t */\n-\t\n-\tfor (i=0; isize_of_array; i++) {\n-\t\n-\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + data_offset)) {\n \t\t\treturn False;\n-\t\t\n+\t\t}\n+\n \t\tif ( ctr->values[i].data_len ) {\n \t\t\tif ( UNMARSHALLING(ps) ) {\n \t\t\t\tctr->values[i].data = PRS_ALLOC_MEM(ps, uint8, ctr->values[i].data_len);\n@@ -7084,11 +7096,30 @@\n \t\t\tif (!prs_uint8s(False, \"data\", ps, depth, ctr->values[i].data, ctr->values[i].data_len))\n \t\t\t\treturn False;\n \t\t}\n-\t\t\t\n-\t\tif ( !prs_align_uint16(ps) )\n+\n+\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n+\t\t/* account for 2 byte alignment */\n+\t\tcurrent_offset += (current_offset % 2);\n+\n+\t\t/* Remember how far we got. */\n+\t\tdata_offset = prs_offset(ps);\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n \t\t\treturn False;\n+\n \t}\n \n+\t/* Go to the last data offset we got to. */\n+\n+\tif (!prs_set_offset(ps, data_offset))\n+\t\treturn False;\n+\n+\t/* And ensure we're 2 byte aligned. */\n+\n+\tif ( !prs_align_uint16(ps) )\n+\t\treturn False;\n+\n \treturn True;\t\n }\n \n\nModified: branches/SAMBA_3_0_25/source/rpc_parse/parse_spoolss.c\n===================================================================\n--- branches/SAMBA_3_0_25/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:26:07 UTC (rev 23121)\n+++ branches/SAMBA_3_0_25/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:40:46 UTC (rev 23122)\n@@ -7026,10 +7026,10 @@\n \t\tdata_offset,\n \t\tcurrent_offset;\n \tconst uint32 basic_unit = 20; /* size of static portion of enum_values */\n-\t\n+\n \tprs_debug(ps, depth, desc, \"spoolss_io_printer_enum_values_ctr\");\n \tdepth++;\t\n-\t\n+\n \t/* \n \t * offset data begins at 20 bytes per structure * size_of_array.\n \t * Don't forget the uint32 at the beginning \n@@ -7046,10 +7046,29 @@\n \t}\n \n \tfor (i=0; isize_of_array; i++) {\n+\t\tuint32 base_offset, return_offset;\n+\n+\t\tbase_offset = prs_offset(ps);\n+\n \t\tvaluename_offset = current_offset;\n \t\tif (!prs_uint32(\"valuename_offset\", ps, depth, &valuename_offset))\n \t\t\treturn False;\n \n+\t\t/* Read or write the value. */\n+\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + valuename_offset)) {\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\t\treturn False;\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n+\t\t\treturn False;\n+\n \t\tif (!prs_uint32(\"value_len\", ps, depth, &ctr->values[i].value_len))\n \t\t\treturn False;\n \t\n@@ -7064,21 +7083,14 @@\n \t\tif (!prs_uint32(\"data_len\", ps, depth, &ctr->values[i].data_len))\n \t\t\treturn False;\n \t\t\t\n-\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n-\t\t/* account for 2 byte alignment */\n-\t\tcurrent_offset += (current_offset % 2);\n-\t}\n+\t\t/* Read or write the data. */\n \n-\t/* \n-\t * loop #2 for writing the dynamically size objects; pay \n-\t * attention to 2-byte alignment here....\n-\t */\n-\t\n-\tfor (i=0; isize_of_array; i++) {\n-\t\n-\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + data_offset)) {\n \t\t\treturn False;\n-\t\t\n+\t\t}\n+\n \t\tif ( ctr->values[i].data_len ) {\n \t\t\tif ( UNMARSHALLING(ps) ) {\n \t\t\t\tctr->values[i].data = PRS_ALLOC_MEM(ps, uint8, ctr->values[i].data_len);\n@@ -7088,11 +7100,30 @@\n \t\t\tif (!prs_uint8s(False, \"data\", ps, depth, ctr->values[i].data, ctr->values[i].data_len))\n \t\t\t\treturn False;\n \t\t}\n-\t\t\t\n-\t\tif ( !prs_align_uint16(ps) )\n+\n+\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n+\t\t/* account for 2 byte alignment */\n+\t\tcurrent_offset += (current_offset % 2);\n+\n+\t\t/* Remember how far we got. */\n+\t\tdata_offset = prs_offset(ps);\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n \t\t\treturn False;\n+\n \t}\n \n+\t/* Go to the last data offset we got to. */\n+\n+\tif (!prs_set_offset(ps, data_offset))\n+\t\treturn False;\n+\n+\t/* And ensure we're 2 byte aligned. */\n+\n+\tif ( !prs_align_uint16(ps) )\n+\t\treturn False;\n+\n \treturn True;\t\n }\n \n\nModified: branches/SAMBA_3_0_26/source/rpc_parse/parse_spoolss.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:26:07 UTC (rev 23121)\n+++ branches/SAMBA_3_0_26/source/rpc_parse/parse_spoolss.c\t2007-05-24 20:40:46 UTC (rev 23122)\n@@ -7026,10 +7026,10 @@\n \t\tdata_offset,\n \t\tcurrent_offset;\n \tconst uint32 basic_unit = 20; /* size of static portion of enum_values */\n-\t\n+\n \tprs_debug(ps, depth, desc, \"spoolss_io_printer_enum_values_ctr\");\n \tdepth++;\t\n-\t\n+\n \t/* \n \t * offset data begins at 20 bytes per structure * size_of_array.\n \t * Don't forget the uint32 at the beginning \n@@ -7046,10 +7046,29 @@\n \t}\n \n \tfor (i=0; isize_of_array; i++) {\n+\t\tuint32 base_offset, return_offset;\n+\n+\t\tbase_offset = prs_offset(ps);\n+\n \t\tvaluename_offset = current_offset;\n \t\tif (!prs_uint32(\"valuename_offset\", ps, depth, &valuename_offset))\n \t\t\treturn False;\n \n+\t\t/* Read or write the value. */\n+\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + valuename_offset)) {\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\t\treturn False;\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n+\t\t\treturn False;\n+\n \t\tif (!prs_uint32(\"value_len\", ps, depth, &ctr->values[i].value_len))\n \t\t\treturn False;\n \t\n@@ -7064,21 +7083,14 @@\n \t\tif (!prs_uint32(\"data_len\", ps, depth, &ctr->values[i].data_len))\n \t\t\treturn False;\n \t\t\t\n-\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n-\t\t/* account for 2 byte alignment */\n-\t\tcurrent_offset += (current_offset % 2);\n-\t}\n+\t\t/* Read or write the data. */\n \n-\t/* \n-\t * loop #2 for writing the dynamically size objects; pay \n-\t * attention to 2-byte alignment here....\n-\t */\n-\t\n-\tfor (i=0; isize_of_array; i++) {\n-\t\n-\t\tif (!prs_unistr(\"valuename\", ps, depth, &ctr->values[i].valuename))\n+\t\treturn_offset = prs_offset(ps);\n+\n+\t\tif (!prs_set_offset(ps, base_offset + data_offset)) {\n \t\t\treturn False;\n-\t\t\n+\t\t}\n+\n \t\tif ( ctr->values[i].data_len ) {\n \t\t\tif ( UNMARSHALLING(ps) ) {\n \t\t\t\tctr->values[i].data = PRS_ALLOC_MEM(ps, uint8, ctr->values[i].data_len);\n@@ -7088,11 +7100,30 @@\n \t\t\tif (!prs_uint8s(False, \"data\", ps, depth, ctr->values[i].data, ctr->values[i].data_len))\n \t\t\t\treturn False;\n \t\t}\n-\t\t\t\n-\t\tif ( !prs_align_uint16(ps) )\n+\n+\t\tcurrent_offset  = data_offset + ctr->values[i].data_len - basic_unit;\n+\t\t/* account for 2 byte alignment */\n+\t\tcurrent_offset += (current_offset % 2);\n+\n+\t\t/* Remember how far we got. */\n+\t\tdata_offset = prs_offset(ps);\n+\n+\t\t/* And go back. */\n+\t\tif (!prs_set_offset(ps, return_offset))\n \t\t\treturn False;\n+\n \t}\n \n+\t/* Go to the last data offset we got to. */\n+\n+\tif (!prs_set_offset(ps, data_offset))\n+\t\treturn False;\n+\n+\t/* And ensure we're 2 byte aligned. */\n+\n+\tif ( !prs_align_uint16(ps) )\n+\t\treturn False;\n+\n \treturn True;\t\n }\n \n\n"}
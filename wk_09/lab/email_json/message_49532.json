{"category": "ham", "to_address": "beginners perl <beginners@perl.org>", "from_address": "Tom Allison <tom@tacocat.net>", "subject": "Re: character encoding & regex", "body": "I got somewhere with this:\nFrom: =?Big5?B?obS2Uq/5r3Wk6KtLLLKjpmGqvbBl?= <>\ntranslates to\nFrom: \\\\{a1}\\\\{b4}\\\\{b6}R\\\\{af}\\\\{f9}\\\\{af}u\\\\{a4}\\\\{e8}\\\\{ab}K,\\\\{b2} \n\\\\{a3}\\\\{a6}a\\\\{aa}\\\\{bd}\\\\{b0}e <>\nwhich still means nothing to me.  But at least I can pick it apart, I  \nthink.\n\n\nI want to match everything in this list that is either \\w or \\\\\\\\\\ \n{[\\da-f]{2}\\} (which is ugly)...\nto give me three matches:\nFrom\n\\\\{a1}\\\\{b4}\\\\{b6}R\\\\{af}\\\\{f9}\\\\{af}u\\\\{a4}\\\\{e8}\\\\{ab}K\n\\\\{b2}\\\\{a3}\\\\{a6}a\\\\{aa}\\\\{bd}\\\\{b0}e\n\nforeach ($string =~ /((?:\\w|\\\\\\{[\\da-f]{2}\\})+)/ig) {\n     print \"$_\\n\";\n}\nSeems to work.\n\n\nAnd then there are other issues like:\n%6d%32%32%36%35%35%34%31%31%2e%6d%79%77%65%62%2e%68%69%6e%65%74%2e%6e% \n65%74\nwhich is easy to do as it's url encoded\nand\n\u62d2\u4fe1PT\nWhich I don't even know what this might be...  HTML code?  It's in a  \nmailto: subject line.\n\nWhat a mess....\nBut it's progress!!!\n\n\nOn Jun 16, 2007, at 6:05 PM, Tom Phoenix wrote:\n\n>\n> On 6/16/07, Tom Allison  wrote:\n>\n>> I'm trying to do some regular expression on strings in email. They  \n>> could be\n>> encoded to something.  But I can't tell because I don't have a  \n>> utf8 unicode\n>> xterm window that will show me anything.  At best I get ?????a??   \n>> and other\n>> trash like that.  I think this is typical for ascii text  \n>> renderings of two-bit\n>> characters.\n>\n> But, I think what you're saying is, you want to be able to tell\n> whether today's ?????a?? is the same mystery word that looked like\n> ?????a?? in yesterday's mail, right? That is, you still won't know\n> what it is, but at least you'll be able to say you saw it again.\n>\n>> I found something that SpamAssassin uses to convert all this \"goo\"  \n>> into a\n>> repeatable set of characters (which is all I'm really after) by  \n>> running\n>> something that looks like this:\n>>\n>> sub _quote_bytea {\n>>      my ($str) = @_;\n>>      my $buf = \"\";\n>>      foreach my $char (split(//,$str)) {\n>>          my $oct = sprintf (\"%lo\", ord($char));\n>>          if (length( $oct ) < 2 ) { $oct = '0' . $oct; }\n>>          if (length( $oct ) < 3 ) { $oct = '0' . $oct; }\n>>          $buf .= '\\\\\\\\\\\\\\\\' . $oct;\n>>      }\n>>      return $buf;\n>> }\n>\n> So that's somebody else's code, not yours? Does that code have any\n> comments that explain what it's doing? What does \"_quote_bytea\" mean?\n>\n> That looks to me like it's replacing each character with four\n> backslashes and at least three octal digits. The two ifs are confusing\n> me. Do you know about leading zeroes in sprintf formats?\n>\n>  my $oct = sprintf (\"%03lo\", ord($char));  # maybe?\n>\n>  my $buf = join \"\",\n>    map sprintf(\"\\\\\\\\\\\\\\\\%03lo\", ord($_)),\n>    split //, $str;              # ???\n>\n>  $str =~ s{(.)}{ sprintf \"\\\\\\\\\\\\\\\\%03lo\", ord($1) }seg;   #???\n>\n> But it sounds to me as if you don't want that particular string; you\n> want any function that gives you a lossless, repeatable coding of your\n> input string, but unlike the input string, the desired result is\n> composed only of printable characters. Yes? And presumably,\n> compactness and readability are also desirable features of the encoded\n> string.\n>\n>  # Encode everything except the \"normal\" ASCII\n>  # characters. Normal includes newline and space, but no other\n>  # inkless characters. Normal does not include backslash.\n>  ###UNPORTABLE### Newline character is machine-dependent\n>  $str =~ s{([^\\n\\x20-\\x5b\\x5d-\\x7e])}{ sprintf \"\\\\{%x}\", ord($1) }seg;\n>\n> By now, I'm sure I must have sufficiently misunderstood either the\n> task or Perl's abilities to accomplish it, so I'll leave it at this.\n> Hope this helps!\n>\n> --Tom Phoenix\n> Stonehenge Perl Training\n>\n> -- \n> To unsubscribe, e-mail: beginners-unsubscribe@perl.org\n> For additional commands, e-mail: beginners-help@perl.\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
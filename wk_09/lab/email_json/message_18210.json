{"category": "ham", "to_address": "bugs-bitbucket@netlabs.develooper.com", "from_address": "Andy Spieherty (via RT) <parrotbug-followup@parrotcode.org>", "subject": "[perl #42772] [PATCH] Re: mmx/sse copy functions (was: Puzzling structure in <parrot/stacks.h>) ", "body": "# New Ticket Created by  Andy Spieherty \n# Please include the string:  [perl #42772]\n# in the subject line of all future correspondence about this issue. \n# \n\n\nOn Thu, 26 Apr 2007, Leopold Toetsch wrote:\n\n> Am Donnerstag, 26. April 2007 21:44 schrieb Andy Spieherty:\n> > Does anyone understand the 'dummy' element in\n> > include/parrot/stacks.h?  Here is the relevant snippet:\n> >\n> >     typedef struct Stack_Chunk {\n> >         pobj_t obj;\n> >         int size;\n> >         const char * name;\n> >         struct Stack_Chunk *prev;\n> >     #if ! DISABLE_GC_DEBUG && defined(I386)\n> >         void * dummy;   /* force 8 byte align for mmx and sse moves */\n> >     #endif\n> >         union { /* force appropriate alignment of 'data' */\n> >             void *data;\n> >     #ifndef I386\n> >             double d_dummy;         /* align double values on stack */\n> >     #endif\n> >         } u;\n> >     } Stack_Chunk_t;\n\n> At some earlier time in parrot history, there was a (32 bit, pointer-sized) \n> 'version' [1] structure item in pobj_t, which was active \n> with !DISABLE_GC_DEBUG. The dummy was needed for i386 (when x86_64 didn't \n> even exist) to align the data pointer at an 8-byte boundary.\n\nAh, yes.  Thanks for the detailed reply.   At this point, removing the \ndummy will put u.data back on an 8-byte boundary (for i386), so that's \nprobably a good thing all around.\n\nI'd suggest the following patch:\n\ndiff -ru parrot-current/include/parrot/stacks.h parrot-andy/include/parrot/stacks.h\n--- parrot-current/include/parrot/stacks.h\t2006-11-12 03:15:19.000000000 -0500\n+++ parrot-andy/include/parrot/stacks.h\t2007-04-27 09:24:04.000000000 -0400\n@@ -29,13 +29,11 @@\n     int size;\n     const char * name;\n     struct Stack_Chunk *prev;\n-#if ! DISABLE_GC_DEBUG && defined(I386)\n-    void * dummy;   /* force 8 byte align for mmx and sse moves */\n-#endif\n-    union { /* force appropriate alignment of 'data' */\n+    union { /* force appropriate alignment of 'data'.  If alignment\n+               is necessary, assume double is good enough.  27-04-2007. */\n         void *data;\n-#ifndef I386\n-        double d_dummy;         /* align double values on stack */\n+#if PARROT_PTR_ALIGNMENT > 1\n+        double d_dummy;\n #endif\n     } u;\n } Stack_Chunk_t;\n--- parrot-current/src/stack_common.c\tThu Apr 26 19:15:14 2007\n+++ parrot-andy/src/stack_common.c\tFri Apr 27 11:49:53 2007\n@@ -59,9 +59,6 @@\n     Stack_Chunk_t *chunk;\n \n     item_size += offsetof(Stack_Chunk_t, u.data);\n-    item_size += 7;\n-    item_size &= ~7;    /* round up to 8 so that the chunk is aligned at\n-                           the same size - the aligned MMX memcpy needs it */\n     make_bufferlike_pool(interp, item_size);\n     chunk = (Stack_Chunk_t *)new_bufferlike_header(interp, item_size);\n     chunk->prev = chunk;        /* mark the top of the stack */\n\n\n\n\n> As the past tense is indicating, above dummy is totally obsolete and the copy \n> functions[2] are unused. The latter could be removed too, but might be a \n> nice-to-have, when something faster than memcpy(3) is wanted or needed, \n> albeit only on restricted (but common) platforms and for aligned memory only. \n> Some recent CPUs do have special instructions for copying unaligned memory \n> reegions too.\n\nYes, indeed.  I could see a future optimization pairing memalign(3C) with \nspecialized copy functions.\n\nThanks again,\n\n-- \n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 104: merge from ronnie in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 104\nrevision-id: tridge@samba.org-20070414104443-0b90a6105ca1c1d5\nparent: tridge@samba.org-20070413103824-0c5e1dbd679c73bd\nparent: ronniesahlberg@gmail.com-20070413103741-t7jc7c48i2rl2v1d\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Sat 2007-04-14 20:44:43 +1000\nmessage:\n  merge from ronnie\nmodified:\n  common/ctdb_client.c           ctdb_client.c-20070411010216-3kd8v37k61steeya-1\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n  tests/ctdb_fetch1.c            ctdb_fetch1.c-20070412111848-xawz6wqk9r0v8jdk-1\n    ------------------------------------------------------------\n    merged: ronniesahlberg@gmail.com-20070413103741-t7jc7c48i2rl2v1d\n    parent: ronniesahlberg@gmail.com-20070412234456-b80kjt2dz2213ijc\n    committer: Ronnie sahlberg \n    branch nick: ctdb\n    timestamp: Fri 2007-04-13 20:37:41 +1000\n    message:\n      add missing code to store_unlock so that the data that a client writes is stored in ltdb\n      \n      this makes it possible to do fetch_lock and store_unlock across a domain socket to read/write data.\n      \n      \n      note that the actual locking is NOT implemented yet\n=== modified file 'common/ctdb_client.c'\n--- a/common/ctdb_client.c\t2007-04-13 10:38:24 +0000\n+++ b/common/ctdb_client.c\t2007-04-14 10:44:43 +0000\n@@ -586,7 +586,7 @@\n   This is called when the program wants to wait for a ctdb_fetch_lock to complete and get the \n   results. This call will block unless the call has already completed.\n */\n-struct ctdb_record_handle *ctdb_client_fetch_lock_recv(struct ctdb_call_state *state, TALLOC_CTX *mem_ctx, TDB_DATA key)\n+struct ctdb_record_handle *ctdb_client_fetch_lock_recv(struct ctdb_call_state *state, TALLOC_CTX *mem_ctx, TDB_DATA key, TDB_DATA *data)\n {\n \tstruct ctdb_record_handle *rec;\n \n@@ -609,6 +609,9 @@\n \trec->data->dsize = state->call.reply_data.dsize;\n \trec->data->dptr  = talloc_memdup(rec, state->call.reply_data.dptr, rec->data->dsize);\n \n+\tif (data) {\n+\t\t*data = *rec->data;\n+\t}\n \treturn rec;\n }\n \n@@ -633,13 +636,14 @@\n \n struct ctdb_record_handle *ctdb_client_fetch_lock(struct ctdb_db_context *ctdb_db, \n \t\t\t\t\t\t  TALLOC_CTX *mem_ctx, \n-\t\t\t\t\t\t  TDB_DATA key, TDB_DATA *data)\n+\t\t\t\t\t\t  TDB_DATA key,\n+\t\t\t\t\t\t  TDB_DATA *data)\n {\n \tstruct ctdb_call_state *state;\n \tstruct ctdb_record_handle *rec;\n \n \tstate = ctdb_client_fetch_lock_send(ctdb_db, mem_ctx, key);\n-\trec = ctdb_client_fetch_lock_recv(state, mem_ctx, key);\n+\trec = ctdb_client_fetch_lock_recv(state, mem_ctx, key, data);\n \n \treturn rec;\n }\n\n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-04-13 10:38:24 +0000\n+++ b/common/ctdb_daemon.c\t2007-04-14 10:44:43 +0000\n@@ -214,12 +214,36 @@\n {\n \tstruct ctdb_db_context *ctdb_db;\n \tstruct ctdb_reply_store_unlock r;\n+\tuint32_t caller = ctdb_get_vnn(client->ctdb);\n+\tstruct ctdb_ltdb_header header;\n+\tTDB_DATA key, data;\n \tint res;\n \n \tctdb_db = find_ctdb_db(client->ctdb, f->db_id);\n+\n \t/* write the data to ltdb */\n-/*XXX*/\n-\n+\tkey.dsize = f->keylen;\n+\tkey.dptr  = &f->data[0];\n+\tres = ctdb_ltdb_fetch(ctdb_db, key, &header, NULL, NULL);\n+\tif (res) {\n+\t\tctdb_set_error(ctdb_db->ctdb, \"Fetch of locally held record failed\");\n+\t\tres = -1;\n+\t\tgoto done;\n+\t}\n+\tif (header.laccessor != caller) {\n+\t\theader.lacount = 0;\n+\t}\n+\theader.laccessor = caller;\n+\theader.lacount++;\n+\tdata.dsize = f->datalen;\n+\tdata.dptr  = &f->data[f->keylen];\n+\tres = ctdb_ltdb_store(ctdb_db, key, &header, data);\n+\tif ( res != 0) {\n+\t\tctdb_set_error(ctdb_db->ctdb, \"ctdb_call tdb_store failed\\n\");\n+\t}\n+\n+\n+done:\n \t/* now send the reply */\n \tZERO_STRUCT(r);\n \n@@ -228,7 +252,7 @@\n \tr.hdr.ctdb_version = CTDB_VERSION;\n \tr.hdr.operation  = CTDB_REPLY_STORE_UNLOCK;\n \tr.hdr.reqid      = f->hdr.reqid;\n-\tr.state          = CTDB_CALL_DONE;\n+\tr.state          = res;\n \t\n \tres = ctdb_queue_send(client->queue, (uint8_t *)&r.hdr, r.hdr.length);\n \tif (res != 0) {\n\n=== modified file 'tests/ctdb_fetch1.c'\n--- a/tests/ctdb_fetch1.c\t2007-04-13 10:38:24 +0000\n+++ b/tests/ctdb_fetch1.c\t2007-04-14 10:44:43 +0000\n@@ -42,7 +42,7 @@\n \tconst char *myaddress = NULL;\n \tint self_connect=0;\n \tint daemon_mode=0;\n-\tTDB_DATA key, *data, *data2, store_data;\n+\tTDB_DATA key, data, data2, store_data;\n \tstruct ctdb_record_handle *rh;\n \n \tstruct poptOption popt_options[] = {\n@@ -137,26 +137,29 @@\n \tctdb_connect_wait(ctdb);\n \n \tkey.dptr  = \"Record\";\n-\tkey.dsize = strlen(key.dptr);\n-\tdata      = NULL;\n-\trh = ctdb_fetch_lock(ctdb_db, ctdb_db, key, data);\n+\tkey.dsize = strlen(key.dptr)+1;\n+\trh = ctdb_fetch_lock(ctdb_db, ctdb_db, key, &data);\n \n \tstore_data.dptr  = \"data to store\";\n \tstore_data.dsize = strlen(store_data.dptr)+1;\n \tret = ctdb_store_unlock(rh, store_data);\n-\tprintf(\"ctdb_store_unlock ret:%d\\n\",ret);\n-\n-\tdata2     = NULL;\n-\trh = ctdb_fetch_lock(ctdb_db, ctdb_db, key, data2);\n-/* hopefully   data2 will now contain the record written above */\n-\n+\n+\trh = ctdb_fetch_lock(ctdb_db, ctdb_db, key, &data2);\n+\t/* hopefully   data2 will now contain the record written above */\n+\tif (!strcmp(\"data to store\", data2.dptr)) {\n+\t\tprintf(\"woohoo we read back the data we stored\\n\");\n+\t} else {\n+\t\tprintf(\"ERROR: we read back different data than we stored\\n\");\n+\t}\n+\t\n \t/* just write it back to unlock it */\n-\tret = ctdb_store_unlock(rh, data2);\n-\tprintf(\"ctdb_store_unlock ret:%d\\n\",ret);\n+\tret = ctdb_store_unlock(rh, store_data);\n \n+#if 0\n \twhile (1) {\n \t\tevent_loop_once(ev);\n \t}\n+#endif\n \n \t/* shut it down */\n \ttalloc_free(ctdb);\n\n"}
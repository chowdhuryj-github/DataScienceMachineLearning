{"category": "ham", "to_address": "<beginners@perl.org>", "from_address": "\"Bob McConnell\" <rvm@CBORD.com>", "subject": "RE: Inter-thread communications", "body": "> -----Original Message-----\n> From: Linux@lists.develooper.com \n> [mailto:Linux@lists.develooper.com] On Behalf Of zentara\n> Sent: Wednesday, June 20, 2007 8:13 AM\n> To: beginners@perl.org\n> Subject: Re: Inter-thread communications\n> \n> On Tue, 19 Jun 2007 15:44:18 -0400, rvm@CBORD.com (\"Bob McConnell\")\n> wrote:\n> \n> \n> >I have been trying to implement this in ActivePerl 5.8.8.820 \n> on W2K, so\n> >I am working in the thread based fork() implementation. IPC does not\n> >seem to exist in that implementation.\n> \n> For forked processes, you need pipes, sockets, or shared mem for\n> IPC.  \n> \n> You probably are better off sticking with threads on Win32, since\n> it only uses threads underneath it all.\n> \n> >I had pretty much figured out that alarm doesn't work in Win32. I had\n> Alarm dosn't work on linux with threads either ( or not as you would\n> expect.... the main thread intercepts all alarms).\n> \n> >tried to use it to interrupt read() on a serial port, and that wasn't\n> >working. Neither did SIGINT or SIGTERM. The only way to get out of it\n> >was Ctrl->Break, which shuts down the whole process.\n> >\n> >Unless the Glib timer can interrupt a serial port read() \n> call, I don't\n> >see any way to timeout a serial port input function on Win32.\n> >Unfortunately, that means I will probably need to steal one \n> of the FC5\n> >boxes from the next room in order to get it to work.\n> \n> Yeah, Glib should be able to do it with some \"flagging magic\". I don't\n> have an example offhand, but if you look at that perlmonks url, about\n> rolling your own event loop, you can see how it MIGHT be done :-)\n> \n> .....pseudo-code follows......\n> \n> ###  filehandle watch\n> open (FH, \"+> test.log\") or warn \"$!\\n\";     # simulate your socket\n> \n> Glib::IO->add_watch (fileno 'FH', ['in'], \\&watch_callback, 'FH', 1 );\n> \n> $main_loop->run;\n> ####################################################################\n> sub watch_callback {\n>     my ($fd, $condition, $fh) = @_;\n> \n>     if($flag){return 1}  # test for timer flag\n> \n>     my @lines = ;\n>     print @lines;\n> \n>    # here you might regex the lines for Ack or Nack, and if found,\n>    #launch a timer to set a flag after 3 seconds ( act as alarm) \n>    my $timer  = Glib::Timeout->add (3000, \\&timer_callback, \n> undef, 1 );\n> \n> \n>     #always return TRUE to continue the callback\n>     return 1;\n> }       \n> \n> \n> \n> Like I said it was just pseudo code, and I have to admit, it would\n> probably take a few hours of realtime testing scripts, to see how\n> the serial port socket actually behaves..... the devil is \n> always in the\n> details.\n> \n> Switching to a linux box would make things work better for sure, but\n> first I recommend checking out POE. It is an advanced \n> event-loop system\n> that has alot of the bugs worked out.\n> There is a POE cookbook of examples online, and you may find\n> something close to your needs.\n> POE does offer alarms and signals.\n> \n> http://poe.perl.org/?POE_Cookbook\n> \n> \n> zentara\n\nThank your for those ideas. I don't know how far I will get with POE\nsince I don't do objects. At this point I have to think about switching\nto C for this project. I know I could throw it together in a couple of\ndays using GCC in Cygwin, which is already installed. I have spent more\ntime than that trying to do it in Perl.\n\nBob McConnell\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n\n"}
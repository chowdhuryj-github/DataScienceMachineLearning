{"category": "ham", "to_address": "\"Inman, Brant A. M.D.\" <Inman.Brant@mayo.edu>", "from_address": "Adaikalavan Ramasamy <ramasamy@cancer.org.uk>", "subject": "Re: [R] MICE for Cox model", "body": "Are you sure you used my pool function? Because as I just have \ndiscovered, it had a minor typo in the code. After replacing \"\ndf <- (m - 1) * (1 + 1/r)2\" with \"df <- (m - 1) * (1 + 1/r)^2\" in my \npool() function, I get\n\n\n  library(survival); data(pbc)\n  d <- pbc[,c('time', 'status', 'age', 'sex',\n              'hepmeg', 'platelet', 'trt', 'trig')]\n  d[d==-9] <- NA\n  d[,c(4,5,7)] <- lapply(d[,c(4,5,7)], FUN=as.factor)\n\n  library(mice)\n  imp <- mice(d, m=10, maxit=10, diagnostics=T, seed=500,\n               defaultImputationMethod=c('norm', 'logreg', 'polyreg'))\n  fit <- coxph.mids( Surv(time,status) ~ age + sex + hepmeg + platelet\n                                          + trt + trig, imp)\n\n  pool(fit)\n\nCall: pool(object = fit)\n\nPooled coefficients:\n          age         sex1      hepmeg1     platelet         trt2 \n   trig\n  0.034924182 -0.208897827  0.987641362 -0.001559426  0.070124108 \n0.004122421\n\nFraction of information about the coefficients missing due to nonresponse:\n        age       sex1    hepmeg1   platelet       trt2       trig\n0.06624167 0.19490517 0.27300965 0.21950332 0.27768153 0.40658964\n\nRegards, Adai\n\n\n\nInman, Brant A. M.D. wrote:\n> Adai,\n> \n> Thanks for the functions.  I tried using your functions and I get the\n> same error message during the pooling part:\n> \n>> pool(micefit)\n> Error in names(df) <- names(f) <- names : 'names' attribute [5] must be\n> the same length as the vector [0]\n> \n> Brant\n> -----Original Message-----\n> From: Adaikalavan Ramasamy [mailto:ramasamy@cancer.org.uk] \n> Sent: Thursday, May 17, 2007 4:56 AM\n> To: Inman, Brant A. M.D.\n> Cc: r-help@stat.math.ethz.ch\n> Subject: Re: [R] MICE for Cox model\n> \n> I encountered this problem about 18 months ago. I contacted Prof. Fox \n> and Dr. Malewski (the R package maintainers for mice) but they referred \n> me to Prof. van Buuren. I wrote to Prof. van Buuren but am unable to \n> find his reply (if he did reply).\n> \n> Here are the functions I used at that time, if you want to take it with \n> lots of salt. Let me know if you find anything fishy with it.\n> \n> \n> coxph.mids <- function (formula, data, ...) {\n> \n>    call <- match.call()\n>    if (!is.mids(data)) stop(\"The data must have class mids\")\n> \n>    analyses <- as.list(1:data$m)\n> \n>    for (i in 1:data$m) {\n>      data.i        <- complete(data, i)\n>      analyses[[i]] <- coxph(formula, data = data.i, ...)\n>    }\n> \n>    object <- list(call = call, call1 = data$call,\n>                   nmis = data$nmis, analyses = analyses)\n> \n>    oldClass(object) <- if (.SV4.) \"mira\" else c(\"mira\", \"coxph\")\n>    return(object)\n> }\n> \n> \n> And in the function 'pool', the small sample adjustment requires \n> residual degrees of freedom (i.e. dfc). For a cox model, I believe that \n> this is simply the number of events minus the regression coefficients. \n> There is support for this from middle of page 149 of the book by Parmer \n> & Machin (ISBN 0471936405). Please correct me if I am wrong.\n> \n> Here is the slightly modified version of pool :\n> \n> \n> pool <- function (object, method = \"smallsample\") {\n> \n>    call <- match.call()\n>    if (!is.mira(object)) stop(\"The object must have class 'mira'\")\n> \n>    if ((m <- length(object$analyses)) < 2)\n>      stop(\"At least two imputations are needed for pooling.\\n\")\n> \n>    analyses <- object$analyses\n> \n>    k     <- length(coef(analyses[[1]]))\n>    names <- names(coef(analyses[[1]]))\n>    qhat  <- matrix(NA, nrow = m, ncol = k, dimnames = list(1:m, names))\n>    u     <- array(NA, dim = c(m, k, k),\n>                   dimnames = list(1:m, names, names))\n> \n>    for (i in 1:m) {\n>      fit       <- analyses[[i]]\n>      qhat[i, ] <- coef(fit)\n>      u[i, , ]  <- vcov(fit)\n>    }\n> \n>    qbar <- apply(qhat, 2, mean)\n>    ubar <- apply(u, c(2, 3), mean)\n>    e <- qhat - matrix(qbar, nrow = m, ncol = k, byrow = TRUE)\n>    b <- (t(e) %*% e)/(m - 1)\n>    t <- ubar + (1 + 1/m) * b\n>    r <- (1 + 1/m) * diag(b/ubar)\n>    f <- (1 + 1/m) * diag(b/t)\n>    df <- (m - 1) * (1 + 1/r)2\n> \n>    if (method == \"smallsample\") {\n> \n>      if( any( class(fit) == \"coxph\" ) ){\n> \n>        ### this loop is the hack for survival analysis ###\n> \n>        status   <- fit$y[ , 2]\n>        n.events <- sum(status == max(status))\n>        p        <- length( coefficients( fit )  )\n>        dfc      <- n.events - p\n> \n>      } else {\n> \n>        dfc <- fit$df.residual\n>      }\n> \n>      df <- dfc/((1 - (f/(m + 1)))/(1 - f) + dfc/df)\n>    }\n> \n>    names(r) <- names(df) <- names(f) <- names\n>    fit <- list(call = call, call1 = object$call, call2 = object$call1,\n>                nmis = object$nmis, m = m, qhat = qhat, u = u,\n>                qbar = qbar, ubar = ubar, b = b, t = t, r = r, df = df,\n>                f = f)\n>    oldClass(fit) <- if (.SV4.) \"mipo\" else c(\"mipo\", oldClass(object))\n>    return(fit)\n> }\n> \n> \n> print.miro only gives the coefficients. Often I need the standard errors\n> as well since I want to test if each regression coefficient from\n> multiple imputation is zero or not. Since the function summary.mipo does\n> not exist, can I suggest the following\n> \n> \n> summary.mipo <- function(object){\n> \n>     if (!is.null(object$call1)){\n>       cat(\"Call: \")\n>       dput(object$call1)\n>     }\n> \n>     est  <- object$qbar\n>     se   <- sqrt(diag(object$t))\n>     tval <- est/se\n>     df   <- object$df\n>     pval <- 2 * pt(abs(tval), df, lower.tail = FALSE)\n> \n>     coefmat <- cbind(est, se, tval, pval)\n>     colnames(coefmat) <- c(\"Estimate\", \"Std. Error\",\n>                                          \"t value\", \"Pr(>|t|)\")\n> \n>     cat(\"\\nCoefficients:\\n\")\n>     printCoefmat( coefmat, P.values=T, has.Pvalue=T, signif.legend=T )\n> \n>     cat(\"\\nFraction of information about the coefficients\n>                                     missing due to nonresponse:\", \"\\n\")\n>     print(object$f)\n> \n>     ans <- list( coefficients=coefmat, df=df,\n>                  call=object$call1, fracinfo.miss=object$f )\n>     invisible( ans )\n> \n> }\n> \n> \n> Hope this helps.\n> \n> Regards, Adai\n> \n> \n> \n> Inman, Brant A. M.D. wrote:\n>> R-helpers:\n>>\n>> I have a dataset that has 168 subjects and 12 variables.  Some of the\n>> variables have missing data and I want to use the multiple imputation\n>> capabilities of the \"mice\" package to address the missing data. Given\n>> that mice only supports linear models and generalized linear models\n> (via\n>> the lm.mids and glm.mids functions) and that I need to fit Cox models,\n> I\n>> followed the previous suggestion of John Fox and have created my own\n>> function \"cox.mids\" to use coxph to fit models to the imputed\n> datasets.\n>> (http://tolstoy.newcastle.edu.au/R/help/06/03/22295.html)\n>>\n>> The function I created is:\n>>\n>> ------------\n>>\n>> cox.mids <- function (formula, data, ...)\n>> {\n>>     call <- match.call()\n>>     if (!is.mids(data)) \n>>         stop(\"The data must have class mids\")\n>>     analyses <- as.list(1:data$m)\n>>     for (i in 1:data$m) {\n>>         data.i <- complete(data, i)\n>>         analyses[[i]] <- coxph(formula, data = data.i, ...)\n>>     }\n>>     object <- list(call = call, call1 = data$call, nmis = data$nmis, \n>>         analyses = analyses)\n>>     oldClass(object) <- c(\"mira\", \"coxph\")\n>>     return(object)\n>> }\n>>\n>> ------------\n>>\n>> The problem that I encounter occurs when I try to use the \"pool\"\n>> function to pool the fitted models into one general model. Here is\n> some\n>> code that reproduces the error using the pbc dataset.\n>>\n>> ------------\n>>\n>> d <- pbc[,c('time','status','age','sex','hepmeg','platelet', 'trt',\n>> 'trig')]\n>> d[d==-9] <- NA \n>> d[,c(4,5,7)] <- lapply(d[,c(4,5,7)], FUN=as.factor)\n>> str(d)\n>>\n>> imp <- mice(d, m=10, maxit=10, diagnostics=T, seed=500, \n>> \tdefaultImputationMethod=c('norm', 'logreg', 'polyreg'))\n>>\n>> fit <- cox.mids(Surv(time,status) ~ age + sex + hepmeg + platelet +\n> trt\n>> + \ttrig, imp)\n>>\n>> pool(fit)\n>>\n>> ------------\n>>\n>> I have looked at the \"pool\" function but cannot figure out what I have\n>> done wrong.  Would really appreciate any help with this.\n>>\n>> Thanks,\n>>\n>> Brant Inman\n>> Mayo Clinic\n>>\n>> ______________________________________________\n>> R-help@stat.math.ethz.ch mailing list\n>> https://stat.ethz.ch/mailman/listinfo/r-help\n>> PLEASE do read the posting guide\n> http://www.R-project.org/posting-guide.html\n>> and provide commented, minimal, self-contained, reproducible code.\n>>\n>>\n>>\n> \n> \n>\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
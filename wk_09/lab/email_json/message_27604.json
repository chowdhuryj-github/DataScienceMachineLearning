{"category": "ham", "to_address": "r-help@stat.math.ethz.ch", "from_address": "\"=?GB2312?B?wO6/ob3c?=\" <klijunjie@gmail.com>", "subject": "[R] model seleciton by leave-one-out cross-validation", "body": "Hi, all\n\nWhen I am using mle.cv(wle), I find a interesting problem: I can't do\nleave-one-out cross-validation with mle.cv(wle). I will illustrate the\nproblem as following:\n\n> xx=matrix(rnorm(20*3),ncol=3)\n> bb=c(1,2,0)\n> yy=xx%*%bb+rnorm(20,0,0.001)+0\n> summary(mle.cv(yy~xx,split=nrow(xx)-1,monte.carlo=2*nrow(xx),verbose=T),\nnum.max=1)[[1]]\nmle.cv: dimension of the split subsample set to default value =  9\n (Intercept)          xx1          xx2          xx3           cv\n0.000000e+00 1.000000e+00 1.000000e+00 0.000000e+00 1.292513e-06\n\n\nSo does anybody know how to do linear model selection by leave-one-out\ncross-validation? I've written one function, but it runs toooooo slow~~~\n\nThanks firstly\n\nThis is my super slow function:\n\n\n####################\n## function: rec.comb\n## input: vec -- vector\n## output: all possible combination from the elements of vec\n####################\nrec.comb=function(vec)\n{\n  if(length(vec)==0){list(NULL)\n  }else { tmp=rec.comb(vec[-1])\n    tmp2=sapply(tmp,function(x)c(vec[1],x))\n    c(tmp,tmp2)\n  }\n}\n\n####################\n## function: CV1glm--CV1 using K fold CV\n## input: y -- response vector; x -- predictors without intercept\n## output: the vector whether each predictor should be selected. E.g.\n (0,1,0,1) means no intecept while var1 and var3 should be selected\n####################\nCV1glm=function(y,x){\n n.var=ncol(x)\n n=nrow(x)\n comb=rec.comb(1: (n.var))\n n.comb=length(comb)\n pe=c()\n\n data=data.frame(y=y)\n glm=glm(y~1,data=data)\n pe[1]=cv.glm(data,glm)$delta[1]\n for(i in 2:n.comb){\n  data=data.frame(y=y,x=x[,comb[[i]]])\n  glm=glm(y~.,data=data)\n  pe[i]=cv.glm(data,glm)$delta[1]\n }\n pe1=c() ####################################without intercept\n pe1[1]=Inf\n for(i in 2:n.comb){\n  data=data.frame(y=y,x=x[,comb[[i]]])\n  glm=glm(y~.-1,data=data)\n  pe1[i]=cv.glm(data,glm)$delta[1]\n }\n\n var=rep(0,n.var)\n if(min(pe)<min(pe1)){\n  int=1\n  var[comb[[which(pe==min(pe))]]]=1\n }else{\n  int=0\n  var[comb[[which(pe1==min(pe1))]]]=1\n }\n c(int,var)\n}\n\n\n\n-- \nJunjie Li,                  klijunjie@gmail.com\nUndergranduate in DEP of Tsinghua University,\n\n\t[[alternative HTML version deleted]]\n\n______________________________________________\nR-help@stat.math.ethz.ch mailing list\nhttps://stat.ethz.ch/mailman/listinfo/r-help\nPLEASE do read the posting guide http://www.R-project.org/posting-guide.html\nand provide commented, minimal, self-contained, reproducible code.\n\n"}
{"category": "ham", "to_address": "Don Hopkins <dhopkins@DonHopkins.com>", "from_address": "Marco Pesenti Gritti <mpg@redhat.com>", "subject": "Re: [sugar] eBook Reader user interface", "body": "On Fri, 2007-05-04 at 23:08 -0700, Don Hopkins wrote:\n> Goal for improving the eBook reader user interface:\n> \n>   I've been doing some exploratory programming with GTK and Sugar,\n>   trying to improve the user interface of the eBook reader, and make\n>   it useable in book mode with the gamepad.\n> \n>   + Support the game keypads in eBook mode. \n> \n>     + Low level game keypad support\n> \n>       Need to remap low level keyboard scan codes to Linux keyboard codes. \n> \n>       The setolpckeys.c program remaps the keys and gamepad buttons.\n> \n>         Currently it maps both gamepads to the numeric keypad keys (KEY_KP8, etc),\n> \twhich the X server and GDK translates to directional keys (GDK_Up, etc).\n> \n> \tI tried to map them to buttons (BTN_A, etc), but the X server seems \n> \tto ignore keycodes in that range. \n> \n> \tThe xorg.conf file has a keycode mask that looked like it might help, \n> \tbut I couldn't get it to work. \n> \n> \tNeed to have unique keycodes reported for each of the two gamepads, \n> \twhich are not the same as any keyboard keys, without any predefined meanings\n> \tlike arrow keys have. \n> \n> \tNeed to define special purpose keycodes just for the OLPC gamepad,\n> \tinstead of trying to reuse existing but not appropriate keycodes. \n> \n> \tWhat is the process for defining new keycodes in ?\n> \n> \tHere's my strawman proposal for some new keycodes. \n> \n> \t  Use keys (\"KEY_*\") instead of buttons (\"BTN_*\"), since they\n> \t  seem to work better.\n> \n> \t  The 0x1b* range seems to be unused in , \n> \t  and it's between other groups of keycodes, so I'll\n> \t  propose using that range for the OLPC. \n> \n> \t  The UP/DOWN/LEFT/RIGHT keys correspond to the directional\n> \t  keypad.\n> \n> \t  #define KEY_XO_GAMEPAD_UP      0x1b0\n> \t  #define KEY_XO_GAMEPAD_DOWN    0x1b1\n> \t  #define KEY_XO_GAMEPAD_LEFT    0x1b2\n> \t  #define KEY_XO_GAMEPAD_RIGHT   0x1b3\n> \n> \t  The NORTH/SOUTH/EAST/WEST keys correspond to the other\n> \t  buttons. Those names are agnostic to the button labels,\n> \t  which may change from the current Playstation buttons\n> \t  (X/O/Triangle/Square). Can anyone suggest better names for\n> \t  the four buttons on the right?\n> \n> \t  #define KEY_XO_GAMEPAD_NORTH   0x1b4\n> \t  #define KEY_XO_GAMEPAD_SOUTH   0x1b5\n> \t  #define KEY_XO_GAMEPAD_EAST    0x1b6\n> \t  #define KEY_XO_GAMEPAD_WEST    0x1b7\n> \n> \t  While we're at it, we could define keycodes for the other\n> \t  OLPC buttons and switches on the screen. I think there are\n> \t  some other sensor switches that could generate keycodes,\n> \t  like opening the screen, rotating it around, and putting it\n> \t  into book mode, so I will make some guesses at names for\n> \t  them, just to get the discussion rolling. \n> \n> \t  #define KEY_XO_SCREEN_ROTATE   0x1b8\n> \t  #define KEY_XO_SCREEN_POWER    0x1b9\n> \t  #define KEY_XO_SCREEN_OPEN     0x1ba\n> \t  #define KEY_XO_SCREEN_CLOSE    0x1bb\n> \t  #define KEY_XO_SCREEN_IN       0x1bc\n> \t  #define KEY_XO_SCREEN_OUT      0x1bd\n> \n> \t  Is there an exhaustive list of all buttons and switches and\n> \t  events on the OLPC? Are any more planned? Which ones should\n> \t  be assigned keycodes?\n> \n>       Rewrote setolpckeys.c code in Python (just uses ioctl, but needs to know keycodes).\n>         Writing utilities like that in Python instead of C makes it easier to \n> \treconfigure the keys on the OLPC without a C compiler. \n> \n>     + High level action support.\n> \n>       GTK uses \"Actions\" to define the actions available in an\n>       application, independent of the user interface used to invoke\n>       them. Actions can be bound to user interface widgets and\n>       keyboard accelerators, and they can hide, show, enable and\n>       disable the corresponding parts of the interface. You can\n>       subclass Action to define custom toolbar buttons and menu items.\n> \n>       We need to define a generic way of navigating and executing the\n>       application's actions from the gamepad.\n> \n>       We can make Sugar specific actions that create the appropriately\n>       styled and customized Sugar user interface widgets.\n> \n>       Actions can be used to support navigation and operation of the\n>       toolbar components from the gamepad:\n> \n>       Actions have a list of their \"proxy\" components (toolbar\n>       buttons, menu items, etc).\n> \n>       Actions know how to execute a callback function, so the user\n>       interface components tell the action to activate, instead of\n>       calling the function themselves.\n> \n>       The actions also know their labels, icons and tooltips.\n> \n>       Actions can be shown and hidden, and all their proxies show and\n>       hide.\n> \n>       Actions can be made sensitive or not (disabled), and all their\n>       proxies enable or disable.\n> \n>       Actions have methods to construct toolbar buttons and menu\n>       items, which subclasses can override to customize the user\n>       interface. The higher level GTK UIManager calls these methods in\n>       actions to create the user interface, although you can still use\n>       Actions without the UIManager, by creating the components\n>       yourself.\n> \n>       There are three standard kinds of actions: Action, which creates\n>       a normal button or menu item, ToggleAction, which creates a\n>       toggle button (checkbox), and RadioAction, which creates a radio\n>       button (multiple choice). \n> \n>       The GTK toolbars and menus support keyboard navigation of\n>       sensitive buttons, as well as showing tooltips on sensitive\n>       buttons, but it won't show a tooltip on unsensitive (disabled)\n>       buttons, tabbing skips over disabled buttons, and it kicks you\n>       out of buttons that get disabled while you're using them, by\n>       moving the focus into the next button (whatever that happens to\n>       be).\n> \n>       All inactive items should show tooltips telling WHY they are\n>       inactive, and WHAT you have to do before using them. \n> \n>       Unfortunately you can't get a tooltip on an inactive item. \n>       This needs to be fixed, so we can display helpful tooltips and\n>       documentation on any item whether active or not. \n>  \n>       Unfortunlatey you can't navigate to an inactive item.  This\n>       needs to be fixed, so the user can use the gamepad to navigate\n>       to an inactive item, to find out what it is and why it's\n>       inactive. (Also, so you can navigate the interface predicably\n>       with muscle memory, because the number of presses required to\n>       navigate doesn't change depending on the state of the\n>       application.)\n> \n>       A problem with the current GTK keyboard navigation behavior of\n>       not allowing inactive items to have the input focus, is that it\n>       violates the principle of least astonishment, makes the\n>       interface less predictable, and interferes with type-ahead:\n> \n>         If you're focused on the \"back page\" button, and select it\n>         until you get to the first page, then it will become inactive\n>         (because you can't go back from the first page), which\n>         results in the input focus being kicked out of the \"back\n>         page\" button and throwing you into the \"next page\" button.\n> \n> \tImagine how hard this \"astonishing\" behavior would be to use\n> \tif you were visually impared. It would not be very obvious\n> \tthat you had \"bounced off\" the first page and suddenly were\n> \tmoving forward. Other toolbars might arbitrarily relocate the\n> \tinput focus to an even more confusing button, when the one\n> \tyou're using gets disabled.\n> \n>         It would be much less astonishing if the input focus simply\n>         remained in the \"back page\" button when you hit the first\n>         page, and a tooltop popped up saying \"You can't go to the\n>         previous page, because you are at the first page.\"\n> \n> \tI've made a simple API for changing the sensitivity of a\n> \tcomponent, that takes a \"reason\" string (translated text) to\n> \tshow to the user in the tooltip of a disabled control (after\n> \tthe normal text). I've changed the code in the eBook reader\n> \tthat disables actions to figure out the most important reason\n> \t(there might be several reasons to disable a control, but\n> \tusually one is most important). It passes that reason to the\n> \tAPI that disables the action, which currently just stores it\n> \taway in a dictionary. Now it needs to be hooked up so it\n> \tactually shows the tooltip with the reason when disabled.\n> \n>       GTK has an \"AcceleratorList\" class that keeps a list of keyboard\n>       accelerators which invoke actions. The UIManager helps manage\n>       the accelerators for you automatically. \n> \n> \tI think we should use accelerators for normal keyboard\n> \tacceleration of application actions, but implement the gamepad\n> \tnavigation stuff as a higher level framework that uses a more\n> \tsemantically meaningful model. (Not just low level tab/backtab\n> \tfocus navigation, or simple global keyboard accelerators, but\n> \tan actual framework specifically designed to support browsing\n> \tand executing arbitrary Actions via the game controller, and\n> \tproviding feedback about the reasons controls are disabled.)\n> \n> \tThe pygtk library has some methods on action_group to add\n> \tactions \"action_group.add_actions(action_list)\", toggle\n> \tactions \"action_group.add_toggle_actions(action_list)\", and\n> \tradio actions \"action_group.add_radio_actions(action_list,\n> \tcur_value, callback, *args)\". These all take an action_list\n> \tthat's a list of action specification tuples. That interface\n> \tis more brittle and less extensible than it should be, because\n> \tit takes tuples instead of dictionaries, and it only makes\n> \tstock GTK actions. \n> \n> \tWe need a more flexible API than add_actions and its ilk, which\n> \tsupports custom Sugar actions, and uses dictionaries instead\n> \tof tuples, so we can easily pass in additional optional\n> \tparameters without changing the API.\n> \n> \tI have taken a first cut at rewriting pygtk's ActionGroup's\n> \tadd_actions, add_toggle_actions and add_radio_actions\n> \tfunctions in Python, and changing them to use custom\n> \tSugarAction, SugarToggleAction and SugarRadioAction classes.\n> \n> \tBut I still don't think the add_actions_esque interface is\n> \tflexible enough. It needs an easy way to add other custom\n> \twidgets (like the search text input field), and it should make\n> \tit easy to customize the user interface classes and configure\n> \tthe objects by passing in additional optional parameters and\n> \tconfiguration dictionaries. (For example, the action\n> \tspecification should be a dictionary that has an optional key\n> \tto specify the toolbar button and menu item classes, and it\n> \tshould be possible to plug in different kinds of user\n> \tinterface controls than toolbars and menus, like pie menus and\n> \tgamepad specific interfaces). \n> \n>       GTK has an \"atk\" module that interfaces to the accessibility toolkit. \n> \n>         I'm not clear on just what this does and how it can help us,\n>         and I would love to hear from somebody who's familiar with it.\n> \n>         I think we can do what we need to support the gamepad without\n>         using the atk, but maybe it could be helpful. But my\n>         impression is that it's more geared towards screen readers, is\n>         tied closely to the user interface layout (declaring that this\n>         label is associated with that control, etc), and it looks like\n> \tit takes a lot of lines of code to use (unless you use some\n> \tkind of framework that supports it automatically).\n> \n>       GTK has a \"UIManager\" that knows how to build menu bars, menus,\n>       toolbars and buttons from XML files, and tie together actions,\n>       accelerators, menus and toolbars. The XML describes the\n>       structure and layout of the user interface, but refers to the\n>       actions by name to configure the buttons and menu items with\n>       labels, icons, tooltips, accelerators, callbacks, and custom\n>       component classes. There is nothing in the XML about what label,\n>       icon, tooltip or widget class to use -- just an Action\n>       name. It's up to the Action to figure out the visual appearance\n>       and behavior of the gui. That's why it should be easier to use\n>       custom Action classes.\n> \n>         I think we need to write our own UIManager and accessibility\n>         framework that addresses our specific needs (like the\n>         focus/tooltip/disable reason issues discussed above, custom\n>         sugar controls, gamepad support, etc), because I don't think\n>         the UIManager (plus the pygtk utilities that go along with it)\n>         are flexible enough to support our needs. I think it would be\n>         easy to implement it in Python, in a way that would be a lot\n>         more flexible and easier to extend that the current C\n>         implementation of GTK's GuiManager.\n\n\nGTK UIManager also does not support tabbed toolbars and palettes (which\nwill display the accellerators).\n\nMarco\n\n_______________________________________________\nSugar mailing list\nSugar@laptop.org\nhttp://mailman.laptop.org/mailman/listinfo/sugar\n\n"}
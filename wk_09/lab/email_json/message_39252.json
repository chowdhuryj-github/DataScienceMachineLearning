{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23255 - in\n\tbranches/SAMBA_3_0_26/source/nsswitch: .", "body": "Author: obnox\nDate: 2007-05-30 22:57:46 +0000 (Wed, 30 May 2007)\nNew Revision: 23255\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23255\n\nLog:\nMerge the reworking of winbindd_ads lookup_groupmem function\nfrom 3_0: Call lsa_lookup_sids on the list of sids that\ncan not be resolved from cache, instead of passing each\nsingle sid to dn_lookup (which becomes obsoleten and is\nremoved). Weed out the sids that could not be resolved.\n\nThis merges r23072, r23078, r23252, r23253.\n\nMichael\n\n\nModified:\n   branches/SAMBA_3_0_26/source/nsswitch/winbindd_ads.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/nsswitch/winbindd_ads.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/nsswitch/winbindd_ads.c\t2007-05-30 22:43:11 UTC (rev 23254)\n+++ branches/SAMBA_3_0_26/source/nsswitch/winbindd_ads.c\t2007-05-30 22:57:46 UTC (rev 23255)\n@@ -402,50 +402,11 @@\n \treturn NT_STATUS_OK;\n }\n \n-/* convert a DN to a name, SID and name type \n-   this might become a major speed bottleneck if groups have\n-   lots of users, in which case we could cache the results\n-*/\n-static BOOL dn_lookup(ADS_STRUCT *ads, TALLOC_CTX *mem_ctx,\n-\t\t      const char *dn,\n-\t\t      char **name, uint32 *name_type, DOM_SID *sid)\n-{\n-\tLDAPMessage *res = NULL;\n-\tconst char *attrs[] = {\"userPrincipalName\", \"sAMAccountName\",\n-\t\t\t       \"objectSid\", \"sAMAccountType\", NULL};\n-\tADS_STATUS rc;\n-\tuint32 atype;\n-\tDEBUG(3,(\"ads: dn_lookup\\n\"));\n+/* If you are looking for \"dn_lookup\": Yes, it used to be here!\n+ * It has gone now since it was a major speed bottleneck in\n+ * lookup_groupmem (its only use). It has been replaced by\n+ * an rpc lookup sids call... R.I.P. */\n \n-\trc = ads_search_retry_dn(ads, &res, dn, attrs);\n-\n-\tif (!ADS_ERR_OK(rc) || !res) {\n-\t\tgoto failed;\n-\t}\n-\n-\t(*name) = ads_pull_username(ads, mem_ctx, res);\n-\n-\tif (!ads_pull_uint32(ads, res, \"sAMAccountType\", &atype)) {\n-\t\tgoto failed;\n-\t}\n-\t(*name_type) = ads_atype_map(atype);\n-\n-\tif (!ads_pull_sid(ads, res, \"objectSid\", sid)) {\n-\t\tgoto failed;\n-\t}\n-\n-\tif (res) \n-\t\tads_msgfree(ads, res);\n-\n-\treturn True;\n-\n-failed:\n-\tif (res) \n-\t\tads_msgfree(ads, res);\n-\n-\treturn False;\n-}\n-\n /* Lookup user information from a rid */\n static NTSTATUS query_user(struct winbindd_domain *domain, \n \t\t\t   TALLOC_CTX *mem_ctx, \n@@ -942,12 +903,19 @@\n \tchar *ldap_exp;\n \tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n \tchar *sidstr;\n-\tchar **members;\n+\tchar **members = NULL;\n \tint i;\n-\tsize_t num_members;\n-\tfstring sid_string;\n+\tsize_t num_members = 0;\n \tads_control args;\n+        struct rpc_pipe_client *cli;\n+        POLICY_HND lsa_policy;\n+\tDOM_SID *sid_mem_nocache = NULL;\n+\tchar **names_nocache = NULL;\n+\tuint32 *name_types_nocache = NULL;\n+\tchar **domains_nocache = NULL;     /* only needed for rpccli_lsa_lookup_sids */\n+\tuint32 num_nocache = 0;\n \n+\n \tDEBUG(10,(\"ads: lookup_groupmem %s sid=%s\\n\", domain->name, \n \t\t  sid_string_static(group_sid)));\n \n@@ -980,9 +948,6 @@\n \t}\n \tSAFE_FREE(sidstr);\n \n-\tmembers = NULL;\n-\tnum_members = 0;\n-\n \targs.control = ADS_EXTENDED_DN_OID;\n \targs.val = ADS_EXTENDED_DN_HEX_STRING;\n \targs.critical = True;\n@@ -996,74 +961,135 @@\n \t\tgoto done;\n \t} \n \t\n-\t/* now we need to turn a list of members into rids, names and name types \n-\t   the problem is that the members are in the form of distinguised names\n-\t*/\n-\n-\tif (num_members) {\n+\tDEBUG(10, (\"ads lookup_groupmem: got %d sids via extended dn call\\n\", num_members));\n+\t\n+\t/* Now that we have a list of sids, we need to get the\n+\t * lists of names and name_types belonging to these sids.\n+\t * even though conceptually not quite clean,  we use the \n+\t * RPC call lsa_lookup_sids for this since it can handle a \n+\t * list of sids. ldap calls can just resolve one sid at a time.\n+\t *\n+\t * At this stage, the sids are still hidden in the exetended dn\n+\t * member output format. We actually do a little better than\n+\t * stated above: In extracting the sids from the member strings,\n+\t * we try to resolve as many sids as possible from the\n+\t * cache. Only the rest is passed to the lsa_lookup_sids call. */\n+\t\n+\tif (num_names) {\n \t\t(*sid_mem) = TALLOC_ZERO_ARRAY(mem_ctx, DOM_SID, num_members);\n+\t\t(*names) = TALLOC_ZERO_ARRAY(mem_ctx, char *, num_members);\n \t\t(*name_types) = TALLOC_ZERO_ARRAY(mem_ctx, uint32, num_members);\n-\t\t(*names) = TALLOC_ZERO_ARRAY(mem_ctx, char *, num_members);\n+\t\t(sid_mem_nocache) = TALLOC_ZERO_ARRAY(mem_ctx, DOM_SID, num_members);\n \n \t\tif ((members == NULL) || (*sid_mem == NULL) ||\n-\t\t     (*name_types == NULL) || (*names == NULL)) {\n+\t\t    (*names == NULL) || (*name_types == NULL) ||\n+\t\t    (sid_mem_nocache == NULL))\n+\t\t{\n \t\t\tDEBUG(1, (\"talloc failed\\n\"));\n \t\t\tstatus = NT_STATUS_NO_MEMORY;\n \t\t\tgoto done;\n \t\t}\n-\t} else {\n+\t}\n+\telse {\n \t\t(*sid_mem) = NULL;\n+\t\t(*names) = NULL;\n \t\t(*name_types) = NULL;\n-\t\t(*names) = NULL;\n \t}\n- \n-\tfor (i=0;i 0) {\n \n+\t\tstatus = cm_connect_lsa(domain, mem_ctx, &cli, &lsa_policy);\n+\n+\t\tif (!NT_STATUS_IS_OK(status)) {\n+\t\t\tgoto done;\n \t\t}\n-\t}\t\n \n+\t\tstatus = rpccli_lsa_lookup_sids_all(cli, mem_ctx, \n+\t\t\t\t\t\t    &lsa_policy,\n+\t\t\t\t\t\t    num_nocache, \n+\t\t\t\t\t\t    sid_mem_nocache, \n+\t\t\t\t\t\t    &domains_nocache, \n+\t\t\t\t\t\t    &names_nocache, \n+\t\t\t\t\t\t    &name_types_nocache);\n+\n+\t\tif (NT_STATUS_IS_OK(status) ||\n+\t\t    NT_STATUS_EQUAL(status, STATUS_SOME_UNMAPPED)) \n+\t\t{\n+\t\t\t/* Copy the entries over from the \"_nocache\" arrays \n+\t\t\t * to the result arrays, skipping the gaps the \n+\t\t\t * lookup_sids call left. */\n+\t\t\t*num_names = 0;\n+\t\t\tfor (i=0; i < num_nocache; i++) {\n+\t\t\t\tif (((names_nocache)[i] != NULL) && \n+\t\t\t\t    ((name_types_nocache)[i] != SID_NAME_UNKNOWN)) \n+\t\t\t\t{\n+\t\t\t\t\tsid_copy(&(*sid_mem)[*num_names],\n+\t\t\t\t\t\t &sid_mem_nocache[i]);\n+\t\t\t\t\t(*names)[*num_names] = names_nocache[i];\n+\t\t\t\t\t(*name_types)[*num_names] = name_types_nocache[i];\n+\t\t\t\t\t(*num_names)++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse if (NT_STATUS_EQUAL(status, NT_STATUS_NONE_MAPPED)) {\n+\t\t\tDEBUG(10, (\"lookup_groupmem: lsa_lookup_sids could \"\n+\t\t\t\t   \"not map any SIDs at all.\\n\"));\n+\t\t\t/* Don't handle this as an error here.\n+\t\t\t * There is nothing left to do with respect to the \n+\t\t\t * overall result... */\n+\t\t}\n+\t\telse if (!NT_STATUS_IS_OK(status)) {\n+\t\t\tDEBUG(10, (\"lookup_groupmem: Error looking up %d \"\n+\t\t\t\t   \"sids via rpc_lsa_lookup_sids: %s\\n\",\n+\t\t\t\t   num_members, nt_errstr(status)));\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n \tstatus = NT_STATUS_OK;\n-\tDEBUG(3,(\"ads lookup_groupmem for sid=%s succeeded\\n\", sid_to_string(sid_string, group_sid)));\n+\tDEBUG(3,(\"ads lookup_groupmem for sid=%s succeeded\\n\",\n+\t\t sid_string_static(group_sid)));\n+\n done:\n \n \tif (res) \n \t\tads_msgfree(ads, res);\n \n+\t/* free intermediate lists. - a temp talloc ctx might be better. */\n+\tTALLOC_FREE(sid_mem_nocache);\n+\tTALLOC_FREE(names_nocache);\n+\tTALLOC_FREE(name_types_nocache);\n+\tTALLOC_FREE(domains_nocache);\n+\n \treturn status;\n }\n \n\n"}
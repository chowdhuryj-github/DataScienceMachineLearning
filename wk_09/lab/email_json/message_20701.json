{"category": "ham", "to_address": "beginners@perl.org", "from_address": "zentara <zentara@highstream.net>", "subject": "Re: Encryption", "body": "On Mon, 30 Apr 2007 12:48:57 +0200, andreas.moroder@sb-brixen.it\n(Andreas Moroder) wrote:\n\n \n>> To be honest, I would assume that the Oracle designers have made this\n>> quite tricky to avoid hacking their passwords.\n>According to the document this is not true.\n>I will try your code later.\n>Thank you\n>Andreas\n\nHi, there seems to be some discrepancies between the 2 explanations of\nthe steps to take. Maybe I'm misunderstanding it all. (probably)\n\nAnyways, here is a quick try I made. It dosn't work right I'm sure, but\nthere are some routines in there that may speed up your attempts at\na script.  I would ask this on perlmonks.org where the REAL perl brains\nare.... I'm just an amateur.\n\nI'm still unclear about the stripping the 8th bit thing. \nAlso when they say to convert the string to utf16, maybe they mean\nchar-by-char, instead of a whole string conversion?\n\nThis is blowin my mind. :-)\nGood Luck.\n\n#!/usr/bin/perl\nuse warnings;\nuse strict;\nuse Crypt::CBC;\nuse Encode;\n\n=head1\nI have to calculate a hash of username and password in perl.\nThe calculation should be done this way:\n\n1. Concatenate the username and the password to produce a plaintext\nstring;\n2. Convert the plaintext string to uppercase characters;\n3. Convert the plaintext string to multi-byte storage format; ASCII \ncharacters have the\nhigh byte set to 0x00;\n4. Encrypt the plaintext string (padded with 0s if necessary to the next\neven block length)\nusing the DES algorithm in cipher block chaining (CBC) mode with a fixed\nkey value of\n0x0090687678ABCDEF;\n5. Encrypt the plaintext string again with DES-CBC, but using the last \nblock of the output\nof the previous step (ignoring parity bits) as the encryption key. The \nlast block of the\noutput is converted into a printable string to produce the password hash\nvalue.\n\nIs it possible to implement this in perl ?\nIs the Crypt-DES Module on CPAN the right module and how can I convert \nstandard string to Multibyte storage ( UTF-16 ? )\nAn example ist\n\nUser: example\npassword: test\nhash: BDA63848A8C31752\n\n\n# more detailed explanation\n\nDave Trahan wants to know the Oracle password algorithm so\nhe can check for weak passwords.  When I was the project\nlead for Trusted Oracle I designed the new password algorithm\nthat is used in versions 6, 7, and later.  I presented the\ndetails at a Bay Area Trusted System Symposium so I am not\nrevealing any information that is not already in the puiblic\ndomain.  Here are some of the details as I remember them.\n\nDesign Goals:\n1. Must work with all terminals.\n   ===> Some terminals do not have lowercase letters, so\n        the password algorithm ignores differences between\n        upper and lower case!!!  The passwords \"Tiger\"\n        and \"tiger\" map to the same value.\n\n2. Must support usernames and passwords that include non-ascii\n   characters.\n        The username and password are converted to\n        16 bit per character representation before any processing\n        is done.  Ascii characters have the high byte zeroed.\n\n3. If different users have the same password, then the one-way\n   hash value (encrypted value) for the passwords will be different.\n\n4. Long passwords are supported.\n        I believe that usernames and passwords can both be 40 chars.\n\nImplementation:\n1.  Upshift password, convert to 16bits per character, and place\n    result left justified in an 80 byte array of zeros.\n\n2.  Using DES in cipher block feedback mode compute the CBC checksum for\n    the 80 byte password array using a fixed secret password (you can\nfind\n    it in the code if you look hard enough).  The result is used as the\n    key for the next step ignoring parity bits to produce the a 56 bit\n    key from the CBC.\n\n3.  Upshift password, and convert to 16bits per character, and place\n    result left justified in an 80 byte array of zeros.\n\n4.  Using DES in cipher block feedback mode compute the CBC checksum\n    for the 80 byte username array using the key generate in step 2.\n\n5.  Convert the CBC checksum from step 4 into a printable string with\n    the obvious algorithm.\n\n                --Bob Baldwin\nDirector of Development                 We provide the best solutions\nLos Altos Technologies, Inc.            to our customers key security\nbald...\n=cut\n\n# start test script #################################\n\nmy $key = pack(\"H16\", \"0090687678ABCDEF\");\nmy $user = 'example';\nmy $password = 'test';\n\nmy $plaintext = uc($user.$password);\nprint(\"$plaintext\\n\");\n\n#converted it to bytes via utf-16 (take a look at \"perldoc perlunicode\")\nmy  $octets = encode(\"utf-16\", $plaintext);\nprint \"utf16->  $octets\\n\";\n\nmy $cipher = Crypt::CBC->new(\n   -key    => $key,\n   -cipher => 'DES',\n   -salt   => 1,\n);\n\nmy $ciphertext = $cipher->encrypt($octets);\nprint(\"$ciphertext\\n\");\n\n\nmy( $hex ) = unpack( 'H*', $ciphertext );\nprint $hex,\"\\n\";\nmy $temp = uc(substr($hex,length($hex)-16,16));\nprint \"\\n$temp\\n\";\n\nmy $key1 = pack(\"H16\", $temp);\n\nmy $cipher1 = Crypt::CBC->new(\n   -key    => $key1,\n   -cipher => 'DES',\n   -salt   => 1,\n);\n\n\nmy $ciphertext1 = $cipher1->encrypt($octets);\nprint(\"$ciphertext1\\n\");\nmy( $hex1 ) = unpack( 'H*', $ciphertext1 );\nprint $hex1,\"\\n\";\n\nmy $temp1 = uc(substr($hex1,length($hex1)-16,16));\nprint \"\\n$temp1\\n\";\n\n__END__\n\n\nzentara\n\n\n\n-- \nI'm not really a human, but I play one on earth.\nhttp://zentara.net/japh.html\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
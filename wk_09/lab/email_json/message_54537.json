{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Michael Scondo <michael.scondo@phil.stud.uni-erlangen.de>", "subject": "Re: strange unexpected deadlock", "body": "On Saturday 23 June 2007 15:08, Tom Phoenix wrote:\n> On 6/23/07, Michael Scondo  wrote:\n> > sub thread1{\n> >                 print \"1\\n\";\n> >                 lock $x;\n> >                 print \"locked x: 1\\n\";\n> >                 cond_wait $x;\n>\n> Can't get past here until $x is signalled by another thread, and\n> unlocked by all other threads.\n>\n\n> As written, this is the end-of-scope for the lock on $x (as well as\n> the one on $y). But unless some third thread can rescue these first\n> two, they seem to be deadlocked, with the first waiting for $x to be\n> unlocked and the second waiting for $y to be signalled.\n>\n\n\nThanks a lot for you explanation !\nI didn't read the manual carefully enough....\n\nTherefore I didn't realize that cond_wait locks a variable again AFTER it has \nbeen signalled.\n\n\n> As you discovered, using the inner braces will release the lock on $x\n> soon enough to avoid the deadlock.\n>\n> By the way, thanks greatly for the detailed, self-contained test case;\n> it showed exactly what you were doing.\n>\nDNRTFM\nDid not read the fucking manual...\n\n\nThanks again for your help,\nMichael\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
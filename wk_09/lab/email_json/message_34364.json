{"category": "ham", "to_address": "Allison Randal <allison@perl.org>, p2 <parrot-porters@perl.org>", "from_address": "\"Patrick R. Michaud\" <pmichaud@pobox.com>", "subject": "Re: PMC architecture discussion", "body": "On Tue, May 22, 2007 at 08:20:19AM -0500, Patrick R. Michaud wrote:\n> On Tue, May 22, 2007 at 01:25:33PM +0100, Nicholas Clark wrote:\n> > \n> > And how often does the type of a PMC change, such that its internal \n> > data layout changes? In Perl 5 this morphing happens everywhere, \n> > but in Parrot?\n\nIn fact, this is probably a really good spot for me to review\nwhat I've been coming across with PMCs and assignment in general.\n\nReturning to the Perl 6 example I gave earlier:\n\n    my @a = (1, 2, 3);\n    my $b := @a[2];\n  \n    @a[2] = foo();\n\nThe simplified code that I gave for the last assignment operation\nlooked like:\n\n  ##  @a[2] = foo();\n    $P4 = 'foo'()                   # $P4 could be any type\n    find_lex $P5, '@a'              # look up @a\n    set $P6, $P5[2]                 # get reference to @a[2]\n    assign $P6, $P4                 # $P6 needs to morph \n                                    #   to whatever type $P4 is\n\nNow let's remove the simplifications so that we can see what\nis really having to take place.  First, the C opcode\non arbitrary types doesn't do morphing.  However, assigning to\nan .Undef object will cause it to morph to the target type.\nSo, what PAST-pm does in its code generation for assignment\nis to first morph the target object into an .Undef, and then \nperform the assignment:\n\n  ##  @a[2] = foo();\n    $P4 = 'foo'()                   # $P4 could be any type\n    find_lex $P5, '@a'              # look up @a\n    set $P6, $P5[2]                 # get reference to @a[2]\n    morph $P6, .Undef               # morph @a[2] to an Undef\n    assign $P6, $P4                 # and assign $P4 to that Undef\n\nThanks to Matt Diephouse for letting me know about this approach.\n\nNow then, this assumes that every type knows how to morph itself\ninto an .Undef and that .Undef can handle assignment from any type.\nFor many PMC classes this isn't (or hasn't been) the case; from\ntime to time we stumble across another type that doesn't know\nhow to morph itself to .Undef or for which .Undef cannot handle\nthe assignment.  When this happens either Matt or I have gone\nin and updated the PMC code to allow these conversions -- the\nprime example is .Sub, but there have been a few others.\n\nThere's more.  The PIR code above for assignment also assumes\nthat @a[2] already exists, which might not be the case.  If\n@a[2] doesn't exist, then $P6 comes back as NULL, and we\ncan't morph a NULL into .Undef.  So the code ends up looking \nlike:\n\n  ##  @a[2] = foo();\n    $P4 = 'foo'()                   # $P4 could be any type\n    find_lex $P5, '@a'              # look up @a\n    set $P6, $P5[2]                 # get reference to @a[2]\n    unless_null $P6, do_morph       # if exists, morph it\n    new $P6, .Undef                 # create a new object\n    set $P5[2], $P6                 # bind @a[2] to the new object\n    goto do_assign                  # now do the assignment\n  do_morph: \n    morph $P6, .Undef               # morph @a[2] to an Undef\n  do_assign:\n    assign $P6, $P4                 # and assign $P4 to that Undef\n\nAnd, of course, the code generally ends up looking slightly \ndifferent if we're talking about assigning to lexical or global\nvariables instead of a keyed object.  For example, in the above\nassignment, if '@a' doesn't already exist we need to vivify it also:\n\n  ##  @a[2] = foo();\n    $P4 = 'foo'()                   # $P4 could be any type\n    find_lex $P5, '@a'              # look up @a\n    unless_null $P5, assign_1       # does @a exist?\n    $P5 = new .ResizablePMCArray    # create an object for @a\n    store_lex '@a', $P5             # store it\n  assign_1:\n    set $P6, $P5[2]                 # get reference to @a[2]\n    unless_null $P6, do_morph       # does @a[2] exist?\n    new $P6, .Undef                 # no, create a new object\n    set $P5[2], $P6                 #     bind @a[2] to the new object\n    goto do_assign                  #     now do the assignment\n  do_morph: \n    morph $P6, .Undef               # morph @a[2] to an Undef\n  do_assign:\n    assign $P6, $P4                 # and assign $P4 to that Undef\n\nThis is what the code tends to look like for each assignment\noperation coming out of PAST-pm.  Not very pretty.\n\nOn irc:#parrot I've speculated that it might be really useful to\nhave opcodes or functions that encapsulate the above into something \na bit smaller (and hopefully written in C to be faster).  I'm\nthinking that we're missing an \"assign_keyed\" opcode, although\nit should probably be called something besides \"assign_*\" because\nthe vrsion I want would create and morph targets as needed\n(the current \"assign\" opcode doesn't do morphing unless the\ntarget object explicitly enables it).  But, sticking with the\nslightly-off \"assign_keyed\" name for now, we'd have\n\n  ##  @a[2] = foo();\n    $P4 = 'foo'()                   # $P4 could be any type\n    find_lex $P5, '@a'              # look up @a\n    unless_null $P5, assign_1       # does @a exist?\n    $P5 = new .ResizablePMCArray    # create an object for @a\n    store_lex '@a', $P5             # store it\n  assign_1:\n    assign_keyed $P5, 2, $P4       # perform assignment\n\nOr perhaps that last statement should be written\n\n    assign $P5[2], $P4\n\nwith my earlier caveat that for *this* version of the assign\nopcode, I want it to create and/morph the target object as\nneeded to match the type of $P4.\n                                    \nFor package-scoped and global variables we'd just use \nassign_keyed on the namespace objects instead of having to \nbe concerned with the separate set_global, set_hll_global, \nor set_root_global opcodes:\n\n  ## our $y; $y = foo();\n    $P0 = 'foo'()\n    $P1 = get_namespace\n\n    assign_keyed $P1['$y'], $P0\n\nAgain, this is much nicer than the current:\n\n  ## our $y; $y = foo();\n    $P0 = 'foo'()\n    get_global $P1, '$y'\n    unless_null $P1, assign_1\n    clone $P1, $P0\n    set_global $P1, '$y'\n    goto done\n  assign_1:\n    morph $P1, .Undef\n    assign $P1, $P0\n  done:\n\nAlso, we get a win because we can get the namespace just\nonce at the beginning of any sub that needs it, instead of\na separate find_global/test existence/store_global for\neach assignment operation:\n\n  ## our $x, $y, $z; $x = foo(); $y = bar(); $z = baz();\n    $P0 = get_namespace\n\n    $P1 = 'foo'()\n    assign_keyed $P0['$x'], $P1\n\n    $P2 = 'bar'()\n    assign_keyed $P0['$y'], $P2\n\n    $P3 = 'baz'()\n    assign_keyed $P0['$z'], $P3\n\nWe might also need to have an assign_lex opcode that\nprovides the \"create/morph target as needed\" semantics\nthat are currently missing.  Again, my caveat that perhaps\n\"assign\" is the wrong word here, to avoid semantic confusion\nwith the existing \"assign\" opcode that doesn't provide morphing\nof the targets [1].\n\nOr perhaps we should just change the existing assign opcode\nto morph targets by default, in which case we don't need\nassign_lex.  But I don't know the full ramifications of that\nsort of fundamental design change.\n\nPm\n\n[1]  Parrot does automatically morph between Integer, Float, and\n     String types when using \"assign\", but this is part of the\n     semantics of those types and not the assign opcode itself.\n     Other types don't automatically morph via assign, thus we\n     have to go through the .Undef type as described above.\n\n"}
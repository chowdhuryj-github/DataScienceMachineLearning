{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "sfrench@samba.org", "subject": "svn commit: samba r22779 - in branches/SAMBA_3_0/source/client: .", "body": "Author: sfrench\nDate: 2007-05-10 19:16:36 +0000 (Thu, 10 May 2007)\nNew Revision: 22779\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22779\n\nLog:\nPatch for not prompting for password on cifs mounts when \"sec=none\"\nspecified\n\n\nModified:\n   branches/SAMBA_3_0/source/client/mount.cifs.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/client/mount.cifs.c\n===================================================================\n--- branches/SAMBA_3_0/source/client/mount.cifs.c\t2007-05-10 19:12:32 UTC (rev 22778)\n+++ branches/SAMBA_3_0/source/client/mount.cifs.c\t2007-05-10 19:16:36 UTC (rev 22779)\n@@ -79,8 +79,8 @@\n static char * mountpassword = NULL;\n char * domain_name = NULL;\n char * prefixpath = NULL;\n+char * servern = NULL;\n \n-\n /* BB finish BB\n \n         cifs_umount\n@@ -128,7 +128,8 @@\n \tstruct passwd *password = getpwuid(getuid());\n \n \tif (password) {\n-\t\tusername = password->pw_name;\n+\t\tif(password->pw_name);\n+\t\t\tusername = strdup(password->pw_name);\n \t}\n \treturn username;\n }\n@@ -419,6 +420,11 @@\n \t\t\t\tprintf(\"password too long\\n\");\n \t\t\t\treturn 1;\n \t\t\t}\n+\t\t} else if (strncmp(data, \"sec\", 3) == 0) {\n+\t\t\tif (value) {\n+\t\t\t\tif (!strcmp(value, \"none\"))\n+\t\t\t\t\tgot_password = 1;\n+\t\t\t}\n \t\t} else if (strncmp(data, \"ip\", 2) == 0) {\n \t\t\tif (!value || !*value) {\n \t\t\t\tprintf(\"target ip address argument missing\");\n@@ -567,8 +573,6 @@\n \t\t\t*filesys_flags &= ~MS_NOEXEC;\n \t\t} else if (strncmp(data, \"guest\", 5) == 0) {\n \t\t\tgot_password=1;\n-                        /* remove the parm since it would otherwise be logged by kern */\n-\t\t\tgoto nocopy;\n \t\t} else if (strncmp(data, \"ro\", 2) == 0) {\n \t\t\t*filesys_flags |= MS_RDONLY;\n \t\t} else if (strncmp(data, \"rw\", 2) == 0) {\n@@ -805,6 +809,9 @@\n \t\t\t\tif(got_ip == 0) {\n \t\t\t\t\thost_entry = gethostbyname(unc_name);\n \t\t\t\t}\n+\t\t\t\tif(strnlen(unc_name, 16) < 16) {\n+\t\t\t\t\tservern = strdup(unc_name);\n+\t\t\t\t}\n \t\t\t\t*(share - 1) = '/'; /* put the slash back */\n \t\t\t\tif ((prefixpath = strchr(share, '/'))) {\n \t\t\t\t\t*prefixpath = 0;  /* permanently terminate the string */\n@@ -880,7 +887,7 @@\n \tchar * ipaddr = NULL;\n \tchar * uuid = NULL;\n \tchar * mountpoint = NULL;\n-\tchar * options;\n+\tchar * options = NULL;\n \tchar * resolved_path;\n \tchar * temp;\n \tint rc;\n@@ -892,6 +899,7 @@\n \tint optlen = 0;\n \tint orgoptlen = 0;\n \tint retry = 0; /* set when we have to retry mount with uppercase */\n+\tint retry_with_rfc1001name = 0; /* set when we have to retry with netbios name */\n \tstruct stat statbuf;\n \tstruct utsname sysinfo;\n \tstruct mntent mountent;\n@@ -1152,26 +1160,40 @@\n \t\toptlen += strlen(ipaddr) + 4;\n \tif(mountpassword)\n \t\toptlen += strlen(mountpassword) + 6;\n-\toptions = (char *)malloc(optlen + 10 + 64 /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n+\tif(options) {\n+\t        printf(\"\\norg options %s at %p\\n\", options, options); /* BB removeme BB */\n \n+\t\tfree(options);\n+\t}\n+\toptions = malloc(optlen + 10 + 64 /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */) + 9 /* servern=\" */ + 16 /* space for maximum RFC1001 name */;\n \tif(options == NULL) {\n \t\tprintf(\"Could not allocate memory for mount options\\n\");\n \t\treturn -1;\n \t}\n-\t\t\n \n+\tprintf(\"\\noptions %s at %p\\n\", options, options); /* BB removeme BB */\t\t\n+\toptions = realloc(options, 3350); /* BB removeme BB */\n+\tprintf(\"\\nrealloc seems ok\\n\"); /* BB removeme BB */\n \toptions[0] = 0;\n \tstrncat(options,\"unc=\",4);\n \tstrcat(options,share_name);\n \t/* scan backwards and reverse direction of slash */\n \ttemp = strrchr(options, '/');\n+\toptions = realloc(options, 980); /* BB removeme BB */\n+\tprintf(\"\\nrealloc seemms very ok\\n\"); /* BB removeme BB */\n \tif(temp > options + 6)\n \t\t*temp = '\\\\';\n \tif(ipaddr) {\n \t\tstrncat(options,\",ip=\",4);\n \t\tstrcat(options,ipaddr);\n \t}\n-\n+\tif((servern) && retry_with_rfc1001name) {\n+\t\tstrcat(options, \",servern=\");\n+\t\tstrcat(options, servern);\n+\t}\t\n+        printf(\"\\noptions1 %s at %p\\n\", options, options); /* BB removeme BB */\n+        options = realloc(options, 1000); /* BB removeme BB */\n+\tprintf(\"realloc1 ok\\n\"); /* BB removeme BB */\n \tif(user_name) {\n \t\t/* check for syntax like user=domain\\user */\n \t\tif(got_domain == 0)\n@@ -1195,6 +1217,7 @@\n \t\tstrncat(options,\",pass=\",6);\n \t\tstrcat(options,mountpassword);\n \t}\n+        printf(\"\\noptions2 %s at %p\\n\", options, options); /* BB removeme BB */\n \n \tstrncat(options,\",ver=\",5);\n \tstrcat(options,MOUNT_CIFS_VERSION_MAJOR);\n@@ -1203,6 +1226,9 @@\n \t\tstrcat(options,\",\");\n \t\tstrcat(options,orgoptions);\n \t}\n+\n+        printf(\"\\noptions2 at %p\\n\", options); /* BB removeme BB */\n+\n \tif(prefixpath) {\n \t\tstrncat(options,\",prefixpath=\",12);\n \t\tstrcat(options,prefixpath); /* no need to cat the / */\n@@ -1220,6 +1246,22 @@\n \t\tcase ENODEV:\n \t\t\tprintf(\"mount error: cifs filesystem not supported by the system\\n\");\n \t\t\tbreak;\n+\t\tcase ENOENT:\n+\t\tcase EHOSTDOWN:\n+\t\t\t/* If this is so old as to not support *SMBSERVER called\n+\t\t\t   name for RFC1001, we can get this error . We also\n+\t\t\t   need to uppercase the sharename for these old servers\n+\t\t\t   so fall through to retry code below. On retry the\n+\t\t\t   code will add \"servern=\" */\n+\t\t\ttmp = servern;\n+\t\t\tif((retry == 0) && tmp) {\n+\t\t\t\tretry_with_rfc1001name = 1;\n+\t\t\t\twhile (*tmp && !(((unsigned char)tmp[0]) & 0x80)) {\n+\t\t\t\t\t*tmp = toupper((unsigned char)*tmp);\n+\t\t\t\t\ttmp++;\n+\t\t\t\t}\n+\t\t\t\tprintf(\"Adding Netbios name of server to mount based on server part of UNC name\\n\");\n+\t\t\t}\n \t\tcase ENXIO:\n \t\t\tif(retry == 0) {\n \t\t\t\tretry = 1;\n@@ -1290,7 +1332,9 @@\n \t}\n \n \tif(options) {\n-\t\tmemset(options,0,optlen);\n+\t\toptions = realloc(options, 1000); /* BB removeme BB */\n+\t\tprintf(\"\\noptions freed %p\\n\", options); /* BB removeme BB */\n+/* memset(options,0,optlen); */\n \t\tfree(options);\n \t}\n \n@@ -1301,10 +1345,17 @@\n \tif(resolved_path) {\n \t\tfree(resolved_path);\n \t}\n+\t\n+\tif(servern) {\n+\t\tfree(servern);\n+\t}\n \n \tif(free_share_name) {\n \t\tfree(share_name);\n-\t\t}\n+\t}\n+\tif(user_name)\n+\t\tfree(user_name);\n+\n \treturn rc;\n }\n \n\n"}
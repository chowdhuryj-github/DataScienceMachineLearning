{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 266: merged ronnies code to delay client requests when in\n\trecovery mode in http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 266\nrevision-id: tridge@samba.org-20070509214318-io4xhj2e6k91eosm\nparent: tridge@samba.org-20070509015437-c9u6pubosc3jz0um\nparent: sahlberg@ronnie-20070509040811-460ac8e7d6691f7f\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Thu 2007-05-10 07:43:18 +1000\nmessage:\n  merged ronnies code to delay client requests when in recovery mode\nmodified:\n  common/ctdb_daemon.c           ctdb_daemon.c-20070409200331-3el1kqgdb9m4ib0g-1\n    ------------------------------------------------------------\n    revno: 197.1.90\n    merged: sahlberg@ronnie-20070509040811-460ac8e7d6691f7f\n    parent: sahlberg@ronnie-20070509040647-f8724a40b8a205e5\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Wed 2007-05-09 14:08:11 +1000\n    message:\n      hang the event from the retry structure instead of the hdr structure\n    ------------------------------------------------------------\n    revno: 197.1.89\n    merged: sahlberg@ronnie-20070509040647-f8724a40b8a205e5\n    parent: sahlberg@ronnie-20070508235923-78a4589b69fa8935\n    committer: Ronnie Sahlberg \n    branch nick: ctdb\n    timestamp: Wed 2007-05-09 14:06:47 +1000\n    message:\n      when we are in recovery mode and we get a REQ_CALL from a client,\n      defer it for one second and try again   \n=== modified file 'common/ctdb_daemon.c'\n--- a/common/ctdb_daemon.c\t2007-05-08 23:59:23 +0000\n+++ b/common/ctdb_daemon.c\t2007-05-09 21:43:18 +0000\n@@ -334,6 +334,30 @@\n }\n \n \n+struct ctdb_client_retry {\n+\tstruct ctdb_client *client;\n+\tstruct ctdb_req_call *call;\n+};\n+\n+static void daemon_request_call_from_client(struct ctdb_client *client, \n+\t\t\t\t\t    struct ctdb_req_call *c);\n+\n+/*\n+  triggered after a one second delay, retrying a client packet\n+  that was deferred because of the daemon being in recovery mode\n+ */\n+static void retry_client_packet(struct event_context *ev, struct timed_event *te, \n+\t\t\t\tstruct timeval t, void *private_data)\n+{\n+\tstruct ctdb_client_retry *retry = talloc_get_type(private_data, struct ctdb_client_retry);\n+\n+\tdaemon_request_call_from_client(retry->client, retry->call);\n+\n+\ttalloc_free(retry);\n+}\n+\n+\n+\n /*\n   this is called when the ctdb daemon received a ctdb request call\n   from a local client over the unix domain socket\n@@ -350,6 +374,29 @@\n \tint ret;\n \tstruct ctdb_context *ctdb = client->ctdb;\n \n+\tif (ctdb->recovery_mode != CTDB_RECOVERY_NORMAL) {\n+\t\tstruct ctdb_client_retry *retry;\n+\t\t\n+\t\tDEBUG(0,(__location__ \" ctdb call %u from client\"\n+\t\t\t \" while we are in recovery mode. Deferring it\\n\", \n+\t\t\t c->hdr.reqid)); \n+\n+\t\t/* hang the event and the structure off client */\n+\t\tretry = talloc(client, struct ctdb_client_retry);\n+\t\tCTDB_NO_MEMORY_VOID(ctdb, retry);\n+\t\tretry->client = client;\n+\t\tretry->call   = c;\n+\t\t\n+\t\t/* this ensures that after the retry happens we\n+\t\t   eventually free this request */\n+\t\ttalloc_steal(retry, c);\n+\t\t\n+\t\tevent_add_timed(ctdb->ev, retry, timeval_current_ofs(1,0), retry_client_packet, retry);\n+\t\treturn;\n+\t}\n+\n+\n+\n \tctdb->status.total_calls++;\n \tctdb->status.pending_calls++;\n \n\n"}
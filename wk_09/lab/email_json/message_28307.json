{"category": "ham", "to_address": "beginners@perl.org", "from_address": "Steve Bertrand <iaccounts@ibctech.ca>", "subject": "Re: $1 $2 var confusion", "body": "> From perldoc perlre:\n> \n>    The numbered match variables ($1, $2, $3, etc.) and the related\n>    punctuation set ($+, $&, $`, $', and $^N) are all dynamically scoped\n>    until the end of the enclosing block or until the next successful match,\n>    whichever comes first.\n> \n> In your first example, $1 is valid until the successful match\n> /domain\\.com/, when\n> it becomes undefined as there are no capturing parentheses. In the\n> second example\n> $1 retains its value since the match fails.\n\nThis makes it crystal clear.\n\n> \n> It's always safer to save captured strings before you use them, and I\n> would never\n> make a capture variable the target of a regex match as in your $2 !~\n> /domain\\.com/.\n\nI agree...this was a piece of legacy code I am replacing. I ALWAYS name\nmy variables prior to doing any work on them, and as such, I've never\nused the numbered variables in that manner as to run into such a\n'quirk'. RTFM (as quoted) cleared it up for me.\n\n> and also, in this case, the test would be better as\n> \n>  unless ($host eq 'domain.com') {\n>    print \"Host name is bad\\n\";\n>  }\n> \n> unless you really want to test whether the host name /contains/ that\n> string?\n\nLike I said, legacy stuff I'm replacing.\n\n\n> Oh, and I think I also prefer\n> \n>  my ($name, $host) = split /@/, $email;\n> \n> instead of the first regex.\n\nYes, agreed.\n\nThanks so much!\n\nSteve\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
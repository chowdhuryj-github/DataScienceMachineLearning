{"category": "ham", "to_address": "p2 <parrot-porters@perl.org>", "from_address": "Allison Randal <allison@perl.org>", "subject": "PMC architecture discussion", "body": "I've been reviewing the PMC proposals on hand to finish off the PMC PDD. \nHere are a few thoughts on the matter, for mailing list discussion. \nOverall, the current structure of PMCs is sound, and allows a good bit \nof flexibility.\n\nI'd like to do away with the PMC_DATA_IN_EXT flag so the \"DPOINTER \n*data;\" struct element is always in the PMC struct instead of being \nsometimes in the PMC struct and sometimes in the PMC_EXT struct. Access \nis all hidden behind macros anyway, so the change shouldn't affect \nanything outside of include/parrot/pobj.h. And, PMC_DATA_IN_EXT is \ncurrently set to 1 in include/parrot/pobj.h, and never unset anywhere in \nthe repository.\n\nOn variable-sized PMCs, I generally agree with the goals the proposal is \ntrying to accomplish, but I want to tackle these goals in a simpler way. \nOne of the goals mentioned for the proposal was to shrink down the size \nof PMCs, but it's hard to get much smaller than a struct containing 1 \nstruct, 1 pointer to a struct, and a pointer to the vtable, where both \nof the 2 contained structs can be null.\n\nSo, rather than making the core PMC struct variable sized, I want to \nmake one of its contained structs variable sized. This is already a \ncommon practice, storing a structure pointer in PMC_data. I also want to \neliminate the union value from the pobj_t struct. The concept that a PMC \ncontains either a buffer, 2 pointers, 2 ints, a float val, or a string \nval, and that these all must overlap in storage is shortsighted. One \nthing that would convince me otherwise is the argument that it's good to \nhave some core PMC data accessible without a pointer dereference. \nStanding against that is the fact that we're currently allocating (a \nsmall piece of) memory for every PMC that may never be used.\n\nThis is the current implementation:\n\n     struct PMC {\n         pobj_t obj;\n         VTABLE *vtable;\n  #if ! PMC_DATA_IN_EXT\n         DPOINTER *data;\n  #endif\n         struct PMC_EXT *pmc_ext;\n     };\n\n---\n     typedef struct pobj_t {\n         UnionVal u;\n         Parrot_UInt flags;\n     } pobj_t;\n\n---\n     struct PMC_EXT {\n  #if PMC_DATA_IN_EXT\n         DPOINTER *data;\n  #endif\n         PMC *_metadata;\n         struct _Sync *_synchronize;\n         PMC *_next_for_GC;\n     };\n\nThis is an alternate structure I'm considering:\n\n     struct PMC {\n         Parrot_UInt flags;\n         DPOINTER *data;          /* Modifiable for each PMC */\n         VTABLE *vtable;\n         struct PMC_EXT *pmc_ext; /* auxiliary data */\n     };\n\n---\n     struct PMC_EXT {\n         PMC *_roles;                /* runtime roles */\n         PMC *_metadata;             /* properties, replaced by a role */\n         struct _Sync *_synchronize; /* [to be deprecated, see STM] */\n         PMC *_next_for_GC;          /* [GC hack, may be replaced] */\n     };\n\n\n(flags could move into the PMC_EXT struct, depending on whether we think \nit will be frequently accessed. It's a question of speed of access \nversus size of the core PMC allocation.)\n\nCombining this with the proposal to give PMCs a vtable function \nresponsible for constructing the PMC: calling the C opcode \nconstructs the core PMC struct for all PMCs, and then calls the \nC (or C) vtable function. Each PMC that overrides \nC creates its own struct to store in C. The C \nPMC's C does nothing. C is separated from C \nso they can be overridden separately.\n\nTo accommodate low-level role composition, the C struct for a PMC \nisn't defined directly in C, it's defined with a bit of Pmc2c syntactic \nsugar. Pmc2c takes all the struct members defined in the PMC and in any \ncompile-time roles and builds them into one struct for the PMC. Also \nincluded are any struct members defined in inherited PMCs. (A PMC is not \npermitted to redefine any struct members defined in parents, and roles \nmay not contain struct members of the same name. Yes, this is rather \nstrict, but it is C.)\n\nFor backward compatibility, some of the first defined roles will provide \n  the simple structures that the union of the current implementation can \ncontain without being a union type (a buffer, 2 pointers, 2 ints, a \nfloat val, or a string val).\n\nLow-level PMCs can also have roles composed at runtime, but these are \nentirely different creatures. They are added through the C \nvtable function and live in a PMC data structure that hangs off the \nPMC_EXT struct. Runtime composed roles are Role PMCs or subclasses of \nthe Role PMC.\n\nThoughts and comments welcome.\n\nAllison\n\n"}
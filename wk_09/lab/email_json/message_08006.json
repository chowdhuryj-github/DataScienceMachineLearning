{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "metze@samba.org", "subject": "svn commit: samba r22319 - in branches/SAMBA_4_0/source/lib/tdb: .\n\tcommon tools", "body": "Author: metze\nDate: 2007-04-17 17:24:02 +0000 (Tue, 17 Apr 2007)\nNew Revision: 22319\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22319\n\nLog:\nsync lib/tdb/ with samba3\n\nmetze\nModified:\n   branches/SAMBA_4_0/source/lib/tdb/common/dump.c\n   branches/SAMBA_4_0/source/lib/tdb/common/freelist.c\n   branches/SAMBA_4_0/source/lib/tdb/common/freelistcheck.c\n   branches/SAMBA_4_0/source/lib/tdb/common/tdb_private.h\n   branches/SAMBA_4_0/source/lib/tdb/config.mk\n   branches/SAMBA_4_0/source/lib/tdb/tools/tdbbackup.c\n   branches/SAMBA_4_0/source/lib/tdb/tools/tdbdump.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/lib/tdb/common/dump.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/dump.c\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/dump.c\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -28,7 +28,8 @@\n \n #include \"tdb_private.h\"\n \n-static tdb_off_t tdb_dump_record(struct tdb_context *tdb, tdb_off_t offset)\n+static tdb_off_t tdb_dump_record(struct tdb_context *tdb, int hash,\n+\t\t\t\t tdb_off_t offset)\n {\n \tstruct list_struct rec;\n \ttdb_off_t tailer_ofs, tailer;\n@@ -39,8 +40,10 @@\n \t\treturn 0;\n \t}\n \n-\tprintf(\" rec: offset=0x%08x next=0x%08x rec_len=%d key_len=%d data_len=%d full_hash=0x%x magic=0x%x\\n\",\n-\t       offset, rec.next, rec.rec_len, rec.key_len, rec.data_len, rec.full_hash, rec.magic);\n+\tprintf(\" rec: hash=%d offset=0x%08x next=0x%08x rec_len=%d \"\n+\t       \"key_len=%d data_len=%d full_hash=0x%x magic=0x%x\\n\",\n+\t       hash, offset, rec.next, rec.rec_len, rec.key_len, rec.data_len,\n+\t       rec.full_hash, rec.magic);\n \n \ttailer_ofs = offset + sizeof(rec) + rec.rec_len - sizeof(tdb_off_t);\n \n@@ -72,7 +75,7 @@\n \t\tprintf(\"hash=%d\\n\", i);\n \n \twhile (rec_ptr) {\n-\t\trec_ptr = tdb_dump_record(tdb, rec_ptr);\n+\t\trec_ptr = tdb_dump_record(tdb, i, rec_ptr);\n \t}\n \n \treturn tdb_unlock(tdb, i, F_WRLCK);\n\nModified: branches/SAMBA_4_0/source/lib/tdb/common/freelist.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/freelist.c\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/freelist.c\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -29,7 +29,7 @@\n #include \"tdb_private.h\"\n \n /* read a freelist record and check for simple errors */\n-int rec_free_read(struct tdb_context *tdb, tdb_off_t off, struct list_struct *rec)\n+int tdb_rec_free_read(struct tdb_context *tdb, tdb_off_t off, struct list_struct *rec)\n {\n \tif (tdb->methods->tdb_read(tdb, off, rec, sizeof(*rec),DOCONV()) == -1)\n \t\treturn -1;\n@@ -37,7 +37,7 @@\n \tif (rec->magic == TDB_MAGIC) {\n \t\t/* this happens when a app is showdown while deleting a record - we should\n \t\t   not completely fail when this happens */\n-\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"rec_free_read non-free magic 0x%x at offset=%d - fixing\\n\", \n+\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"tdb_rec_free_read non-free magic 0x%x at offset=%d - fixing\\n\", \n \t\t\t rec->magic, off));\n \t\trec->magic = TDB_FREE_MAGIC;\n \t\tif (tdb->methods->tdb_write(tdb, off, rec, sizeof(*rec)) == -1)\n@@ -47,7 +47,7 @@\n \tif (rec->magic != TDB_FREE_MAGIC) {\n \t\t/* Ensure ecode is set for log fn. */\n \t\ttdb->ecode = TDB_ERR_CORRUPT;\n-\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"rec_free_read bad magic 0x%x at offset=%d\\n\", \n+\t\tTDB_LOG((tdb, TDB_DEBUG_WARNING, \"tdb_rec_free_read bad magic 0x%x at offset=%d\\n\", \n \t\t\t   rec->magic, off));\n \t\treturn TDB_ERRCODE(TDB_ERR_CORRUPT, -1);\n \t}\n@@ -286,7 +286,7 @@\n \t   issues when faced with a slowly increasing record size.\n \t */\n \twhile (rec_ptr) {\n-\t\tif (rec_free_read(tdb, rec_ptr, rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, rec_ptr, rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n@@ -311,7 +311,7 @@\n \t}\n \n \tif (bestfit.rec_ptr != 0) {\n-\t\tif (rec_free_read(tdb, bestfit.rec_ptr, rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, bestfit.rec_ptr, rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n\nModified: branches/SAMBA_4_0/source/lib/tdb/common/freelistcheck.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/freelistcheck.c\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/freelistcheck.c\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -88,7 +88,7 @@\n \t\t\tgoto fail;\n \t\t}\n \n-\t\tif (rec_free_read(tdb, rec_ptr, &rec) == -1) {\n+\t\tif (tdb_rec_free_read(tdb, rec_ptr, &rec) == -1) {\n \t\t\tgoto fail;\n \t\t}\n \n\nModified: branches/SAMBA_4_0/source/lib/tdb/common/tdb_private.h\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/common/tdb_private.h\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/common/tdb_private.h\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -206,5 +206,7 @@\n \t\t\t   struct list_struct *rec);\n void tdb_io_init(struct tdb_context *tdb);\n int tdb_expand(struct tdb_context *tdb, tdb_off_t size);\n+int tdb_rec_free_read(struct tdb_context *tdb, tdb_off_t off,\n+\t\t      struct list_struct *rec);\n \n \n\nModified: branches/SAMBA_4_0/source/lib/tdb/config.mk\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/config.mk\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/config.mk\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -51,7 +51,6 @@\n # Start BINARY tdbbackup\n [BINARY::tdbbackup]\n INSTALLDIR = BINDIR\n-ENABLE = NO\n OBJ_FILES= \\\n \t\ttools/tdbbackup.o\n PRIVATE_DEPENDENCIES = \\\n\nModified: branches/SAMBA_4_0/source/lib/tdb/tools/tdbbackup.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/tools/tdbbackup.c\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/tools/tdbbackup.c\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -42,10 +42,183 @@\n  */\n \n #include \"replace.h\"\n+#include \"system/locale.h\"\n+#include \"system/time.h\"\n+#include \"system/filesys.h\"\n #include \"tdb.h\"\n-#include \"system/filesys.h\"\n \n+#ifdef HAVE_GETOPT_H\n+#include \n+#endif\n+\n+static int failed;\n+\n+static char *add_suffix(const char *name, const char *suffix)\n+{\n+\tchar *ret;\n+\tint len = strlen(name) + strlen(suffix) + 1;\n+\tret = (char *)malloc(len);\n+\tif (!ret) {\n+\t\tfprintf(stderr,\"Out of memory!\\n\");\n+\t\texit(1);\n+\t}\n+\tsnprintf(ret, len, \"%s%s\", name, suffix);\n+\treturn ret;\n+}\n+\n+static int copy_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n+{\n+\tTDB_CONTEXT *tdb_new = (TDB_CONTEXT *)state;\n+\n+\tif (tdb_store(tdb_new, key, dbuf, TDB_INSERT) != 0) {\n+\t\tfprintf(stderr,\"Failed to insert into %s\\n\", tdb_name(tdb));\n+\t\tfailed = 1;\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+\n+static int test_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n+{\n+\treturn 0;\n+}\n+\n /*\n+  carefully backup a tdb, validating the contents and\n+  only doing the backup if its OK\n+  this function is also used for restore\n+*/\n+static int backup_tdb(const char *old_name, const char *new_name, int hash_size)\n+{\n+\tTDB_CONTEXT *tdb;\n+\tTDB_CONTEXT *tdb_new;\n+\tchar *tmp_name;\n+\tstruct stat st;\n+\tint count1, count2;\n+\n+\ttmp_name = add_suffix(new_name, \".tmp\");\n+\n+\t/* stat the old tdb to find its permissions */\n+\tif (stat(old_name, &st) != 0) {\n+\t\tperror(old_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* open the old tdb */\n+\ttdb = tdb_open(old_name, 0, 0, O_RDWR, 0);\n+\tif (!tdb) {\n+\t\tprintf(\"Failed to open %s\\n\", old_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* create the new tdb */\n+\tunlink(tmp_name);\n+\ttdb_new = tdb_open(tmp_name,\n+\t\t\t   hash_size ? hash_size : tdb_hash_size(tdb),\n+\t\t\t   TDB_DEFAULT, O_RDWR|O_CREAT|O_EXCL, \n+\t\t\t   st.st_mode & 0777);\n+\tif (!tdb_new) {\n+\t\tperror(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* lock the old tdb */\n+\tif (tdb_lockall(tdb) != 0) {\n+\t\tfprintf(stderr,\"Failed to lock %s\\n\", old_name);\n+\t\ttdb_close(tdb);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\tfailed = 0;\n+\n+\t/* traverse and copy */\n+\tcount1 = tdb_traverse(tdb, copy_fn, (void *)tdb_new);\n+\tif (count1 < 0 || failed) {\n+\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n+\t\ttdb_close(tdb);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* close the old tdb */\n+\ttdb_close(tdb);\n+\n+\t/* close the new tdb and re-open read-only */\n+\ttdb_close(tdb_new);\n+\ttdb_new = tdb_open(tmp_name, 0, TDB_DEFAULT, O_RDONLY, 0);\n+\tif (!tdb_new) {\n+\t\tfprintf(stderr,\"failed to reopen %s\\n\", tmp_name);\n+\t\tunlink(tmp_name);\n+\t\tperror(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\t\n+\t/* traverse the new tdb to confirm */\n+\tcount2 = tdb_traverse(tdb_new, test_fn, 0);\n+\tif (count2 != count1) {\n+\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* make sure the new tdb has reached stable storage */\n+\tfsync(tdb_fd(tdb_new));\n+\n+\t/* close the new tdb and rename it to .bak */\n+\ttdb_close(tdb_new);\n+\tunlink(new_name);\n+\tif (rename(tmp_name, new_name) != 0) {\n+\t\tperror(new_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\tfree(tmp_name);\n+\n+\treturn 0;\n+}\n+\n+/*\n+  verify a tdb and if it is corrupt then restore from *.bak\n+*/\n+static int verify_tdb(const char *fname, const char *bak_name)\n+{\n+\tTDB_CONTEXT *tdb;\n+\tint count = -1;\n+\n+\t/* open the tdb */\n+\ttdb = tdb_open(fname, 0, 0, O_RDONLY, 0);\n+\n+\t/* traverse the tdb, then close it */\n+\tif (tdb) {\n+\t\tcount = tdb_traverse(tdb, test_fn, NULL);\n+\t\ttdb_close(tdb);\n+\t}\n+\n+\t/* count is < 0 means an error */\n+\tif (count < 0) {\n+\t\tprintf(\"restoring %s\\n\", fname);\n+\t\treturn backup_tdb(bak_name, fname, 0);\n+\t}\n+\n+\tprintf(\"%s : %d records\\n\", fname, count);\n+\n+\treturn 0;\n+}\n+\n+/*\n   see if one file is newer than another\n */\n static int file_newer(const char *fname1, const char *fname2)\n@@ -66,6 +239,7 @@\n \tprintf(\"   -h            this help message\\n\");\n \tprintf(\"   -s suffix     set the backup suffix\\n\");\n \tprintf(\"   -v            verify mode (restore if corrupt)\\n\");\n+\tprintf(\"   -n hashsize   set the new hash size for the backup\\n\");\n }\n \t\t\n \n@@ -75,11 +249,10 @@\n \tint ret = 0;\n \tint c;\n \tint verify = 0;\n+\tint hashsize = 0;\n \tconst char *suffix = \".bak\";\n-\textern int optind;\n-\textern char *optarg;\n \n-\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {\n+\twhile ((c = getopt(argc, argv, \"vhs:n:\")) != -1) {\n \t\tswitch (c) {\n \t\tcase 'h':\n \t\t\tusage();\n@@ -90,6 +263,9 @@\n \t\tcase 's':\n \t\t\tsuffix = optarg;\n \t\t\tbreak;\n+\t\tcase 'n':\n+\t\t\thashsize = atoi(optarg);\n+\t\t\tbreak;\n \t\t}\n \t}\n \n@@ -113,7 +289,7 @@\n \t\t\t}\n \t\t} else {\n \t\t\tif (file_newer(fname, bak_name) &&\n-\t\t\t    backup_tdb(fname, bak_name) != 0) {\n+\t\t\t    backup_tdb(fname, bak_name, hashsize) != 0) {\n \t\t\t\tret = 1;\n \t\t\t}\n \t\t}\n\nModified: branches/SAMBA_4_0/source/lib/tdb/tools/tdbdump.c\n===================================================================\n--- branches/SAMBA_4_0/source/lib/tdb/tools/tdbdump.c\t2007-04-17 17:17:19 UTC (rev 22318)\n+++ branches/SAMBA_4_0/source/lib/tdb/tools/tdbdump.c\t2007-04-17 17:24:02 UTC (rev 22319)\n@@ -19,9 +19,10 @@\n */\n \n #include \"replace.h\"\n-#include \"tdb.h\"\n #include \"system/locale.h\"\n+#include \"system/time.h\"\n #include \"system/filesys.h\"\n+#include \"tdb.h\"\n \n static void print_data(TDB_DATA d)\n {\n@@ -37,22 +38,23 @@\n \t}\n }\n \n-static int traverse_fn(struct tdb_context *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n+static int traverse_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n {\n \tprintf(\"{\\n\");\n-\tprintf(\"key = \\\"\");\n+\tprintf(\"key(%d) = \\\"\", (int)key.dsize);\n \tprint_data(key);\n \tprintf(\"\\\"\\n\");\n-\tprintf(\"data = \\\"\");\n+\tprintf(\"data(%d) = \\\"\", (int)dbuf.dsize);\n \tprint_data(dbuf);\n \tprintf(\"\\\"\\n\");\n \tprintf(\"}\\n\");\n \treturn 0;\n }\n \n-static int dump_tdb(const char *fname)\n+static int dump_tdb(const char *fname, const char *keyname)\n {\n-\tstruct tdb_context *tdb;\n+\tTDB_CONTEXT *tdb;\n+\tTDB_DATA key, value;\n \t\n \ttdb = tdb_open(fname, 0, 0, O_RDONLY, 0);\n \tif (!tdb) {\n@@ -60,20 +62,55 @@\n \t\treturn 1;\n \t}\n \n-\ttdb_traverse(tdb, traverse_fn, NULL);\n+\tif (!keyname) {\n+\t\ttdb_traverse(tdb, traverse_fn, NULL);\n+\t} else {\n+\t\tkey.dptr = discard_const_p(uint8_t,keyname);\n+\t\tkey.dsize = strlen( keyname);\n+\t\tvalue = tdb_fetch(tdb, key);\n+\t\tif (!value.dptr) {\n+\t\t\treturn 1;\n+\t\t} else {\n+\t\t\tprint_data(value);\n+\t\t\tfree(value.dptr);\n+\t\t}\n+\t}\n+\n \treturn 0;\n }\n \n+static void usage( void)\n+{\n+\tprintf( \"Usage: tdbdump [options] \\n\\n\");\n+\tprintf( \"   -h          this help message\\n\");\n+\tprintf( \"   -k keyname  dumps value of keyname\\n\");\n+}\n+\n  int main(int argc, char *argv[])\n {\n-\tchar *fname;\n+\tchar *fname, *keyname=NULL;\n+\tint c;\n \n \tif (argc < 2) {\n \t\tprintf(\"Usage: tdbdump \\n\");\n \t\texit(1);\n \t}\n \n-\tfname = argv[1];\n+\twhile ((c = getopt( argc, argv, \"hk:\")) != -1) {\n+\t\tswitch (c) {\n+\t\tcase 'h':\n+\t\t\tusage();\n+\t\t\texit( 0);\n+\t\tcase 'k':\n+\t\t\tkeyname = optarg;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tusage();\n+\t\t\texit( 1);\n+\t\t}\n+\t}\n \n-\treturn dump_tdb(fname);\n+\tfname = argv[optind];\n+\n+\treturn dump_tdb(fname, keyname);\n }\n\n"}
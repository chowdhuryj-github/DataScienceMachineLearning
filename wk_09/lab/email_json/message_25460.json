{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "\"Will Coleda\" <will@coleda.com>", "subject": "Re: [perl #42905] [PATCH] implement vtable overriding for PDD15,\n  bugfix", "body": "Alek Storm (via RT) writes: \n\n> # New Ticket Created by  \"Alek Storm\" \n> # Please include the string:  [perl #42905]\n> # in the subject line of all future correspondence about this issue. \n> #  \n> \n> \n> I've attached a patch to implement vtable overriding for PDD15.  The basic\n> idea is to wrap all Object vtable methods in code that searches up the\n> parent stack for the corresponding vtable method, call it if found, and if\n> it's not found, call the original implementation of the method, or throw an\n> exception.  Any variables used in the wrapper code are prefixed with '__' to\n> avoid name collisions. \n> \n> The PCCMETHOD 'add_vtable_method' is added to Class.  Using two separate\n> methods for adding normal methods and vtable methods is much cleaner and\n> more logical, since they are two completely separate functionalities.  In\n> fact, using this interface, the :vtable pragma is completely unnecessary, so\n> we could remove it if we wanted to.\n\nHow would one implement a vtable method, (referring to self), and then add \nit to the object? You'd have to add an \":init :load :anon\" block after the \nvtable was defined in order to invoke add_vtable_method, and you'd need a \nreference to the invokable you're adding, which means you'd have to leave it \nlying about in a namespace somewhere so you could extract it. \n\nSo, I think keeping a compile time directive like :vtable around is still a \ngood idea. \n\n>  Because I was unsure exactly how the\n> interface is going to end up, 'add_method' also adds vtable methods also, if\n> :vtable is set on the method. If we decide to go with this interface, I'd\n> like to take it out, along with the :vtable pragma. \n> \n> Trying to override 'mark', 'destroy', or 'morph' throws an exception,\n> because overriding them might be dangerous.  An exception is also thrown for\n> 'init_pmc', see below.\n\n(morph) FYI, there are dynamic PMCs that already override morph, for good or \nevil. \n\n> The 'init' vtable method in Object is not wrapped by pmc2c, since its\n> override is called from Class.new().  Class.new() is changed from accepting\n> a named slurpy of attributes to an unnamed slurpy of initializer\n> parameters.  This slurpy is :flattened and passed to 'init'.  This is really\n> cool, because now 'init' acts like a normal method, and can accept a\n> variable-sized parameter list.  This makes 'init_pmc' obsolete, so trying to\n> override it throws an exception.  Named parameters don't work, but c'mon,\n> you can't have it all, right? \n> \n> In the implementation of Class.new(), the slurpy had to be manually\n> flattened, due to limitations in the argument passing implementation:\n> Parrot_run_meth_fromc* takes a va_list, and va_lists are passed around\n> internally in src/inter_call.c.  This is bad, because va_list is an opaque\n> type, and we need to generate one without a variable argument list.  I don't\n> know why it's like that, but it definitely can't stay that way - it's much\n> better to use an array of UnionVal's.  Maybe I'll fix it later. \n> \n> Currently, passing arguments to Class.new() when 'init' is not overridden\n> doesn't throw an exception.  Should it? \n> \n> This patch also fixes a bug with 'invoke' in both ParrotObject and Object:\n> 'self' had to be explicitly passed to the override.  This is fixed by adding\n> the signature flag PARROT_ARG_OBJECT, and unshifting that OR-ed with\n> PARROT_ARG_PMC onto the args signature.  This has a counterpart already used\n> in fetch_arg_sig() in src/inter_call.c. \n> \n> For compatibility with the old object system, this patch doesn't change the\n> semantics of the :vtable pragma according to the discussion in #42430.  Once\n> the old system is gone, we can change it. \n> \n> The old double-underscore method of vtable overriding can die along with the\n> old object system, but I would prefer to submit a patch to get rid of it\n> sooner, since I don't know how long the old object system will stick around.\n\nMatt Diephouse had done some work to remove usage of this idiom.\n\n> I've updated PDD15 to match the new interface and semantics.  Obviously the\n> documentation is only correct if all of the patch gets applied, so if it\n> doesn't, this must be changed. \n> \n> Tests are included for 'init', 'invoke', and vtable method lookup through\n> the parent stack.  Also, I fixed some tests in t/pmc/parrotobject.t that\n> overrode 'invoke' without using the :method pragma, and removed the test for\n> #41372, which is now obsolete. \n> \n> Also, a question: what exactly is the '_namespace' member of Parrot_Class\n> used for?  I don't see it used anywhere; it can be gotten and set, but is\n> otherwise useless, since methods are added using a separate mechanism. \n> \n> Well, that's about it.  I realize some people (especially Allison ;)) will\n> probably disagree with parts of this patch, but I'd like to get the parts we\n> do agree on committed.  Thanks. \n> \n> diffstat output:\n>  docs/pdds/pdd15_objects.pod   |   32 ++++++--\n>  include/parrot/enums.h        |    5 -\n>  include/parrot/objects.h      |    1\n>  lib/Parrot/Pmc2c.pm           |    6 -\n>  lib/Parrot/Pmc2c/Object.pm    |  158\n> ++++++++++++++++++++++++++++++++++++++++++\n>  lib/Parrot/Pmc2c/PCCMETHOD.pm |    2\n>  src/inter_call.c              |    7 +\n>  src/objects.c                 |    7 +\n>  src/ops/object.ops            |    4 -\n>  src/pmc/class.pmc             |  150\n> ++++++++++++++++++++++++++++++++++++---\n>  src/pmc/classobject.h         |    4 +\n>  src/pmc/delegate.pmc          |   16 +++-\n>  src/pmc/object.pmc            |   51 +++++++++++++\n>  t/pmc/class.t                 |  114 ++++++++++++++++++++++--------\n>  t/pmc/object-meths.t          |   24 ++++++\n>  t/pmc/parrotobject.t          |   23 ------\n>  16 files changed, 521 insertions(+), 83 deletions(-) \n> \n> -- \n> Alek Storm\n\n"}
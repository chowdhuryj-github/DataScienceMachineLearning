{"category": "ham", "to_address": "parrot-porters@perl.org", "from_address": "chromatic <chromatic@wgz.org>", "subject": "FOTW src/debug.c", "body": "This file implements most of the Parrot debugger.  The interpreter struct has \na slot called pdb that contains a PDB_t (parrot/debug.h).\n\nThis file is somewhat messy.  It has some string manipulation functions \n(nextarg(), skip_ws(), parse_int(), parse_string()) that should probably go \nelsewhere.\n\nThere are also some places that seem somewhat careless about memory allocation \nand freeing.  For example, where in this file does interp->pdb get \ninitialized?  (Answer: in src/embed.c - Parrot_disassemble()).\n\nWhere does it get freed?  (Answer: nowhere that I can tell.)\n\nThe freeing *could* go in Parrot_really_destroy() in src/inter_create.c (did \nyou catch the contradiction in names there?), but I'm starting to think that \neach file that represents the entry point into a system should have two \nfunctions, one that initializes the system and its necessary data structures \nand another that finalizes and frees things.\n\nI don't know if we have any good tests for the debugger; this is something we \nought to consider if we're going to move code around.  Sadly, I don't know \nany easy way to test things apart from opening a Parrot process and feeding \ndata in and out.  Making the debugger scriptable from PIR is a bigger project \nthan I'm comfortable suggesting until it gets more tests.\n\nSome of the other memory-related functions have a little bit too much magic.  \nFor example, PDB_free_file() takes the file to free out of the current \ndebugger.  It does the right thing to free files, but there appear to be \ncases where it's useful to free a file that's not the debugger's current \nfile, so this function is inappropriately general.\n\nOther functions have odd names -- PDB_hasInstructions() (no underscore?), \nPDB_print() (should be PDB_print_registers()).\n\nThe code is fairly decent.  Most of the issues here relate to organization.\n\n-- c\n\n"}
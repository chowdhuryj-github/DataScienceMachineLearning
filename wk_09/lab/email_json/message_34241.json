{"category": "ham", "to_address": "Allison Randal <allison@perl.org>", "from_address": "Nicholas Clark <nick@ccl4.org>", "subject": "Re: PMC architecture discussion", "body": "On Mon, May 21, 2007 at 06:48:25PM -0700, Allison Randal wrote:\n\n> On variable-sized PMCs, I generally agree with the goals the proposal is \n> trying to accomplish, but I want to tackle these goals in a simpler way. \n> One of the goals mentioned for the proposal was to shrink down the size \n> of PMCs, but it's hard to get much smaller than a struct containing 1 \n> struct, 1 pointer to a struct, and a pointer to the vtable, where both \n> of the 2 contained structs can be null.\n\nApart from\n\nstruct PMC {\n    struct PMC_DATA *data;\n    struct VTABLE *vtable;\n};\n\nwhere the data pointer isn't allowed to be NULL, and what it points to is\n\nstruct PMC_DATA {\n    ...\t\t\t/* Fixed stuff */\n    char your_stuff[1];\t/* Actually variable length. */\n}\n\n\nOr if it is allowed to be NULL, that NULL has one very well defined meaning, with\nassumed defaults for all the parts of \"Fixed stuff\"\n\n> So, rather than making the core PMC struct variable sized, I want to \n> make one of its contained structs variable sized. This is already a \n> common practice, storing a structure pointer in PMC_data. I also want to \n> eliminate the union value from the pobj_t struct. The concept that a PMC \n> contains either a buffer, 2 pointers, 2 ints, a float val, or a string \n> val, and that these all must overlap in storage is shortsighted. One \n> thing that would convince me otherwise is the argument that it's good to \n> have some core PMC data accessible without a pointer dereference. \n\nI believe that it was intended as a caching layer, precisely to avoid a pointer\ndereference. I can't remember far enough back offhand, but it would not surprise\nme if the original structure was cache line aligned on ILP32 systems.\n\n> Standing against that is the fact that we're currently allocating (a \n> small piece of) memory for every PMC that may never be used.\n\nThis sounds like it ends up with a very similar system to Perl 5's SVs, with\nfixed sized heads and variable sized bodies.\n\nIIRC Dan's reason for really not wanting variable sized bodies was the experience\nof 5005 threads - if the body can be reallocated, then you need take a lock to\neven read it, in a multi-threaded environment.\n\n\n> This is an alternate structure I'm considering:\n> \n>     struct PMC {\n>         Parrot_UInt flags;\n>         DPOINTER *data;          /* Modifiable for each PMC */\n>         VTABLE *vtable;\n>         struct PMC_EXT *pmc_ext; /* auxiliary data */\n>     };\n> \n\nWould it be better to have one pointer to data, and state that free-form data\nfollows in memory immediately after this structure?\n\n>     struct PMC_EXT {\n>         PMC *_roles;                /* runtime roles */\n>         PMC *_metadata;             /* properties, replaced by a role */\n>         struct _Sync *_synchronize; /* [to be deprecated, see STM] */\n>         PMC *_next_for_GC;          /* [GC hack, may be replaced] */\n>     };\n\nI'm not sure if the design axioms behind Dan's desire to avoid locking for reading\nremain. In particular, is the assumption now that if a PMC becomes visible to more\nthan one thread (by being shared) then its vtable is changed to an alternative\nvtable that performs locking?\n\nAnd how often does the type of a PMC change, such that its internal data layout\nchanges? In Perl 5 this morphing happens everywhere, but in Parrot?\n\n\nNicholas Clark\n\n"}
{"category": "ham", "to_address": "Allison Randal via RT <parrotbug-followup@parrotcode.org>", "from_address": "Andy Spieherty <spiehera@lafayette.edu>", "subject": "[PATCH] Re: [perl #42774] [PATCH] Configure.pl --gc=libc doesn't\n compile", "body": "On Wed, 9 May 2007, Allison Randal via RT wrote:\n\n> Andy Spieherty wrote:\n> > \n> > I was about to post a patch adding those functions in, but I see that \n> > you're in the middle of a much more thorough review than I had attempted, \n> > so my patch isn't going to apply anymore, and would probably be \n> > misleading, to boot.\n> \n> Just adding Parrot_allocate_aligned and Parrot_merge_memory_pools \n> shouldn't conflict. I'm pretty confident they will need to be \n> implemented custom for res_lea.c. (I haven't made any changes to the \n> file since my last commit.)\n> \n> > Going down that route anyway, I haven't solved any GC problems, so it may \n> > not end up being a useful diversion.  Still, I have been looking at the \n> > hand-rolling of structures, such as this one at the top of resources.c, to \n> > see if they could be simplified in the simplified --gc=libc case (where \n> > we're not worrying about compaction and moving aligned pools to unaligned \n> > places.)\n> > \n> > \n> >                     +-----------------+\n> >                     |  ref_count   |f |    # GC header\n> >   obj->bufstart  -> +-----------------+\n> >                     |  data           |\n> >                     v                 v \n\nHere is a patch to get Configure.pl --gc=libc to at least compile again.\nAlas, it still doesn't seem to work.  I'm getting various panics and\ncrashes that usually (but not always) appear to be related to string\nstuff.  I suspect I might not have Parrot_allocate_string() quite right,\nor there may be other spots elsewhere that assume something about the \noverall memory layout that I'm violating here.\n\nIn any case, this doesn't hurt the default Configuration and at least\nallows --gc=libc to compile, so I think it's a step forward, and a good \npoint to sync up.  I'm not sure when I'll next have a chance to look at\nthis.\n\ndiff -r -u parrot-current/config/gen/makefiles/root.in parrot-andy/config/gen/makefiles/root.in\n--- parrot-current/config/gen/makefiles/root.in\t2007-04-20 19:15:12.000000000 -0400\n+++ parrot-andy/config/gen/makefiles/root.in\t2007-05-11 15:47:34.000000000 -0400\n@@ -1014,6 +1014,8 @@\n \n $(SRC_DIR)/gc/resources$(O) : $(GENERAL_H_FILES)\n \n+$(SRC_DIR)/gc/res_lea$(O) : $(GENERAL_H_FILES)\n+\n $(SRC_DIR)/headers$(O) : $(GENERAL_H_FILES)\n \n $(SRC_DIR)/hll$(O) : $(GENERAL_H_FILES)\ndiff -r -u parrot-current/include/parrot/pobj.h parrot-andy/include/parrot/pobj.h\n--- parrot-current/include/parrot/pobj.h\t2007-05-08 19:15:14.000000000 -0400\n+++ parrot-andy/include/parrot/pobj.h\t2007-05-11 15:47:34.000000000 -0400\n@@ -61,6 +61,54 @@\n #define PMC_num_val(pmc)      (pmc)->obj.u._num_val\n #define PMC_str_val(pmc)      (pmc)->obj.u._string_val\n \n+/* See src/gc/resources.c. the basic idea is that buffer memory is\n+   set up as follows:\n+                    +-----------------+\n+                    |  ref_count   |f |    # GC header\n+  obj->bufstart  -> +-----------------+\n+                    |  data           |\n+                    v                 v\n+\n+The actual set-up is more involved because of padding.  obj->bufstart must\n+be suitably aligned for any UnionVal.  (Perhaps it should be a Buffer\n+there instead.)  The start of the memory region (as returned by malloc()\n+is also suitably aligned for any use.  If, for example, malloc() returns\n+objects aligned on 8-byte boundaries, and obj->bufstart is also aligned\n+on 8-byte boundaries, then there should be 4 bytes of padding.  It is\n+handled differently in the two files resources.c and res_lea.c.  (I have\n+not yet figured out how the 'possible padding' is handled in resources.c.\n+--A.D.  2007-05-11.)\n+\n+                     src/gc/resources.c:       src/gc/res_lea.c:\n+\n+ptr from malloc ->  +------------------+      +------------------+\n+                    | possible padding |      | INTVAL ref_count |\n+                    | INTVAL ref_count |      | possible padding |\n+obj->bufstart   ->  +------------------+      +------------------+\n+                    |     data         |      |      data        |\n+                    v                  v      v                  v\n+\n+*/\n+typedef struct Buffer_alloc_unit {\n+    INTVAL ref_count;\n+    UnionVal buffer[1]; /* Guarantee it's suitably aligned */\n+} Buffer_alloc_unit;\n+\n+/* Given a pointer to the buffer, find the ref_count and the actual start of\n+   the allocated space. Setting ref_count is clunky because we avoid lvalue\n+   casts. */\n+#ifdef GC_IS_MALLOC       /* see src/gc/res_lea.c */\n+#  define Buffer_alloc_offset    (offsetof(Buffer_alloc_unit, buffer))\n+#  define PObj_bufallocstart(b)  ((char *)PObj_bufstart(b) - Buffer_alloc_offset)\n+#  define PObj_bufrefcount(b)    (((Buffer_alloc_unit *)PObj_bufallocstart(b))->ref_count)\n+#  define PObj_bufrefcountptr(b) (&PObj_bufrefcount(b))\n+#else                     /* see src/gc/resources.c */\n+#  define Buffer_alloc_offset sizeof(INTVAL)\n+#  define PObj_bufallocstart(b)  ((char *)PObj_bufstart(b) - Buffer_alloc_offset)\n+#  define PObj_bufrefcount(b)    (*(INTVAL *)PObj_bufallocstart(b))\n+#  define PObj_bufrefcountptr(b) ((INTVAL *)PObj_bufallocstart(b))\n+#endif\n+\n /* BEGIN DEPRECATED BUFFER ACCESSORS */\n /* macros for accessing old buffer members\n  * #define bufstart obj.u._b._bufstart\ndiff -r -u parrot-current/src/gc/dod.c parrot-andy/src/gc/dod.c\n--- parrot-current/src/gc/dod.c\t2007-05-08 19:15:13.000000000 -0400\n+++ parrot-andy/src/gc/dod.c\t2007-05-11 15:47:34.000000000 -0400\n@@ -465,7 +465,7 @@\n \n                 if (PObj_COW_TEST(b) && PObj_bufstart(b) &&\n                         !PObj_external_TEST(b)) {\n-                    INTVAL * const refcount = (INTVAL *) PObj_bufstart(b) - 1;\n+                    INTVAL * const refcount = PObj_bufrefcountptr(b);\n                     *refcount               = 0;\n                 }\n             }\n@@ -503,7 +503,7 @@\n                     PObj_bufstart(b) &&\n                    !PObj_external_TEST(b)) {\n \n-                INTVAL * const refcount = (INTVAL *) PObj_bufstart(b) - 1;\n+                INTVAL * const refcount = PObj_bufrefcountptr(b);\n \n                 /* mark users of this bufstart by incrementing refcount */\n                 if (PObj_live_TEST(b))\ndiff -r -u parrot-current/src/gc/res_lea.c parrot-andy/src/gc/res_lea.c\n--- parrot-current/src/gc/res_lea.c\t2007-05-08 19:15:13.000000000 -0400\n+++ parrot-andy/src/gc/res_lea.c\t2007-05-11 16:11:46.000000000 -0400\n@@ -115,57 +115,70 @@\n =item C\n \n-COWable objects (strings or Buffers) use an INTVAL at C for\n-refcounting in DOD. C is incremented by that C.\n+COWable objects (strings or Buffers) use an INTVAL before C for\n+refcounting in DOD.\n \n =cut\n \n */\n \n void\n-Parrot_reallocate(Interp *interp, Buffer *from, size_t tosize)\n+Parrot_reallocate(Interp *interp, Buffer *buffer, size_t tosize)\n {\n-    Buffer * const buffer = from;\n     const size_t oldlen = PObj_buflen(buffer);\n-    void *p;\n+    Buffer_alloc_unit *p;\n \n     if (!PObj_bufstart(buffer)) {\n-        p = 1 + (INTVAL *)xcalloc(1, sizeof (INTVAL) + tosize);\n+        Parrot_allocate_aligned(interp, buffer, tosize);\n+        /* The previous version zeroed the memory here, but I'm not\n+           sure why. */\n+        memset(PObj_bufstart(buffer), 0, tosize);\n     }\n     else {\n         if (!tosize) {    /* realloc(3) does free, if tosize == 0 here */\n             return;    /* do nothing */\n         }\n-        p = 1 + (INTVAL *)xrealloc((INTVAL *)PObj_bufstart(buffer) - 1,\n-                                   sizeof (INTVAL) + tosize);\n+        p = (Buffer_alloc_unit *) xrealloc(PObj_bufallocstart(buffer),\n+                                           Buffer_alloc_offset + tosize);\n         if (tosize > oldlen)\n-            memset(p + oldlen, 0, tosize - oldlen);\n+            memset((char *)p->buffer + oldlen, 0, tosize - oldlen);\n+        PObj_bufstart(buffer) = p->buffer;\n+        PObj_buflen(buffer) = tosize;\n     }\n-    PObj_bufstart(buffer) = p;\n-    PObj_buflen(buffer) = tosize;\n }\n \n+\n /*\n \n =item C\n \n-Allocates and returns the required memory. C is the number of\n-bytes of memory required.\n+Allocate buffer memory for the given Buffer pointer. The C\n+has to be a multiple of the word size.\n+C will be set to exactly the given C.\n+See the comments and diagram in resources.c.\n+\n+This was never called anyway, so it isn't implemented here.\n+\n+=item C\n+\n+Like above, except the address of the buffer is guaranteed to be\n+suitably aligned for holding anything contained in UnionVal\n+(such as FLOATVAL).\n \n =cut\n \n */\n \n void\n-Parrot_allocate(Interp *interp, Buffer *buffer, size_t size)\n+Parrot_allocate_aligned(Interp *interp, Buffer *buffer, size_t size)\n {\n-    Buffer * const b = buffer;\n-    void * const p = xmalloc(sizeof (INTVAL) + size);\n-\n-    *(INTVAL *)p = 0;\n-    PObj_bufstart(b) = 1 + (INTVAL *)p;\n-    PObj_buflen(b) = size;\n+    Buffer_alloc_unit *p;\n+    p = (Buffer_alloc_unit *) xmalloc(Buffer_alloc_offset + size);\n+    p->ref_count = 0;\n+    PObj_bufstart(buffer) = p->buffer;\n+    PObj_buflen(buffer) = size;\n }\n \n /*\n@@ -183,16 +196,17 @@\n void\n Parrot_reallocate_string(Interp *interp, STRING *str, size_t tosize)\n {\n-    if (!PObj_bufstart(str))\n+    const size_t oldlen = PObj_buflen(str);\n+    Buffer_alloc_unit *p;\n+\n+    if (!PObj_bufstart(str)) {\n         Parrot_allocate_string(interp, str, tosize);\n+    }\n     else if (tosize) {\n-        const size_t pad = BUFFER_ALIGNMENT - 1;\n-        void *p;\n-        tosize = ((tosize + pad + sizeof (INTVAL)) & ~pad);\n-        p = xrealloc((char *)((INTVAL*)PObj_bufstart(str) - 1), tosize);\n-        PObj_bufstart(str) = str->strstart = (char *)p + sizeof (INTVAL);\n-        /* usable size at bufstart */\n-        PObj_buflen(str) = tosize - sizeof (INTVAL);\n+        p = (Buffer_alloc_unit *) xrealloc(PObj_bufallocstart(str),\n+                                           Buffer_alloc_offset + tosize);\n+        PObj_bufstart(str) = str->strstart = (char *) p->buffer;\n+        PObj_buflen(str) = tosize;\n     }\n }\n \n@@ -211,14 +225,11 @@\n void\n Parrot_allocate_string(Interp *interp, STRING *str, size_t size)\n {\n-    void *p;\n-    const size_t pad = BUFFER_ALIGNMENT - 1;\n-\n-    size = ((size + pad + sizeof (INTVAL)) & ~pad);\n-    p = xcalloc(1, size);\n-    *(INTVAL*)p = 0;\n-    PObj_bufstart(str) = str->strstart = (char *)p + sizeof (INTVAL);\n-    PObj_buflen(str) = size - sizeof (INTVAL);\n+    Buffer_alloc_unit *p;\n+    p = (Buffer_alloc_unit *) xcalloc(Buffer_alloc_offset + size, 1);\n+    p->ref_count = 0;\n+    PObj_bufstart(str) = str->strstart = (char *) p->buffer;\n+    PObj_buflen(str) = size;\n }\n \n /*\n@@ -240,6 +251,21 @@\n /*\n \n =item C\n+\n+Does nothing.\n+\n+=cut\n+\n+*/\n+void\n+Parrot_merge_memory_pools(Interp *dest, Interp *source)\n+{\n+}\n+\n+/*\n+\n+=item C\n \n Does nothing.\ndiff -r -u parrot-current/src/string.c parrot-andy/src/string.c\n--- parrot-current/src/string.c\t2007-05-01 19:15:22.000000000 -0400\n+++ parrot-andy/src/string.c\t2007-05-11 15:47:34.000000000 -0400\n@@ -206,7 +206,7 @@\n     /* TODO create string_free API for reusing string headers */\n #ifdef GC_IS_MALLOC\n         if (!PObj_is_cowed_TESTALL(dest) && PObj_bufstart(dest)) {\n-            mem_sys_free((INTVAL*)PObj_bufstart(dest) - 1);\n+            mem_sys_free(PObj_bufallocstart(dest));\n         }\n #endif\n         dest = Parrot_reuse_COW_reference(interp, src, dest);\n-- \n\n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n"}
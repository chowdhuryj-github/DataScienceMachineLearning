{"category": "ham", "to_address": "Volker.Lendecke@SerNet.DE, ronniesahlberg@gmail.com,\n   samba-technical@samba.org", "from_address": "tridge@samba.org", "subject": "Re: ctdb shortcut locking", "body": "Volker,\n\nRonnie and I have now fleshed out a more complete picture of how we\nwill do scalable ctdb_fetch_lock(). I'll try and explain it below, and\nwe'd appreciate your comments.\n\nThe nomenclature will be:\n\n  - 'client' is a ctdb client, which will be an instance of a smbd\n    daemon for Samba\n\n  - 'ctdbd' is the ctdb daemon\n\npseudo-code for ctdb_fetch_lock in the client:\n\n ctdb_fetch_lock() {\n\t/* do a blocking chainlock on the record */\n\ttdb_chainlock(); \n        \n\t/* fetch the header and data for the record */\n\tctdb_ltdb_fetch();\n\n\t/* if we are not the dmaster, then ask ctdbd to make us the\n\t   dmaster */\n\tif (header.dmaster != ctdb->vnn) {\n\t\task_ctdb_daemon_to_make_us_master();\n\t\twait_for_reply_from_daemon();\n\n\t\t/* the dmaster reply has come in, but the daemon has\n\t\t   _not_ updated the record header to mark us as the\n\t\t   dmaster - do that now in the client */\n\t\tlocally_update_record_header();\n        }\n\n\t/* we are now the dmaster, and we have the record locked */\n\treturn record;\n }\n\n\nhere is the pseudo-code in the daemon:\n\n ctdbd_make_us_dmaster() {\n\t/* use a CTDB_CALL to force migration of the record */\n\tcall->call_id = CTDB_FETCH_FUNC;\n\tcall->flags = CTDB_IMMEDIATE_MIGRATION;\n        ctdb_call_send();\n\n\t/* when we get the reply, then don't update the header\n\tin the daemon, instead send the reply up to the client and get it to\n\tdo the work. This makes it race free, as the client held the\n\tchainlock the whole time */\n\tonreply:\n\t\tsend_record_to_client();\n }\n\nnotice that the above code in the daemon involves no IO on the\ndatabase, and no locking. The client is doing all the db IO and\nlocking.\n\nAdditionally, in the ctdb daemon, when it receives a ctdb request from\na remote node that requires it to read/write the ltdb, it uses the\nevent driven tdb code I showed in the last message to do the IOs. \n\n ctdbd_process_remote_request() {\n\t/* try to get the lock in a non-blocking fashion */\n\ttdb_chainlock_nonblock();\n\n\t/* if we can't get the lock immediately, then use the event\n\tdriven tdb locking to defer the request until we get the lock\n\t*/\n\tif (!got_lock) {\n\t\t/* pass in the request as the private data in the callback,\n\t\t   so we can retry the request when the event driven\n\t\t   locking triggers */\n\t\ttdb_chainlockwait(....., ctdbd_process_remote_request, request);\n\t\treturn;\n\t}\n\n\t/* we have the lock, process the request normally */\n\t....\n }\n\nThe risk with all this is that the client will die before it updates\nthe header on the record, thus leaving the database with an inconsistent\ndmaster. We can handle that in the destructor for the client, by\nchecking that the record header wasupdated for the last record it\noperated on. We only have to check at most 1 record per client\n(assuming clients are single threaded).\n\nMake sense? We should be able to make this race free, and it should\nrun as fast as normal Samba on local tdb for the uncontended case. \n\nCheers, Tridge\n\n"}
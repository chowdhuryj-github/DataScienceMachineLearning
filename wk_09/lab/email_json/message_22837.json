{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "gd@samba.org", "subject": "svn commit: samba r22664 - in branches/SAMBA_3_0/source: . include\n\tlibads libsmb", "body": "Author: gd\nDate: 2007-05-04 09:55:40 +0000 (Fri, 04 May 2007)\nNew Revision: 22664\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22664\n\nLog:\nWhen we have krb5_get_init_creds_opt_get_error() then try to get the NTSTATUS\ncodes directly out of the krb5_error edata.\n\nGuenther\n\nModified:\n   branches/SAMBA_3_0/source/configure.in\n   branches/SAMBA_3_0/source/include/ads.h\n   branches/SAMBA_3_0/source/libads/kerberos.c\n   branches/SAMBA_3_0/source/libsmb/clikrb5.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0/source/configure.in\n===================================================================\n--- branches/SAMBA_3_0/source/configure.in\t2007-05-04 09:46:17 UTC (rev 22663)\n+++ branches/SAMBA_3_0/source/configure.in\t2007-05-04 09:55:40 UTC (rev 22664)\n@@ -3658,6 +3658,7 @@\n   AC_CHECK_FUNC_EXT(initialize_krb5_error_table, $KRB5_LIBS)\n   AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_alloc, $KRB5_LIBS)\n   AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_free, $KRB5_LIBS)\n+  AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_get_error, $KRB5_LIBS)\n   AC_CHECK_FUNC_EXT(krb5_enctype_to_string, $KRB5_LIBS)\n \n   LIBS=\"$KRB5_LIBS $LIBS\"\n\nModified: branches/SAMBA_3_0/source/include/ads.h\n===================================================================\n--- branches/SAMBA_3_0/source/include/ads.h\t2007-05-04 09:46:17 UTC (rev 22663)\n+++ branches/SAMBA_3_0/source/include/ads.h\t2007-05-04 09:55:40 UTC (rev 22664)\n@@ -298,6 +298,12 @@\n \n #ifdef HAVE_KRB5\n typedef struct {\n+\tNTSTATUS ntstatus;\n+\tuint32 unknown1;\n+\tuint32 unknown2; /* 0x00000001 */\n+} KRB5_EDATA_NTSTATUS;\n+\n+typedef struct {\n #if defined(HAVE_MAGIC_IN_KRB5_ADDRESS) && defined(HAVE_ADDRTYPE_IN_KRB5_ADDRESS) /* MIT */\n \tkrb5_address **addrs;\n #elif defined(HAVE_KRB5_ADDRESSES) /* Heimdal */\n\nModified: branches/SAMBA_3_0/source/libads/kerberos.c\n===================================================================\n--- branches/SAMBA_3_0/source/libads/kerberos.c\t2007-05-04 09:46:17 UTC (rev 22663)\n+++ branches/SAMBA_3_0/source/libads/kerberos.c\t2007-05-04 09:55:40 UTC (rev 22664)\n@@ -55,6 +55,127 @@\n \treturn 0;\n }\n \n+static BOOL smb_krb5_err_io_nstatus(TALLOC_CTX *mem_ctx, \n+\t\t\t\t    DATA_BLOB *edata_blob, \n+\t\t\t\t    KRB5_EDATA_NTSTATUS *edata)\n+{\n+\tBOOL ret = False;\n+\tprs_struct ps;\n+\n+\tif (!mem_ctx || !edata_blob || !edata) \n+\t\treturn False;\n+\n+\tif (!prs_init(&ps, edata_blob->length, mem_ctx, UNMARSHALL))\n+\t\treturn False;\n+\n+\tif (!prs_copy_data_in(&ps, (char *)edata_blob->data, edata_blob->length))\n+\t\tgoto out;\n+\n+\tprs_set_offset(&ps, 0);\n+\n+\tif (!prs_ntstatus(\"ntstatus\", &ps, 1, &edata->ntstatus))\n+\t\tgoto out;\n+\n+\tif (!prs_uint32(\"unknown1\", &ps, 1, &edata->unknown1))\n+\t\tgoto out;\n+\n+\tif (!prs_uint32(\"unknown2\", &ps, 1, &edata->unknown2)) /* only seen 00000001 here */\n+\t\tgoto out;\n+\n+\tret = True;\n+ out:\n+\tprs_mem_free(&ps);\n+\n+\treturn ret;\n+}\n+\n+ static BOOL smb_krb5_get_ntstatus_from_krb5_error(krb5_error *error,\n+\t\t\t\t\t\t   NTSTATUS *nt_status)\n+{\n+\tDATA_BLOB edata;\n+\tDATA_BLOB unwrapped_edata;\n+\tTALLOC_CTX *mem_ctx;\n+\tKRB5_EDATA_NTSTATUS parsed_edata;\n+\n+#ifdef HAVE_E_DATA_POINTER_IN_KRB5_ERROR\n+\tedata = data_blob(error->e_data->data, error->e_data->length);\n+#else\n+\tedata = data_blob(error->e_data.data, error->e_data.length);\n+#endif /* HAVE_E_DATA_POINTER_IN_KRB5_ERROR */\n+\n+#ifdef DEVELOPER\n+\tdump_data(10, edata.data, edata.length);\n+#endif /* DEVELOPER */\n+\n+\tmem_ctx = talloc_init(\"smb_krb5_get_ntstatus_from_krb5_error\");\n+\tif (mem_ctx == NULL) {\n+\t\tdata_blob_free(&edata);\n+\t\treturn False;\n+\t}\n+\n+\tif (!unwrap_edata_ntstatus(mem_ctx, &edata, &unwrapped_edata)) {\n+\t\tdata_blob_free(&edata);\n+\t\tTALLOC_FREE(mem_ctx);\n+\t\treturn False;\n+\t}\n+\n+\tdata_blob_free(&edata);\n+\n+\tif (!smb_krb5_err_io_nstatus(mem_ctx, &unwrapped_edata, &parsed_edata)) {\n+\t\tdata_blob_free(&unwrapped_edata);\n+\t\tTALLOC_FREE(mem_ctx);\n+\t\treturn False;\n+\t}\n+\n+\tdata_blob_free(&unwrapped_edata);\n+\n+\tif (nt_status) {\n+\t\t*nt_status = parsed_edata.ntstatus;\n+\t}\n+\n+\tTALLOC_FREE(mem_ctx);\n+\n+\treturn True;\n+}\n+\n+ static BOOL smb_krb5_get_ntstatus_from_krb5_error_init_creds_opt(krb5_context ctx, \n+ \t\t\t\t\t\t\t\t  krb5_get_init_creds_opt *opt, \n+\t\t\t\t\t\t\t\t  NTSTATUS *nt_status)\n+{\n+\tBOOL ret = False;\n+\tkrb5_error *error = NULL;\n+\n+#ifdef HAVE_KRB5_GET_INIT_CREDS_OPT_GET_ERROR\n+\tret = krb5_get_init_creds_opt_get_error(ctx, opt, &error);\n+\tif (ret) {\n+\t\tDEBUG(1,(\"krb5_get_init_creds_opt_get_error gave: %s\\n\", \n+\t\t\terror_message(ret)));\n+\t\treturn False;\n+\t}\n+#endif /* HAVE_KRB5_GET_INIT_CREDS_OPT_GET_ERROR */\n+\n+\tif (!error) {\n+\t\tDEBUG(1,(\"no krb5_error\\n\"));\n+\t\treturn False;\n+\t}\n+\n+#ifdef HAVE_E_DATA_POINTER_IN_KRB5_ERROR\n+\tif (!error->e_data) {\n+#else\n+\tif (error->e_data.data == NULL) {\n+#endif /* HAVE_E_DATA_POINTER_IN_KRB5_ERROR */\n+\t\tDEBUG(1,(\"no edata in krb5_error\\n\")); \n+\t\tkrb5_free_error(ctx, error);\n+\t\treturn False;\n+\t}\n+\n+\tret = smb_krb5_get_ntstatus_from_krb5_error(error, nt_status);\n+\n+\tkrb5_free_error(ctx, error);\n+\n+\treturn ret;\n+}\n+\n /*\n   simulate a kinit, putting the tgt in the given cache location. If cache_name == NULL\n   place in default cache location.\n\nModified: branches/SAMBA_3_0/source/libsmb/clikrb5.c\n===================================================================\n--- branches/SAMBA_3_0/source/libsmb/clikrb5.c\t2007-05-04 09:46:17 UTC (rev 22663)\n+++ branches/SAMBA_3_0/source/libsmb/clikrb5.c\t2007-05-04 09:55:40 UTC (rev 22664)\n@@ -272,6 +272,45 @@\n }\n #endif\n \n+BOOL unwrap_edata_ntstatus(TALLOC_CTX *mem_ctx, \n+\t\t\t   DATA_BLOB *edata, \n+\t\t\t   DATA_BLOB *edata_out)\n+{\n+\tDATA_BLOB edata_contents;\n+\tASN1_DATA data;\n+\tint edata_type;\n+\n+\tif (!edata->length) {\n+\t\treturn False;\n+\t}\n+\n+\tasn1_load(&data, *edata);\n+\tasn1_start_tag(&data, ASN1_SEQUENCE(0));\n+\tasn1_start_tag(&data, ASN1_CONTEXT(1));\n+\tasn1_read_Integer(&data, &edata_type);\n+\n+\tif (edata_type != KRB5_PADATA_PW_SALT) {\n+\t\tDEBUG(0,(\"edata is not of required type %d but of type %d\\n\", \n+\t\t\tKRB5_PADATA_PW_SALT, edata_type));\n+\t\tasn1_free(&data);\n+\t\treturn False;\n+\t}\n+\t\n+\tasn1_start_tag(&data, ASN1_CONTEXT(2));\n+\tasn1_read_OctetString(&data, &edata_contents);\n+\tasn1_end_tag(&data);\n+\tasn1_end_tag(&data);\n+\tasn1_end_tag(&data);\n+\tasn1_free(&data);\n+\n+\t*edata_out = data_blob_talloc(mem_ctx, edata_contents.data, edata_contents.length);\n+\n+\tdata_blob_free(&edata_contents);\n+\n+\treturn True;\n+}\n+\n+\n BOOL unwrap_pac(TALLOC_CTX *mem_ctx, DATA_BLOB *auth_data, DATA_BLOB *unwrapped_pac_data)\n {\n \tDATA_BLOB pac_contents;\n\n"}
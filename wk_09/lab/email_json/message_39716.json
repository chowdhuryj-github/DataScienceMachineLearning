{"category": "ham", "to_address": "\"Paul Lalli\" <mritty@gmail.com>", "from_address": "\"Sharan Basappa\" <sharan.basappa@gmail.com>", "subject": "Re: did I get greedy quantifiers wrong ?", "body": "Thanks Paul, Yitzle ..\n\nOn 31 May 2007 07:28:26 -0700, Paul Lalli  wrote:\n> On May 31, 10:15 am, sharan.basa...@gmail.com (Sharan Basappa) wrote:\n> > Thanks a lot Paul ..\n> >\n> > For this rule :\n> > $str = mississippi;\n> > $str =~ m/m(.*i)(.*pi)/;\n> >\n> > My initial understanding was that .*i would match all the way till last char i.\n>\n> > This would indeed be true if .*i was not followed by .*pi.\n>\n> > Do you agree ?\n>\n> Yes.  Like you said initially - a regexp quantifier will match as much\n> as possible WITHOUT PREVENING THE MATCH FROM SUCEEDING.  If the .*i\n> matched all the way up until the very last i, then the .*pi would fail\n> because there'd be nothing left to match.\n>\n> FWIW, you can add:\n> use re 'debug';\n> to the top of your script to see exactly what Perl does when trying to\n> match a regexp.  You'll see in this case that it first tries to\n> let .*i match all the way to the end, but then finds that .*pi now\n> fails, so it backtracks, letting the .* part of .*i match less and\n> less until .*pi can also match.\n>\n> Paul Lalli\n>\n>\n> --\n> To unsubscribe, e-mail: beginners-unsubscribe@perl.org\n> For additional commands, e-mail: beginners-help@perl.org\n> http://learn.perl.org/\n>\n>\n>\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
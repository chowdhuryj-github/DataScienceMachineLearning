{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Jelmer Vernooij <jelmer@samba.org>", "subject": "Rev 12126: Use talloc in loadparm. in\n\tfile:///home/jelmer/bzr.samba/SAMBA_4_0/", "body": "At file:///home/jelmer/bzr.samba/SAMBA_4_0/\n\n------------------------------------------------------------\nrevno: 12126\nrevision-id: jelmer@samba.org-20070509112813-hfcw7ovikq4o69bj\nparent: jelmer@samba.org-20070509105243-c8umb0w5w1d1ogsj\ncommitter: Jelmer Vernooij \nbranch nick: SAMBA_4_0\ntimestamp: Wed 2007-05-09 13:28:13 +0200\nmessage:\n  Use talloc in loadparm.\nmodified:\n  source/lib/util/util_str.c     svn-v2:13658@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0-source%2flib%2futil%2futil_str.c\n  source/param/loadparm.c        svn-v2:2@0c0555d6-39d7-0310-84fc-f1cc0bd64818-trunk-source%2fparam%2floadparm.c\n=== modified file 'source/lib/util/util_str.c'\n--- a/source/lib/util/util_str.c\t2007-04-19 14:21:56 +0000\n+++ b/source/lib/util/util_str.c\t2007-05-09 11:28:13 +0000\n@@ -246,36 +246,23 @@\n }\n \n /**\n- Set a string value, allocing the space for the string\n-**/\n-static BOOL string_init(char **dest,const char *src)\n-{\n-\tif (!src) src = \"\";\n-\n-\t(*dest) = strdup(src);\n-\tif ((*dest) == NULL) {\n-\t\tDEBUG(0,(\"Out of memory in string_init\\n\"));\n-\t\treturn False;\n-\t}\n-\treturn True;\n-}\n-\n-/**\n- Free a string value.\n-**/\n-_PUBLIC_ void string_free(char **s)\n-{\n-\tif (s) SAFE_FREE(*s);\n-}\n-\n-/**\n  Set a string value, deallocating any existing space, and allocing the space\n  for the string\n **/\n-_PUBLIC_ BOOL string_set(char **dest, const char *src)\n+_PUBLIC_ BOOL string_set(TALLOC_CTX *mem_ctx, char **dest, const char *src)\n {\n-\tstring_free(dest);\n-\treturn string_init(dest,src);\n+\tif (dest != NULL)\n+\t\ttalloc_free(*dest);\n+\n+\tif (src == NULL) \n+\t\tsrc = \"\";\n+\n+\t(*dest) = talloc_strdup(mem_ctx, src);\n+\tif ((*dest) == NULL) {\n+\t\tDEBUG(0,(\"Out of memory in string_set\\n\"));\n+\t\treturn false;\n+\t}\n+\treturn true;\n }\n \n /**\n\n=== modified file 'source/param/loadparm.c'\n--- a/source/param/loadparm.c\t2007-05-09 10:52:43 +0000\n+++ b/source/param/loadparm.c\t2007-05-09 11:28:13 +0000\n@@ -598,7 +598,7 @@\n \t\t     parm_table[i].type == P_USTRING) &&\n \t\t    parm_table[i].ptr &&\n \t\t    !(parm_table[i].flags & FLAG_CMDLINE)) {\n-\t\t\tstring_set(parm_table[i].ptr, \"\");\n+\t\t\tstring_set(ctx, parm_table[i].ptr, \"\");\n \t\t}\n \t}\n \n@@ -974,30 +974,28 @@\n \tif (lookup_service >= ctx->iNumServices) \n \t\treturn NULL;\n \t\n-\tdata = (lookup_service < 0) ? \n-\t\tGlobals.param_opt : ctx->ServicePtrs[lookup_service]->param_opt;\n     \n \tasprintf(&vfskey, \"%s:%s\", type, option);\n \tstrlower(vfskey);\n \n-\twhile (data) {\n+\tdata = (lookup_service < 0) ? \n+\t\tGlobals.param_opt : ctx->ServicePtrs[lookup_service]->param_opt;\n+\tfor (; data; data = data->next) {\n \t\tif (strcmp(data->key, vfskey) == 0) {\n \t\t\tfree(vfskey);\n \t\t\treturn data->value;\n \t\t}\n-\t\tdata = data->next;\n \t}\n \n \tif (lookup_service >= 0) {\n \t\t/* Try to fetch the same option but from globals */\n \t\t/* but only if we are not already working with Globals */\n-\t\tdata = Globals.param_opt;\n-\t\twhile (data) {\n+\t\t\n+\t\tfor (data = Globals.param_opt; data; data = data->next) {\n \t\t\tif (strcmp(data->key, vfskey) == 0) {\n \t\t\t\tfree(vfskey);\n \t\t\t\treturn data->value;\n \t\t\t}\n-\t\t\tdata = data->next;\n \t\t}\n \t}\n \n@@ -1167,45 +1165,7 @@\n \n static void free_service(struct service *pservice)\n {\n-\tint i;\n-        struct param_opt *data, *pdata;\n-\tif (!pservice)\n-\t\treturn;\n-\n-\tif (pservice->szService)\n-\t\tDEBUG(5, (\"free_service: Freeing service %s\\n\",\n-\t\t       pservice->szService));\n-\n-\tstring_free(&pservice->szService);\n-\tSAFE_FREE(pservice->copymap);\n-\n-\tfor (i = 0; parm_table[i].label; i++) {\n-\t\tif ((parm_table[i].type == P_STRING ||\n-\t\t     parm_table[i].type == P_USTRING) &&\n-\t\t    parm_table[i].class == P_LOCAL) {\n-\t\t\tstring_free((char **)\n-\t\t\t\t    (((char *)pservice) +\n-\t\t\t\t     PTR_DIFF(parm_table[i].ptr, &sDefault)));\n-\t\t} else if (parm_table[i].type == P_LIST &&\n-\t\t\t   parm_table[i].class == P_LOCAL) {\n-\t\t\tchar ***listp = (char ***)(((char *)pservice) + \n-\t\t\t\t\t\t   PTR_DIFF(parm_table[i].ptr, &sDefault));\n-\t\t\ttalloc_free(*listp);\n-\t\t\t*listp = NULL;\n-\t\t}\n-\t}\n-\t\t\t\t\n-\tDEBUG(5,(\"Freeing parametrics:\\n\"));\n-\tdata = pservice->param_opt;\n-\twhile (data) {\n-\t\tDEBUG(5,(\"[%s = %s]\\n\", data->key, data->value));\n-\t\tstring_free(&data->key);\n-\t\tstring_free(&data->value);\n-\t\tpdata = data->next;\n-\t\tSAFE_FREE(data);\n-\t\tdata = pdata;\n-\t}\n-\n+\ttalloc_free_children(pservice);\n \tZERO_STRUCTP(pservice);\n }\n \n@@ -1225,21 +1185,19 @@\n \ttservice = *pservice;\n \n \t/* it might already exist */\n-\tif (name) {\n+\tif (name != NULL) {\n \t\ti = getservicebyname(ctx, name, NULL);\n \t\tif (i >= 0) {\n \t\t\t/* Clean all parametric options for service */\n \t\t\t/* They will be added during parsing again */\n \t\t\tdata = ctx->ServicePtrs[i]->param_opt;\n \t\t\twhile (data) {\n-\t\t\t\tstring_free(&data->key);\n-\t\t\t\tstring_free(&data->value);\n \t\t\t\tpdata = data->next;\n-\t\t\t\tSAFE_FREE(data);\n+\t\t\t\ttalloc_free(data);\n \t\t\t\tdata = pdata;\n \t\t\t}\n \t\t\tctx->ServicePtrs[i]->param_opt = NULL;\n-\t\t\treturn (i);\n+\t\t\treturn i;\n \t\t}\n \t}\n \n@@ -1252,7 +1210,8 @@\n \tif (i == ctx->iNumServices) {\n \t\tstruct service **tsp;\n \t\t\n-\t\ttsp = realloc_p(ctx->ServicePtrs, struct service *,\tnum_to_alloc);\n+\t\ttsp = talloc_realloc(ctx, ctx->ServicePtrs, struct service *, \n+\t\t\t\t\t\t\t num_to_alloc);\n \t\t\t\t\t   \n \t\tif (!tsp) {\n \t\t\tDEBUG(0,(\"add_a_service: failed to enlarge ServicePtrs!\\n\"));\n@@ -1260,7 +1219,7 @@\n \t\t}\n \t\telse {\n \t\t\tctx->ServicePtrs = tsp;\n-\t\t\tctx->ServicePtrs[ctx->iNumServices] = malloc_p(struct service);\n+\t\t\tctx->ServicePtrs[ctx->iNumServices] = talloc(ctx, struct service);\n \t\t}\n \t\tif (!ctx->ServicePtrs[ctx->iNumServices]) {\n \t\t\tDEBUG(0,(\"add_a_service: out of memory!\\n\"));\n@@ -1276,8 +1235,8 @@\n \tinit_service(ctx->ServicePtrs[i]);\n \tcopy_service(ctx->ServicePtrs[i], &tservice, NULL);\n \tif (name)\n-\t\tstring_set(&ctx->ServicePtrs[i]->szService, name);\n-\treturn (i);\n+\t\tstring_set(ctx, &ctx->ServicePtrs[i]->szService, name);\n+\treturn i;\n }\n \n /***************************************************************************\n@@ -1305,13 +1264,13 @@\n \t\tstring_sub(newHomedir,\"%H\", pszHomedir, sizeof(newHomedir)); \n \t}\n \n-\tstring_set(&ctx->ServicePtrs[i]->szPath, newHomedir);\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->szPath, newHomedir);\n \n \tif (!(*(ctx->ServicePtrs[i]->comment))) {\n \t\tpstring comment;\n \t\tslprintf(comment, sizeof(comment) - 1,\n \t\t\t \"Home directory of %s\", user);\n-\t\tstring_set(&ctx->ServicePtrs[i]->comment, comment);\n+\t\tstring_set(ctx, &ctx->ServicePtrs[i]->comment, comment);\n \t}\n \tctx->ServicePtrs[i]->bAvailable = sDefault.bAvailable;\n \tctx->ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;\n@@ -1319,7 +1278,7 @@\n \tDEBUG(3, (\"adding home's share [%s] for user '%s' at '%s'\\n\", pszHomename, \n \t       user, newHomedir));\n \t\n-\treturn (True);\n+\treturn true;\n }\n \n /***************************************************************************\n@@ -1348,9 +1307,9 @@\n \tslprintf(comment, sizeof(comment) - 1,\n \t\t \"%s Service (%s)\", fstype, Globals.szServerString);\n \n-\tstring_set(&ctx->ServicePtrs[i]->szPath, tmpdir());\n-\tstring_set(&ctx->ServicePtrs[i]->comment, comment);\n-\tstring_set(&ctx->ServicePtrs[i]->fstype, fstype);\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->szPath, tmpdir());\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->comment, comment);\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->fstype, fstype);\n \tctx->ServicePtrs[i]->iMaxConnections = -1;\n \tctx->ServicePtrs[i]->bAvailable = true;\n \tctx->ServicePtrs[i]->bRead_only = true;\n@@ -1363,7 +1322,7 @@\n \n \tDEBUG(3, (\"adding hidden service %s\\n\", name));\n \n-\treturn (True);\n+\treturn true;\n }\n \n /***************************************************************************\n@@ -1377,16 +1336,16 @@\n \tint i = add_a_service(ctx, ctx->ServicePtrs[iDefaultService], pszPrintername);\n \n \tif (i < 0)\n-\t\treturn (False);\n+\t\treturn false;\n \n-\t/* note that we do NOT default the availability flag to True - */\n+\t/* note that we do NOT default the availability flag to true - */\n \t/* we take it from the default service passed. This allows all */\n \t/* dynamic printers to be disabled by disabling the [printers] */\n \t/* entry (if/when the 'available' keyword is implemented!).    */\n \n \t/* the printer name is set to the service name. */\n-\tstring_set(&ctx->ServicePtrs[i]->szPrintername, pszPrintername);\n-\tstring_set(&ctx->ServicePtrs[i]->comment, comment);\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->szPrintername, pszPrintername);\n+\tstring_set(ctx, &ctx->ServicePtrs[i]->comment, comment);\n \tctx->ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;\n \t/* Printers cannot be read_only. */\n \tctx->ServicePtrs[i]->bRead_only = false;\n@@ -1395,7 +1354,7 @@\n \n \tDEBUG(3, (\"adding printer service %s\\n\", pszPrintername));\n \n-\treturn (True);\n+\treturn true;\n }\n \n /***************************************************************************\n@@ -1408,11 +1367,11 @@\n \tint iIndex;\n \n \tif (*pszParmName == '-')\n-\t\treturn (-1);\n+\t\treturn -1;\n \n \tfor (iIndex = 0; parm_table[iIndex].label; iIndex++)\n \t\tif (strwicmp(parm_table[iIndex].label, pszParmName) == 0)\n-\t\t\treturn (iIndex);\n+\t\t\treturn iIndex;\n \n \t/* Warn only if it isn't parametric option */\n \tif (strchr(pszParmName, ':') == NULL)\n@@ -1420,7 +1379,7 @@\n \t/* We do return 'fail' for parametric options as well because they are\n \t   stored in different storage\n \t */\n-\treturn (-1);\n+\treturn -1;\n }\n \n \n@@ -1502,17 +1461,17 @@\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase P_STRING:\n-\t\t\t\t\tstring_set(dest_ptr,\n+\t\t\t\t\tstring_set(pserviceDest, dest_ptr,\n \t\t\t\t\t\t   *(char **)src_ptr);\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase P_USTRING:\n-\t\t\t\t\tstring_set(dest_ptr,\n+\t\t\t\t\tstring_set(pserviceDest, dest_ptr,\n \t\t\t\t\t\t   *(char **)src_ptr);\n \t\t\t\t\tstrupper(*(char **)dest_ptr);\n \t\t\t\t\tbreak;\n \t\t\t\tcase P_LIST:\n-\t\t\t\t\t*(const char ***)dest_ptr = str_list_copy(talloc_autofree_context(), \n+\t\t\t\t\t*(const char ***)dest_ptr = str_list_copy(pserviceDest, \n \t\t\t\t\t\t\t\t\t\t  *(const char ***)src_ptr);\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n@@ -1528,30 +1487,26 @@\n \t\t\t       sizeof(int) * NUMPARAMETERS);\n \t}\n \t\n-\tdata = pserviceSource->param_opt;\n-\twhile (data) {\n+\tfor (data = pserviceSource->param_opt; data; data = data->next) {\n \t\tnot_added = true;\n-\t\tpdata = pserviceDest->param_opt;\n \t\t/* Traverse destination */\n-\t\twhile (pdata) {\n+\t\tfor (pdata = pserviceDest->param_opt; pdata; pdata = pdata->next) {\n \t\t\t/* If we already have same option, override it */\n \t\t\tif (strcmp(pdata->key, data->key) == 0) {\n-\t\t\t\tstring_free(&pdata->value);\n-\t\t\t\tpdata->value = strdup(data->value);\n+\t\t\t\ttalloc_free(&pdata->value);\n+\t\t\t\tpdata->value = talloc_strdup(pdata, data->value);\n \t\t\t\tnot_added = false;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tpdata = pdata->next;\n \t\t}\n \t\tif (not_added) {\n-\t\t\tparamo = malloc_p(struct param_opt);\n+\t\t\tparamo = talloc(pserviceDest, struct param_opt);\n \t\t\tif (!paramo)\n \t\t\t\tsmb_panic(\"OOM\");\n-\t\t\tparamo->key = strdup(data->key);\n-\t\t\tparamo->value = strdup(data->value);\n+\t\t\tparamo->key = talloc_strdup(paramo, data->key);\n+\t\t\tparamo->value = talloc_strdup(paramo, data->value);\n \t\t\tDLIST_ADD(pserviceDest->param_opt, paramo);\n \t\t}\n-\t\tdata = data->next;\n \t}\n }\n \n@@ -1609,18 +1564,18 @@\n \t}\n \n \tif (!f) {\n-\t\tf = malloc_p(struct file_lists);\n+\t\tf = talloc(ctx, struct file_lists);\n \t\tif (!f)\n \t\t\treturn;\n \t\tf->next = ctx->file_lists;\n \t\tf->name = strdup(fname);\n \t\tif (!f->name) {\n-\t\t\tSAFE_FREE(f);\n+\t\t\ttalloc_free(f);\n \t\t\treturn;\n \t\t}\n-\t\tf->subfname = strdup(subfname);\n+\t\tf->subfname = talloc_strdup(f, subfname);\n \t\tif (!f->subfname) {\n-\t\t\tSAFE_FREE(f);\n+\t\t\ttalloc_free(f);\n \t\t\treturn;\n \t\t}\n \t\tctx->file_lists = f;\n@@ -1658,7 +1613,7 @@\n \t\t\t\t (\"file %s modified: %s\\n\", n2,\n \t\t\t\t  ctime(&mod_time)));\n \t\t\tf->modtime = mod_time;\n-\t\t\tSAFE_FREE(f->subfname);\n+\t\t\ttalloc_free(f->subfname);\n \t\t\tf->subfname = strdup(n2);\n \t\t\treturn true;\n \t\t}\n@@ -1680,7 +1635,7 @@\n \n \tadd_to_file_list(ctx, pszParmValue, fname);\n \n-\tstring_set(ptr, fname);\n+\tstring_set(ctx, ptr, fname);\n \n \tif (file_exist(fname))\n \t\treturn (pm_process(fname, parse_section, parse_parameter, ctx));\n@@ -1701,7 +1656,7 @@\n \tint iTemp;\n \tstruct service serviceTemp;\n \n-\tstring_set(ptr, pszParmValue);\n+\tstring_set(ctx, ptr, pszParmValue);\n \n \tinit_service(&serviceTemp);\n \n@@ -1734,8 +1689,8 @@\n static void init_copymap(struct service *pservice)\n {\n \tint i;\n-\tSAFE_FREE(pservice->copymap);\n-\tpservice->copymap = malloc_array_p(int, NUMPARAMETERS);\n+\tpservice->copymap = talloc_realloc(pservice, pservice->copymap, \n+\t\t\t\t\t\t\t\t\t   int, NUMPARAMETERS);\n \tif (!pservice->copymap)\n \t\tDEBUG(0,\n \t\t      (\"Couldn't allocate copymap!! (size %d)\\n\",\n@@ -1754,20 +1709,24 @@\n {\n \tstruct param_opt *paramo, *data;\n \tchar *name;\n+\tTALLOC_CTX *mem_ctx;\n \n \twhile (isspace((unsigned char)*pszParmName)) {\n \t\tpszParmName++;\n \t}\n \n \tname = strdup(pszParmName);\n-\tif (!name) return False;\n+\tif (name == NULL) \n+\t\treturn False;\n \n \tstrlower(name);\n \n \tif (snum < 0) {\n \t\tdata = Globals.param_opt;\n+\t\tmem_ctx = lp_talloc; /* FIXME */\n \t} else {\n \t\tdata = ctx->ServicePtrs[snum]->param_opt;\n+\t\tmem_ctx = ctx->ServicePtrs[snum];\n \t}\n \n \t/* Traverse destination */\n@@ -1780,19 +1739,19 @@\n \t\t\t\treturn True;\n \t\t\t}\n \n-\t\t\tfree(paramo->value);\n-\t\t\tparamo->value = strdup(pszParmValue);\n+\t\t\ttalloc_free(paramo->value);\n+\t\t\tparamo->value = talloc_strdup(paramo, pszParmValue);\n \t\t\tparamo->flags = flags;\n \t\t\tfree(name);\n \t\t\treturn True;\n \t\t}\n \t}\n \n-\tparamo = malloc_p(struct param_opt);\n+\tparamo = talloc(mem_ctx, struct param_opt);\n \tif (!paramo)\n \t\tsmb_panic(\"OOM\");\n-\tparamo->key = strdup(name);\n-\tparamo->value = strdup(pszParmValue);\n+\tparamo->key = talloc_strdup(paramo, name);\n+\tparamo->value = talloc_strdup(paramo, pszParmValue);\n \tparamo->flags = flags;\n \tif (snum < 0) {\n \t\tDLIST_ADD(Globals.param_opt, paramo);\n@@ -1823,7 +1782,7 @@\n \t\t\treturn lp_do_parameter_parametric(ctx, snum, pszParmName, pszParmValue, 0);\n \t\t}\n \t\tDEBUG(0, (\"Ignoring unknown parameter \\\"%s\\\"\\n\", pszParmName));\n-\t\treturn (True);\n+\t\treturn true;\n \t}\n \n \tif (parm_table[parmnum].flags & FLAG_DEPRECATED) {\n@@ -1834,7 +1793,7 @@\n \t/* if the flag has been set on the command line, then don't allow override,\n \t   but don't report an error */\n \tif (parm_table[parmnum].flags & FLAG_CMDLINE) {\n-\t\treturn True;\n+\t\treturn true;\n \t}\n \n \tdef_ptr = parm_table[parmnum].ptr;\n@@ -1847,7 +1806,7 @@\n \t\t\tDEBUG(0,\n \t\t\t      (\"Global parameter %s found in service section!\\n\",\n \t\t\t       pszParmName));\n-\t\t\treturn (True);\n+\t\t\treturn true;\n \t\t}\n \t\tparm_ptr =\n \t\t\t((char *)ctx->ServicePtrs[snum]) + PTR_DIFF(def_ptr,\n@@ -1868,7 +1827,7 @@\n \t/* if it is a special case then go ahead */\n \tif (parm_table[parmnum].special) {\n \t\tparm_table[parmnum].special(ctx, pszParmValue, (char **)parm_ptr);\n-\t\treturn (True);\n+\t\treturn true;\n \t}\n \n \t/* now switch on the type of variable it is */\n@@ -1909,11 +1868,11 @@\n \t\t\tbreak;\n \n \t\tcase P_STRING:\n-\t\t\tstring_set(parm_ptr, pszParmValue);\n+\t\t\tstring_set(ctx, parm_ptr, pszParmValue);\n \t\t\tbreak;\n \n \t\tcase P_USTRING:\n-\t\t\tstring_set(parm_ptr, pszParmValue);\n+\t\t\tstring_set(ctx, parm_ptr, pszParmValue);\n \t\t\tstrupper(*(char **)parm_ptr);\n \t\t\tbreak;\n \n@@ -1949,7 +1908,7 @@\n \t\t}\n \t}\n \n-\treturn (True);\n+\treturn true;\n }\n \n /***************************************************************************\n\n"}
{"category": "ham", "to_address": "Chas Owens <chas.owens@gmail.com>", "from_address": "Pierre Mariani <frenchyp@gmail.com>", "subject": "Re: improving my code: array of references", "body": "On Fri, 2007-04-27 at 12:03 -0400, Chas Owens wrote:\n> On 4/27/07, Pierre Mariani  wrote:\n> snip\n> > > - modify_variable() doesn't appear to modify anything, otherwise why\n> > > are you assigning its return value to the scalar passed as a parameter?\n> > > It seems to be just a function.\n> >\n> > Modify_variable modifies its input variable.\n> \n> I think the issue is what you mean by \"modifies\".  In order to say\n> that the modify_variable function modifies its input then something\n> like the following must be true:\n> \n> my $foo = 5\n> modify_variable($foo)\n> print \"$foo\\n\"; #prints \"6\\n\"\n> \n\nYeah, that's exactly it.\n\n> \n> >\n> > > - Why are you using references? Are you sure you need to?\n> > >\n> > Please correct me if I am wrong.\n> > My understanding is that:\n> > 1) if I do:\n> >         my @array = ($a, $b, $c);\n> >         for (@array) { $_ = modify_variable($_)}\n> > I am going to modify $array[0], $array[1] and $array[2], and NOT $a, $b,\n> > $c.\n> \n> Yes, that is correct, but this is most likely an invalid use of an\n> array.  Either you should be using a array from the beginning, or you\n> should be using a list.  Assigning a bunch of scalar variables to an\n> array just to group them is useless.\n\nAgree on that, but given other details that I didn't communicate, it is\nnot quite possible (this is actually a pl/perlu function in postgresql,\nthe variables I am working on are passed to the function, and their type\nis limited by the function definition, so unless I create a composite\ntype I can't pass them as an array directly).\n\n> $_ = modify_variable($_) for $a, $b, $c;\n> \n> is a better construct.  However, it would be even better to make\n> modify_variable take multiple arguments:\n> \n> ($a, $b, $c) = modify_variables($a, $b, $c);\n\nI agree on that (even better would be to make it work on references),\nbut unfortunately I can't modify it.\n\n> > 2) if I do:\n> >         for ($a, $b, $c) {$_ = modify_variable($_)}\n> > I am going to modify $a, $b, $c, which is good, but if $a, $b, $c are\n> > big I am going to be passing around lots of data.\n> \n> Ah, here is the crux of the problem.  You thing you are passing\n> copies.  Perl aliases its arguments to functions.  In C++ terms you\n> are passing by reference (if I got the terminology right).  Passing\n> \"this is a really long string\" and \"a\" both take up the same amount of\n> time and memory.  Only passing around arrays and hashes take up O(n)\n> space and time.  That is why it is good form to pass them as\n> references.\n> \n> snip\n> > >   $_ = function($_) foreach ($var1, $var2, $var3);\n> > >\n> > > Will this do? Or is there more to the problem than you've explained?\n> snip\n> \n> $_ = function($_) foreach ($var1, $var2, $var3);\n> \n> is the same as\n> \n> foreach ($var1, $var2, $var3) {\n>     $_ = function($_)\n> }\n> \n> If you only have one statement* in a loop for can write it in the\n> former method.  It is considered by many to be clearer.\n> \n> \n> * well, you can chain statements using , but that is poor form outside\n> of Perl Golf, Obfuscation, and one-liners.\n\nThank you for the information. I was familiar with this kind of syntax\nbut never used it.\n\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
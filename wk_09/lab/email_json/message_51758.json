{"category": "ham", "to_address": "\"Speakup is a screen review system for Linux.\" <speakup@braille.uwo.ca>", "from_address": "\"Spie Sutherland\" <spie@proficio.ca>", "subject": "Re: TTSynth Is Available Again", "body": "Travis wrote:\nWhy would you need any libs (regardless of gcc version) if it was a  \nstatically linked binary?\n\nI haven't touched the TTSynth but a few years ago worked on \ngetting the tts part of viavoice working on newer versions of \nslackware and also on lfs. The problem is that when the tts \nwas released, that statically built binary was built using the \ntoolchain and runtime environment of the time, and at some \npoint it stopped working for most people. You had the choice\nnot upgrading your os (not a good choice!) or not having the \ntts, or trying to work around the problem. \n\nI forget the exact details but essentially glibc is tricky as far \nas distributions go, it is built as part of the toolchain since \nother stuff uses it, and the toolchain, that being the compiler,\nassembler, linker, binutils, etc, they work together in certain\nversions and they crash hard in others. You cannot take an\nold binutils and expect it to work with a newer gcc or \nglibc. \n\nI recall that on slackware I was able to get it working on \nnewer versions using some additional binaries and creating \nsome symbolic links, basically I copied over binaries from \nolder version of slackware and added them with the \nnecessary links so the tts could find and use them. LFS was \na different story. I had to try building several different entire \ntoolchains until I found one that worked. If you arbitrarily \npick a combination of binutils, gcc, and glibc, odds are \nthat you won't even get the toolchain built. It will fail in \nthe compile somewhere because these are moving targets.\nIt is actually quite a lot of work to get a stable toolchain\nbuilt from source, even more so if you diverge from x86\ninto arm and other architectures. \n\nAs I said, I forget the exact details, but don't forget that \neven if a binary is statically compiled, it's built to work with \na runtime c library. At some point the old binary started \ncrashing with unable to resolve symbol errors. If one \nwants to get ibm tts working on slackware or lfs they \nprobably need to incorporate old runtime libraries that\ndon't exist. With LFS in particular, the whole idea of the\nsystem is build it as you like it, so that's why I say you\nare on your own with that system. I often see how most\nsoftware will have fedora or debian or whatever support\nor pre-compiled binaries, doubt you'll ever see them for\nLFS, it's not even reallt considered a distro, is it?\n\nOn slackware, I'm used to having to do extra work \nbecause not many projects support slackware or have\nany slackware precompiled binaries. On the other \nhand I almost never add binaries, only build from \nsource, so that never bugs me too much. It can be a \nchallenge though, for example to get the latest vmware\nworking on slackware you have to create a fake \n(empty) system v style init directory tree or the install\nwill just fail. You also have to install pam and change\na few things in the pam configuration that comes with\nvmware. I still like slackware and lfs because I can \nunderstand them. The other systems can be a bit \nmysterious at times, convenient when they work \nbut not as easy to figure out when things break. \n\n> All linux distros can use statically linked binaries can't they? so  \n> what's the problem?\n> unless static linked versions of said binary aren't possible to build  \n> perhaps?\n\n\n_______________________________________________\nSpeakup mailing list\nSpeakup@braille.uwo.ca\nhttp://speech.braille.uwo.ca/mailman/listinfo/speakup\n\n"}
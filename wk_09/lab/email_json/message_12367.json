{"category": "ham", "to_address": "Patrick Rutkowski <rutski89@gmail.com>", "from_address": "Leopold Toetsch <lt@toetsch.at>", "subject": "Re: I Don't Understand The Context Allocation/Destruction Code", "body": "Am Sonntag, 22. April 2007 09:11 schrieb Patrick Rutkowski:\n> I think Leo would be the best person to go to for an explanation,\n> especially if you plan to dramatically rework the code. \n\n> >> This is where I start not to understand.  Why reg_alloc + 7?  Why\n> >> shift left\n> >> and right by 3?\n> >\n> > I'm not sure if it is actually doing anything that needs to be that\n> > complicated to code that way.  It could be able to be written as:\n> >\n> >     const int slot = (reg_alloc + 7) / 8; /* divide by eight for\n> > some reason and round up on remainder */\n> >     reg_alloc = slot * 8; /* reg_alloc is now evenly divisible by 8 */\n\nSure. It's just rounding up to the next multpile of 8.\n\n> > ...  Now, slot is multiplied by sizeof(void*) later on,\n> > which may be why it's divided by eight in the first place.\n\nThe rounding up happens to reduce the size of the free_list array. \n\n> > The n = slot + 1 I find a little odd, because the number is already\n> > rounded up, so it's rounding up and then adding an extra place of\n> > memory.\n\nThis is for the extension of the free_list.\n\n> >> I do understand the purpose of the resizing code, but not how slot\n> >> relates to\n> >> it:\n> >>\n> >>     if (slot >= interp->ctx_mem.n_free_slots) {\n\nWell, if slot is beyond the end of the list, it's resized.\n\n> > The *(void **) has been confusing me for a long time. \n\nThe free list per size (i.e. one slot) is a linked list of pointers.\n\n> >> I'd like to find a simpler scheme, if it's possible.  Otherwise,\n> >> I'd like to\n> >> figure out what's going on so we can at least explain it somehow.\n\nWhy? This is all rather straight-forward and can be found in any memory \nallocator e.g. ins smallobjects.\n\nleo\n\n"}
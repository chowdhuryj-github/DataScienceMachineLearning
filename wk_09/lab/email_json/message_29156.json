{"category": "ham", "to_address": "Chas Owens <chas.owens@gmail.com>", "from_address": "Mathew Snyder <theillien@yahoo.com>", "subject": "Re: Stuck on a hash referrence, kinda", "body": "That's waaaaaaay over my head.  The method I used works so I'll stick with that.\n Thanks though.  :)\n\nKeep up with me and what I'm up to: http://theillien.blogspot.com\n\n\nChas Owens wrote:\n> My understanding of the problem:\n> \n> You have a ref to a HoH and you need to find all of the first set of\n> keys that have a specific, but unspecified at coding time, second key\n> or value.\n> \n> For key I would do something like this\n> \n> my $key2 = func_to_get_key2();\n> for $key1 (grep { exists $store->{$key1}{$key2} } sort keys %$store) {\n>    process($store, $key1, $key2);\n> }\n> \n> For value I would use a similar construct\n> \n> my ($key2, $value) = func_to_get_key2_and_value();\n> for $key1 (grep { $store->{$key1}{$key2} eq $value } sort keys %$store) {\n>    process($store, $key1, $key2);\n> }\n> \n> N.B. eq is not a good test of equality for numbers (use == instead)\n> and == is not a good test of equality for floating point numbers that\n> are the result of even simple operations (use an inequaltiy with an\n> appropriate delta* instead); hopefully objects will provide an\n> overridden eq or == operator or will provide an explicit method for\n> testing equality.\n> \n> \n> * I may have butchered that, what I mean is something like\n> ($value <= $target-$delta and $value <= $target+$delta)\n> where $delta is a small value that is equal to the amount of rounding\n> error you think may have crept in.\n> \n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
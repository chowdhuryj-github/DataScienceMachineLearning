{"category": "ham", "to_address": "James Keenan via RT <parrotbug-followup@parrotcode.org>", "from_address": "Andy Spieherty <spiehera@lafayette.edu>", "subject": "Re: [perl #42412] Configure.pl things =no is true ", "body": "On Tue, 1 May 2007, James Keenan via RT wrote:\n\n> On Tue Apr 10 01:45:31 2007, jrisom@gmail.com wrote:\n> > Configure should act as though writing --foo=no is false instead of \n> > true.  Tonight I tried using --execcapable=no to get around a compile \n> > failure, but then realized that it would probably treat \"no\" as a true \n> > value.\n> > \n> \n> I discussed this ticket with other participants in the recent hackathon \n> in Toronto.  I am inclined to recommend that we not make any changes in \n> Configure.pl's behavior as implied by the ticket, for a number of \n> reasons:\n\n> 1.  Configure.pl is a Perl script.  The truth value of the string 'no' \n> in Perl is true.  Cet. par., in Perl if you want to negate something you \n> 'undef' it or you assign it a value of 0 (or the string '0').  So the \n> current behavior of the 'execcapable' option is consistent with Perl's \n> customary behavior.\n\nThe language in which Configure.pl is written is an implementation detail.\nThough using 1 and 0 for true and false is a perfectly reasonable interface\nmodel to present to the outside world, it's also sensible to be tolerant\nof users.\n\nOne thing that is really needed is a consistent vision for what the\ndifferent options expect.  Currently, there are at least four different\nways in the help menu to turn stuff off:\n\n\t--nomanicheck\n\t--cgoto=0\n\t--without-gdbm\n\t--icu-config=none\n\nThis means that for undocumented things, like -execcapable, the user has\nto guess.\n\n> 2.  In config/auto/jit.pm, $execcapable is set to 1 for Unix-ish \n> operating systems and Windows and set to 0 for other OSes.  But if you \n> want to set a different behavior, it appears to me that you can simply \n> pass a value of 1 or 0 to the execcapable option.\n\nExcept that the --execcapable option isn't documented as taking a value.\nHow is the user to know?\n\n> 3.  If we really thought we'd make extensive use of something equivalent \n> to '-- execcapable=no', we could create a '--noexeccapable' option \n> analogous to '-- nomanicheck' (see lib/Parrot/Configure/Options.pm).\n\n> 4.  AFAICT from looking at Perl 5's Configure.sh, Perl 5 survives \n> without a 'no' value for any of its configuration options.\n\nI don't know exactly what you mean.  As a general rule, Configure uses\n-D to define something, and -U to undefine it.  However, since we often\nneed more than a simple boolean, the -D and -U syntax is richer and\nallows setting nearly arbitrary things.  That richer syntax feeds back\ninto user expectations, and that feedback has led us to accept a variety\nof equivalent ways of saying the same thing.\n\nFor example, to turn off optimization, either of the following are\nequivalent:\n\n\tConfigure -Doptimize=none\n\tConfigure -Uoptimize\n\nThe second actually sets $optimize=undef, but I assume that the\nuser probably didn't literally mean to pass the flag 'undef' to the \nC compiler in the hopes that the compiler would then optimize the program.\nRather the user's intention was clearly to disable optimization.\nConfigure thus considers both cases equivalent.\n\nThis can get out of hand, of course:  For example, if you want\nto not use threads, any of the following are equivalent:\n\n\tConfigure -Dusethreads=no\n\tConfigure -Dusethreads=false\n\tConfigure -Dusethreads=undef\n\tConfigure -Uusethreads\n\nThe last two are identical in setting $usethreads=undef.  The others\nwork because Configure tests with\n\n    case \"$usethreads\" in\n\t$define|true|[yY]*)  \n\nThe 'define/undef' interface is generally the \"official\" way to set\nbooleans, but supporting the true/false and yes/no variants is a courtesy\nto the user that costs nearly nothing to implement.\n\nIn short, it seems to me that the user's intent was obvious in writing\n--foo=no, and if foo is a boolean, you ought to honor the user's intent,\neven if the user didn't use the official 1/0 notation.\n\n> In short, YAGNI.  What do others think?\n\nI'm afraid I don't have any idea what YAGNI means.\nBut I'll continue anyway.  Here's what I think:\n\nConfigure.pl will eventually end up setting many, many variables.  It is\nimpossible to predict ahead of time which ones users will want or need\nto override.  Providing separate --foo options for every single one of\nthem doesn't scale well at all.  Configure.pl's help screen is already\n114 lines long.\n\nInstead, what I think is needed is a meta-syntax -- a way of setting\n(nearly) arbitrary Configure.pl variables to (nearly) arbitrary values.\nThough that syntax can and should declare an 'official' way to set\nbooleans (and 1/0 is one such perfectly reasonably way), I think it\nshould also be a forgiving interface, and should accept reasonable\nunambiguous alternatives, such as --foo=no instead of --foo=0.\n\nFor what it's worth, those are my rambling thoughts this morning.\n\n-- \n    Andy Spieherty\t\tspiehera@lafayette.edu\n\n"}
{"category": "ham", "to_address": "=?UTF-8?B?VGhvbWFzIELDpHR6bGVy?= <t.baetzler@bringe.com>", "from_address": "Jeff Pang <pangj@earthlink.net>", "subject": "Re: Query an IP from file", "body": "Thomas B\u00e4tzler \\u5199\\u9053:\n> Hi, \n> \n> Jeff Pang  asked:\n> \n>> I have a text file which contains lots of IPs,like:\n>>\n>> 58.253.0.0/16;\n>> 58.254.0.0/16;\n>> 58.255.0.0/16;\n>> 60.0.0.0/16;\n>> 60.1.0.0/16;\n>> 60.10.0.0/16;\n>> 60.16.0.0/16;\n>> 60.17.0.0/16;\n>> 60.18.0.0/16;\n>> 60.19.0.0/16;\n>> 60.2.0.0/16;\n>> 60.20.0.0/16;\n>> 60.21.0.0/16;\n>> 60.22.0.0/16;\n>> 60.23.0.0/16;\n>> 60.3.0.0/16;\n>>\n>> My question is,given an IP,ie 59.32.232.33,how can I know it \n>> exists in this file or not?\n>> Is there a module already?thanks.\n> \n> It's not a module, but here's some of my code that\n> might be useful if you want to test many ip adresses\n> against a fixed set of networks.\n> \n> It is built on the facts that IP adresses can be \n> converted to integers that retain the ordering\n> of the adresses and that networks are a range of\n> ip adresses - so your problem is really figuring\n> out whether a number x falls into one of n discrete\n> intervals.\n> \n> The method of choice for this kind of problem is\n> doing a binary search.\n> \n> I've tested several approaches and settled for\n> dynamically creating an unrolled variant of an\n> iterative binary search.\n> \n> HTH,\n> Thomas\n\n\nHello Thomas,\n\nI tried your codes,it's good I think.\nI've modified some of the codes to fit my situation.\nBut if the network data files include too much IPs,my program used up \nall memory and couldn't get continued.\nBelow are my modified codes.Attachments are two network data files.\n\nAny suggestion guys?Thanks.\n\n\n================================\n#!/usr/bin/perl\nuse strict;\nuse warnings;\nuse Socket;\n#use Data::Dumper;\n\n#------------------\n# main\n#------------------\n\n# read from ISPs' network data files,each item in files looks like \n\"222.85.93.0/24\"\n# \"tel_acl.txt\" store TEL's network data,\"cnc_acl.txt\" store CNC's \nnetwork data.\nour $teldata = build_array(\"tel_acl.txt\");\nour $cncdata = build_array(\"cnc_acl.txt\");\n\n# default ISP,when an IP belong to neither TEL nor CNC,then specify it \nto this default ISP\nour $default_isp = 'unknown';\n\n#\n# main loop,accept an ip from STDIN\n#\nwhile(<>) {\n     chomp;\n     my $isp = query_an_ip($_);\n     print $isp,\"\\n\";\n}\n\n\n#------------------\n# subroutines\n#------------------\n\n#\n# verify an ip belong to which ISP\n#\nsub query_an_ip {\n         my $ip = shift;\n         my $int = ip_to_number($ip);\n\n         if (binSearch($teldata,$int) != -1) {\n                 return 'tel';\n         } elsif (binSearch($cncdata,$int) != -1) {\n                 return 'cnc';\n         } else {\n                 return $default_isp;\n         }\n}\n\n#\n# build an array for binary search\n#\n\nsub build_array {\n     my $file = shift;\n     my @data = ();\n\n     open FILE,$file or die $!;\n     while() {\n         next unless /^(\\d+\\.\\d+\\.\\d+\\.\\d+)\\/(\\d+)/;\n         my ($netnum,$mask) = ($1,$2);\n\n         # translate netnum and mask to int\n         $netnum = ip_to_number($netnum);\n         $mask = make_mask($mask);\n\n         # Sanity check: Network number ANDed to the host mask must be 0\n         next if $netnum & $mask;\n\n         for (my $i=$netnum;$i<=$netnum+$mask;$i++) {\n             push @data,$i\n         }\n     }\n     close FILE;\n\n     # sort this array and get rid of duplicated items\n     my %tmp;\n     @data = grep { ++$tmp{$_} < 2 }\n             sort {$a <=> $b} @data;\n\n     return \\@data;\n}\n\n\n#\n# number of mask bits => inverted Bit mask\n#\n# converts the xx number of mask bits (in ip.ip.ip.ip/xx) to an\n# inverted bit mask, i.e. 24 becomes 0x000000FF\n#\n\nsub make_mask {\n\n     if( $_[0] < 0 || $_[0] > 32 ){\n         die \"Illegal mask /$_[0]\";\n     } else {\n         return( 2 ** ( 32 - $_[0] ) - 1);\n     }\n}\n\n\n#\n# ip.ip.ip.ip => 0x????????\n#\n# convert a dottect decimal IP address to an unsigned long number\n# in host byte order.\n#\n\nsub ip_to_number {\n\n     if( defined ( my $nl = inet_aton( $_[0] ) ) ){\n         # convert network to host byte order\n         return( unpack( 'N', $nl ) );\n     } else {\n         die \"Invalid IP address '$_[0]'!\\n\";\n     }\n}\n\n\n#\n# binary search,need a sorted array\n#\n\nsub binSearch\n{\n     my $arr_ref = shift;\n     my $key = shift;\n     my $low = 0;\n     my $high = $#$arr_ref;\n\n     my $middle;\n\n     while($low <= $high) {\n         $middle = int(($low+$high)/2);\n         if ($key == $arr_ref->[$middle]) {\n             return $middle;\n         } elsif ($key < $arr_ref->[$middle]) {\n             $high = $middle -1;\n         } else {\n             $low = $middle +1;\n         }\n     }\n\n     return -1;\n}\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
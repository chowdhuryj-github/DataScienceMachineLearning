{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14411 - doc/trunk/design/syn", "body": "Author: larry\nDate: Thu May 31 22:43:55 2007\nNew Revision: 14411\n\nModified:\n   doc/trunk/design/syn/S12.pod\n\nLog:\nThere is no longer any run-time dwimmery in indirect dispatch.\nNow use $obj.\"$foo\" exclusively for symbolic method indirection\n$obj.$var and $obj.@var forms now allow *only* hard refs to Code objects.\nPrefix ops written as postfix no longer use quote form, but $obj.prefix:<+>\n$obj.:<+> is allowed as a shorthand for $obj.prefix:<+>\nClarified that all anonymous Code objects are closures, not methods.\nWALK pseudo-class is dead.  Now just use .WALK method to return candidates.\n\n\nModified: doc/trunk/design/syn/S12.pod\n==============================================================================\n--- doc/trunk/design/syn/S12.pod\t(original)\n+++ doc/trunk/design/syn/S12.pod\tThu May 31 22:43:55 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 27 Oct 2004\n-  Last Modified: 29 May 2007\n+  Last Modified: 31 May 2007\n   Number: 12\n-  Version: 53\n+  Version: 54\n \n =head1 Overview\n \n@@ -218,15 +218,30 @@\n \n     .doit(1,2,3)\n \n-It can use a simple scalar variable for the method name:\n+There are several forms of indirection for the method name.  You can\n+replace the identifier with a quoted string, and it will be evaluated\n+as a quote and then the result of that is used as the method name.\n \n-    $obj.$methodname(1,2,3)\n+    $obj.\"$methodname\"(1,2,3)   # use contents of $methodname as method name\n+    $obj.'$methodname'(1,2,3)   # no interpolation; call method with $ in name!\n \n-The variable may contain either the name of a method or a closure\n-object.  In the latter case the closure is called with the object\n-as its first argument, so that a closure may be used to abstract a\n+For situations where you already have a method located, you\n+can use a simple scalar variable in place of method name:\n+\n+    $methodobj = $foo ?? &bar !! &baz\n+    $obj.$methodobj(1,2,3)\n+\n+or more succinctly but less readably:\n+\n+    $obj.$($foo ?? &bar !! &baz)(1,2,3)\n+\n+The variable must contain a Code object, that is, a closure of some\n+sort.  Regardless of whether the closure was defined as a method or\n+a sub or a block, the closure is called as a method, with the object\n+as its first argument, and the rest of the arguments second, third,\n+and so on.   For instance, such a closure may be used to abstract a\n \"navigational\" path through a data structure without specifying the\n-root of the path till later.\n+root of the path till later:\n \n     $locator = -> $root, $x, $y { $root.[$x]{$y}[3] }\n     $obj.$locator(42,\"baz\")  # $obj[42][3]\n@@ -234,30 +249,61 @@\n     $locator = { . }\n     $obj.$locator            # $obj\n \n-The method name may also be quoted with either single or double quotes:\n-\n-    $obj.\"$methodname\"(1,2,3)   # same as previous\n-    $obj.'$methodname'(1,2,3)   # call method with $ in name!\n+As a convenient form of documentation, such a closure may also be written\n+in the form of an anonymous method:\n \n-The latter is especially useful for postfix forms that might be confusing\n-to the lexer or to the human reader:\n-\n-    $filename.'+'      # same as +$filename.\n-    .'+'               # same as +$_\n-\n-And in fact, if there is a choice between a unary prefix and a postfix\n-operator, the quoted forms will choose the prefix operator.  See S03.\n-Likewise, presuming that C<$op> does not name an ordinary method on\n-C<$left>, this calls any arbitrary infix operator:\n+    $locator = method ($root: $x, $y) { $root.[$x]{$y}[3] }\n+    $obj.$locator(42,\"baz\")  # $obj[42][3]\n \n-    $left.$op($right)\n+    $locator = method { self. }\n+    $obj.$locator            # $obj\n \n-Of course you can force that with:\n+Note however that, like any anonymous closure, an anonymous method\n+can only be dispatched to directly, like a sub.  You may, of course,\n+bind an anonymous method to the name of a method in a class's public\n+interface, in which case it is no longer anonymous, and may be\n+dispatched to normally via the class.  (And in fact, when the normal\n+method dispatcher is calling individual candidates in its candidate\n+list, it calls each candidate as a sub, not as a method, or you'd\n+end up with recursive dispatchers.)  But fundamentally, there's\n+no such thing as a method closure.  The C declarator on an\n+anonymous method has the primary effect of making the declaration\n+of the invocant optional.  (It also makes it an official C\n+that can be returned from, just as if you'd used C to declare it.)\n+\n+Instead of a scalar variable, an array variable may also be used:\n+\n+    $obj.@candidates(1,2,3)\n+\n+As with the scalar variant, each array element must be a Code object,\n+but the list is treated as a list of candidates to call.\n+\n+Another form of indirection relies on the fact that operators are named\n+using a variant on hash subscript notation, which gives you these forms:\n+\n+    $x.infix:{$op}($y)\n+    $x.prefix:{$op}\n+    $x.postfix:{$op}\n+\n+Generally you see these with the literal angle bracket form of subscript:\n+\n+    $a.infix:<*>($b)      # equivalent to $a * $b\n+    $a.prefix:<++>        # equivalent to ++$a\n+    $a.postfix:<++>       # equivalent to $a++\n+\n+If you omit the syntactic category, the call will be dispatched according\n+to the number of arguments either as \"prefix\" or as \"infix\":\n+\n+    $a.:<+>($b)           # equivalent to $a + $b\n+    $a.:<++>              # equivalent to ++$a\n+    $a.:               # equivalent to !$a\n+    @a.:<[*]>             # equivalent to [*] @a\n \n-    $left.infix:{$op}($right)\n+But it's probably better to spell out the syntactic category when\n+the actual operator is not obvious:\n \n-The C forms of quoting are not allowed for method indirection,\n-since they'd be taken as ordinary method names.\n+    $x.infix:{$op}($y)\n+    $x.prefix:{$op}\n \n You must use a special syntax to call a private method:\n \n@@ -651,7 +697,8 @@\n are expected to return a value that can be used as a boolean.\n While this is primarily intended for use by file tests, other classes\n may define such methods to provide a similar mechanism for interrogating\n-properties.\n+properties.  (Also note that syntactic category names are reserved for\n+calling operators as if they were methods.)\n \n Depending on the class, the pairs in question may have arguments.\n The C class in particular makes use of pair syntax for subscript\n@@ -691,12 +738,15 @@\n     $object.\"+meth\"(@args)\n     $object.'VAR'(@args)\n \n-The order and selection of the candidates may be\n-specified by arguments to a pseudo-class known as C:\n+As with ordinary calls, the identifier supplying the literal method\n+name may be replaced with an interpolated quote to specify the method\n+name indirectly.  It may also be replaced with an array to specify\n+the exact list of candidates to be considered:\n \n-    $object.*WALK[:breadth:omit($?CLASS)]::meth(@args);\n+    my @candidates := $object.WALK(:name, :breadth, :omit($?CLASS));\n+    $object.*@candidates(@args);\n \n-The C pseudo-class takes these arguments:\n+The C method takes these arguments:\n \n     :canonical      # canonical dispatch order\n     :ascendant      # most-derived first, like destruction order\n@@ -705,7 +755,7 @@\n     :breadth        # like multi dispatch\n \n     :super              # only immediate parent classes\n-    :method       # only classes containing method declaration\n+    :name         # only classes containing named method declaration\n     :omit(Selector)     # only classes that don't match selector\n     :include(Selector)  # only classes that match selector\n \n@@ -770,6 +820,9 @@\n \n     $junction.values\u00bb.meth(@args);\n \n+As with other forms of method call, the \"meth\" above may be replaced\n+with a quoted string or variable to do various forms of indirection.\n+\n =head1 Multisubs and Multimethods\n \n The \"long name\" of a subroutine or method includes the type signature\n\n"}
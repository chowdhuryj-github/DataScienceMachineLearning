{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "Larry Wall <larry@wall.org>", "subject": "Re: [svn:perl6-synopsis] r14415 - doc/trunk/design/syn", "body": "On Sun, Jun 03, 2007 at 10:23:44PM -0700, Jonathan Lang wrote:\n: Let me see if I understand this correctly:\n: \n: * In list context, a list of captures gets flattened.\n\nYes.\n\n: * In slice context (a variant of list context), a list of captures\n: doesn't get flattened.\n\nMore than that, the captures get turned into sublists (subarrays?)\nthat prevent any subsequent flattening.\n\n: * In hash context (another variant of list context), a list of\n: captures gets flattened, and then grouped into Pairs.\n\nYes.\n\n: * In item context, a list of captures becomes a single Array object,\n: and the question about whether or not it gets flattened gets deferred\n: until its contents get looked at in list, slice, or hash context.\n\nThat's the intent.  $() used to assume @@ inside till this latest\nchange, but that seemed insufficiently lazy to me...\n\nBut it kinda means there's yet another list context that doesn't\ndecide yet, used explicitly by the insides of \\(...) and implicitly\nby the $() context.  Not sure if it needs a name yet, or whether it's\na design smell.  Arguably \"list\" should be non-committal and we give\n@() a different name like \"flat\", but that grates in my brain for\nsome reason, if only because most list contexts would in the end\nbe flat anyway.  And \"list\" in English already implies something\nflatter than, say, an \"outline\".\n\n: Meanwhile, 'zip' produces a list of captures - which, because list\n: context is the default \"plural\" context, immediately gets flattened\n: most of the time.  As I see it, then, the serial equivalent to\n: 'zip(@a;@b)' would be '(@a;@b)', and 'list(@a;@b)' would be the serial\n: equivalent to 'list(zip(@a;@b))'.\n\nThat doesn't make sense to me.  You seem to be thinking that semicolon\nhas zip semantics, when it doesn't.  All ; does is make a list of\ncaptures.  list() flattens any ; by interpolating the captures when\nyou bind to list's *@ argument, but zip binds to *@@ so it slices\nit instead so that it can deal with the lists in parallel rather\nthan serially.  And the list() in list(zip()) would just listify the\n*results* of zip, not the arguments to zip...\n\n: Or does '(@a;@b)' default to slice context?\n\nParentheses don't supply context.  They only group.  (@a;@b) returns\na list of captures.  It requires a binding (or other sigil) coercion\nto supply context.\n\nLarry\n\n"}
{"category": "ham", "to_address": "Thomas Wittek <mail@gedankenkonstrukt.de>", "from_address": "Austin Hastings <Austin_Hastings@Yahoo.com>", "subject": "Re: Is Perl 6 too late?", "body": "Thomas Wittek wrote:\n> chromatic wrote:\n>   \n>> theproblemlinguisticallyspeakingisthatsometimes [snipped]\n>>     \n>\n> I can't remember that I said that you shouldn't separate your\n> expressions (by punctation/whitspaces),\n> $.but! (*adding$ %*characters _+that^# &$might) @#not_ !#be()\n> !&necessary_ *#$doesn't! *(make) !@_it$ =_easier\n> to read and to type (in addition it was a torture to type that).\n>   \n\nForgive chromatic. Part of joining @Larry is undergoing a painful \ninitiation process, which tends to inspire zealotry.\n\nThe point, though, is that there are three ways of handling the whole \n\"part of speech\" issue. One is with a dictionary (reserved words): in \nthis method, every word is assigned a part of speech, usually with a \n\"default.\" Any use of the word \"FOR\" must be a loop, any use of \"INT\" \nmust be a typedef, etc.\n\nAnother is with context (and predeclaration). In this method, the \nsurrounding context can be used to infer the part of speech of a word, \nwith some sort of confirmation for 'new' words (user-defined variables, \nfunctions, etc.). Most present-day compiled languages use this one, \nalthough they frequently rely on the \"reserved words\" approach, too, for \nsome words.\n\nFinally, the approach Larry has chosen is to explicitly mark the part of \nspeech. Perl up to version 5 used an approach that attempted to \ncorrelate the marker with the part of speech associated with the \nsurrounding context: foo(@array) vs. foo($array[0])\n\nThis approach was criticized for providing relatively little value over \nthe context+lookup approach. If the sigil has to correspond to the \ncontext, then only in rare cases (ambiguous context) is the sigil adding \nmuch value.\n\nThe new approach (@array[0]) ties the sigil to the declaration, serving \nto distinguish name collisions and of course to autovivify variables \ncorrectly.\n\nUltimately, it comes down to value added, and culture/custom. \"Perl has \nalways used sigils, so perl should continue to use sigils.\" That's a \nlegitimate stand, in the absence of compelling arguments to the \ncontrary. It \"let's perl be perl.\"\n\nAs far as value goes, let's call the C/C++ approach the \"nul\" approach, \nsince by default there is no sigil in front of words. (And I'm \nconsidering * and & to be sigils, rather than operators.)\n\nThe nul approach reduces typing. It relies on context to identify the \npart of speech, occasionally forces some look-ahead (a name followed by \n'(' is an invocation instead of a reference) and can't handle multiply \ntyped (@foo vs. &foo vs. $foo vs. %foo) names.\n\nThe perl approach increases typing, by something less than 1 character \nper identifier. (This is a real cost, that Larry continues to elect to \nbear.) The p5 version imposed some disambiguation burden on the parser, \nsince $foo[0] involved @foo, not $foo. Perl *can* handle *some* multiply \ntyped names. There is a difference between $foo and @foo, but not \nbetween \"my Cat $foo\" and \"my Dog $foo\".\n\nIn addition, however, there is the whole *foo thing. Adding the sigil \nhas encouraged people to think in weird ways, 'tied' variables and \ntypeglobs not least among them. I don't know if a 'perl' that used the \nnul approach would ever have had those features. (Sapir-Whorf lives!)\n\nThe perl approach, then, opts to pay a significant penalty (0.9+ \ncharacters per variable) to allow access to the cool extra features that \nfew other languages use, and none so compactly.\n\nA similar trade-off exists with the statement terminating semicolon. In \nthis case, it involves the number of statements per line:\n\nA language that terminates statements can ignore whitespace, allowing \nmultiple statements per line and statements that span multiple lines.\n\nA language that associates line termination with statement termination \nmust pay a separate cost (continuation marker) for a statement to span \nmultiple lines. It will not, in general, support multiple statements per \nline. (Though it could make the terminator \"optional\" and then inject \nterminators between colinear statements.)\n\nThe vast majority of languages have opted to terminate statements. Perl \nis among them. Probably the best argument is that encountering a \nsemicolon (or full stop, in COBOL) is a positive indicator rather than a \nnegative one. \"I see a semicolon. I know the statement is over.\" as \nopposed to \"I don't see a continuation marker, so it's likely that the \nstatement is over, although it could be tabbed way off to the right or \nsomething.\"\n\nAlso, there's the increasing size of words to consider. While $a = $b + \n$c is a great example of why line termination is not needed, the trend \nis for variable and function names, not to mention object and method \ndereferences, to grow longer.\n\n>From \nhttp://www.oreillynet.com/pub/a/javascript/2003/03/18/movabletype.html I \nget:\n\n|MT::Template::Context->add_tag(HelloWorld => sub { return 'Hello World.'; } );|\n\n\nThe MT::...add_tag method name alone is 30 characters. Jam a few long \nidentifiers together and you're writing a lot of multi-line statements.\n\nIf the termination marker were optional, then the punctuation would \nstill have to be reserved--it is unlikely there is another use for \nsemicolon that is obviously exclusive from statement termination that \nneeds to be filled.\n\nAnd if the termination marker were not optional, but prohibited, then \nperl wouldn't have one-liners. That's DEFINITELY \"unperlish,\" so we \nwon't go there.\n\nSo line termination doesn't gain a punctuation character, and causes the \nends of lines to be uncertain. It does reduce typing, for the small \ncrowd of people that wouldn't just use them anyway because they use them \nin every other language.\n\nI think the lack of value here outweights the \"savings\" of one character \nper line.\n\n>   \n>>> So semicolons don't seem to be the best invention since sliced bread.\n>>> There should be extra-syntax for the rare cases (multiline) and not for\n>>> the common ones.\n>>>       \n>> Somehow English seems to get by with periods at the ends of statements, though \n>> almost no one pronounces them.\n>>     \n>\n> Oh, I thought Perl was a programming language. My fault.\n> Apples and oranges.\n> Most modern scripting languages don't need the semicolons. I think\n> there's no plausible reason for them.\n>\n>   \n\nActually, perl is probably the most \"linguistic\" of programming \nlanguages. A lot of $Larry's concerns with perl syntax, and perl \nlanguage issues, has historically been linguistic concern. The notion of \n\"end weight,\" for example, was an important part of the restructuring of \nregexes in p6. (See http://en.wikipedia.org/wiki/Larry_Wall)\n\nI'm going to forgive you the \"no plausible reason for them\" comment, \nsince I listed some above. (And since chromatic got you riled up.) But \nplease keep in mind that there are reasons for them, and some of those \nreasons are reasons of \"custom\" (i.e., \"we always did it like this\" or \n\"everybody does it\") and custom really is a good reason, although proven \nvalue can trump custom. Also, of course, remember that Larry's a pretty \nsmart guy, particularly in the linguistics field. There are more people \nworking in perl than work in Esperanto.\n\n>> I agree.  You need less ignorant colleagues.  I'm not sure Perl 6 can fix \n>> that.\n>>     \n>\n> I don't think that it's a point of ignorance.\n> Especially as they (and enough other people on the web) only seem to be\n> ignorant regarding Perl. Strange, huh?\n>\n>   \n\nRegarding perl6, yes. Regarding all of perl, not so much. I think this \ngoes back to \"perl 6 is late,\" which is really just another way of \nsaying \"perl 6 has taken a long time.\" Since perl5 is a functioning, \npopular language, it's not like there's an \"incredibly popular scripting \nlanguage\" gap...\n>> By the way, I'm still waiting to meet your cadre of Dylan hackers.\n>>     \n\nThis little snip is especially interesting since working with early \nversions of perl 6 required mastering Haskell, a language that doubled \nin popularity when the 2 computer scientists using it were joined by \nLuke Palmer and Autrijus Tang.\n\nKeep yer stick on the ice.\n\n=Austin\n\n\n"}
{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Allison Randal <allison@perl.org>", "subject": "Re: [perl #42865] [BUG] There's no way to set a vtable function with\n a Sub at runtime", "body": "Matt Diephouse (via RT) wrote:\n> There's no real way to set a vtable function at runtime. It's  \n> possible to use the PIR compiler to eval a new function, but there's  \n> no way to take an existing sub and add it as a vtable function[1].\n> \n> Before :vtable, this operation simply meant adding the sub to the new  \n> namespace under the right name. But since that's going away, we need  \n> a new way to do things.\n> \n> I suspect we need some sort of set_vtable opcode.\n> \n>      set_vtable ['Foo'; 'Bar'], 'get_string', $P0\n> \n> Maybe there should be set_root_vtable and set_hll_vtable variants to  \n> go along with to match the set_*global opcodes.\n\nFor classes, the 'add_method' method takes a named parameter to say \nwhether it's a vtable function. And, vtable functions aren't stored in \nthe namespace at all anymore, but in a data structure inside the class, \nso you wouldn't have 'root' and 'hll' variants. I can see potentially \nsee adding an 'add_vtable' vtable function, parallel to add_method, \nadd_attribute, etc.\n\nWhat's the use case for modifying a low-level PMC's vtable entries at \nruntime? Or, are you only talking about overriding vtable functions in a \nclass?\n\nAllison\n\n"}
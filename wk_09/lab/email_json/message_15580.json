{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "mimir@samba.org", "subject": "svn commit: samba r22519 - in branches/SAMBA_4_0/source/libnet: .", "body": "Author: mimir\nDate: 2007-04-25 15:24:01 +0000 (Wed, 25 Apr 2007)\nNew Revision: 22519\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22519\n\nLog:\nconvert libnet_DomainOpenSamr function from state-handling routine\nto composite_continue.\n\n\nrafal\n\n\nModified:\n   branches/SAMBA_4_0/source/libnet/libnet_domain.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/libnet/libnet_domain.c\n===================================================================\n--- branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-04-25 14:18:22 UTC (rev 22518)\n+++ branches/SAMBA_4_0/source/libnet/libnet_domain.c\t2007-04-25 15:24:01 UTC (rev 22519)\n@@ -1,4 +1,4 @@\n-/* \n+ /* \n    Unix SMB/CIFS implementation.\n \n    Copyright (C) Rafal Szczesniak 2005\n@@ -28,22 +28,15 @@\n #include \"librpc/gen_ndr/ndr_samr_c.h\"\n #include \"librpc/gen_ndr/ndr_lsa_c.h\"\n \n-static void domain_open_handler(struct rpc_request*);\n \n-enum domain_open_stage { DOMOPEN_CONNECT, DOMOPEN_LOOKUP, DOMOPEN_OPEN,\n-\t\t\t DOMOPEN_CLOSE_EXISTING, DOMOPEN_RPC_CONNECT };\n-\n struct domain_open_samr_state {\n-\tenum domain_open_stage    stage;\n \tstruct libnet_context     *ctx;\n \tstruct dcerpc_pipe        *pipe;\n-\tstruct rpc_request        *req;\n-\tstruct composite_context  *rpcconn_req;\n+\tstruct libnet_RpcConnect  rpcconn;\n \tstruct samr_Connect       connect;\n \tstruct samr_LookupDomain  lookup;\n \tstruct samr_OpenDomain    open;\n \tstruct samr_Close         close;\n-\tstruct libnet_RpcConnect  rpcconn;\n \tstruct lsa_String         domain_name;\n \tuint32_t                  access_mask;\n \tstruct policy_handle      connect_handle;\n@@ -54,13 +47,20 @@\n };\n \n \n+static void continue_domain_open_close(struct rpc_request *req);\n+static void continue_domain_open_connect(struct rpc_request *req);\n+static void continue_domain_open_lookup(struct rpc_request *req);\n+static void continue_domain_open_open(struct rpc_request *req);\n+\n+\n /**\n  * Stage 0.5 (optional): Connect to samr rpc pipe\n  */\n-static void domain_open_rpc_connect(struct composite_context *ctx)\n+static void continue_domain_open_rpc_connect(struct composite_context *ctx)\n {\n \tstruct composite_context *c;\n \tstruct domain_open_samr_state *s;\n+\tstruct rpc_request *conn_req;\n \n \tc = talloc_get_type(ctx->async.private_data, struct composite_context);\n \ts = talloc_get_type(c->private_data, struct domain_open_samr_state);\n@@ -76,13 +76,11 @@\n \ts->connect.out.connect_handle  = &s->connect_handle;\n \n \t/* send request */\n-\ts->req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n-\tif (composite_nomem(s->req, c)) return;\n+\tconn_req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n+\tif (composite_nomem(conn_req, c)) return;\n \n \t/* callback handler */\n-\ts->req->async.callback = domain_open_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = DOMOPEN_CONNECT;\n+\tcomposite_continue_rpc(c, conn_req, continue_domain_open_connect, c);\n }\n \n \n@@ -90,12 +88,18 @@\n  * Stage 0.5 (optional): Close existing (in libnet context) domain\n  * handle\n  */\n-static NTSTATUS domain_open_close(struct composite_context *c,\n-\t\t\t\t  struct domain_open_samr_state *s)\n+static void continue_domain_open_close(struct rpc_request *req)\n {\n+\tstruct composite_context *c;\n+\tstruct domain_open_samr_state *s;\n+\tstruct rpc_request *conn_req;\n+\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_open_samr_state);\n+\n \t/* receive samr_Close reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \n \t/* reset domain handle and associated data in libnet_context */\n \ts->ctx->samr.name        = NULL;\n@@ -108,135 +112,100 @@\n \ts->connect.out.connect_handle  = &s->connect_handle;\n \t\n \t/* send request */\n-\ts->req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n-\tif (s->req == NULL) return NT_STATUS_NO_MEMORY;\n+\tconn_req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n+\tif (composite_nomem(conn_req, c)) return;\n \n \t/* callback handler */\n-\ts->req->async.callback = domain_open_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = DOMOPEN_CONNECT;\n-\t\n-\treturn NT_STATUS_OK;\n+\tcomposite_continue_rpc(c, conn_req, continue_domain_open_connect, c);\n }\n \n \n /**\n  * Stage 1: Connect to SAM server.\n  */\n-static NTSTATUS domain_open_connect(struct composite_context *c,\n-\t\t\t\t    struct domain_open_samr_state *s)\n+static void continue_domain_open_connect(struct rpc_request *req)\n {\n-\tstruct samr_LookupDomain *r = &s->lookup;\n+\tstruct composite_context *c;\n+\tstruct domain_open_samr_state *s;\n+\tstruct rpc_request *lookup_req;\n+\tstruct samr_LookupDomain *r;\n+\t\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_open_samr_state);\n \n \t/* receive samr_Connect reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \n+\tr = &s->lookup;\n+\n \t/* prepare for samr_LookupDomain call */\n \tr->in.connect_handle = &s->connect_handle;\n \tr->in.domain_name    = &s->domain_name;\n \n-\ts->req = dcerpc_samr_LookupDomain_send(s->pipe, c, r);\n-\tif (s->req == NULL) goto failure;\n+\tlookup_req = dcerpc_samr_LookupDomain_send(s->pipe, c, r);\n+\tif (composite_nomem(lookup_req, c)) return;\n \n-\ts->req->async.callback = domain_open_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = DOMOPEN_LOOKUP;\n-\n-\treturn NT_STATUS_OK;\n-\n-failure:\n-\treturn NT_STATUS_UNSUCCESSFUL;\n+\tcomposite_continue_rpc(c, lookup_req, continue_domain_open_lookup, c);\n }\n \n \n /**\n  * Stage 2: Lookup domain by name.\n  */\n-static NTSTATUS domain_open_lookup(struct composite_context *c,\n-\t\t\t\t   struct domain_open_samr_state *s)\n+static void continue_domain_open_lookup(struct rpc_request *req)\n {\n-\tstruct samr_OpenDomain *r = &s->open;\n+\tstruct composite_context *c;\n+\tstruct domain_open_samr_state *s;\n+\tstruct rpc_request *opendom_req;\n+\tstruct samr_OpenDomain *r;\n \n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_open_samr_state);\n+\t\n \t/* receive samr_LookupDomain reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tc->status = dcerpc_ndr_request_recv(req);\n \n+\tr = &s->open;\n+\n+\t/* check the rpc layer status */\n+\tif (!composite_is_ok(c));\n+\n+\t/* check the rpc call itself status */\n+\tif (!NT_STATUS_IS_OK(s->lookup.out.result)) {\n+\t\tcomposite_error(c, s->lookup.out.result);\n+\t\treturn;\n+\t}\n+\n \t/* prepare for samr_OpenDomain call */\n \tr->in.connect_handle = &s->connect_handle;\n \tr->in.access_mask    = SEC_FLAG_MAXIMUM_ALLOWED;\n \tr->in.sid            = s->lookup.out.sid;\n \tr->out.domain_handle = &s->domain_handle;\n \n-\ts->req = dcerpc_samr_OpenDomain_send(s->pipe, c, r);\n-\tif (s->req == NULL) goto failure;\n+\topendom_req = dcerpc_samr_OpenDomain_send(s->pipe, c, r);\n+\tif (composite_nomem(opendom_req, c)) return;\n \n-\ts->req->async.callback = domain_open_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = DOMOPEN_OPEN;\n-\n-\treturn NT_STATUS_OK;\n-\n-failure:\n-\treturn NT_STATUS_UNSUCCESSFUL;\n+\tcomposite_continue_rpc(c, opendom_req, continue_domain_open_open, c);\n }\n \n \n /*\n  * Stage 3: Open domain.\n  */\n-static NTSTATUS domain_open_open(struct composite_context *c,\n-\t\t\t\t struct domain_open_samr_state *s)\n+static void continue_domain_open_open(struct rpc_request *req)\n {\n-\t/* receive samr_OpenDomain reply */\n-\tc->status = dcerpc_ndr_request_recv(s->req);\n-\tNT_STATUS_NOT_OK_RETURN(c->status);\n+\tstruct composite_context *c;\n+\tstruct domain_open_samr_state *s;\n \n-\tc->state = COMPOSITE_STATE_DONE;\n-\t\n-\treturn NT_STATUS_OK;\n-}\n+\tc = talloc_get_type(req->async.private, struct composite_context);\n+\ts = talloc_get_type(c->private_data, struct domain_open_samr_state);\n \n+\t/* receive samr_OpenDomain reply */\n+\tc->status = dcerpc_ndr_request_recv(req);\n+\tif (!composite_is_ok(c)) return;\n \n-/**\n- * Event handler for asynchronous request. Handles transition through\n- * intermediate stages of the call.\n- *\n- * @param req rpc call context\n- */\n-static void domain_open_handler(struct rpc_request *req)\n-{\n-\tstruct composite_context *c = req->async.private;\n-\tstruct domain_open_samr_state *s = talloc_get_type(c->private_data,\n-\t\t\t\t\t\t\t   struct domain_open_samr_state);\n-\n-\t/* Stages of the call */\n-\tswitch (s->stage) {\n-\tcase DOMOPEN_CONNECT:\n-\t\tc->status = domain_open_connect(c, s);\n-\t\tbreak;\n-\tcase DOMOPEN_LOOKUP:\n-\t\tc->status = domain_open_lookup(c, s);\n-\t\tbreak;\n-\tcase DOMOPEN_OPEN:\n-\t\tc->status = domain_open_open(c, s);\n-\t\tbreak;\n-\tcase DOMOPEN_CLOSE_EXISTING:\n-\t\tc->status = domain_open_close(c, s);\n-\t\tbreak;\n-\tcase DOMOPEN_RPC_CONNECT:\n-\t\t/* this state shouldn't be handled here */\n-\t\tc->status = NT_STATUS_UNSUCCESSFUL;\n-\t\tbreak;\n-\t}\n-\n-\tif (!NT_STATUS_IS_OK(c->status)) {\n-\t\tc->state = COMPOSITE_STATE_ERROR;\n-\t}\n-\n-\tif (c->state == COMPOSITE_STATE_DONE) {\n-\t\tcomposite_done(c);\n-\t}\n+\tcomposite_done(c);\n }\n \n \n@@ -254,6 +223,8 @@\n {\n \tstruct composite_context *c;\n \tstruct domain_open_samr_state *s;\n+\tstruct composite_context *rpcconn_req;\n+\tstruct rpc_request *close_req, *conn_req;\n \n \tc = composite_create(ctx, ctx->event_ctx);\n \tif (c == NULL) return NULL;\n@@ -278,13 +249,10 @@\n \t\ts->rpcconn.in.dcerpc_iface = &dcerpc_table_samr;\n \t\t\n \t\t/* send rpc pipe connect request */\n-\t\ts->rpcconn_req = libnet_RpcConnect_send(ctx, c, &s->rpcconn);\n-\t\tif (composite_nomem(s->rpcconn_req, c)) return c;\n+\t\trpcconn_req = libnet_RpcConnect_send(ctx, c, &s->rpcconn);\n+\t\tif (composite_nomem(rpcconn_req, c)) return c;\n \n-\t\ts->rpcconn_req->async.fn = domain_open_rpc_connect;\n-\t\ts->rpcconn_req->async.private_data  = c;\n-\t\ts->stage = DOMOPEN_RPC_CONNECT;\n-\n+\t\tcomposite_continue(c, rpcconn_req, continue_domain_open_rpc_connect, c);\n \t\treturn c;\n \t}\n \n@@ -304,14 +272,11 @@\n \t\t\ts->close.in.handle = &ctx->samr.handle;\n \n \t\t\t/* send request to close domain handle */\n-\t\t\ts->req = dcerpc_samr_Close_send(s->pipe, c, &s->close);\n-\t\t\tif (composite_nomem(s->req, c)) return c;\n+\t\t\tclose_req = dcerpc_samr_Close_send(s->pipe, c, &s->close);\n+\t\t\tif (composite_nomem(close_req, c)) return c;\n \n \t\t\t/* callback handler */\n-\t\t\ts->req->async.callback = domain_open_handler;\n-\t\t\ts->req->async.private  = c;\n-\t\t\ts->stage = DOMOPEN_CLOSE_EXISTING;\n-\n+\t\t\tcomposite_continue_rpc(c, close_req, continue_domain_open_close, c);\n \t\t\treturn c;\n \t\t}\n \t}\n@@ -322,14 +287,11 @@\n \ts->connect.out.connect_handle  = &s->connect_handle;\n \t\n \t/* send request */\n-\ts->req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n-\tif (composite_nomem(s->req, c)) return c;\n+\tconn_req = dcerpc_samr_Connect_send(s->pipe, c, &s->connect);\n+\tif (composite_nomem(conn_req, c)) return c;\n \n \t/* callback handler */\n-\ts->req->async.callback = domain_open_handler;\n-\ts->req->async.private  = c;\n-\ts->stage = DOMOPEN_CONNECT;\n-\n+\tcomposite_continue_rpc(c, conn_req, continue_domain_open_connect, c);\n \treturn c;\n }\n \n\n"}
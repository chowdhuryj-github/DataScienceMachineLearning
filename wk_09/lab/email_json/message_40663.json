{"category": "ham", "to_address": "parrot-porters@perl.org", "from_address": "Andy Lester <andy@petdance.com>", "subject": "Use const proactively", "body": " From my wiki at http://xoa.petdance.com/Use_const_proactively\n\n  Const your local variables\n\nThe following is adapted from C++ Coding Standards by Herb Sutter and  \nAndrei Alexandrescu (with some C++-specific stuff removed):\n\n     const is your friend: Immutable values are easier to understand,  \ntrack, and reason about, so prefer consted variables wherever it is  \nsensible and make const your default choice when you define a value.  \nIt's safe, and it's checked at compile time. Don't cast away const  \nexcept to call a const-incorrect function. Constants simplify code  \nbecause you only have to look at where the constant is defined to  \nknow its value everywhere. Consider this code:\n\n     void Fun( const char * p ) {\n         const size_t len = strlen(p);\n\n         /* ... 30 more lines ... */\n\n         if (len > 1)\n            ...\n     }\n\n     When seeing len's definition above, you gain instance confidence  \nabout len's semantics throughout its scope. It's a snapshot of p's  \nlength at a specific point. Just by looking up one line, you know  \nlen's semantics over its whole scope. Without the const, len might be  \nlater modified. Best of all, the compiler will help you ensure that  \nthis truth remains true.\n\n     Yes, const is viral -- add it in one place, and it wants to  \npropagate throughout your code as you call other functions who  \nsignatures aren't yet const-correct. This is a feature, and this  \nquality greatly increases const's power.\n\n     Const-correctness is worthwhile, proven, effective, and highly  \nrecommended. Understanding how and where a program's state changes is  \nvital, and const documents that directly in code where the compiler  \ncan help to enforce it.\n\n== Const your function parameters\n\nConsting function parameters also lets the compiler know the behavior  \nof your function. Consider this snippet of code:\n\nchar buffer[20];\nc = buffer[0];\n\nThe compiler or lint can now warn you that you're using buffer even  \nthough it hasn't been initialized. But what about this:\n\nvoid foo(char *p);\n\nchar buffer[20];\nfoo(buffer);\nc = buffer[0];\n\nIs foo() initializing what is sent into it? The compiler can't tell.  \nBut if you define it like so:\n\nvoid foo(const char *p);\n\nnow the compiler knows that buffer can't be getting initialized.\n\nThink of consting your function parameters as a very basic contract  \nwith the caller.\n\n\n== What am I consting?\n\nIn an declaration such as\n\n    char *p;\n\nthere are two places const can be placed - with different effects.\n\nconst char* p;\n     The bytes p points at are considered const when accessed via p,  \nbut the pointer p itself is not const\n\nchar* const p;\n     The pointer \"p\" is considered const, but the bytes it points at  \nare not\n\nThey can be combined:\n\nconst char* const p;\n     Both constant pointer and constant data\n\nThe rule is that const affects the thing immediately following it.\n\nxoxo,\nAndy\n\n--\nAndy Lester => andy@petdance.com => www.petdance.com => AIM:petdance\n\n\n\n\n"}
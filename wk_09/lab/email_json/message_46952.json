{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "obnox@samba.org", "subject": "svn commit: samba r23453 - in branches/SAMBA_3_0_26/source: .\n\tregistry", "body": "Author: obnox\nDate: 2007-06-12 23:23:01 +0000 (Tue, 12 Jun 2007)\nNew Revision: 23453\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23453\n\nLog:\nfetch_reg_keys_specific and fetch_reg_values_specific are now\nonly used in rpc_server/srv_winreg_nt.c. \n\nBy moving them to a module of their own, this patch reduces the \ndiff between the registry code of 3_0 and 3_0_26 even more.\n\nMichael\n\n\nAdded:\n   branches/SAMBA_3_0_26/source/registry/reg_frontend_legacy.c\nModified:\n   branches/SAMBA_3_0_26/source/Makefile.in\n   branches/SAMBA_3_0_26/source/registry/reg_frontend.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/Makefile.in\n===================================================================\n--- branches/SAMBA_3_0_26/source/Makefile.in\t2007-06-12 23:04:38 UTC (rev 23452)\n+++ branches/SAMBA_3_0_26/source/Makefile.in\t2007-06-12 23:23:01 UTC (rev 23453)\n@@ -369,6 +369,7 @@\n RPC_INITSHUTDOWN_OBJ =  librpc/gen_ndr/srv_initshutdown.o rpc_server/srv_initshutdown_nt.o\n \n RPC_REG_OBJ =  rpc_server/srv_winreg.o rpc_server/srv_winreg_nt.o \\\n+\t       registry/reg_frontend_legacy.o \\\n \t       librpc/gen_ndr/srv_winreg.o $(REGFIO_OBJ)\n \n RPC_LSA_DS_OBJ =  rpc_server/srv_lsa_ds.o rpc_server/srv_lsa_ds_nt.o\n\nModified: branches/SAMBA_3_0_26/source/registry/reg_frontend.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/registry/reg_frontend.c\t2007-06-12 23:04:38 UTC (rev 23452)\n+++ branches/SAMBA_3_0_26/source/registry/reg_frontend.c\t2007-06-12 23:23:01 UTC (rev 23453)\n@@ -84,117 +84,6 @@\n \treturn True;\n }\n \n-/***********************************************************************\n- retreive a specific subkey specified by index.  Caller is \n- responsible for freeing memory\n- ***********************************************************************/\n-\n-BOOL fetch_reg_keys_specific( REGISTRY_KEY *key, char** subkey, uint32 key_index )\n-{\n-\tstatic REGSUBKEY_CTR *ctr = NULL;\n-\tstatic pstring save_path;\n-\tchar *s;\n-\t\n-\t*subkey = NULL;\n-\t\n-\t/* simple caching for performance; very basic heuristic */\n-\n-\tDEBUG(8,(\"fetch_reg_keys_specific: Looking for key [%d] of  [%s]\\n\", key_index, key->name));\n-\t\n-\tif ( !ctr ) {\n-\t\tDEBUG(8,(\"fetch_reg_keys_specific: Initializing cache of subkeys for [%s]\\n\", key->name));\n-\n-\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGSUBKEY_CTR )) ) {\n-\t\t\tDEBUG(0,(\"fetch_reg_keys_specific: talloc() failed!\\n\"));\n-\t\t\treturn False;\n-\t\t}\n-\t\t\n-\t\tpstrcpy( save_path, key->name );\n-\t\t\n-\t\tif ( fetch_reg_keys( key, ctr) == -1 )\n-\t\t\treturn False;\n-\t\t\t\n-\t}\n-\t/* clear the cache when key_index == 0 or the path has changed */\n-\telse if ( !key_index || StrCaseCmp( save_path, key->name) ) {\n-\n-\t\tDEBUG(8,(\"fetch_reg_keys_specific: Updating cache of subkeys for [%s]\\n\", key->name));\n-\t\t\n-\t\tTALLOC_FREE( ctr );\n-\n-\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGSUBKEY_CTR )) ) {\n-\t\t\tDEBUG(0,(\"fetch_reg_keys_specific: talloc() failed!\\n\"));\n-\t\t\treturn False;\n-\t\t}\n-\t\t\n-\t\tpstrcpy( save_path, key->name );\n-\t\t\n-\t\tif ( fetch_reg_keys( key, ctr) == -1 )\n-\t\t\treturn False;\n-\t}\n-\t\n-\tif ( !(s = regsubkey_ctr_specific_key( ctr, key_index )) )\n-\t\treturn False;\n-\n-\t*subkey = SMB_STRDUP( s );\n-\n-\treturn True;\n-}\n-\n-/***********************************************************************\n- retreive a specific subkey specified by index.  Caller is \n- responsible for freeing memory\n- ***********************************************************************/\n-\n-BOOL fetch_reg_values_specific( REGISTRY_KEY *key, REGISTRY_VALUE **val, uint32 val_index )\n-{\n-\tstatic REGVAL_CTR \t*ctr = NULL;\n-\tstatic pstring\t\tsave_path;\n-\tREGISTRY_VALUE\t\t*v;\n-\t\n-\t*val = NULL;\n-\t\n-\t/* simple caching for performance; very basic heuristic */\n-\t\n-\tif ( !ctr ) {\n-\t\tDEBUG(8,(\"fetch_reg_values_specific: Initializing cache of values for [%s]\\n\", key->name));\n-\n-\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGVAL_CTR )) ) {\n-\t\t\tDEBUG(0,(\"fetch_reg_values_specific: talloc() failed!\\n\"));\n-\t\t\treturn False;\n-\t\t}\n-\n-\t\tpstrcpy( save_path, key->name );\n-\t\t\n-\t\tif ( fetch_reg_values( key, ctr) == -1 )\n-\t\t\treturn False;\n-\t}\n-\t/* clear the cache when val_index == 0 or the path has changed */\n-\telse if ( !val_index || !strequal(save_path, key->name) ) {\n-\n-\t\tDEBUG(8,(\"fetch_reg_values_specific: Updating cache of values for [%s]\\n\", key->name));\t\t\n-\t\t\n-\t\tTALLOC_FREE( ctr );\n-\n-\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGVAL_CTR )) ) {\n-\t\t\tDEBUG(0,(\"fetch_reg_values_specific: talloc() failed!\\n\"));\n-\t\t\treturn False;\n-\t\t}\n-\n-\t\tpstrcpy( save_path, key->name );\n-\t\t\n-\t\tif ( fetch_reg_values( key, ctr) == -1 )\n-\t\t\treturn False;\n-\t}\n-\t\n-\tif ( !(v = regval_ctr_specific_value( ctr, val_index )) )\n-\t\treturn False;\n-\n-\t*val = dup_registry_value( v );\n-\n-\treturn True;\n-}\n-\n WERROR regkey_open_internal( TALLOC_CTX *ctx, REGISTRY_KEY **regkey,\n \t\t\t     const char *path,\n                              const struct nt_user_token *token,\n\nAdded: branches/SAMBA_3_0_26/source/registry/reg_frontend_legacy.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/registry/reg_frontend_legacy.c\t2007-06-12 23:04:38 UTC (rev 23452)\n+++ branches/SAMBA_3_0_26/source/registry/reg_frontend_legacy.c\t2007-06-12 23:23:01 UTC (rev 23453)\n@@ -0,0 +1,137 @@\n+/* \n+ *  Unix SMB/CIFS implementation.\n+ *  Virtual Windows Registry Layer\n+ *  Copyright (C) Gerald Carter                     2002-2005\n+ *\n+ *  This program is free software; you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation; either version 2 of the License, or\n+ *  (at your option) any later version.\n+ *  \n+ *  This program is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *  \n+ *  You should have received a copy of the GNU General Public License\n+ *  along with this program; if not, write to the Free Software\n+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n+ */\n+\n+/* Implementation of registry frontend view functions. */\n+\n+/* Legacy registry frontend functions only used in\n+ * rpc_server/srv_winreg_nt.c anymore. */\n+\n+#include \n+\n+/***********************************************************************\n+ retreive a specific subkey specified by index.  Caller is \n+ responsible for freeing memory\n+ ***********************************************************************/\n+\n+BOOL fetch_reg_keys_specific( REGISTRY_KEY *key, char** subkey, uint32 key_index )\n+{\n+\tstatic REGSUBKEY_CTR *ctr = NULL;\n+\tstatic pstring save_path;\n+\tchar *s;\n+\t\n+\t*subkey = NULL;\n+\t\n+\t/* simple caching for performance; very basic heuristic */\n+\n+\tDEBUG(8,(\"fetch_reg_keys_specific: Looking for key [%d] of  [%s]\\n\", key_index, key->name));\n+\t\n+\tif ( !ctr ) {\n+\t\tDEBUG(8,(\"fetch_reg_keys_specific: Initializing cache of subkeys for [%s]\\n\", key->name));\n+\n+\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGSUBKEY_CTR )) ) {\n+\t\t\tDEBUG(0,(\"fetch_reg_keys_specific: talloc() failed!\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\t\t\n+\t\tpstrcpy( save_path, key->name );\n+\t\t\n+\t\tif ( fetch_reg_keys( key, ctr) == -1 )\n+\t\t\treturn False;\n+\t\t\t\n+\t}\n+\t/* clear the cache when key_index == 0 or the path has changed */\n+\telse if ( !key_index || StrCaseCmp( save_path, key->name) ) {\n+\n+\t\tDEBUG(8,(\"fetch_reg_keys_specific: Updating cache of subkeys for [%s]\\n\", key->name));\n+\t\t\n+\t\tTALLOC_FREE( ctr );\n+\n+\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGSUBKEY_CTR )) ) {\n+\t\t\tDEBUG(0,(\"fetch_reg_keys_specific: talloc() failed!\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\t\t\n+\t\tpstrcpy( save_path, key->name );\n+\t\t\n+\t\tif ( fetch_reg_keys( key, ctr) == -1 )\n+\t\t\treturn False;\n+\t}\n+\t\n+\tif ( !(s = regsubkey_ctr_specific_key( ctr, key_index )) )\n+\t\treturn False;\n+\n+\t*subkey = SMB_STRDUP( s );\n+\n+\treturn True;\n+}\n+\n+/***********************************************************************\n+ retreive a specific subkey specified by index.  Caller is \n+ responsible for freeing memory\n+ ***********************************************************************/\n+\n+BOOL fetch_reg_values_specific( REGISTRY_KEY *key, REGISTRY_VALUE **val, uint32 val_index )\n+{\n+\tstatic REGVAL_CTR \t*ctr = NULL;\n+\tstatic pstring\t\tsave_path;\n+\tREGISTRY_VALUE\t\t*v;\n+\t\n+\t*val = NULL;\n+\t\n+\t/* simple caching for performance; very basic heuristic */\n+\t\n+\tif ( !ctr ) {\n+\t\tDEBUG(8,(\"fetch_reg_values_specific: Initializing cache of values for [%s]\\n\", key->name));\n+\n+\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGVAL_CTR )) ) {\n+\t\t\tDEBUG(0,(\"fetch_reg_values_specific: talloc() failed!\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\tpstrcpy( save_path, key->name );\n+\t\t\n+\t\tif ( fetch_reg_values( key, ctr) == -1 )\n+\t\t\treturn False;\n+\t}\n+\t/* clear the cache when val_index == 0 or the path has changed */\n+\telse if ( !val_index || !strequal(save_path, key->name) ) {\n+\n+\t\tDEBUG(8,(\"fetch_reg_values_specific: Updating cache of values for [%s]\\n\", key->name));\t\t\n+\t\t\n+\t\tTALLOC_FREE( ctr );\n+\n+\t\tif ( !(ctr = TALLOC_ZERO_P( NULL, REGVAL_CTR )) ) {\n+\t\t\tDEBUG(0,(\"fetch_reg_values_specific: talloc() failed!\\n\"));\n+\t\t\treturn False;\n+\t\t}\n+\n+\t\tpstrcpy( save_path, key->name );\n+\t\t\n+\t\tif ( fetch_reg_values( key, ctr) == -1 )\n+\t\t\treturn False;\n+\t}\n+\t\n+\tif ( !(v = regval_ctr_specific_value( ctr, val_index )) )\n+\t\treturn False;\n+\n+\t*val = dup_registry_value( v );\n+\n+\treturn True;\n+}\n\n"}
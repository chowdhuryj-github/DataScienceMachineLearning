{"category": "ham", "to_address": "Monty <dale.schmitz@offutt.af.mil>", "from_address": "\"Tom Phoenix\" <tom@stonehenge.com>", "subject": "Re: Snippet explanation please", "body": "On 7/5/07, Monty  wrote:\n\n> I'm reading \"Network Programming with Perl\" by Lincoln Stein, and I've\n> come across a snippet of code I'mnot quite following:\n>\n> open (WHOFH, \"who |\") or die \"Can't open who: $!\";\n>\n> While () {\n>     next unless /^(\\S+)/;\n>     $who{$1}++;\n> }\n\nThat should be \"while\", not \"While\"; you probably know that perl is\ncase-sensitive. But the rest of it looks like something Dr. Stein\nmight write.\n\n> It's the 'next' line I'm unclear on.  I know that results: parse the\n> first field from each output line of the 'who' command, but I'm\n> wondering why this might have been done in this way.  It seems to me\n> that the 'next' line states \"get the next record unless the current\n> one startes with a non-whitespace character\".\n>\n> The UNIX 'who' command output lines always start with non-whitespace\n> characters, as far as I can see.  It seems just as sensible to leave\n> this line out.  Does anyone know additional value to doing this?\n\nI believe Dr. Stein was using that line primarily to capture the\nusername at the beginning of the line, ensuring that the pattern match\nsucceeds. Another programmer might do that like this:\n\n    unless (/^(\\S+)/) {\n      warn \"unexpected data from 'who' command: '$_', continuing\";\n      next;\n    }\n\nThis program makes noise where the other was silent, but only when it\nencounters somebody's unusual (buggy?) who command. If it didn't have\nthe warning, it would be close to what's in the book.\n\n> Also, the '$who{$1}++' lines has the same effect here as \"awk '{ print\n> $1 }'\",\n\nWell, yessss, that's true except that it's not. But I think you're\njust talking about $1 here.\n\n> and leads me to believe that $2, $3, etc. also exist, but that\n> doesn't seem to be the case as I've tried printing those variables.\n> How does the '$1' work in this case?\n\nThere's one memory variable for each pair of memory parentheses in the\nlast successful pattern match. This one has only one pair, so it has\nonly $1. The others, $2 and so on, are all undef. You can have $42 if\nyou have 42 pairs of memory parentheses in your pattern, but in that\ncase please don't ask me to help maintain your code. In any case, the\nperlre manpage has the details.\n\nIn general, it's poor form to use $1 and friends except shortly after\na successful pattern match, so likewise it's poor form not to check\nthe result of the pattern match, even if you're sure it will succeed.\n\nHope this helps!\n\n--Tom Phoenix\nStonehenge Perl Training\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n"}
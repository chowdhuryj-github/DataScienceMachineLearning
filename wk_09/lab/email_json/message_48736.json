{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14422 - doc/trunk/design/syn", "body": "Author: larry\nDate: Fri Jun 15 12:10:26 2007\nNew Revision: 14422\n\nModified:\n   doc/trunk/design/syn/S03.pod\n   doc/trunk/design/syn/S12.pod\n\nLog:\nsome cleanup suggestions by dduncan++\nspec out several migration error catching policies, like infix: pseudo-op\n\n\nModified: doc/trunk/design/syn/S03.pod\n==============================================================================\n--- doc/trunk/design/syn/S03.pod\t(original)\n+++ doc/trunk/design/syn/S03.pod\tFri Jun 15 12:10:26 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 8 Mar 2004\n-  Last Modified: 2 Jun 2007\n+  Last Modified: 15 Jun 2007\n   Number: 3\n-  Version: 116\n+  Version: 117\n \n =head1 Overview\n \n@@ -220,6 +220,10 @@\n     .meth       # call on $_\n     .=meth      # modify $_\n \n+Note that this may occur only where a term is expected.  Where a\n+postfix is expected, it is a postfix.  If only an infix is expected\n+(that is, after a term with intervening whitespace), it is a syntax error.\n+\n =item *\n \n Listop (leftward)\n@@ -312,6 +316,16 @@\n \n     $x.:<++>       # prefix:<++>($x)\n \n+=item *\n+\n+There is specifically no C<< infix:<.> >> operator, so\n+\n+    $foo . $bar\n+\n+will always result in a compile-time error indicating the user should\n+use C<< infix:<~> >> instead.  This is to catch an error likely to\n+be made by Perl 5 programmers learning Perl 6.\n+\n =back\n \n =head2 Autoincrement precedence\n@@ -377,14 +391,14 @@\n \n =item *\n \n-Autoincrement prefix:<++> or postfix:<++> operator\n+Autoincrement C<< prefix:<++> >> or C<< postfix:<++> >> operator\n \n     $x++\n     ++$x;\n \n =item *\n \n-Autodecrement prefix:<--> or postfix:<--> operator\n+Autodecrement C<< prefix:<--> >> or C<< postfix:<--> >> operator\n \n     $x--\n     --$x\n@@ -397,7 +411,7 @@\n \n =item *\n \n-infix:<**> exponentiation operator\n+C<< infix:<**> >> exponentiation operator\n \n     $x ** 2\n \n@@ -418,7 +432,7 @@\n \n =item *\n \n-prefix:, boolean context\n+C<< prefix: >>, boolean context\n \n     ?$x\n \n@@ -428,7 +442,7 @@\n \n =item *\n \n-prefix:, boolean negation\n+C<< prefix: >>, boolean negation\n \n     !$x\n \n@@ -437,7 +451,7 @@\n \n =item *\n \n-prefix:<+>, numeric context\n+C<< prefix:<+> >>, numeric context\n \n     +$x\n \n@@ -450,7 +464,7 @@\n \n =item *\n \n-prefix:<->, numeric negation\n+C<< prefix:<-> >>, numeric negation\n \n     -$x\n \n@@ -458,7 +472,7 @@\n \n =item *\n \n-prefix:<~>, string context\n+C<< prefix:<~> >>, string context\n \n     ~$x\n \n@@ -467,7 +481,7 @@\n \n =item *\n \n-prefix:<|>, flatten object into arglist\n+C<< prefix:<|> >>, flatten object into arglist\n \n     | $capture\n \n@@ -476,7 +490,7 @@\n \n =item *\n \n-prefix:<+^>, numeric bitwise negation\n+C<< prefix:<+^> >>, numeric bitwise negation\n \n     +^$x\n \n@@ -484,14 +498,14 @@\n \n =item *\n \n-prefix:<~^>, string bitwise negation\n+C<< prefix:<~^> >>, string bitwise negation\n \n     ~^$x\n Coerces to string buffer and then does bitwise negation on each element.\n \n =item *\n \n-prefix:, boolean bitwise negation\n+C<< prefix: >>, boolean bitwise negation\n \n     ?^$x\n \n@@ -499,7 +513,7 @@\n \n =item *\n \n-prefix:<\\>, Capture constructor\n+C<< prefix:<\\> >>, Capture constructor\n \n     \\$x\n     \\@x\n@@ -511,7 +525,7 @@\n \n =item *\n \n-prefix:<^>, upto operator\n+C<< prefix:<^> >>, upto operator\n \n     ^$limit\n \n@@ -520,7 +534,7 @@\n \n =item *\n \n-prefix:<=>, iterate iterator\n+C<< prefix:<=> >>, iterate iterator\n \n     =$iterator\n \n@@ -543,7 +557,7 @@\n \n =item *\n \n-infix:<*>\n+C<< infix:<*> >>\n \n     $x*$y\n \n@@ -551,7 +565,7 @@\n \n =item *\n \n-infix:\n+C<< infix: >>\n \n     $numerator / $denominator\n \n@@ -571,7 +585,7 @@\n \n =item *\n \n-infix:, generic division\n+C<< infix: >>, generic division\n \n     $numerator div $denominator\n \n@@ -589,7 +603,7 @@\n \n =item *\n \n-infix:<%>, modulus\n+C<< infix:<%> >>, modulus\n \n     $x % $mod\n \n@@ -597,15 +611,15 @@\n \n =item *\n \n-infix:, generic modulus\n+C<< infix: >>, generic modulus\n \n     $x mod $mod\n \n-Dispatches to the infix: multi most appropriate to the operand types.\n+Dispatches to the C<< infix: >> multi most appropriate to the operand types.\n \n =item *\n \n-infix:, string/buffer replication\n+C<< infix: >>, string/buffer replication\n \n     $string x $count\n \n@@ -620,7 +634,7 @@\n \n =item *\n \n-infix:, list replication\n+C<< infix: >>, list replication\n \n     @list xx $count\n \n@@ -637,7 +651,7 @@\n \n =item *\n \n-infix:{'+&'}, numeric bitwise and\n+C<< infix:{'+&'} >>, numeric bitwise and\n \n     $x +& $y\n \n@@ -645,13 +659,13 @@\n \n =item *\n \n-infix:{'+<'}, numeric shift left\n+C<< infix:{'+<'} >>, numeric shift left\n \n     $integer +< $bits\n \n =item *\n \n-infix:{'+>'}, numeric shift right\n+C<< infix:{'+>'} >>, numeric shift right\n \n     $integer +> $bits\n \n@@ -660,19 +674,19 @@\n \n =item *\n \n-infix:<~&>, buffer bitwise and\n+C<< infix:<~&> >>, buffer bitwise and\n \n     $x ~& $y\n \n =item *\n \n-infix:{'~<'}, buffer bitwise shift left\n+C<< infix:{'~<'} >>, buffer bitwise shift left\n \n     $buf ~< $bits\n \n =item *\n \n-infix:{'~>'}, buffer bitwise shift right\n+C<< infix:{'~>'} >>, buffer bitwise shift right\n \n     $buf ~> $bits\n \n@@ -681,7 +695,7 @@\n \n =item *\n \n-infix:, boolean bitwise and\n+C<< infix: >>, boolean bitwise and\n \n     $x ?& $y\n \n@@ -697,55 +711,55 @@\n \n =item *\n \n-infix:<+>, numeric addition\n+C<< infix:<+> >>, numeric addition\n \n     $x + $y\n \n =item *\n \n-infix:<->, numeric subtraction\n+C<< infix:<-> >>, numeric subtraction\n \n     $x - $y\n \n =item *\n \n-infix:<~>, string/buffer concatenation\n+C<< infix:<~> >>, string/buffer concatenation\n \n     $x ~ $y\n \n =item *\n \n-infix:<+|>, numeric bitwise inclusive or\n+C<< infix:<+|> >>, numeric bitwise inclusive or\n \n     $x +| $y\n \n =item *\n \n-infix:<+^> numeric bitwise exclusive or\n+C<< infix:<+^> >> numeric bitwise exclusive or\n \n     $x +^ $y\n \n =item *\n \n-infix:<~|>, buffer bitwise inclusive or\n+C<< infix:<~|> >>, buffer bitwise inclusive or\n \n     $x ~| $y\n \n =item *\n \n-infix:<~^> buffer bitwise exclusive or\n+C<< infix:<~^> >> buffer bitwise exclusive or\n \n     $x ~^ $y\n \n =item *\n \n-infix:, boolean bitwise inclusive or\n+C<< infix: >>, boolean bitwise inclusive or\n \n     $x ?| $y\n \n =item *\n \n-infix: boolean bitwise exclusive or\n+C<< infix: >> boolean bitwise exclusive or\n \n     $x ?^ $y\n \n@@ -757,7 +771,7 @@\n \n =item *\n \n-infix:<&>, all() operator\n+C<< infix:<&> >>, all() operator\n \n     $x & $y\n \n@@ -769,13 +783,13 @@\n \n =item *\n \n-infix:<|>, any() operator\n+C<< infix:<|> >>, any() operator\n \n     $x | $y\n \n =item *\n \n-infix:<^>, one() operator\n+C<< infix:<^> >>, one() operator\n \n     $x ^ $y\n \n@@ -802,13 +816,13 @@\n \n =item *\n \n-infix:\n+C<< infix: >>\n \n     $value but Mixin\n \n =item *\n \n-infix:\n+C<< infix: >>\n \n     $object does Mixin\n \n@@ -866,7 +880,7 @@\n \n =item *\n \n-infix:<==> etc.\n+C<< infix:<==> >> etc.\n \n     == != < <= > >=\n \n@@ -874,7 +888,7 @@\n \n =item *\n \n-infix: etc.\n+C<< infix: >> etc.\n \n     eq ne lt le gt ge\n \n@@ -956,7 +970,7 @@\n \n =item *\n \n-infix:<&&>, short-circuit and\n+C<< infix:<&&> >>, short-circuit and\n \n     $condition && $whentrue\n \n@@ -973,7 +987,7 @@\n \n =item *\n \n-infix:<||>, short-circuiting inclusive-or\n+C<< infix:<||> >>, short-circuiting inclusive-or\n \n     $condition || $whenfalse\n \n@@ -988,7 +1002,7 @@\n \n =item *\n \n-infix:<^^>, exclusive-or\n+C<< infix:<^^> >>, exclusive-or\n \n     $x ^^ $y\n \n@@ -999,7 +1013,7 @@\n \n =item *\n \n-infix:, defined-or\n+C<< infix: >>, defined-or\n \n     $value // $default\n \n@@ -1073,6 +1087,14 @@\n \n     my $x = hmm() ?? 1 !! 2;          # much better\n \n+=item *\n+\n+C<< infix: >>\n+\n+To catch likely errors by people familiar with C-derived languages\n+(including Perl 5), a bare question mark in infix position will\n+produce an error suggesting that the user use C instead.\n+\n =back\n \n =head2 Item assignment precedence\n@@ -1081,7 +1103,7 @@\n \n =item *\n \n-infix:<=>\n+C<< infix:<=> >>\n \n     $x = 1, $y = 2;\n \n@@ -1090,7 +1112,7 @@\n \n =item *\n \n-infix:<:=>, run-time binding\n+C<< infix:<:=> >>, run-time binding\n \n     $signature := $capture\n \n@@ -1125,7 +1147,7 @@\n \n =item *\n \n-infix:<::=>, compile-time binding\n+C<< infix:<::=> >>, compile-time binding\n \n     $signature ::= $capture\n \n@@ -1135,7 +1157,7 @@\n \n =item *\n \n-infix:{'=>'}, Pair constructor\n+C<< infix:{'=>'} >>, Pair constructor\n \n     foo => 1, bar => \"baz\"\n \n@@ -1163,13 +1185,13 @@\n \n =item *\n \n-prefix:\n+C<< prefix: >>\n \n     true any(@args) eq '-v' | '-V'\n \n =item *\n \n-prefix:\n+C<< prefix: >>\n \n     not any(@args) eq '-v' | '-V'\n \n@@ -1181,7 +1203,7 @@\n \n =item *\n \n-infix:<,>, the argument separator\n+C<< infix:<,> >>, the argument separator\n \n     1, 2, 3, @many\n \n@@ -1201,13 +1223,13 @@\n \n =item *\n \n-infix:, the zip operator\n+C<< infix: >>, the zip operator\n \n     1,2 Z 3,4   # (1,3),(2,4)\n \n =item *\n \n-infix:, the minmax operator\n+C<< infix: >>, the minmax operator\n \n     $min0, $max0 minmax $min1, $max1    # ($min0 min $min1, $max0 max $max1)\n \n@@ -1226,7 +1248,7 @@\n \n =item *\n \n-infix:, the cross operator\n+C<< infix: >>, the cross operator\n \n     1,2 X 3,4          # (1,3), (1,4), (2,3), (2,4)\n \n@@ -1269,7 +1291,7 @@\n \n =item *\n \n-infix:<=>, list assignment\n+C<< infix:<=> >>, list assignment\n \n     @array = 1,2,3;\n \n@@ -1291,7 +1313,7 @@\n \n =item *\n \n-infix:<:>, the invocant marker\n+C<< infix:<:> >>, the invocant marker\n \n     say $*OUT: \"howdy, world\"\n \n@@ -1435,7 +1457,7 @@\n \n =item *\n \n-infix:, short-circuit and\n+C<< infix: >>, short-circuit and\n \n     $condition and $whentrue\n \n@@ -1452,7 +1474,7 @@\n \n =item *\n \n-infix:, short-circuit inclusive or\n+C<< infix: >>, short-circuit inclusive or\n \n     $condition or $whenfalse\n \n@@ -1462,7 +1484,7 @@\n \n =item *\n \n-infix:, exclusive or\n+C<< infix: >>, exclusive or\n \n     $x xor $y\n \n@@ -1473,7 +1495,7 @@\n \n =item *\n \n-infix:, short-circuit defined-or\n+C<< infix: >>, short-circuit defined-or\n \n     $value err $default\n \n@@ -1579,10 +1601,17 @@\n Perl\u00a05's C<${...}>, C<@{...}>, C<%{...}>, etc. dereferencing\n forms are now C<$(...)>, C<@(...)>, C<%(...)>, etc. instead.\n Listop-like forms use the bare sigil following by whitespace.\n+Use of the Perl 5 curly forms will result in an error message\n+pointing the user to the new forms.\n \n =item *\n \n-C<< -> >> becomes C<.>, like the rest of the world uses.\n+C<< -> >> becomes C<.>, like the rest of the world uses.  There is\n+a pseudo C<< postfix:{'->'} >> operator that produces a compile-time\n+error reminding Perl 5 users to use dot instead.  (The \"pointy block\"\n+use of C<< -> >> in Perl 5 requires preceding whitespace when the arrow\n+could be confused with a postfix, that is when an infix is expected.\n+Preceding whitespace is not required in term position.)\n \n =item *\n \n@@ -1652,6 +1681,10 @@\n Note that C<:s> still returns the filesize, but C<:!s> is true\n only if the file is of size 0.\n \n+(Inadvertent use of the Perl 5 forms will normally result in treatment\n+as a negated postdeclared subroutine, which is likely to produce an\n+error message at the end of compilation.)\n+\n =item *\n \n All postfix operators that do not start with a dot also have\n@@ -1717,7 +1750,8 @@\n \n =item *\n \n-The C conditional operator becomes C.\n+The C conditional operator becomes C.  A pseudo operator,\n+C<< infix: >>, catches migratory brainos at compile time.\n \n =item *\n \n@@ -1730,6 +1764,9 @@\n \n In item context comma C<,> now constructs a C object from its\n operands.  You have to use a C<[*-1]> subscript to get the last one.\n+(Note the C<*>.  Negative subscripts no longer implicitly count from\n+the end; in fact, the compiler may complain if you use C<[-1]> on an\n+object known at compile time not to have negative subscripts.)\n \n =item *\n \n@@ -3099,6 +3136,8 @@\n     [^]()       # one()\n     [!==]()     # Bool::False   (also for 1 arg)\n     [==]()      # Bool::True    (also for 1 arg)\n+    [before]()  # Bool::True    (also for 1 arg)\n+    [after]()   # Bool::True    (also for 1 arg)\n     [<]()       # Bool::True    (also for 1 arg)\n     [<=]()      # Bool::True    (also for 1 arg)\n     [>]()       # Bool::True    (also for 1 arg)\n\nModified: doc/trunk/design/syn/S12.pod\n==============================================================================\n--- doc/trunk/design/syn/S12.pod\t(original)\n+++ doc/trunk/design/syn/S12.pod\tFri Jun 15 12:10:26 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 27 Oct 2004\n-  Last Modified: 31 May 2007\n+  Last Modified: 15 May 2007\n   Number: 12\n-  Version: 54\n+  Version: 55\n \n =head1 Overview\n \n@@ -225,6 +225,16 @@\n     $obj.\"$methodname\"(1,2,3)   # use contents of $methodname as method name\n     $obj.'$methodname'(1,2,3)   # no interpolation; call method with $ in name!\n \n+[Note: to help catch the mistaken use of C<< infix:<.> >> as a string\n+concatenation operator, Perl 6 will warn you about \"useless use of\n+quotes\" at compile time if the string inside quotes is an identifier.\n+(It does not warn about non-identifier strings, but such strings are\n+likely to produce missing method errors at run time in any case.)\n+Also, if there is whitespace around an intended C<.> concatenation,\n+it cannot be parsed as a method call at all; instead if fails at\n+compile time because standard Perl 6 has no C<< infix:<.> >> operator\n+unless the user happens to have defined one (bad idea).]\n+\n For situations where you already have a method located, you\n can use a simple scalar variable in place of method name:\n \n\n"}
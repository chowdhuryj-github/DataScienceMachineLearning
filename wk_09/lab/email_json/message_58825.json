{"category": "ham", "to_address": "jakin44@users.sourceforge.net, Jason Kivlighn <jkivlighn@gmail.com>,\n   \"cc-devel@lists.ibiblio.org\" <cc-devel@lists.ibiblio.org>", "from_address": "Jon Phillips <jon@rejon.org>", "subject": "Re: [cc-devel] [Cctools-cvs] SF.net SVN: cctools: [6089]\n\tliblicense/trunk", "body": "Heya, why are you pulling in xdgmime into the tree? We should be\ndepending on externals as much as possible. Can we avoid pulling this\ninto the tree? And/or is it setup with svn externals if absolutely\nnecessary to pull it in.\n\nJon\n\nOn Fri, 2007-06-29 at 12:16 -0700, jakin44@users.sourceforge.net wrote:\n> Revision: 6089\n>           http://svn.sourceforge.net/cctools/?rev=6089&view=rev\n> Author:   jakin44\n> Date:     2007-06-29 12:16:02 -0700 (Fri, 29 Jun 2007)\n> \n> Log Message:\n> -----------\n> Pull in xdgmime from Freedesktop for mime-type detection.\n> \n> Modified Paths:\n> --------------\n>     liblicense/trunk/Makefile.am\n>     liblicense/trunk/configure.ac\n> \n> Added Paths:\n> -----------\n>     liblicense/trunk/xdgmime/\n>     liblicense/trunk/xdgmime/Makefile.am\n>     liblicense/trunk/xdgmime/xdgmime.c\n>     liblicense/trunk/xdgmime/xdgmime.h\n>     liblicense/trunk/xdgmime/xdgmimealias.c\n>     liblicense/trunk/xdgmime/xdgmimealias.h\n>     liblicense/trunk/xdgmime/xdgmimecache.c\n>     liblicense/trunk/xdgmime/xdgmimecache.h\n>     liblicense/trunk/xdgmime/xdgmimeglob.c\n>     liblicense/trunk/xdgmime/xdgmimeglob.h\n>     liblicense/trunk/xdgmime/xdgmimeint.c\n>     liblicense/trunk/xdgmime/xdgmimeint.h\n>     liblicense/trunk/xdgmime/xdgmimemagic.c\n>     liblicense/trunk/xdgmime/xdgmimemagic.h\n>     liblicense/trunk/xdgmime/xdgmimeparent.c\n>     liblicense/trunk/xdgmime/xdgmimeparent.h\n> \n> Modified: liblicense/trunk/Makefile.am\n> ===================================================================\n> --- liblicense/trunk/Makefile.am\t2007-06-28 23:38:45 UTC (rev 6088)\n> +++ liblicense/trunk/Makefile.am\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -1,4 +1,4 @@\n> -SUBDIRS = . modules bindings tests\n> +SUBDIRS = . xdgmime modules bindings tests\n>  \n>  lib_LTLIBRARIES = liblicense.la\n>  \n> @@ -9,4 +9,4 @@\n>  \twrite_license.c \\\n>  \tsystem_default.c \\\n>  \tmodule_wrangler.c \\\n> -\tsystem_licenses.c \n> \\ No newline at end of file\n> +\tsystem_licenses.c \n> \n> Modified: liblicense/trunk/configure.ac\n> ===================================================================\n> --- liblicense/trunk/configure.ac\t2007-06-28 23:38:45 UTC (rev 6088)\n> +++ liblicense/trunk/configure.ac\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -66,7 +66,7 @@\n>  # check for exempi\n>  ##################################################################\n>  \n> -EXEMPI_REQUIRED=1.99.1\n> +EXEMPI_REQUIRED=1.99.3\n>  \n>  AC_ARG_ENABLE(xmp, AC_HELP_STRING([--disable-xmp], [Disable XMP extraction]),,[enable_xmp=yes])\n>  if test \"x$enable_xmp\" = \"xyes\"; then\n> @@ -89,6 +89,7 @@\n>  \tbindings/Makefile\n>  \tbindings/python/Makefile\n>  \ttests/Makefile\n> +\txdgmime/Makefile\n>  ])\n>  \n>  AC_CONFIG_HEADERS([config.h])\n> \n> Added: liblicense/trunk/xdgmime/Makefile.am\n> ===================================================================\n> --- liblicense/trunk/xdgmime/Makefile.am\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/Makefile.am\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,18 @@\n> +\n> +noinst_LTLIBRARIES = libxdgmime.la\n> +\n> +libxdgmime_la_SOURCES = \\\n> +\txdgmime.c \t\\\n> +\txdgmime.h\t\\\n> +\txdgmimealias.c\t\\\n> +\txdgmimealias.h\t\\\n> +\txdgmimecache.c\t\\\n> +\txdgmimecache.h\t\\\n> +\txdgmimeglob.c \t\\\n> +\txdgmimeglob.h \t\\\n> +\txdgmimeint.c \t\\\n> +\txdgmimeint.h \t\\\n> +\txdgmimemagic.c  \\\n> +\txdgmimemagic.h\t\\\n> +\txdgmimeparent.c\t\\\n> +\txdgmimeparent.h\n> \n> Added: liblicense/trunk/xdgmime/xdgmime.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmime.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmime.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,828 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmime.c: XDG Mime Spec mime resolver.  Based on version 0.11 of the spec.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + * \n> + * Copyright (C) 2003,2004  Red Hat, Inc.\n> + * Copyright (C) 2003,2004  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + * \n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \"xdgmime.h\"\n> +#include \"xdgmimeint.h\"\n> +#include \"xdgmimeglob.h\"\n> +#include \"xdgmimemagic.h\"\n> +#include \"xdgmimealias.h\"\n> +#include \"xdgmimeparent.h\"\n> +#include \"xdgmimecache.h\"\n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +\n> +typedef struct XdgDirTimeList XdgDirTimeList;\n> +typedef struct XdgCallbackList XdgCallbackList;\n> +\n> +static int need_reread = TRUE;\n> +static time_t last_stat_time = 0;\n> +\n> +static XdgGlobHash *global_hash = NULL;\n> +static XdgMimeMagic *global_magic = NULL;\n> +static XdgAliasList *alias_list = NULL;\n> +static XdgParentList *parent_list = NULL;\n> +static XdgDirTimeList *dir_time_list = NULL;\n> +static XdgCallbackList *callback_list = NULL;\n> +\n> +XdgMimeCache **_caches = NULL;\n> +static int n_caches = 0;\n> +\n> +const char *xdg_mime_type_unknown = \"application/octet-stream\";\n> +\n> +\n> +enum\n> +{\n> +  XDG_CHECKED_UNCHECKED,\n> +  XDG_CHECKED_VALID,\n> +  XDG_CHECKED_INVALID\n> +};\n> +\n> +struct XdgDirTimeList\n> +{\n> +  time_t mtime;\n> +  char *directory_name;\n> +  int checked;\n> +  XdgDirTimeList *next;\n> +};\n> +\n> +struct XdgCallbackList\n> +{\n> +  XdgCallbackList *next;\n> +  XdgCallbackList *prev;\n> +  int              callback_id;\n> +  XdgMimeCallback  callback;\n> +  void            *data;\n> +  XdgMimeDestroy   destroy;\n> +};\n> +\n> +/* Function called by xdg_run_command_on_dirs.  If it returns TRUE, further\n> + * directories aren't looked at */\n> +typedef int (*XdgDirectoryFunc) (const char *directory,\n> +\t\t\t\t void       *user_data);\n> +\n> +static XdgDirTimeList *\n> +xdg_dir_time_list_new (void)\n> +{\n> +  XdgDirTimeList *retval;\n> +\n> +  retval = calloc (1, sizeof (XdgDirTimeList));\n> +  retval->checked = XDG_CHECKED_UNCHECKED;\n> +\n> +  return retval;\n> +}\n> +\n> +static void\n> +xdg_dir_time_list_free (XdgDirTimeList *list)\n> +{\n> +  XdgDirTimeList *next;\n> +\n> +  while (list)\n> +    {\n> +      next = list->next;\n> +      free (list->directory_name);\n> +      free (list);\n> +      list = next;\n> +    }\n> +}\n> +\n> +static int\n> +xdg_mime_init_from_directory (const char *directory)\n> +{\n> +  char *file_name;\n> +  struct stat st;\n> +  XdgDirTimeList *list;\n> +\n> +  assert (directory != NULL);\n> +\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/mime.cache\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/mime.cache\");\n> +  if (stat (file_name, &st) == 0)\n> +    {\n> +      XdgMimeCache *cache = _xdg_mime_cache_new_from_file (file_name);\n> +\n> +      if (cache != NULL)\n> +\t{\n> +\t  list = xdg_dir_time_list_new ();\n> +\t  list->directory_name = file_name;\n> +\t  list->mtime = st.st_mtime;\n> +\t  list->next = dir_time_list;\n> +\t  dir_time_list = list;\n> +\n> +\t  _caches = realloc (_caches, sizeof (XdgMimeCache *) * (n_caches + 2));\n> +\t  _caches[n_caches] = cache;\n> +          _caches[n_caches + 1] = NULL;\n> +\t  n_caches++;\n> +\n> +\t  return FALSE;\n> +\t}\n> +    }\n> +  free (file_name);\n> +\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/globs\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/globs\");\n> +  if (stat (file_name, &st) == 0)\n> +    {\n> +      _xdg_mime_glob_read_from_file (global_hash, file_name);\n> +\n> +      list = xdg_dir_time_list_new ();\n> +      list->directory_name = file_name;\n> +      list->mtime = st.st_mtime;\n> +      list->next = dir_time_list;\n> +      dir_time_list = list;\n> +    }\n> +  else\n> +    {\n> +      free (file_name);\n> +    }\n> +\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/magic\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/magic\");\n> +  if (stat (file_name, &st) == 0)\n> +    {\n> +      _xdg_mime_magic_read_from_file (global_magic, file_name);\n> +\n> +      list = xdg_dir_time_list_new ();\n> +      list->directory_name = file_name;\n> +      list->mtime = st.st_mtime;\n> +      list->next = dir_time_list;\n> +      dir_time_list = list;\n> +    }\n> +  else\n> +    {\n> +      free (file_name);\n> +    }\n> +\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/aliases\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/aliases\");\n> +  _xdg_mime_alias_read_from_file (alias_list, file_name);\n> +  free (file_name);\n> +\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/subclasses\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/subclasses\");\n> +  _xdg_mime_parent_read_from_file (parent_list, file_name);\n> +  free (file_name);\n> +\n> +  return FALSE; /* Keep processing */\n> +}\n> +\n> +/* Runs a command on all the directories in the search path */\n> +static void\n> +xdg_run_command_on_dirs (XdgDirectoryFunc  func,\n> +\t\t\t void             *user_data)\n> +{\n> +  const char *xdg_data_home;\n> +  const char *xdg_data_dirs;\n> +  const char *ptr;\n> +\n> +  xdg_data_home = getenv (\"XDG_DATA_HOME\");\n> +  if (xdg_data_home)\n> +    {\n> +      if ((func) (xdg_data_home, user_data))\n> +\treturn;\n> +    }\n> +  else\n> +    {\n> +      const char *home;\n> +\n> +      home = getenv (\"HOME\");\n> +      if (home != NULL)\n> +\t{\n> +\t  char *guessed_xdg_home;\n> +\t  int stop_processing;\n> +\n> +\t  guessed_xdg_home = malloc (strlen (home) + strlen (\"/.local/share/\") + 1);\n> +\t  strcpy (guessed_xdg_home, home);\n> +\t  strcat (guessed_xdg_home, \"/.local/share/\");\n> +\t  stop_processing = (func) (guessed_xdg_home, user_data);\n> +\t  free (guessed_xdg_home);\n> +\n> +\t  if (stop_processing)\n> +\t    return;\n> +\t}\n> +    }\n> +\n> +  xdg_data_dirs = getenv (\"XDG_DATA_DIRS\");\n> +  if (xdg_data_dirs == NULL)\n> +    xdg_data_dirs = \"/usr/local/share/:/usr/share/\";\n> +\n> +  ptr = xdg_data_dirs;\n> +\n> +  while (*ptr != '\\000')\n> +    {\n> +      const char *end_ptr;\n> +      char *dir;\n> +      int len;\n> +      int stop_processing;\n> +\n> +      end_ptr = ptr;\n> +      while (*end_ptr != ':' && *end_ptr != '\\000')\n> +\tend_ptr ++;\n> +\n> +      if (end_ptr == ptr)\n> +\t{\n> +\t  ptr++;\n> +\t  continue;\n> +\t}\n> +\n> +      if (*end_ptr == ':')\n> +\tlen = end_ptr - ptr;\n> +      else\n> +\tlen = end_ptr - ptr + 1;\n> +      dir = malloc (len + 1);\n> +      strncpy (dir, ptr, len);\n> +      dir[len] = '\\0';\n> +      stop_processing = (func) (dir, user_data);\n> +      free (dir);\n> +\n> +      if (stop_processing)\n> +\treturn;\n> +\n> +      ptr = end_ptr;\n> +    }\n> +}\n> +\n> +/* Checks file_path to make sure it has the same mtime as last time it was\n> + * checked.  If it has a different mtime, or if the file doesn't exist, it\n> + * returns FALSE.\n> + *\n> + * FIXME: This doesn't protect against permission changes.\n> + */\n> +static int\n> +xdg_check_file (const char *file_path)\n> +{\n> +  struct stat st;\n> +\n> +  /* If the file exists */\n> +  if (stat (file_path, &st) == 0)\n> +    {\n> +      XdgDirTimeList *list;\n> +\n> +      for (list = dir_time_list; list; list = list->next)\n> +\t{\n> +\t  if (! strcmp (list->directory_name, file_path) &&\n> +\t      st.st_mtime == list->mtime)\n> +\t    {\n> +\t      if (list->checked == XDG_CHECKED_UNCHECKED)\n> +\t\tlist->checked = XDG_CHECKED_VALID;\n> +\t      else if (list->checked == XDG_CHECKED_VALID)\n> +\t\tlist->checked = XDG_CHECKED_INVALID;\n> +\n> +\t      return (list->checked != XDG_CHECKED_VALID);\n> +\t    }\n> +\t}\n> +      return TRUE;\n> +    }\n> +\n> +  return FALSE;\n> +}\n> +\n> +static int\n> +xdg_check_dir (const char *directory,\n> +\t       int        *invalid_dir_list)\n> +{\n> +  int invalid;\n> +  char *file_name;\n> +\n> +  assert (directory != NULL);\n> +\n> +  /* Check the globs file */\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/globs\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/globs\");\n> +  invalid = xdg_check_file (file_name);\n> +  free (file_name);\n> +  if (invalid)\n> +    {\n> +      *invalid_dir_list = TRUE;\n> +      return TRUE;\n> +    }\n> +\n> +  /* Check the magic file */\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/magic\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/magic\");\n> +  invalid = xdg_check_file (file_name);\n> +  free (file_name);\n> +  if (invalid)\n> +    {\n> +      *invalid_dir_list = TRUE;\n> +      return TRUE;\n> +    }\n> +\n> +  /* Check the mime.cache file */\n> +  file_name = malloc (strlen (directory) + strlen (\"/mime/mime.cache\") + 1);\n> +  strcpy (file_name, directory); strcat (file_name, \"/mime/mime.cache\");\n> +  invalid = xdg_check_file (file_name);\n> +  free (file_name);\n> +  if (invalid)\n> +    {\n> +      *invalid_dir_list = TRUE;\n> +      return TRUE;\n> +    }\n> +\n> +  return FALSE; /* Keep processing */\n> +}\n> +\n> +/* Walks through all the mime files stat()ing them to see if they've changed.\n> + * Returns TRUE if they have. */\n> +static int\n> +xdg_check_dirs (void)\n> +{\n> +  XdgDirTimeList *list;\n> +  int invalid_dir_list = FALSE;\n> +\n> +  for (list = dir_time_list; list; list = list->next)\n> +    list->checked = XDG_CHECKED_UNCHECKED;\n> +\n> +  xdg_run_command_on_dirs ((XdgDirectoryFunc) xdg_check_dir,\n> +\t\t\t   &invalid_dir_list);\n> +\n> +  if (invalid_dir_list)\n> +    return TRUE;\n> +\n> +  for (list = dir_time_list; list; list = list->next)\n> +    {\n> +      if (list->checked != XDG_CHECKED_VALID)\n> +\treturn TRUE;\n> +    }\n> +\n> +  return FALSE;\n> +}\n> +\n> +/* We want to avoid stat()ing on every single mime call, so we only look for\n> + * newer files every 5 seconds.  This will return TRUE if we need to reread the\n> + * mime data from disk.\n> + */\n> +static int\n> +xdg_check_time_and_dirs (void)\n> +{\n> +  struct timeval tv;\n> +  time_t current_time;\n> +  int retval = FALSE;\n> +\n> +  gettimeofday (&tv, NULL);\n> +  current_time = tv.tv_sec;\n> +\n> +  if (current_time >= last_stat_time + 5)\n> +    {\n> +      retval = xdg_check_dirs ();\n> +      last_stat_time = current_time;\n> +    }\n> +\n> +  return retval;\n> +}\n> +\n> +/* Called in every public function.  It reloads the hash function if need be.\n> + */\n> +static void\n> +xdg_mime_init (void)\n> +{\n> +  if (xdg_check_time_and_dirs ())\n> +    {\n> +      xdg_mime_shutdown ();\n> +    }\n> +\n> +  if (need_reread)\n> +    {\n> +      global_hash = _xdg_glob_hash_new ();\n> +      global_magic = _xdg_mime_magic_new ();\n> +      alias_list = _xdg_mime_alias_list_new ();\n> +      parent_list = _xdg_mime_parent_list_new ();\n> +\n> +      xdg_run_command_on_dirs ((XdgDirectoryFunc) xdg_mime_init_from_directory,\n> +\t\t\t       NULL);\n> +\n> +      need_reread = FALSE;\n> +    }\n> +}\n> +\n> +const char *\n> +xdg_mime_get_mime_type_for_data (const void *data,\n> +\t\t\t\t size_t      len)\n> +{\n> +  const char *mime_type;\n> +\n> +  xdg_mime_init ();\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_get_mime_type_for_data (data, len);\n> +\n> +  mime_type = _xdg_mime_magic_lookup_data (global_magic, data, len, NULL, 0);\n> +\n> +  if (mime_type)\n> +    return mime_type;\n> +\n> +  return XDG_MIME_TYPE_UNKNOWN;\n> +}\n> +\n> +const char *\n> +xdg_mime_get_mime_type_for_file (const char  *file_name,\n> +                                 struct stat *statbuf)\n> +{\n> +  const char *mime_type;\n> +  /* currently, only a few globs occur twice, and none\n> +   * more often, so 5 seems plenty.\n> +   */\n> +  const char *mime_types[5];\n> +  FILE *file;\n> +  unsigned char *data;\n> +  int max_extent;\n> +  int bytes_read;\n> +  struct stat buf;\n> +  const char *base_name;\n> +  int n;\n> +\n> +  if (file_name == NULL)\n> +    return NULL;\n> +  if (! _xdg_utf8_validate (file_name))\n> +    return NULL;\n> +\n> +  xdg_mime_init ();\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_get_mime_type_for_file (file_name, statbuf);\n> +\n> +  base_name = _xdg_get_base_name (file_name);\n> +  n = _xdg_glob_hash_lookup_file_name (global_hash, base_name, mime_types, 5);\n> +\n> +  if (n == 1)\n> +    return mime_types[0];\n> +\n> +  if (!statbuf)\n> +    {\n> +      if (stat (file_name, &buf) != 0)\n> +\treturn XDG_MIME_TYPE_UNKNOWN;\n> +\n> +      statbuf = &buf\n> +    }\n> +\n> +  if (!S_ISREG (statbuf->st_mode))\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +\n> +  /* FIXME: Need to make sure that max_extent isn't totally broken.  This could\n> +   * be large and need getting from a stream instead of just reading it all\n> +   * in. */\n> +  max_extent = _xdg_mime_magic_get_buffer_extents (global_magic);\n> +  data = malloc (max_extent);\n> +  if (data == NULL)\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +        \n> +  file = fopen (file_name, \"r\");\n> +  if (file == NULL)\n> +    {\n> +      free (data);\n> +      return XDG_MIME_TYPE_UNKNOWN;\n> +    }\n> +\n> +  bytes_read = fread (data, 1, max_extent, file);\n> +  if (ferror (file))\n> +    {\n> +      free (data);\n> +      fclose (file);\n> +      return XDG_MIME_TYPE_UNKNOWN;\n> +    }\n> +\n> +  mime_type = _xdg_mime_magic_lookup_data (global_magic, data, bytes_read,\n> +\t\t\t\t\t   mime_types, n);\n> +\n> +  free (data);\n> +  fclose (file);\n> +\n> +  if (mime_type)\n> +    return mime_type;\n> +\n> +  return XDG_MIME_TYPE_UNKNOWN;\n> +}\n> +\n> +const char *\n> +xdg_mime_get_mime_type_from_file_name (const char *file_name)\n> +{\n> +  const char *mime_types[2];\n> +\n> +  xdg_mime_init ();\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_get_mime_type_from_file_name (file_name);\n> +\n> +  if (_xdg_glob_hash_lookup_file_name (global_hash, file_name, mime_types, 2) == 1)\n> +    return mime_types[0];\n> +  else\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +}\n> +\n> +int\n> +xdg_mime_is_valid_mime_type (const char *mime_type)\n> +{\n> +  /* FIXME: We should make this a better test\n> +   */\n> +  return _xdg_utf8_validate (mime_type);\n> +}\n> +\n> +void\n> +xdg_mime_shutdown (void)\n> +{\n> +  XdgCallbackList *list;\n> +\n> +  /* FIXME: Need to make this (and the whole library) thread safe */\n> +  if (dir_time_list)\n> +    {\n> +      xdg_dir_time_list_free (dir_time_list);\n> +      dir_time_list = NULL;\n> +    }\n> +\t\n> +  if (global_hash)\n> +    {\n> +      _xdg_glob_hash_free (global_hash);\n> +      global_hash = NULL;\n> +    }\n> +  if (global_magic)\n> +    {\n> +      _xdg_mime_magic_free (global_magic);\n> +      global_magic = NULL;\n> +    }\n> +\n> +  if (alias_list)\n> +    {\n> +      _xdg_mime_alias_list_free (alias_list);\n> +      alias_list = NULL;\n> +    }\n> +\n> +  if (parent_list)\n> +    {\n> +      _xdg_mime_parent_list_free (parent_list);\n> +      parent_list = NULL;\n> +    }\n> +  \n> +  for (list = callback_list; list; list = list->next)\n> +    (list->callback) (list->data);\n> +\n> +  need_reread = TRUE;\n> +}\n> +\n> +int\n> +xdg_mime_get_max_buffer_extents (void)\n> +{\n> +  xdg_mime_init ();\n> +  \n> +  if (_caches)\n> +    return _xdg_mime_cache_get_max_buffer_extents ();\n> +\n> +  return _xdg_mime_magic_get_buffer_extents (global_magic);\n> +}\n> +\n> +static const char *\n> +_xdg_mime_unalias_mime_type (const char *mime_type)\n> +{\n> +  const char *lookup;\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_unalias_mime_type (mime_type);\n> +\n> +  if ((lookup = _xdg_mime_alias_list_lookup (alias_list, mime_type)) != NULL)\n> +    return lookup;\n> +\n> +  return mime_type;\n> +}\n> +\n> +const char *\n> +xdg_mime_unalias_mime_type (const char *mime_type)\n> +{\n> +  xdg_mime_init ();\n> +\n> +  return _xdg_mime_unalias_mime_type (mime_type);\n> +}\n> +\n> +int\n> +_xdg_mime_mime_type_equal (const char *mime_a,\n> +\t\t\t   const char *mime_b)\n> +{\n> +  const char *unalias_a, *unalias_b;\n> +\n> +  unalias_a = _xdg_mime_unalias_mime_type (mime_a);\n> +  unalias_b = _xdg_mime_unalias_mime_type (mime_b);\n> +\n> +  if (strcmp (unalias_a, unalias_b) == 0)\n> +    return 1;\n> +\n> +  return 0;\n> +}\n> +\n> +int\n> +xdg_mime_mime_type_equal (const char *mime_a,\n> +\t\t\t  const char *mime_b)\n> +{\n> +  xdg_mime_init ();\n> +\n> +  return _xdg_mime_mime_type_equal (mime_a, mime_b);\n> +}\n> +\n> +int\n> +xdg_mime_media_type_equal (const char *mime_a,\n> +\t\t\t   const char *mime_b)\n> +{\n> +  char *sep;\n> +\n> +  xdg_mime_init ();\n> +\n> +  sep = strchr (mime_a, '/');\n> +  \n> +  if (sep && strncmp (mime_a, mime_b, sep - mime_a + 1) == 0)\n> +    return 1;\n> +\n> +  return 0;\n> +}\n> +\n> +#if 0\n> +static int\n> +xdg_mime_is_super_type (const char *mime)\n> +{\n> +  int length;\n> +  const char *type;\n> +\n> +  length = strlen (mime);\n> +  type = &(mime[length - 2]);\n> +\n> +  if (strcmp (type, \"/*\") == 0)\n> +    return 1;\n> +\n> +  return 0;\n> +}\n> +#endif\n> +\n> +int\n> +_xdg_mime_mime_type_subclass (const char *mime,\n> +\t\t\t      const char *base)\n> +{\n> +  const char *umime, *ubase;\n> +  const char **parents;\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_mime_type_subclass (mime, base);\n> +\n> +  umime = _xdg_mime_unalias_mime_type (mime);\n> +  ubase = _xdg_mime_unalias_mime_type (base);\n> +\n> +  if (strcmp (umime, ubase) == 0)\n> +    return 1;\n> +\n> +#if 0  \n> +  /* Handle supertypes */\n> +  if (xdg_mime_is_super_type (ubase) &&\n> +      xdg_mime_media_type_equal (umime, ubase))\n> +    return 1;\n> +#endif\n> +\n> +  /*  Handle special cases text/plain and application/octet-stream */\n> +  if (strcmp (ubase, \"text/plain\") == 0 && \n> +      strncmp (umime, \"text/\", 5) == 0)\n> +    return 1;\n> +\n> +  if (strcmp (ubase, \"application/octet-stream\") == 0)\n> +    return 1;\n> +  \n> +  parents = _xdg_mime_parent_list_lookup (parent_list, umime);\n> +  for (; parents && *parents; parents++)\n> +    {\n> +      if (_xdg_mime_mime_type_subclass (*parents, ubase))\n> +\treturn 1;\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +int\n> +xdg_mime_mime_type_subclass (const char *mime,\n> +\t\t\t     const char *base)\n> +{\n> +  xdg_mime_init ();\n> +\n> +  return _xdg_mime_mime_type_subclass (mime, base);\n> +}\n> +\n> +char **\n> +xdg_mime_list_mime_parents (const char *mime)\n> +{\n> +  const char **parents;\n> +  char **result;\n> +  int i, n;\n> +\n> +  if (_caches)\n> +    return _xdg_mime_cache_list_mime_parents (mime);\n> +\n> +  parents = xdg_mime_get_mime_parents (mime);\n> +\n> +  if (!parents)\n> +    return NULL;\n> +\n> +  for (i = 0; parents[i]; i++) ;\n> +  \n> +  n = (i + 1) * sizeof (char *);\n> +  result = (char **) malloc (n);\n> +  memcpy (result, parents, n);\n> +\n> +  return result;\n> +}\n> +\n> +const char **\n> +xdg_mime_get_mime_parents (const char *mime)\n> +{\n> +  const char *umime;\n> +\n> +  xdg_mime_init ();\n> +\n> +  umime = _xdg_mime_unalias_mime_type (mime);\n> +\n> +  return _xdg_mime_parent_list_lookup (parent_list, umime);\n> +}\n> +\n> +void \n> +xdg_mime_dump (void)\n> +{\n> +  printf (\"*** ALIASES ***\\n\\n\");\n> +  _xdg_mime_alias_list_dump (alias_list);\n> +  printf (\"\\n*** PARENTS ***\\n\\n\");\n> +  _xdg_mime_parent_list_dump (parent_list);\n> +}\n> +\n> +\n> +/* Registers a function to be called every time the mime database reloads its files\n> + */\n> +int\n> +xdg_mime_register_reload_callback (XdgMimeCallback  callback,\n> +\t\t\t\t   void            *data,\n> +\t\t\t\t   XdgMimeDestroy   destroy)\n> +{\n> +  XdgCallbackList *list_el;\n> +  static int callback_id = 1;\n> +\n> +  /* Make a new list element */\n> +  list_el = calloc (1, sizeof (XdgCallbackList));\n> +  list_el->callback_id = callback_id;\n> +  list_el->callback = callback;\n> +  list_el->data = data;\n> +  list_el->destroy = destroy;\n> +  list_el->next = callback_list;\n> +  if (list_el->next)\n> +    list_el->next->prev = list_el;\n> +\n> +  callback_list = list_el;\n> +  callback_id ++;\n> +\n> +  return callback_id - 1;\n> +}\n> +\n> +void\n> +xdg_mime_remove_callback (int callback_id)\n> +{\n> +  XdgCallbackList *list;\n> +\n> +  for (list = callback_list; list; list = list->next)\n> +    {\n> +      if (list->callback_id == callback_id)\n> +\t{\n> +\t  if (list->next)\n> +\t    list->next = list->prev;\n> +\n> +\t  if (list->prev)\n> +\t    list->prev->next = list->next;\n> +\t  else\n> +\t    callback_list = list->next;\n> +\n> +\t  /* invoke the destroy handler */\n> +\t  (list->destroy) (list->data);\n> +\t  free (list);\n> +\t  return;\n> +\t}\n> +    }\n> +}\n> \n> Added: liblicense/trunk/xdgmime/xdgmime.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmime.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmime.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,108 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmime.h: XDG Mime Spec mime resolver.  Based on version 0.11 of the spec.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + * \n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + * \n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +\n> +#ifndef __XDG_MIME_H__\n> +#define __XDG_MIME_H__\n> +\n> +#include \n> +#include \n> +\n> +#ifdef __cplusplus\n> +extern \"C\" {\n> +#endif /* __cplusplus */\n> +\n> +#ifdef XDG_PREFIX\n> +#define XDG_ENTRY(func) _XDG_ENTRY2(XDG_PREFIX,func)\n> +#define _XDG_ENTRY2(prefix,func) _XDG_ENTRY3(prefix,func)\n> +#define _XDG_ENTRY3(prefix,func) prefix##_##func\n> +#endif\n> +\n> +typedef void (*XdgMimeCallback) (void *user_data);\n> +typedef void (*XdgMimeDestroy)  (void *user_data);\n> +\n> +  \n> +#ifdef XDG_PREFIX\n> +#define xdg_mime_get_mime_type_for_data       XDG_ENTRY(get_mime_type_for_data)\n> +#define xdg_mime_get_mime_type_for_file       XDG_ENTRY(get_mime_type_for_file)\n> +#define xdg_mime_get_mime_type_from_file_name XDG_ENTRY(get_mime_type_from_file_name)\n> +#define xdg_mime_is_valid_mime_type           XDG_ENTRY(is_valid_mime_type)\n> +#define xdg_mime_mime_type_equal              XDG_ENTRY(mime_type_equal)\n> +#define xdg_mime_media_type_equal             XDG_ENTRY(media_type_equal)\n> +#define xdg_mime_mime_type_subclass           XDG_ENTRY(mime_type_subclass)\n> +#define xdg_mime_get_mime_parents             XDG_ENTRY(get_mime_parents)\n> +#define xdg_mime_list_mime_parents            XDG_ENTRY(list_mime_parents)\n> +#define xdg_mime_unalias_mime_type            XDG_ENTRY(unalias_mime_type)\n> +#define xdg_mime_get_max_buffer_extents       XDG_ENTRY(get_max_buffer_extents)\n> +#define xdg_mime_shutdown                     XDG_ENTRY(shutdown)\n> +#define xdg_mime_register_reload_callback     XDG_ENTRY(register_reload_callback)\n> +#define xdg_mime_remove_callback              XDG_ENTRY(remove_callback)\n> +#define xdg_mime_type_unknown                 XDG_ENTRY(type_unknown)\n> +#endif\n> +\n> +extern const char *xdg_mime_type_unknown;\n> +#define XDG_MIME_TYPE_UNKNOWN xdg_mime_type_unknown\n> +\n> +const char  *xdg_mime_get_mime_type_for_data       (const void *data,\n> +\t\t\t\t\t\t    size_t      len);\n> +const char  *xdg_mime_get_mime_type_for_file       (const char *file_name,\n> +                                                    struct stat *statbuf);\n> +const char  *xdg_mime_get_mime_type_from_file_name (const char *file_name);\n> +int          xdg_mime_is_valid_mime_type           (const char *mime_type);\n> +int          xdg_mime_mime_type_equal              (const char *mime_a,\n> +\t\t\t\t\t\t    const char *mime_b);\n> +int          xdg_mime_media_type_equal             (const char *mime_a,\n> +\t\t\t\t\t\t    const char *mime_b);\n> +int          xdg_mime_mime_type_subclass           (const char *mime_a,\n> +\t\t\t\t\t\t    const char *mime_b);\n> +  /* xdg_mime_get_mime_parents() is deprecated since it does\n> +   * not work correctly with caches. Use xdg_mime_list_parents() \n> +   * instead, but notice that that function expects you to free\n> +   * the array it returns. \n> +   */\n> +const char **xdg_mime_get_mime_parents\t\t   (const char *mime);\n> +char **      xdg_mime_list_mime_parents\t\t   (const char *mime);\n> +const char  *xdg_mime_unalias_mime_type\t\t   (const char *mime);\n> +int          xdg_mime_get_max_buffer_extents       (void);\n> +void         xdg_mime_shutdown                     (void);\n> +void         xdg_mime_dump                         (void);\n> +int          xdg_mime_register_reload_callback     (XdgMimeCallback  callback,\n> +\t\t\t\t\t\t    void            *data,\n> +\t\t\t\t\t\t    XdgMimeDestroy   destroy);\n> +void         xdg_mime_remove_callback              (int              callback_id);\n> +\n> +  /* Private versions of functions that don't call xdg_mime_init () */\n> +int          _xdg_mime_mime_type_equal             (const char *mime_a,\n> +\t\t\t\t\t\t    const char *mime_b);\n> +int          _xdg_mime_mime_type_subclass          (const char *mime,\n> +\t\t\t\t\t\t    const char *base);\n> +\n> +#ifdef __cplusplus\n> +}\n> +#endif /* __cplusplus */\n> +\n> +#endif /* __XDG_MIME_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimealias.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimealias.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimealias.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,184 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimealias.c: Private file.  Datastructure for storing the aliases.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2004  Red Hat, Inc.\n> + * Copyright (C) 2004  Matthias Clasen \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \"xdgmimealias.h\"\n> +#include \"xdgmimeint.h\"\n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE\t(0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE\t(!FALSE)\n> +#endif\n> +\n> +typedef struct XdgAlias XdgAlias;\n> +\n> +struct XdgAlias \n> +{\n> +  char *alias;\n> +  char *mime_type;\n> +};\n> +\n> +struct XdgAliasList\n> +{\n> +  struct XdgAlias *aliases;\n> +  int n_aliases;\n> +};\n> +\n> +XdgAliasList *\n> +_xdg_mime_alias_list_new (void)\n> +{\n> +  XdgAliasList *list;\n> +\n> +  list = malloc (sizeof (XdgAliasList));\n> +\n> +  list->aliases = NULL;\n> +  list->n_aliases = 0;\n> +\n> +  return list;\n> +}\n> +\n> +void         \n> +_xdg_mime_alias_list_free (XdgAliasList *list)\n> +{\n> +  int i;\n> +\n> +  if (list->aliases)\n> +    {\n> +      for (i = 0; i < list->n_aliases; i++)\n> +\t{\n> +\t  free (list->aliases[i].alias);\n> +\t  free (list->aliases[i].mime_type);\n> +\t}\n> +      free (list->aliases);\n> +    }\n> +  free (list);\n> +}\n> +\n> +static int\n> +alias_entry_cmp (const void *v1, const void *v2)\n> +{\n> +  return strcmp (((XdgAlias *)v1)->alias, ((XdgAlias *)v2)->alias);\n> +}\n> +\n> +const char  *\n> +_xdg_mime_alias_list_lookup (XdgAliasList *list,\n> +\t\t\t     const char   *alias)\n> +{\n> +  XdgAlias *entry;\n> +  XdgAlias key;\n> +\n> +  if (list->n_aliases > 0)\n> +    {\n> +      key.alias = (char *)alias;\n> +      key.mime_type = 0;\n> +\n> +      entry = bsearch (&key, list->aliases, list->n_aliases,\n> +\t\t       sizeof (XdgAlias), alias_entry_cmp);\n> +      if (entry)\n> +        return entry->mime_type;\n> +    }\n> +\n> +  return NULL;\n> +}\n> +\n> +void\n> +_xdg_mime_alias_read_from_file (XdgAliasList *list,\n> +\t\t\t\tconst char   *file_name)\n> +{\n> +  FILE *file;\n> +  char line[255];\n> +  int alloc;\n> +\n> +  file = fopen (file_name, \"r\");\n> +\n> +  if (file == NULL)\n> +    return;\n> +\n> +  /* FIXME: Not UTF-8 safe.  Doesn't work if lines are greater than 255 chars.\n> +   * Blah */\n> +  alloc = list->n_aliases + 16;\n> +  list->aliases = realloc (list->aliases, alloc * sizeof (XdgAlias));\n> +  while (fgets (line, 255, file) != NULL)\n> +    {\n> +      char *sep;\n> +      if (line[0] == '#')\n> +\tcontinue;\n> +\n> +      sep = strchr (line, ' ');\n> +      if (sep == NULL)\n> +\tcontinue;\n> +      *(sep++) = '\\000';\n> +      sep[strlen (sep) -1] = '\\000';\n> +      if (list->n_aliases == alloc)\n> +\t{\n> +\t  alloc <<= 1;\n> +\t  list->aliases = realloc (list->aliases, \n> +\t\t\t\t   alloc * sizeof (XdgAlias));\n> +\t}\n> +      list->aliases[list->n_aliases].alias = strdup (line);\n> +      list->aliases[list->n_aliases].mime_type = strdup (sep);\n> +      list->n_aliases++;\n> +    }\n> +  list->aliases = realloc (list->aliases, \n> +\t\t\t   list->n_aliases * sizeof (XdgAlias));\n> +\n> +  fclose (file);  \n> +  \n> +  if (list->n_aliases > 1)\n> +    qsort (list->aliases, list->n_aliases, \n> +           sizeof (XdgAlias), alias_entry_cmp);\n> +}\n> +\n> +\n> +void\n> +_xdg_mime_alias_list_dump (XdgAliasList *list)\n> +{\n> +  int i;\n> +\n> +  if (list->aliases)\n> +    {\n> +      for (i = 0; i < list->n_aliases; i++)\n> +\t{\n> +\t  printf (\"%s %s\\n\", \n> +\t\t  list->aliases[i].alias,\n> +\t\t  list->aliases[i].mime_type);\n> +\t}\n> +    }\n> +}\n> +\n> +\n> \n> Added: liblicense/trunk/xdgmime/xdgmimealias.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimealias.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimealias.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,50 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimealias.h: Private file.  Datastructure for storing the aliases.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2004  Red Hat, Inc.\n> + * Copyright (C) 200  Matthias Clasen \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifndef __XDG_MIME_ALIAS_H__\n> +#define __XDG_MIME_ALIAS_H__\n> +\n> +#include \"xdgmime.h\"\n> +\n> +typedef struct XdgAliasList XdgAliasList;\n> +\n> +#ifdef XDG_PREFIX\n> +#define _xdg_mime_alias_read_from_file        XDG_ENTRY(alias_read_from_file)\n> +#define _xdg_mime_alias_list_new              XDG_ENTRY(alias_list_new)\n> +#define _xdg_mime_alias_list_free             XDG_ENTRY(alias_list_free)\n> +#define _xdg_mime_alias_list_lookup           XDG_ENTRY(alias_list_lookup)\n> +#endif\n> +\n> +void          _xdg_mime_alias_read_from_file (XdgAliasList *list,\n> +\t\t\t\t\t      const char   *file_name);\n> +XdgAliasList *_xdg_mime_alias_list_new       (void);\n> +void          _xdg_mime_alias_list_free      (XdgAliasList *list);\n> +const char   *_xdg_mime_alias_list_lookup    (XdgAliasList *list,\n> +\t\t\t\t\t      const char  *alias);\n> +void          _xdg_mime_alias_list_dump      (XdgAliasList *list);\n> +\n> +#endif /* __XDG_MIME_ALIAS_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimecache.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimecache.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimecache.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,901 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimealias.c: Private file.  mmappable caches for mime data\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2005  Matthias Clasen \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \n> +#include \n> +#include \n> +\n> +#include \n> +#include \n> +#include \n> +#include \n> +\n> +#include  /* for ntohl/ntohs */\n> +\n> +#ifdef HAVE_MMAP\n> +#include \n> +#endif\n> +\n> +#include \n> +#include \n> +\n> +#include \"xdgmimecache.h\"\n> +#include \"xdgmimeint.h\"\n> +\n> +#ifndef MAX\n> +#define MAX(a,b) ((a) > (b) ? (a) : (b))\n> +#endif\n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE\t(0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE\t(!FALSE)\n> +#endif\n> +\n> +#ifndef _O_BINARY\n> +#define _O_BINARY 0\n> +#endif\n> +\n> +#ifndef MAP_FAILED\n> +#define MAP_FAILED ((void *) -1)\n> +#endif\n> +\n> +#define MAJOR_VERSION 1\n> +#define MINOR_VERSION 0\n> +\n> +struct _XdgMimeCache\n> +{\n> +  int ref_count;\n> +\n> +  size_t  size;\n> +  char   *buffer;\n> +};\n> +\n> +#define GET_UINT16(cache,offset) (ntohs(*(xdg_uint16_t*)((cache) + (offset))))\n> +#define GET_UINT32(cache,offset) (ntohl(*(xdg_uint32_t*)((cache) + (offset))))\n> +\n> +XdgMimeCache *\n> +_xdg_mime_cache_ref (XdgMimeCache *cache)\n> +{\n> +  cache->ref_count++;\n> +  return cache;\n> +}\n> +\n> +void\n> +_xdg_mime_cache_unref (XdgMimeCache *cache)\n> +{\n> +  cache->ref_count--;\n> +\n> +  if (cache->ref_count == 0)\n> +    {\n> +#ifdef HAVE_MMAP\n> +      munmap (cache->buffer, cache->size);\n> +#endif\n> +      free (cache);\n> +    }\n> +}\n> +\n> +XdgMimeCache *\n> +_xdg_mime_cache_new_from_file (const char *file_name)\n> +{\n> +  XdgMimeCache *cache = NULL;\n> +\n> +#ifdef HAVE_MMAP\n> +  int fd = -1;\n> +  struct stat st;\n> +  char *buffer = NULL;\n> +\n> +  /* Open the file and map it into memory */\n> +  fd = open (file_name, O_RDONLY|_O_BINARY, 0);\n> +\n> +  if (fd < 0)\n> +    return NULL;\n> +  \n> +  if (fstat (fd, &st) < 0 || st.st_size < 4)\n> +    goto done;\n> +\n> +  buffer = (char *) mmap (NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n> +\n> +  if (buffer == MAP_FAILED)\n> +    goto done;\n> +\n> +  /* Verify version */\n> +  if (GET_UINT16 (buffer, 0) != MAJOR_VERSION ||\n> +      GET_UINT16 (buffer, 2) != MINOR_VERSION)\n> +    {\n> +      munmap (buffer, st.st_size);\n> +\n> +      goto done;\n> +    }\n> +  \n> +  cache = (XdgMimeCache *) malloc (sizeof (XdgMimeCache));\n> +  cache->ref_count = 1;\n> +  cache->buffer = buffer;\n> +  cache->size = st.st_size;\n> +\n> + done:\n> +  if (fd != -1)\n> +    close (fd);\n> +\n> +#endif  /* HAVE_MMAP */\n> +\n> +  return cache;\n> +}\n> +\n> +static int\n> +cache_magic_matchlet_compare_to_data (XdgMimeCache *cache, \n> +\t\t\t\t      xdg_uint32_t  offset,\n> +\t\t\t\t      const void   *data,\n> +\t\t\t\t      size_t        len)\n> +{\n> +  xdg_uint32_t range_start = GET_UINT32 (cache->buffer, offset);\n> +  xdg_uint32_t range_length = GET_UINT32 (cache->buffer, offset + 4);\n> +  xdg_uint32_t data_length = GET_UINT32 (cache->buffer, offset + 12);\n> +  xdg_uint32_t data_offset = GET_UINT32 (cache->buffer, offset + 16);\n> +  xdg_uint32_t mask_offset = GET_UINT32 (cache->buffer, offset + 20);\n> +  \n> +  unsigned int i, j;\n> +\n> +  for (i = range_start; i <= range_start + range_length; i++)\n> +    {\n> +      int valid_matchlet = TRUE;\n> +      \n> +      if (i + data_length > len)\n> +\treturn FALSE;\n> +\n> +      if (mask_offset)\n> +\t{\n> +\t  for (j = 0; j < data_length; j++)\n> +\t    {\n> +\t      if ((((unsigned char *)cache->buffer)[data_offset + j] & ((unsigned char *)cache->buffer)[mask_offset + j]) !=\n> +\t\t  ((((unsigned char *) data)[j + i]) & ((unsigned char *)cache->buffer)[mask_offset + j]))\n> +\t\t{\n> +\t\t  valid_matchlet = FALSE;\n> +\t\t  break;\n> +\t\t}\n> +\t    }\n> +\t}\n> +      else\n> +\t{\n> +\t  for (j = 0; j < data_length; j++)\n> +\t    {\n> +\t      if (((unsigned char *)cache->buffer)[data_offset + j] != ((unsigned char *) data)[j + i])\n> +\t\t{\n> +\t\t  valid_matchlet = FALSE;\n> +\t\t  break;\n> +\t\t}\n> +\t    }\n> +\t}\n> +      \n> +      if (valid_matchlet)\n> +\treturn TRUE;\n> +    }\n> +  \n> +  return FALSE;  \n> +}\n> +\n> +static int\n> +cache_magic_matchlet_compare (XdgMimeCache *cache, \n> +\t\t\t      xdg_uint32_t  offset,\n> +\t\t\t      const void   *data,\n> +\t\t\t      size_t        len)\n> +{\n> +  xdg_uint32_t n_children = GET_UINT32 (cache->buffer, offset + 24);\n> +  xdg_uint32_t child_offset = GET_UINT32 (cache->buffer, offset + 28);\n> +\n> +  unsigned int i;\n> +  \n> +  if (cache_magic_matchlet_compare_to_data (cache, offset, data, len))\n> +    {\n> +      if (n_children == 0)\n> +\treturn TRUE;\n> +      \n> +      for (i = 0; i < n_children; i++)\n> +\t{\n> +\t  if (cache_magic_matchlet_compare (cache, child_offset + 32 * i,\n> +\t\t\t\t\t    data, len))\n> +\t    return TRUE;\n> +\t}\n> +    }\n> +  \n> +  return FALSE;  \n> +}\n> +\n> +static const char *\n> +cache_magic_compare_to_data (XdgMimeCache *cache, \n> +\t\t\t     xdg_uint32_t  offset,\n> +\t\t\t     const void   *data, \n> +\t\t\t     size_t        len, \n> +\t\t\t     int          *prio)\n> +{\n> +  xdg_uint32_t priority = GET_UINT32 (cache->buffer, offset);\n> +  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, offset + 4);\n> +  xdg_uint32_t n_matchlets = GET_UINT32 (cache->buffer, offset + 8);\n> +  xdg_uint32_t matchlet_offset = GET_UINT32 (cache->buffer, offset + 12);\n> +\n> +  unsigned int i;\n> +\n> +  for (i = 0; i < n_matchlets; i++)\n> +    {\n> +      if (cache_magic_matchlet_compare (cache, matchlet_offset + i * 32, \n> +\t\t\t\t\tdata, len))\n> +\t{\n> +\t  *prio = priority;\n> +\t  \n> +\t  return cache->buffer + mimetype_offset;\n> +\t}\n> +    }\n> +\n> +  return NULL;\n> +}\n> +\n> +static const char *\n> +cache_magic_lookup_data (XdgMimeCache *cache, \n> +\t\t\t const void   *data, \n> +\t\t\t size_t        len, \n> +\t\t\t int          *prio,\n> +\t\t\t const char   *mime_types[],\n> +\t\t\t int           n_mime_types)\n> +{\n> +  xdg_uint32_t list_offset;\n> +  xdg_uint32_t n_entries;\n> +  xdg_uint32_t offset;\n> +\n> +  unsigned int j;\n> +  int n;\n> +\n> +  *prio = 0;\n> +\n> +  list_offset = GET_UINT32 (cache->buffer, 24);\n> +  n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +  offset = GET_UINT32 (cache->buffer, list_offset + 8);\n> +  \n> +  for (j = 0; j < n_entries; j++)\n> +    {\n> +      const char *match;\n> +\n> +      match = cache_magic_compare_to_data (cache, offset + 16 * j, \n> +\t\t\t\t\t   data, len, prio);\n> +      if (match)\n> +\treturn match;\n> +      else\n> +\t{\n> +\t  xdg_uint32_t mimetype_offset;\n> +\t  const char *non_match;\n> +\t  \n> +\t  mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * j + 4);\n> +\t  non_match = cache->buffer + mimetype_offset;\n> +\n> +\t  for (n = 0; n < n_mime_types; n++)\n> +\t    {\n> +\t      if (mime_types[n] && \n> +\t\t  xdg_mime_mime_type_equal (mime_types[n], non_match))\n> +\t\tmime_types[n] = NULL;\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  return NULL;\n> +}\n> +\n> +static const char *\n> +cache_alias_lookup (const char *alias)\n> +{\n> +  const char *ptr;\n> +  int i, min, max, mid, cmp;\n> +\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 4);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +      xdg_uint32_t offset;\n> +\n> +      min = 0; \n> +      max = n_entries - 1;\n> +      while (max >= min) \n> +\t{\n> +\t  mid = (min + max) / 2;\n> +\n> +\t  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid);\n> +\t  ptr = cache->buffer + offset;\n> +\t  cmp = strcmp (ptr, alias);\n> +\t  \n> +\t  if (cmp < 0)\n> +\t    min = mid + 1;\n> +\t  else if (cmp > 0)\n> +\t    max = mid - 1;\n> +\t  else\n> +\t    {\n> +\t      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid + 4);\n> +\t      return cache->buffer + offset;\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  return NULL;\n> +}\n> +\n> +static int\n> +cache_glob_lookup_literal (const char *file_name,\n> +\t\t\t   const char *mime_types[],\n> +\t\t\t   int         n_mime_types)\n> +{\n> +  const char *ptr;\n> +  int i, min, max, mid, cmp;\n> +\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 12);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +      xdg_uint32_t offset;\n> +\n> +      min = 0; \n> +      max = n_entries - 1;\n> +      while (max >= min) \n> +\t{\n> +\t  mid = (min + max) / 2;\n> +\n> +\t  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid);\n> +\t  ptr = cache->buffer + offset;\n> +\t  cmp = strcmp (ptr, file_name);\n> +\t  \n> +\t  if (cmp < 0)\n> +\t    min = mid + 1;\n> +\t  else if (cmp > 0)\n> +\t    max = mid - 1;\n> +\t  else\n> +\t    {\n> +\t      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid + 4);\n> +\t      mime_types[0] = (const char *)(cache->buffer + offset);\n> +\t      \n> +\t      return 1;\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +static int\n> +cache_glob_lookup_fnmatch (const char *file_name,\n> +\t\t\t   const char *mime_types[],\n> +\t\t\t   int         n_mime_types)\n> +{\n> +  const char *mime_type;\n> +  const char *ptr;\n> +\n> +  int i, n;\n> +  unsigned int j;\n> +\n> +  n = 0;\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +\n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 20);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +\n> +      for (j = 0; j < n_entries && n < n_mime_types; j++)\n> +\t{\n> +\t  xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * j);\n> +\t  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * j + 4);\n> +\t  ptr = cache->buffer + offset;\n> +\t  mime_type = cache->buffer + mimetype_offset;\n> +\n> +\t  /* FIXME: Not UTF-8 safe */\n> +\t  if (fnmatch (ptr, file_name, 0) == 0)\n> +\t    mime_types[n++] = mime_type;\n> +\t}\n> +\n> +      if (n > 0)\n> +\treturn n;\n> +    }\n> +  \n> +  return 0;\n> +}\n> +\n> +static int\n> +cache_glob_node_lookup_suffix (XdgMimeCache *cache,\n> +\t\t\t       xdg_uint32_t  n_entries,\n> +\t\t\t       xdg_uint32_t  offset,\n> +\t\t\t       const char   *suffix, \n> +\t\t\t       int           ignore_case,\n> +\t\t\t       const char   *mime_types[],\n> +\t\t\t       int           n_mime_types)\n> +{\n> +  xdg_unichar_t character;\n> +  xdg_unichar_t match_char;\n> +  xdg_uint32_t mimetype_offset;\n> +  xdg_uint32_t n_children;\n> +  xdg_uint32_t child_offset; \n> +\n> +  int min, max, mid, n;\n> +  unsigned int i;\n> +\n> +  character = _xdg_utf8_to_ucs4 (suffix);\n> +  if (ignore_case)\n> +    character = _xdg_ucs4_to_lower (character);\n> +\n> +  min = 0;\n> +  max = n_entries - 1;\n> +  while (max >= min)\n> +    {\n> +      mid = (min + max) /  2;\n> +\n> +      match_char = GET_UINT32 (cache->buffer, offset + 16 * mid);\n> +\n> +      if (match_char < character)\n> +\tmin = mid + 1;\n> +      else if (match_char > character)\n> +\tmax = mid - 1;\n> +      else \n> +\t{\n> +\t  suffix = _xdg_utf8_next_char (suffix);\n> +\t  if (*suffix == '\\0')\n> +\t    {\n> +\t      mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 4);\n> +\t      n = 0;\n> +\t      mime_types[n++] = cache->buffer + mimetype_offset;\n> +\t      \n> +\t      n_children = GET_UINT32 (cache->buffer, offset + 16 * mid + 8);\n> +\t      child_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 12);\n> +\t      i = 0;\n> +\t      while (n < n_mime_types && i < n_children)\n> +\t\t{\n> +\t\t  match_char = GET_UINT32 (cache->buffer, child_offset + 16 * i);\n> +\t\t  mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * i + 4);\n> +\t\t  if (match_char != 0)\n> +\t\t    break;\n> +\n> +\t\t  mime_types[n++] = cache->buffer + mimetype_offset;\n> +\t\t  i++;\n> +\t\t}\n> +\n> +\t      return n;\n> +\t    }\n> +\t  else\n> +\t    {\n> +\t      n_children = GET_UINT32 (cache->buffer, offset + 16 * mid + 8);\n> +\t      child_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 12);\n> +      \n> +\t      return cache_glob_node_lookup_suffix (cache, \n> +\t\t\t\t\t\t    n_children, child_offset,\n> +\t\t\t\t\t\t    suffix, ignore_case,\n> +\t\t\t\t\t\t    mime_types,\n> +\t\t\t\t\t\t    n_mime_types);\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +static int\n> +cache_glob_lookup_suffix (const char *suffix, \n> +\t\t\t  int         ignore_case,\n> +\t\t\t  const char *mime_types[],\n> +\t\t\t  int         n_mime_types)\n> +{\n> +  int i, n;\n> +\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +\n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 16);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +      xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4);\n> +\n> +      n = cache_glob_node_lookup_suffix (cache, \n> +\t\t\t\t\t n_entries, offset, \n> +\t\t\t\t\t suffix, ignore_case,\n> +\t\t\t\t\t mime_types,\n> +\t\t\t\t\t n_mime_types);\n> +      if (n > 0)\n> +\treturn n;\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +static void\n> +find_stopchars (char *stopchars)\n> +{\n> +  int i, k, l;\n> +  unsigned int j;\n> +\n> +  k = 0;\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +\n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 16);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +      xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4);\n> +\n> +      for (j = 0; j < n_entries; j++)\n> +\t{\n> +\t  xdg_uint32_t match_char = GET_UINT32 (cache->buffer, offset);\n> +\t  \n> +\t  if (match_char < 128)\n> +\t    {\n> +\t      for (l = 0; l < k; l++)\n> +\t\t{\n> +\t\t  xdg_uint32_t character;\n> +\n> +\t\t  character = stopchars[l];\n> +\n> +\t\t  if (character == match_char)\n> +\t\t    break;\n> +\t\t}\n> +\n> +\t      if (l == k)\n> +\t\t{\n> +\t\t  stopchars[k] = (char) match_char;\n> +\t\t  k++;\n> +\t\t}\n> +\t    }\n> +\n> +\t  offset += 16;\n> +\t}\n> +    }\n> +\n> +  stopchars[k] = '\\0';\n> +}\n> +\n> +static int\n> +cache_glob_lookup_file_name (const char *file_name, \n> +\t\t\t     const char *mime_types[],\n> +\t\t\t     int         n_mime_types)\n> +{\n> +  const char *ptr;\n> +  char stopchars[128];\n> +  int n;\n> +  \n> +  assert (file_name != NULL);\n> +\n> +  /* First, check the literals */\n> +  n = cache_glob_lookup_literal (file_name, mime_types, n_mime_types);\n> +  if (n > 0)\n> +    return n;\n> +\n> +  find_stopchars (stopchars);\n> +\n> +  /* Next, check suffixes */\n> +  ptr = strpbrk (file_name, stopchars);\n> +  while (ptr)\n> +    {\n> +      n = cache_glob_lookup_suffix (ptr, FALSE, mime_types, n_mime_types);\n> +      if (n > 0)\n> +\treturn n;\n> +      \n> +      n = cache_glob_lookup_suffix (ptr, TRUE, mime_types, n_mime_types);\n> +      if (n > 0)\n> +\treturn n;\n> +\n> +      ptr = strpbrk (ptr + 1, stopchars);\n> +    }\n> +  \n> +  /* Last, try fnmatch */\n> +  return cache_glob_lookup_fnmatch (file_name, mime_types, n_mime_types);\n> +}\n> +\n> +int\n> +_xdg_mime_cache_get_max_buffer_extents (void)\n> +{\n> +  xdg_uint32_t offset;\n> +  xdg_uint32_t max_extent;\n> +  int i;\n> +\n> +  max_extent = 0;\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +\n> +      offset = GET_UINT32 (cache->buffer, 24);\n> +      max_extent = MAX (max_extent, GET_UINT32 (cache->buffer, offset + 4));\n> +    }\n> +\n> +  return max_extent;\n> +}\n> +\n> +static const char *\n> +cache_get_mime_type_for_data (const void *data,\n> +\t\t\t      size_t      len,\n> +\t\t\t      const char *mime_types[],\n> +\t\t\t      int         n_mime_types)\n> +{\n> +  const char *mime_type;\n> +  int i, n, priority;\n> +\n> +  priority = 0;\n> +  mime_type = NULL;\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +\n> +      int prio;\n> +      const char *match;\n> +\n> +      match = cache_magic_lookup_data (cache, data, len, &prio, \n> +\t\t\t\t       mime_types, n_mime_types);\n> +      if (prio > priority)\n> +\t{\n> +\t  priority = prio;\n> +\t  mime_type = match;\n> +\t}\n> +    }\n> +\n> +  if (priority > 0)\n> +    return mime_type;\n> +\n> +  for (n = 0; n < n_mime_types; n++)\n> +    {\n> +      if (mime_types[n])\n> +\treturn mime_types[n];\n> +    }\n> +\n> +  return XDG_MIME_TYPE_UNKNOWN;\n> +}\n> +\n> +const char *\n> +_xdg_mime_cache_get_mime_type_for_data (const void *data,\n> +\t\t\t\t\tsize_t      len)\n> +{\n> +  return cache_get_mime_type_for_data (data, len, NULL, 0);\n> +}\n> +\n> +const char *\n> +_xdg_mime_cache_get_mime_type_for_file (const char  *file_name,\n> +\t\t\t\t\tstruct stat *statbuf)\n> +{\n> +  const char *mime_type;\n> +  const char *mime_types[2];\n> +  FILE *file;\n> +  unsigned char *data;\n> +  int max_extent;\n> +  int bytes_read;\n> +  struct stat buf;\n> +  const char *base_name;\n> +  int n;\n> +\n> +  if (file_name == NULL)\n> +    return NULL;\n> +\n> +  if (! _xdg_utf8_validate (file_name))\n> +    return NULL;\n> +\n> +  base_name = _xdg_get_base_name (file_name);\n> +  n = cache_glob_lookup_file_name (base_name, mime_types, 2);\n> +\n> +  if (n == 1)\n> +    return mime_types[0];\n> +\n> +  if (!statbuf)\n> +    {\n> +      if (stat (file_name, &buf) != 0)\n> +\treturn XDG_MIME_TYPE_UNKNOWN;\n> +\n> +      statbuf = &buf\n> +    }\n> +\n> +  if (!S_ISREG (statbuf->st_mode))\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +\n> +  /* FIXME: Need to make sure that max_extent isn't totally broken.  This could\n> +   * be large and need getting from a stream instead of just reading it all\n> +   * in. */\n> +  max_extent = _xdg_mime_cache_get_max_buffer_extents ();\n> +  data = malloc (max_extent);\n> +  if (data == NULL)\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +        \n> +  file = fopen (file_name, \"r\");\n> +  if (file == NULL)\n> +    {\n> +      free (data);\n> +      return XDG_MIME_TYPE_UNKNOWN;\n> +    }\n> +\n> +  bytes_read = fread (data, 1, max_extent, file);\n> +  if (ferror (file))\n> +    {\n> +      free (data);\n> +      fclose (file);\n> +      return XDG_MIME_TYPE_UNKNOWN;\n> +    }\n> +\n> +  mime_type = cache_get_mime_type_for_data (data, bytes_read,\n> +\t\t\t\t\t    mime_types, n);\n> +\n> +  free (data);\n> +  fclose (file);\n> +\n> +  return mime_type;\n> +}\n> +\n> +const char *\n> +_xdg_mime_cache_get_mime_type_from_file_name (const char *file_name)\n> +{\n> +  const char *mime_types[2];\n> +\n> +  if (cache_glob_lookup_file_name (file_name, mime_types, 2) == 1)\n> +    return mime_types[0];\n> +  else\n> +    return XDG_MIME_TYPE_UNKNOWN;\n> +}\n> +\n> +#if 1\n> +static int\n> +is_super_type (const char *mime)\n> +{\n> +  int length;\n> +  const char *type;\n> +\n> +  length = strlen (mime);\n> +  type = &(mime[length - 2]);\n> +\n> +  if (strcmp (type, \"/*\") == 0)\n> +    return 1;\n> +\n> +  return 0;\n> +}\n> +#endif\n> +\n> +int\n> +_xdg_mime_cache_mime_type_subclass (const char *mime,\n> +\t\t\t\t    const char *base)\n> +{\n> +  const char *umime, *ubase;\n> +\n> +  int i, min, max, med, cmp;\n> +  unsigned int j;\n> +\n> +  umime = _xdg_mime_cache_unalias_mime_type (mime);\n> +  ubase = _xdg_mime_cache_unalias_mime_type (base);\n> +\n> +  if (strcmp (umime, ubase) == 0)\n> +    return 1;\n> +\n> +  /* We really want to handle text/ * in GtkFileFilter, so we just\n> +   * turn on the supertype matching\n> +   */\n> +#if 1\n> +  /* Handle supertypes */\n> +  if (is_super_type (ubase) &&\n> +      xdg_mime_media_type_equal (umime, ubase))\n> +    return 1;\n> +#endif\n> +\n> +  /*  Handle special cases text/plain and application/octet-stream */\n> +  if (strcmp (ubase, \"text/plain\") == 0 && \n> +      strncmp (umime, \"text/\", 5) == 0)\n> +    return 1;\n> +\n> +  if (strcmp (ubase, \"application/octet-stream\") == 0)\n> +    return 1;\n> + \n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +      \n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 8);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +      xdg_uint32_t offset, n_parents, parent_offset;\n> +\n> +      min = 0; \n> +      max = n_entries - 1;\n> +      while (max >= min)\n> +\t{\n> +\t  med = (min + max)/2;\n> +\t  \n> +\t  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * med);\n> +\t  cmp = strcmp (cache->buffer + offset, umime);\n> +\t  if (cmp < 0)\n> +\t    min = med + 1;\n> +\t  else if (cmp > 0)\n> +\t    max = med - 1;\n> +\t  else\n> +\t    {\n> +\t      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * med + 4);\n> +\t      n_parents = GET_UINT32 (cache->buffer, offset);\n> +\t      \n> +\t      for (j = 0; j < n_parents; j++)\n> +\t\t{\n> +\t\t  parent_offset = GET_UINT32 (cache->buffer, offset + 4 + 4 * j);\n> +\t\t  if (_xdg_mime_cache_mime_type_subclass (cache->buffer + parent_offset, ubase))\n> +\t\t    return 1;\n> +\t\t}\n> +\n> +\t      break;\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +const char *\n> +_xdg_mime_cache_unalias_mime_type (const char *mime)\n> +{\n> +  const char *lookup;\n> +  \n> +  lookup = cache_alias_lookup (mime);\n> +  \n> +  if (lookup)\n> +    return lookup;\n> +  \n> +  return mime;  \n> +}\n> +\n> +char **\n> +_xdg_mime_cache_list_mime_parents (const char *mime)\n> +{\n> +  int i, p;\n> +  unsigned int j;\n> +  char *all_parents[128]; /* we'll stop at 128 */ \n> +  char **result;\n> +\n> +  p = 0;\n> +  for (i = 0; _caches[i]; i++)\n> +    {\n> +      XdgMimeCache *cache = _caches[i];\n> +  \n> +      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 8);\n> +      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);\n> +\n> +      for (j = 0; j < n_entries; j++)\n> +\t{\n> +\t  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * i);\n> +\t  xdg_uint32_t parents_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * i + 4);\n> +\t  \n> +\t  if (strcmp (cache->buffer + mimetype_offset, mime) == 0)\n> +\t    {\n> +\t      xdg_uint32_t n_parents = GET_UINT32 (cache->buffer, parents_offset);\n> +\t      \n> +\t      for (j = 0; j < n_parents; j++)\n> +\t\tall_parents[p++] = cache->buffer + parents_offset + 4 + 4 * j;\n> +\n> +\t      break;\n> +\t    }\n> +\t}\n> +    }\n> +  all_parents[p++] = 0;\n> +  \n> +  result = (char **) malloc (p * sizeof (char *));\n> +  memcpy (result, all_parents, p * sizeof (char *));\n> +\n> +  return result;\n> +}\n> +\n> \n> Added: liblicense/trunk/xdgmime/xdgmimecache.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimecache.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimecache.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,63 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimecache.h: Private file.  Datastructure for mmapped caches.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2005  Matthias Clasen \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifndef __XDG_MIME_CACHE_H__\n> +#define __XDG_MIME_CACHE_H__\n> +\n> +#include \"xdgmime.h\"\n> +\n> +typedef struct _XdgMimeCache XdgMimeCache;\n> +\n> +#ifdef XDG_PREFIX\n> +#define _xdg_mime_cache_new_from_file        XDG_ENTRY(cache_new_from_file)\n> +#define _xdg_mime_cache_ref                  XDG_ENTRY(cache_ref)\n> +#define _xdg_mime_cache_unref                XDG_ENTRY(cache_unref)\n> +#endif\n> +\n> +extern XdgMimeCache **_caches;\n> +\n> +XdgMimeCache *_xdg_mime_cache_new_from_file (const char   *file_name);\n> +XdgMimeCache *_xdg_mime_cache_ref           (XdgMimeCache *cache);\n> +void          _xdg_mime_cache_unref         (XdgMimeCache *cache);\n> +\n> +\n> +const char  *_xdg_mime_cache_get_mime_type_for_data       (const void *data,\n> +\t\t \t\t\t\t           size_t      len);\n> +const char  *_xdg_mime_cache_get_mime_type_for_file       (const char  *file_name,\n> +\t\t\t\t\t\t\t   struct stat *statbuf);\n> +const char  *_xdg_mime_cache_get_mime_type_from_file_name (const char *file_name);\n> +int          _xdg_mime_cache_is_valid_mime_type           (const char *mime_type);\n> +int          _xdg_mime_cache_mime_type_equal              (const char *mime_a,\n> +\t\t\t\t\t\t           const char *mime_b);\n> +int          _xdg_mime_cache_media_type_equal             (const char *mime_a,\n> +\t\t\t\t\t\t\t   const char *mime_b);\n> +int          _xdg_mime_cache_mime_type_subclass           (const char *mime_a,\n> +\t\t\t\t\t\t\t   const char *mime_b);\n> +char       **_xdg_mime_cache_list_mime_parents\t\t  (const char *mime);\n> +const char  *_xdg_mime_cache_unalias_mime_type            (const char *mime);\n> +int          _xdg_mime_cache_get_max_buffer_extents       (void);\n> +\n> +#endif /* __XDG_MIME_CACHE_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimeglob.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimeglob.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimeglob.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,547 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimeglob.c: Private file.  Datastructure for storing the globs.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \"xdgmimeglob.h\"\n> +#include \"xdgmimeint.h\"\n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE\t(0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE\t(!FALSE)\n> +#endif\n> +\n> +typedef struct XdgGlobHashNode XdgGlobHashNode;\n> +typedef struct XdgGlobList XdgGlobList;\n> +\n> +struct XdgGlobHashNode\n> +{\n> +  xdg_unichar_t character;\n> +  const char *mime_type;\n> +  XdgGlobHashNode *next;\n> +  XdgGlobHashNode *child;\n> +};\n> +struct XdgGlobList\n> +{\n> +  const char *data;\n> +  const char *mime_type;\n> +  XdgGlobList *next;\n> +};\n> +\n> +struct XdgGlobHash\n> +{\n> +  XdgGlobList *literal_list;\n> +  XdgGlobHashNode *simple_node;\n> +  XdgGlobList *full_list;\n> +};\n> +\n> +\n> +/* XdgGlobList\n> + */\n> +static XdgGlobList *\n> +_xdg_glob_list_new (void)\n> +{\n> +  XdgGlobList *new_element;\n> +\n> +  new_element = calloc (1, sizeof (XdgGlobList));\n> +\n> +  return new_element;\n> +}\n> +\n> +/* Frees glob_list and all of it's children */\n> +static void\n> +_xdg_glob_list_free (XdgGlobList *glob_list)\n> +{\n> +  XdgGlobList *ptr, *next;\n> +\n> +  ptr = glob_list;\n> +\n> +  while (ptr != NULL)\n> +    {\n> +      next = ptr->next;\n> +\n> +      if (ptr->data)\n> +\tfree ((void *) ptr->data);\n> +      if (ptr->mime_type)\n> +\tfree ((void *) ptr->mime_type);\n> +      free (ptr);\n> +\n> +      ptr = next;\n> +    }\n> +}\n> +\n> +static XdgGlobList *\n> +_xdg_glob_list_append (XdgGlobList *glob_list,\n> +\t\t       void        *data,\n> +\t\t       const char  *mime_type)\n> +{\n> +  XdgGlobList *new_element;\n> +  XdgGlobList *tmp_element;\n> +\n> +  new_element = _xdg_glob_list_new ();\n> +  new_element->data = data;\n> +  new_element->mime_type = mime_type;\n> +  if (glob_list == NULL)\n> +    return new_element;\n> +\n> +  tmp_element = glob_list;\n> +  while (tmp_element->next != NULL)\n> +    tmp_element = tmp_element->next;\n> +\n> +  tmp_element->next = new_element;\n> +\n> +  return glob_list;\n> +}\n> +\n> +#if 0\n> +static XdgGlobList *\n> +_xdg_glob_list_prepend (XdgGlobList *glob_list,\n> +\t\t\tvoid        *data,\n> +\t\t\tconst char  *mime_type)\n> +{\n> +  XdgGlobList *new_element;\n> +\n> +  new_element = _xdg_glob_list_new ();\n> +  new_element->data = data;\n> +  new_element->next = glob_list;\n> +  new_element->mime_type = mime_type;\n> +\n> +  return new_element;\n> +}\n> +#endif\n> +\n> +/* XdgGlobHashNode\n> + */\n> +\n> +static XdgGlobHashNode *\n> +_xdg_glob_hash_node_new (void)\n> +{\n> +  XdgGlobHashNode *glob_hash_node;\n> +\n> +  glob_hash_node = calloc (1, sizeof (XdgGlobHashNode));\n> +\n> +  return glob_hash_node;\n> +}\n> +\n> +static void\n> +_xdg_glob_hash_node_dump (XdgGlobHashNode *glob_hash_node,\n> +\t\t\t  int depth)\n> +{\n> +  int i;\n> +  for (i = 0; i < depth; i++)\n> +    printf (\" \");\n> +\n> +  printf (\"%c\", (char)glob_hash_node->character);\n> +  if (glob_hash_node->mime_type)\n> +    printf (\" - %s\\n\", glob_hash_node->mime_type);\n> +  else\n> +    printf (\"\\n\");\n> +  if (glob_hash_node->child)\n> +    _xdg_glob_hash_node_dump (glob_hash_node->child, depth + 1);\n> +  if (glob_hash_node->next)\n> +    _xdg_glob_hash_node_dump (glob_hash_node->next, depth);\n> +}\n> +\n> +static XdgGlobHashNode *\n> +_xdg_glob_hash_insert_text (XdgGlobHashNode *glob_hash_node,\n> +\t\t\t    const char      *text,\n> +\t\t\t    const char      *mime_type)\n> +{\n> +  XdgGlobHashNode *node;\n> +  xdg_unichar_t character;\n> +\n> +  character = _xdg_utf8_to_ucs4 (text);\n> +\n> +  if ((glob_hash_node == NULL) ||\n> +      (character < glob_hash_node->character))\n> +    {\n> +      node = _xdg_glob_hash_node_new ();\n> +      node->character = character;\n> +      node->next = glob_hash_node;\n> +      glob_hash_node = node;\n> +    }\n> +  else if (character == glob_hash_node->character)\n> +    {\n> +      node = glob_hash_node;\n> +    }\n> +  else\n> +    {\n> +      XdgGlobHashNode *prev_node;\n> +      int found_node = FALSE;\n> +\n> +      /* Look for the first character of text in glob_hash_node, and insert it if we\n> +       * have to.*/\n> +      prev_node = glob_hash_node;\n> +      node = prev_node->next;\n> +\n> +      while (node != NULL)\n> +\t{\n> +\t  if (character < node->character)\n> +\t    {\n> +\t      node = _xdg_glob_hash_node_new ();\n> +\t      node->character = character;\n> +\t      node->next = prev_node->next;\n> +\t      prev_node->next = node;\n> +\n> +\t      found_node = TRUE;\n> +\t      break;\n> +\t    }\n> +\t  else if (character == node->character)\n> +\t    {\n> +\t      found_node = TRUE;\n> +\t      break;\n> +\t    }\n> +\t  prev_node = node;\n> +\t  node = node->next;\n> +\t}\n> +\n> +      if (! found_node)\n> +\t{\n> +\t  node = _xdg_glob_hash_node_new ();\n> +\t  node->character = character;\n> +\t  node->next = prev_node->next;\n> +\t  prev_node->next = node;\n> +\t}\n> +    }\n> +\n> +  text = _xdg_utf8_next_char (text);\n> +  if (*text == '\\000')\n> +    {\n> +      if (node->mime_type)\n> +\t{\n> +\t  if (strcmp (node->mime_type, mime_type))\n> +\t    {\n> +\t      XdgGlobHashNode *child;\n> +\t      int found_node = FALSE;\n> +\t      \n> +\t      child = node->child;\n> +\t      while (child && child->character == '\\0')\n> +\t\t{\n> +\t\t  if (strcmp (child->mime_type, mime_type) == 0)\n> +\t\t    {\n> +\t\t      found_node = TRUE;\n> +\t\t      break;\n> +\t\t    }\n> +\t\t  child = child->next;\n> +\t\t}\n> +\n> +\t      if (!found_node)\n> +\t\t{\n> +\t\t  child = _xdg_glob_hash_node_new ();\n> +\t\t  child->character = '\\000';\n> +\t\t  child->mime_type = strdup (mime_type);\n> +\t\t  child->child = NULL;\n> +\t\t  child->next = node->child;\n> +\t\t  node->child = child;\n> +\t\t}\n> +\t    }\n> +\t}\n> +      else\n> +\t{\n> +\t  node->mime_type = strdup (mime_type);\n> +\t}\n> +    }\n> +  else\n> +    {\n> +      node->child = _xdg_glob_hash_insert_text (node->child, text, mime_type);\n> +    }\n> +  return glob_hash_node;\n> +}\n> +\n> +static int\n> +_xdg_glob_hash_node_lookup_file_name (XdgGlobHashNode *glob_hash_node,\n> +\t\t\t\t      const char      *file_name,\n> +\t\t\t\t      int              ignore_case,\n> +\t\t\t\t      const char      *mime_types[],\n> +\t\t\t\t      int              n_mime_types)\n> +{\n> +  int n;\n> +  XdgGlobHashNode *node;\n> +  xdg_unichar_t character;\n> +\n> +  if (glob_hash_node == NULL)\n> +    return 0;\n> +\n> +  character = _xdg_utf8_to_ucs4 (file_name);\n> +  if (ignore_case)\n> +    character = _xdg_ucs4_to_lower(character);\n> +\n> +  for (node = glob_hash_node; node && character >= node->character; node = node->next)\n> +    {\n> +      if (character == node->character)\n> +\t{\n> +\t  file_name = _xdg_utf8_next_char (file_name);\n> +\t  if (*file_name == '\\000')\n> +\t    {\n> +\t      n = 0;\n> +\t      if (node->mime_type)\n> +\t        mime_types[n++] = node->mime_type;\n> +\t      node = node->child;\n> +\t      while (n < n_mime_types && node && node->character == 0)\n> +\t\t{\n> +\t\t  if (node->mime_type)\n> +\t\t    mime_types[n++] = node->mime_type;\n> +\t\t  node = node->next;\n> +\t\t}\n> +\t    }\n> +\t  else\n> +\t    {\n> +\t      n = _xdg_glob_hash_node_lookup_file_name (node->child,\n> +\t\t\t\t\t\t\tfile_name,\n> +\t\t\t\t\t\t\tignore_case,\n> +\t\t\t\t\t\t\tmime_types,\n> +\t\t\t\t\t\t\tn_mime_types);\n> +\t    }\n> +\t  return n;\n> +\t}\n> +    }\n> +\n> +  return 0;\n> +}\n> +\n> +int\n> +_xdg_glob_hash_lookup_file_name (XdgGlobHash *glob_hash,\n> +\t\t\t\t const char  *file_name,\n> +\t\t\t\t const char  *mime_types[],\n> +\t\t\t\t int          n_mime_types)\n> +{\n> +  XdgGlobList *list;\n> +  const char *ptr;\n> +  char stopchars[128];\n> +  int i, n;\n> +  XdgGlobHashNode *node;\n> +\n> +  /* First, check the literals */\n> +\n> +  assert (file_name != NULL && n_mime_types > 0);\n> +\n> +  for (list = glob_hash->literal_list; list; list = list->next)\n> +    {\n> +      if (strcmp ((const char *)list->data, file_name) == 0)\n> +\t{\n> +\t  mime_types[0] = list->mime_type;\n> +\t  return 1;\n> +\t}\n> +    }\n> +\n> +  i = 0;\n> +  for (node = glob_hash->simple_node; node; node = node->next)\n> +    {\n> +      if (node->character < 128)\n> + \tstopchars[i++] = (char)node->character;\n> +    }\n> +  stopchars[i] = '\\0';\n> + \n> +  ptr = strpbrk (file_name, stopchars);\n> +  while (ptr)\n> +    {\n> +      n = _xdg_glob_hash_node_lookup_file_name (glob_hash->simple_node, ptr, FALSE,\n> +\t\t\t\t\t\tmime_types, n_mime_types);\n> +      if (n > 0)\n> +\treturn n;\n> +      \n> +      n = _xdg_glob_hash_node_lookup_file_name (glob_hash->simple_node, ptr, TRUE,\n> +\t\t\t\t\t\tmime_types, n_mime_types);\n> +      if (n > 0)\n> +\treturn n;\n> +      \n> +      ptr = strpbrk (ptr + 1, stopchars);\n> +    }\n> +\n> +  /* FIXME: Not UTF-8 safe */\n> +  n = 0;\n> +  for (list = glob_hash->full_list; list && n < n_mime_types; list = list->next)\n> +    {\n> +      if (fnmatch ((const char *)list->data, file_name, 0) == 0)\n> +\tmime_types[n++] = list->mime_type;\n> +    }\n> +\n> +  return n;\n> +}\n> +\n> +\n> +\n> +/* XdgGlobHash\n> + */\n> +\n> +XdgGlobHash *\n> +_xdg_glob_hash_new (void)\n> +{\n> +  XdgGlobHash *glob_hash;\n> +\n> +  glob_hash = calloc (1, sizeof (XdgGlobHash));\n> +\n> +  return glob_hash;\n> +}\n> +\n> +\n> +static void\n> +_xdg_glob_hash_free_nodes (XdgGlobHashNode *node)\n> +{\n> +  if (node)\n> +    {\n> +      if (node->child)\n> +       _xdg_glob_hash_free_nodes (node->child);\n> +      if (node->next)\n> +       _xdg_glob_hash_free_nodes (node->next);\n> +      if (node->mime_type)\n> +\tfree ((void *) node->mime_type);\n> +      free (node);\n> +    }\n> +}\n> +\n> +void\n> +_xdg_glob_hash_free (XdgGlobHash *glob_hash)\n> +{\n> +  _xdg_glob_list_free (glob_hash->literal_list);\n> +  _xdg_glob_list_free (glob_hash->full_list);\n> +  _xdg_glob_hash_free_nodes (glob_hash->simple_node);\n> +  free (glob_hash);\n> +}\n> +\n> +XdgGlobType\n> +_xdg_glob_determine_type (const char *glob)\n> +{\n> +  const char *ptr;\n> +  int maybe_in_simple_glob = FALSE;\n> +  int first_char = TRUE;\n> +\n> +  ptr = glob;\n> +\n> +  while (*ptr != '\\000')\n> +    {\n> +      if (*ptr == '*' && first_char)\n> +\tmaybe_in_simple_glob = TRUE;\n> +      else if (*ptr == '\\\\' || *ptr == '[' || *ptr == '?' || *ptr == '*')\n> +\t  return XDG_GLOB_FULL;\n> +\n> +      first_char = FALSE;\n> +      ptr = _xdg_utf8_next_char (ptr);\n> +    }\n> +  if (maybe_in_simple_glob)\n> +    return XDG_GLOB_SIMPLE;\n> +  else\n> +    return XDG_GLOB_LITERAL;\n> +}\n> +\n> +/* glob must be valid UTF-8 */\n> +void\n> +_xdg_glob_hash_append_glob (XdgGlobHash *glob_hash,\n> +\t\t\t    const char  *glob,\n> +\t\t\t    const char  *mime_type)\n> +{\n> +  XdgGlobType type;\n> +\n> +  assert (glob_hash != NULL);\n> +  assert (glob != NULL);\n> +\n> +  type = _xdg_glob_determine_type (glob);\n> +\n> +  switch (type)\n> +    {\n> +    case XDG_GLOB_LITERAL:\n> +      glob_hash->literal_list = _xdg_glob_list_append (glob_hash->literal_list, strdup (glob), strdup (mime_type));\n> +      break;\n> +    case XDG_GLOB_SIMPLE:\n> +      glob_hash->simple_node = _xdg_glob_hash_insert_text (glob_hash->simple_node, glob + 1, mime_type);\n> +      break;\n> +    case XDG_GLOB_FULL:\n> +      glob_hash->full_list = _xdg_glob_list_append (glob_hash->full_list, strdup (glob), strdup (mime_type));\n> +      break;\n> +    }\n> +}\n> +\n> +void\n> +_xdg_glob_hash_dump (XdgGlobHash *glob_hash)\n> +{\n> +  XdgGlobList *list;\n> +  printf (\"LITERAL STRINGS\\n\");\n> +  if (glob_hash->literal_list == NULL)\n> +    {\n> +      printf (\"    None\\n\");\n> +    }\n> +  else\n> +    {\n> +      for (list = glob_hash->literal_list; list; list = list->next)\n> +\tprintf (\"    %s - %s\\n\", (char *)list->data, list->mime_type);\n> +    }\n> +  printf (\"\\nSIMPLE GLOBS\\n\");\n> +  _xdg_glob_hash_node_dump (glob_hash->simple_node, 4);\n> +\n> +  printf (\"\\nFULL GLOBS\\n\");\n> +  if (glob_hash->full_list == NULL)\n> +    {\n> +      printf (\"    None\\n\");\n> +    }\n> +  else\n> +    {\n> +      for (list = glob_hash->full_list; list; list = list->next)\n> +\tprintf (\"    %s - %s\\n\", (char *)list->data, list->mime_type);\n> +    }\n> +}\n> +\n> +\n> +void\n> +_xdg_mime_glob_read_from_file (XdgGlobHash *glob_hash,\n> +\t\t\t       const char  *file_name)\n> +{\n> +  FILE *glob_file;\n> +  char line[255];\n> +\n> +  glob_file = fopen (file_name, \"r\");\n> +\n> +  if (glob_file == NULL)\n> +    return;\n> +\n> +  /* FIXME: Not UTF-8 safe.  Doesn't work if lines are greater than 255 chars.\n> +   * Blah */\n> +  while (fgets (line, 255, glob_file) != NULL)\n> +    {\n> +      char *colon;\n> +      if (line[0] == '#')\n> +\tcontinue;\n> +\n> +      colon = strchr (line, ':');\n> +      if (colon == NULL)\n> +\tcontinue;\n> +      *(colon++) = '\\000';\n> +      colon[strlen (colon) -1] = '\\000';\n> +      _xdg_glob_hash_append_glob (glob_hash, colon, line);\n> +    }\n> +\n> +  fclose (glob_file);\n> +}\n> \n> Added: liblicense/trunk/xdgmime/xdgmimeglob.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimeglob.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimeglob.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,67 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimeglob.h: Private file.  Datastructure for storing the globs.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifndef __XDG_MIME_GLOB_H__\n> +#define __XDG_MIME_GLOB_H__\n> +\n> +#include \"xdgmime.h\"\n> +\n> +typedef struct XdgGlobHash XdgGlobHash;\n> +\n> +typedef enum\n> +{\n> +  XDG_GLOB_LITERAL, /* Makefile */\n> +  XDG_GLOB_SIMPLE,  /* *.gif */\n> +  XDG_GLOB_FULL     /* x*.[ch] */\n> +} XdgGlobType;\n> +\n> +  \n> +#ifdef XDG_PREFIX\n> +#define _xdg_mime_glob_read_from_file         XDG_ENTRY(glob_read_from_file)\n> +#define _xdg_glob_hash_new                    XDG_ENTRY(hash_new)\n> +#define _xdg_glob_hash_free                   XDG_ENTRY(hash_free)\n> +#define _xdg_glob_hash_lookup_file_name       XDG_ENTRY(hash_lookup_file_name)\n> +#define _xdg_glob_hash_append_glob            XDG_ENTRY(hash_append_glob)\n> +#define _xdg_glob_determine_type              XDG_ENTRY(determine_type)\n> +#define _xdg_glob_hash_dump                   XDG_ENTRY(hash_dump)\n> +#endif\n> +\n> +void         _xdg_mime_glob_read_from_file   (XdgGlobHash *glob_hash,\n> +\t\t\t\t\t      const char  *file_name);\n> +XdgGlobHash *_xdg_glob_hash_new              (void);\n> +void         _xdg_glob_hash_free             (XdgGlobHash *glob_hash);\n> +int          _xdg_glob_hash_lookup_file_name (XdgGlobHash *glob_hash,\n> +\t\t\t\t\t      const char  *text,\n> +\t\t\t\t\t      const char  *mime_types[],\n> +\t\t\t\t\t      int          n_mime_types);\n> +void         _xdg_glob_hash_append_glob      (XdgGlobHash *glob_hash,\n> +\t\t\t\t\t      const char  *glob,\n> +\t\t\t\t\t      const char  *mime_type);\n> +XdgGlobType  _xdg_glob_determine_type        (const char  *glob);\n> +void         _xdg_glob_hash_dump             (XdgGlobHash *glob_hash);\n> +\n> +#endif /* __XDG_MIME_GLOB_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimeint.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimeint.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimeint.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,154 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimeint.c: Internal defines and functions.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \"xdgmimeint.h\"\n> +#include \n> +#include \n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE\t(0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE\t(!FALSE)\n> +#endif\n> +\n> +static const char _xdg_utf8_skip_data[256] = {\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n> +  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n> +  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1\n> +};\n> +\n> +const char * const _xdg_utf8_skip = _xdg_utf8_skip_data;\n> +\n> +\n> +\n> +/* Returns the number of unprocessed characters. */\n> +xdg_unichar_t\n> +_xdg_utf8_to_ucs4(const char *source)\n> +{\n> +  xdg_unichar_t ucs32;\n> +  if( ! ( *source & 0x80 ) )\n> +    {\n> +      ucs32 = *source;\n> +    }\n> +  else\n> +    {\n> +      int bytelength = 0;\n> +      xdg_unichar_t result;\n> +      if ( ! (*source & 0x40) )\n> +\t{\n> +\t  ucs32 = *source;\n> +\t}\n> +      else\n> +\t{\n> +\t  if ( ! (*source & 0x20) )\n> +\t    {\n> +\t      result = *source++ & 0x1F;\n> +\t      bytelength = 2;\n> +\t    }\n> +\t  else if ( ! (*source & 0x10) )\n> +\t    {\n> +\t      result = *source++ & 0x0F;\n> +\t      bytelength = 3;\n> +\t    }\n> +\t  else if ( ! (*source & 0x08) )\n> +\t    {\n> +\t      result = *source++ & 0x07;\n> +\t      bytelength = 4;\n> +\t    }\n> +\t  else if ( ! (*source & 0x04) )\n> +\t    {\n> +\t      result = *source++ & 0x03;\n> +\t      bytelength = 5;\n> +\t    }\n> +\t  else if ( ! (*source & 0x02) )\n> +\t    {\n> +\t      result = *source++ & 0x01;\n> +\t      bytelength = 6;\n> +\t    }\n> +\t  else\n> +\t    {\n> +\t      result = *source++;\n> +\t      bytelength = 1;\n> +\t    }\n> +\n> +\t  for ( bytelength --; bytelength > 0; bytelength -- )\n> +\t    {\n> +\t      result <<= 6;\n> +\t      result |= *source++ & 0x3F;\n> +\t    }\n> +\t  ucs32 = result;\n> +\t}\n> +    }\n> +  return ucs32;\n> +}\n> +\n> +\n> +/* hullo.  this is great code.  don't rewrite it */\n> +\n> +xdg_unichar_t\n> +_xdg_ucs4_to_lower (xdg_unichar_t source)\n> +{\n> +  /* FIXME: Do a real to_upper sometime */\n> +  /* CaseFolding-3.2.0.txt has a table of rules. */\n> +  if ((source & 0xFF) == source)\n> +    return (xdg_unichar_t) tolower ((unsigned char) source);\n> +  return source;\n> +}\n> +\n> +int\n> +_xdg_utf8_validate (const char *source)\n> +{\n> +  /* FIXME: actually write */\n> +  return TRUE;\n> +}\n> +\n> +const char *\n> +_xdg_get_base_name (const char *file_name)\n> +{\n> +  const char *base_name;\n> +\n> +  if (file_name == NULL)\n> +    return NULL;\n> +\n> +  base_name = strrchr (file_name, '/');\n> +\n> +  if (base_name == NULL)\n> +    return file_name;\n> +  else\n> +    return base_name + 1;\n> +}\n> \n> Added: liblicense/trunk/xdgmime/xdgmimeint.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimeint.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimeint.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,73 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimeint.h: Internal defines and functions.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifndef __XDG_MIME_INT_H__\n> +#define __XDG_MIME_INT_H__\n> +\n> +#include \"xdgmime.h\"\n> +\n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE (0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE (!FALSE)\n> +#endif\n> +\n> +/* FIXME: Needs to be configure check */\n> +typedef unsigned int   xdg_unichar_t;\n> +typedef unsigned char  xdg_uchar8_t;\n> +typedef unsigned short xdg_uint16_t;\n> +typedef unsigned int   xdg_uint32_t;\n> +\n> +#ifdef XDG_PREFIX\n> +#define _xdg_utf8_skip   XDG_ENTRY(utf8_skip)\n> +#define _xdg_utf8_to_ucs4   XDG_ENTRY(utf8_to_ucs4)\n> +#define _xdg_ucs4_to_lower   XDG_ENTRY(ucs4_to_lower)\n> +#define _xdg_utf8_validate   XDG_ENTRY(utf8_validate)\n> +#define _xdg_get_base_name   XDG_ENTRY(get_ase_name)\n> +#endif\n> +\n> +#define SWAP_BE16_TO_LE16(val) (xdg_uint16_t)(((xdg_uint16_t)(val) << 8)|((xdg_uint16_t)(val) >> 8))\n> +\n> +#define SWAP_BE32_TO_LE32(val) (xdg_uint32_t)((((xdg_uint32_t)(val) & 0xFF000000U) >> 24) |\t\\\n> +\t\t\t\t\t      (((xdg_uint32_t)(val) & 0x00FF0000U) >> 8) |\t\\\n> +\t\t\t\t\t      (((xdg_uint32_t)(val) & 0x0000FF00U) << 8) |\t\\\n> +\t\t\t\t\t      (((xdg_uint32_t)(val) & 0x000000FFU) << 24))\n> +/* UTF-8 utils\n> + */\n> +extern const char *const _xdg_utf8_skip;\n> +#define _xdg_utf8_next_char(p) (char *)((p) + _xdg_utf8_skip[*(unsigned char *)(p)])\n> +#define _xdg_utf8_char_size(p) (int) (_xdg_utf8_skip[*(unsigned char *)(p)])\n> +\n> +xdg_unichar_t  _xdg_utf8_to_ucs4  (const char    *source);\n> +xdg_unichar_t  _xdg_ucs4_to_lower (xdg_unichar_t  source);\n> +int            _xdg_utf8_validate (const char    *source);\n> +const char    *_xdg_get_base_name (const char    *file_name);\n> +\n> +#endif /* __XDG_MIME_INT_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimemagic.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimemagic.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimemagic.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,824 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimemagic.: Private file.  Datastructure for storing magic files.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifdef HAVE_CONFIG_H\n> +#include \n> +#endif\n> +\n> +#include \n> +#include \"xdgmimemagic.h\"\n> +#include \"xdgmimeint.h\"\n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +#include \n> +\n> +#ifndef\tFALSE\n> +#define\tFALSE\t(0)\n> +#endif\n> +\n> +#ifndef\tTRUE\n> +#define\tTRUE\t(!FALSE)\n> +#endif\n> +\n> +extern int errno;\n> +\n> +typedef struct XdgMimeMagicMatch XdgMimeMagicMatch;\n> +typedef struct XdgMimeMagicMatchlet XdgMimeMagicMatchlet;\n> +\n> +typedef enum\n> +{\n> +  XDG_MIME_MAGIC_SECTION,\n> +  XDG_MIME_MAGIC_MAGIC,\n> +  XDG_MIME_MAGIC_ERROR,\n> +  XDG_MIME_MAGIC_EOF\n> +} XdgMimeMagicState;\n> +\n> +struct XdgMimeMagicMatch\n> +{\n> +  const char *mime_type;\n> +  int priority;\n> +  XdgMimeMagicMatchlet *matchlet;\n> +  XdgMimeMagicMatch *next;\n> +};\n> +\n> +\n> +struct XdgMimeMagicMatchlet\n> +{\n> +  int indent;\n> +  int offset;\n> +  unsigned int value_length;\n> +  unsigned char *value;\n> +  unsigned char *mask;\n> +  unsigned int range_length;\n> +  unsigned int word_size;\n> +  XdgMimeMagicMatchlet *next;\n> +};\n> +\n> +\n> +struct XdgMimeMagic\n> +{\n> +  XdgMimeMagicMatch *match_list;\n> +  int max_extent;\n> +};\n> +\n> +static XdgMimeMagicMatch *\n> +_xdg_mime_magic_match_new (void)\n> +{\n> +  return calloc (1, sizeof (XdgMimeMagicMatch));\n> +}\n> +\n> +\n> +static XdgMimeMagicMatchlet *\n> +_xdg_mime_magic_matchlet_new (void)\n> +{\n> +  XdgMimeMagicMatchlet *matchlet;\n> +\n> +  matchlet = malloc (sizeof (XdgMimeMagicMatchlet));\n> +\n> +  matchlet->indent = 0;\n> +  matchlet->offset = 0;\n> +  matchlet->value_length = 0;\n> +  matchlet->value = NULL;\n> +  matchlet->mask = NULL;\n> +  matchlet->range_length = 1;\n> +  matchlet->word_size = 1;\n> +  matchlet->next = NULL;\n> +\n> +  return matchlet;\n> +}\n> +\n> +\n> +static void\n> +_xdg_mime_magic_matchlet_free (XdgMimeMagicMatchlet *mime_magic_matchlet)\n> +{\n> +  if (mime_magic_matchlet)\n> +    {\n> +      if (mime_magic_matchlet->next)\n> +\t_xdg_mime_magic_matchlet_free (mime_magic_matchlet->next);\n> +      if (mime_magic_matchlet->value)\n> +\tfree (mime_magic_matchlet->value);\n> +      if (mime_magic_matchlet->mask)\n> +\tfree (mime_magic_matchlet->mask);\n> +      free (mime_magic_matchlet);\n> +    }\n> +}\n> +\n> +\n> +/* Frees mime_magic_match and the remainder of its list\n> + */\n> +static void\n> +_xdg_mime_magic_match_free (XdgMimeMagicMatch *mime_magic_match)\n> +{\n> +  XdgMimeMagicMatch *ptr, *next;\n> +\n> +  ptr = mime_magic_match;\n> +  while (ptr)\n> +    {\n> +      next = ptr->next;\n> +\n> +      if (ptr->mime_type)\n> +\tfree ((void *) ptr->mime_type);\n> +      if (ptr->matchlet)\n> +\t_xdg_mime_magic_matchlet_free (ptr->matchlet);\n> +      free (ptr);\n> +\n> +      ptr = next;\n> +    }\n> +}\n> +\n> +/* Reads in a hunk of data until a newline character or a '\\000' is hit.  The\n> + * returned string is null terminated, and doesn't include the newline.\n> + */\n> +static unsigned char *\n> +_xdg_mime_magic_read_to_newline (FILE *magic_file,\n> +\t\t\t\t int  *end_of_file)\n> +{\n> +  unsigned char *retval;\n> +  int c;\n> +  int len, pos;\n> +\n> +  len = 128;\n> +  pos = 0;\n> +  retval = malloc (len);\n> +  *end_of_file = FALSE;\n> +\n> +  while (TRUE)\n> +    {\n> +      c = getc_unlocked (magic_file);\n> +      if (c == EOF)\n> +\t{\n> +\t  *end_of_file = TRUE;\n> +\t  break;\n> +\t}\n> +      if (c == '\\n' || c == '\\000')\n> +\tbreak;\n> +      retval[pos++] = (unsigned char) c;\n> +      if (pos % 128 == 127)\n> +\t{\n> +\t  len = len + 128;\n> +\t  retval = realloc (retval, len);\n> +\t}\n> +    }\n> +\n> +  retval[pos] = '\\000';\n> +  return retval;\n> +}\n> +\n> +/* Returns the number read from the file, or -1 if no number could be read.\n> + */\n> +static int\n> +_xdg_mime_magic_read_a_number (FILE *magic_file,\n> +\t\t\t       int  *end_of_file)\n> +{\n> +  /* LONG_MAX is about 20 characters on my system */\n> +#define MAX_NUMBER_SIZE 30\n> +  char number_string[MAX_NUMBER_SIZE + 1];\n> +  int pos = 0;\n> +  int c;\n> +  long retval = -1;\n> +\n> +  while (TRUE)\n> +    {\n> +      c = getc_unlocked (magic_file);\n> +\n> +      if (c == EOF)\n> +\t{\n> +\t  *end_of_file = TRUE;\n> +\t  break;\n> +\t}\n> +      if (! isdigit (c))\n> +\t{\n> +\t  ungetc (c, magic_file);\n> +\t  break;\n> +\t}\n> +      number_string[pos] = (char) c;\n> +      pos++;\n> +      if (pos == MAX_NUMBER_SIZE)\n> +\tbreak;\n> +    }\n> +  if (pos > 0)\n> +    {\n> +      number_string[pos] = '\\000';\n> +      errno = 0;\n> +      retval = strtol (number_string, NULL, 10);\n> +\n> +      if ((retval < INT_MIN) || (retval > INT_MAX) || (errno != 0))\n> +\treturn -1;\n> +    }\n> +\n> +  return retval;\n> +}\n> +\n> +/* Headers are of the format:\n> + * [:]\n> + */\n> +static XdgMimeMagicState\n> +_xdg_mime_magic_parse_header (FILE *magic_file, XdgMimeMagicMatch *match)\n> +{\n> +  int c;\n> +  char *buffer;\n> +  char *end_ptr;\n> +  int end_of_file = 0;\n> +\n> +  assert (magic_file != NULL);\n> +  assert (match != NULL);\n> +\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    return XDG_MIME_MAGIC_EOF;\n> +  if (c != '[')\n> +    return XDG_MIME_MAGIC_ERROR;\n> +\n> +  match->priority = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);\n> +  if (end_of_file)\n> +    return XDG_MIME_MAGIC_EOF;\n> +  if (match->priority == -1)\n> +    return XDG_MIME_MAGIC_ERROR;\n> +\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    return XDG_MIME_MAGIC_EOF;\n> +  if (c != ':')\n> +    return XDG_MIME_MAGIC_ERROR;\n> +\n> +  buffer = (char *)_xdg_mime_magic_read_to_newline (magic_file, &end_of_file);\n> +  if (end_of_file)\n> +    return XDG_MIME_MAGIC_EOF;\n> +\n> +  end_ptr = buffer;\n> +  while (*end_ptr != ']' && *end_ptr != '\\000' && *end_ptr != '\\n')\n> +    end_ptr++;\n> +  if (*end_ptr != ']')\n> +    {\n> +      free (buffer);\n> +      return XDG_MIME_MAGIC_ERROR;\n> +    }\n> +  *end_ptr = '\\000';\n> +\n> +  match->mime_type = strdup (buffer);\n> +  free (buffer);\n> +\n> +  return XDG_MIME_MAGIC_MAGIC;\n> +}\n> +\n> +static XdgMimeMagicState\n> +_xdg_mime_magic_parse_error (FILE *magic_file)\n> +{\n> +  int c;\n> +\n> +  while (1)\n> +    {\n> +      c = getc_unlocked (magic_file);\n> +      if (c == EOF)\n> +\treturn XDG_MIME_MAGIC_EOF;\n> +      if (c == '\\n')\n> +\treturn XDG_MIME_MAGIC_SECTION;\n> +    }\n> +}\n> +\n> +/* Headers are of the format:\n> + * [ indent ] \">\" start-offset \"=\" value\n> + * [ \"&\" mask ] [ \"~\" word-size ] [ \"+\" range-length ] \"\\n\"\n> + */\n> +static XdgMimeMagicState\n> +_xdg_mime_magic_parse_magic_line (FILE              *magic_file,\n> +\t\t\t\t  XdgMimeMagicMatch *match)\n> +{\n> +  XdgMimeMagicMatchlet *matchlet;\n> +  int c;\n> +  int end_of_file;\n> +  int indent = 0;\n> +  unsigned int bytes_read;\n> +\n> +  assert (magic_file != NULL);\n> +\n> +  /* Sniff the buffer to make sure it's a valid line */\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    return XDG_MIME_MAGIC_EOF;\n> +  else if (c == '[')\n> +    {\n> +      ungetc (c, magic_file);\n> +      return XDG_MIME_MAGIC_SECTION;\n> +    }\n> +  else if (c == '\\n')\n> +    return XDG_MIME_MAGIC_MAGIC;\n> +\n> +  /* At this point, it must be a digit or a '>' */\n> +  end_of_file = FALSE;\n> +  if (isdigit (c))\n> +    {\n> +      ungetc (c, magic_file);\n> +      indent = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);\n> +      if (end_of_file)\n> +\treturn XDG_MIME_MAGIC_EOF;\n> +      if (indent == -1)\n> +\treturn XDG_MIME_MAGIC_ERROR;\n> +      c = getc_unlocked (magic_file);\n> +      if (c == EOF)\n> +\treturn XDG_MIME_MAGIC_EOF;\n> +    }\n> +\n> +  if (c != '>')\n> +    return XDG_MIME_MAGIC_ERROR;\n> +\n> +  matchlet = _xdg_mime_magic_matchlet_new ();\n> +  matchlet->indent = indent;\n> +  matchlet->offset = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);\n> +  if (end_of_file)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_EOF;\n> +    }\n> +  if (matchlet->offset == -1)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_ERROR;\n> +    }\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_EOF;\n> +    }\n> +  else if (c != '=')\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_ERROR;\n> +    }\n> +\n> +  /* Next two bytes determine how long the value is */\n> +  matchlet->value_length = 0;\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_EOF;\n> +    }\n> +  matchlet->value_length = c & 0xFF;\n> +  matchlet->value_length = matchlet->value_length << 8;\n> +\n> +  c = getc_unlocked (magic_file);\n> +  if (c == EOF)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_EOF;\n> +    }\n> +  matchlet->value_length = matchlet->value_length + (c & 0xFF);\n> +\n> +  matchlet->value = malloc (matchlet->value_length);\n> +\n> +  /* OOM */\n> +  if (matchlet->value == NULL)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      return XDG_MIME_MAGIC_ERROR;\n> +    }\n> +  bytes_read = fread (matchlet->value, 1, matchlet->value_length, magic_file);\n> +  if (bytes_read != matchlet->value_length)\n> +    {\n> +      _xdg_mime_magic_matchlet_free (matchlet);\n> +      if (feof (magic_file))\n> +\treturn XDG_MIME_MAGIC_EOF;\n> +      else\n> +\treturn XDG_MIME_MAGIC_ERROR;\n> +    }\n> +\n> +  c = getc_unlocked (magic_file);\n> +  if (c == '&')\n> +    {\n> +      matchlet->mask = malloc (matchlet->value_length);\n> +      /* OOM */\n> +      if (matchlet->mask == NULL)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  return XDG_MIME_MAGIC_ERROR;\n> +\t}\n> +      bytes_read = fread (matchlet->mask, 1, matchlet->value_length, magic_file);\n> +      if (bytes_read != matchlet->value_length)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  if (feof (magic_file))\n> +\t    return XDG_MIME_MAGIC_EOF;\n> +\t  else\n> +\t    return XDG_MIME_MAGIC_ERROR;\n> +\t}\n> +      c = getc_unlocked (magic_file);\n> +    }\n> +\n> +  if (c == '~')\n> +    {\n> +      matchlet->word_size = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);\n> +      if (end_of_file)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  return XDG_MIME_MAGIC_EOF;\n> +\t}\n> +      if (matchlet->word_size != 0 &&\n> +\t  matchlet->word_size != 1 &&\n> +\t  matchlet->word_size != 2 &&\n> +\t  matchlet->word_size != 4)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  return XDG_MIME_MAGIC_ERROR;\n> +\t}\n> +      c = getc_unlocked (magic_file);\n> +    }\n> +\n> +  if (c == '+')\n> +    {\n> +      int range_length;\n> +\n> +      range_length = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);\n> +      if (end_of_file)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  return XDG_MIME_MAGIC_EOF;\n> +\t}\n> +      if (range_length == -1)\n> +\t{\n> +\t  _xdg_mime_magic_matchlet_free (matchlet);\n> +\t  return XDG_MIME_MAGIC_ERROR;\n> +\t}\n> +      /* now we are sure that range_length is positive */\n> +      matchlet->range_length = (unsigned int) range_length;\n> +      c = getc_unlocked (magic_file);\n> +    }\n> +\n> +\n> +  if (c == '\\n')\n> +    {\n> +      /* We clean up the matchlet, byte swapping if needed */\n> +      if (matchlet->word_size > 1)\n> +\t{\n> +#if LITTLE_ENDIAN\n> +\t  unsigned int i;\n> +#endif\n> +\t  if (matchlet->value_length % matchlet->word_size != 0)\n> +\t    {\n> +\t      _xdg_mime_magic_matchlet_free (matchlet);\n> +\t      return XDG_MIME_MAGIC_ERROR;\n> +\t    }\n> +\t  /* FIXME: need to get this defined in a  style file */\n> +#if LITTLE_ENDIAN\n> +\t  for (i = 0; i < matchlet->value_length; i = i + matchlet->word_size)\n> +\t    {\n> +\t      if (matchlet->word_size == 2)\n> +\t\t*((xdg_uint16_t *) matchlet->value + i) = SWAP_BE16_TO_LE16 (*((xdg_uint16_t *) (matchlet->value + i)));\n> +\t      else if (matchlet->word_size == 4)\n> +\t\t*((xdg_uint32_t *) matchlet->value + i) = SWAP_BE32_TO_LE32 (*((xdg_uint32_t *) (matchlet->value + i)));\n> +\t      if (matchlet->mask)\n> +\t\t{\n> +\t\t  if (matchlet->word_size == 2)\n> +\t\t    *((xdg_uint16_t *) matchlet->mask + i) = SWAP_BE16_TO_LE16 (*((xdg_uint16_t *) (matchlet->mask + i)));\n> +\t\t  else if (matchlet->word_size == 4)\n> +\t\t    *((xdg_uint32_t *) matchlet->mask + i) = SWAP_BE32_TO_LE32 (*((xdg_uint32_t *) (matchlet->mask + i)));\n> +\n> +\t\t}\n> +\t    }\n> +#endif\n> +\t}\n> +\n> +      matchlet->next = match->matchlet;\n> +      match->matchlet = matchlet;\n> +\n> +\n> +      return XDG_MIME_MAGIC_MAGIC;\n> +    }\n> +\n> +  _xdg_mime_magic_matchlet_free (matchlet);\n> +  if (c == EOF)\n> +    return XDG_MIME_MAGIC_EOF;\n> +\n> +  return XDG_MIME_MAGIC_ERROR;\n> +}\n> +\n> +static int\n> +_xdg_mime_magic_matchlet_compare_to_data (XdgMimeMagicMatchlet *matchlet,\n> +\t\t\t\t\t  const void           *data,\n> +\t\t\t\t\t  size_t                len)\n> +{\n> +  unsigned int i, j;\n> +  for (i = matchlet->offset; i < matchlet->offset + matchlet->range_length; i++)\n> +    {\n> +      int valid_matchlet = TRUE;\n> +\n> +      if (i + matchlet->value_length > len)\n> +\treturn FALSE;\n> +\n> +      if (matchlet->mask)\n> +\t{\n> +\t  for (j = 0; j < matchlet->value_length; j++)\n> +\t    {\n> +\t      if ((matchlet->value[j] & matchlet->mask[j]) !=\n> +\t\t  ((((unsigned char *) data)[j + i]) & matchlet->mask[j]))\n> +\t\t{\n> +\t\t  valid_matchlet = FALSE;\n> +\t\t  break;\n> +\t\t}\n> +\t    }\n> +\t}\n> +      else\n> +\t{\n> +\t  for (j = 0; j <  matchlet->value_length; j++)\n> +\t    {\n> +\t      if (matchlet->value[j] != ((unsigned char *) data)[j + i])\n> +\t\t{\n> +\t\t  valid_matchlet = FALSE;\n> +\t\t  break;\n> +\t\t}\n> +\t    }\n> +\t}\n> +      if (valid_matchlet)\n> +\treturn TRUE;\n> +    }\n> +  return FALSE;\n> +}\n> +\n> +static int\n> +_xdg_mime_magic_matchlet_compare_level (XdgMimeMagicMatchlet *matchlet,\n> +\t\t\t\t\tconst void           *data,\n> +\t\t\t\t\tsize_t                len,\n> +\t\t\t\t\tint                   indent)\n> +{\n> +  while ((matchlet != NULL) && (matchlet->indent == indent))\n> +    {\n> +      if (_xdg_mime_magic_matchlet_compare_to_data (matchlet, data, len))\n> +\t{\n> +\t  if ((matchlet->next == NULL) ||\n> +\t      (matchlet->next->indent <= indent))\n> +\t    return TRUE;\n> +\n> +\t  if (_xdg_mime_magic_matchlet_compare_level (matchlet->next,\n> +\t\t\t\t\t\t      data,\n> +\t\t\t\t\t\t      len,\n> +\t\t\t\t\t\t      indent + 1))\n> +\t    return TRUE;\n> +\t}\n> +\n> +      do\n> +\t{\n> +\t  matchlet = matchlet->next;\n> +\t}\n> +      while (matchlet && matchlet->indent > indent);\n> +    }\n> +\n> +  return FALSE;\n> +}\n> +\n> +static int\n> +_xdg_mime_magic_match_compare_to_data (XdgMimeMagicMatch *match,\n> +\t\t\t\t       const void        *data,\n> +\t\t\t\t       size_t             len)\n> +{\n> +  return _xdg_mime_magic_matchlet_compare_level (match->matchlet, data, len, 0);\n> +}\n> +\n> +static void\n> +_xdg_mime_magic_insert_match (XdgMimeMagic      *mime_magic,\n> +\t\t\t      XdgMimeMagicMatch *match)\n> +{\n> +  XdgMimeMagicMatch *list;\n> +\n> +  if (mime_magic->match_list == NULL)\n> +    {\n> +      mime_magic->match_list = match;\n> +      return;\n> +    }\n> +\n> +  if (match->priority > mime_magic->match_list->priority)\n> +    {\n> +      match->next = mime_magic->match_list;\n> +      mime_magic->match_list = match;\n> +      return;\n> +    }\n> +\n> +  list = mime_magic->match_list;\n> +  while (list->next != NULL)\n> +    {\n> +      if (list->next->priority < match->priority)\n> +\t{\n> +\t  match->next = list->next;\n> +\t  list->next = match;\n> +\t  return;\n> +\t}\n> +      list = list->next;\n> +    }\n> +  list->next = match;\n> +  match->next = NULL;\n> +}\n> +\n> +XdgMimeMagic *\n> +_xdg_mime_magic_new (void)\n> +{\n> +  return calloc (1, sizeof (XdgMimeMagic));\n> +}\n> +\n> +void\n> +_xdg_mime_magic_free (XdgMimeMagic *mime_magic)\n> +{\n> +  if (mime_magic) {\n> +    _xdg_mime_magic_match_free (mime_magic->match_list);\n> +    free (mime_magic);\n> +  }\n> +}\n> +\n> +int\n> +_xdg_mime_magic_get_buffer_extents (XdgMimeMagic *mime_magic)\n> +{\n> +  return mime_magic->max_extent;\n> +}\n> +\n> +const char *\n> +_xdg_mime_magic_lookup_data (XdgMimeMagic *mime_magic,\n> +\t\t\t     const void   *data,\n> +\t\t\t     size_t        len,\n> +                             const char   *mime_types[],\n> +                             int           n_mime_types)\n> +{\n> +  XdgMimeMagicMatch *match;\n> +  const char *mime_type;\n> +  int n;\n> +  int priority;\n> +  int had_match;\n> +\n> +  mime_type = NULL;\n> +  priority = 0;\n> +  had_match = 0;\n> +  for (match = mime_magic->match_list; match; match = match->next)\n> +    {\n> +      if (_xdg_mime_magic_match_compare_to_data (match, data, len))\n> +\t{\n> +\t  if (!had_match || match->priority > priority ||\n> +\t      (mime_type != NULL && _xdg_mime_mime_type_subclass (match->mime_type, mime_type)))\n> +\t    {\n> +\t      mime_type = match->mime_type;\n> +\t      priority = match->priority;\n> +\t    }\n> +\t  else if (had_match && match->priority == priority)\n> +\t    /* multiple unrelated patterns with the same priority matched,\n> +\t     * so we can't tell what type this is. */\n> +\t    mime_type = NULL;\n> +\n> +\t  had_match = 1;\n> +\t}\n> +      else \n> +\t{\n> +\t  for (n = 0; n < n_mime_types; n++)\n> +\t    {\n> +\t      if (mime_types[n] && \n> +\t\t  _xdg_mime_mime_type_equal (mime_types[n], match->mime_type))\n> +\t\tmime_types[n] = NULL;\n> +\t    }\n> +\t}\n> +    }\n> +\n> +  if (mime_type == NULL)\n> +    {\n> +      for (n = 0; n < n_mime_types; n++)\n> +\t{\n> +\t  if (mime_types[n])\n> +\t    mime_type = mime_types[n];\n> +\t}\n> +    }\n> +\n> +  return mime_type;\n> +}\n> +\n> +static void\n> +_xdg_mime_update_mime_magic_extents (XdgMimeMagic *mime_magic)\n> +{\n> +  XdgMimeMagicMatch *match;\n> +  int max_extent = 0;\n> +\n> +  for (match = mime_magic->match_list; match; match = match->next)\n> +    {\n> +      XdgMimeMagicMatchlet *matchlet;\n> +\n> +      for (matchlet = match->matchlet; matchlet; matchlet = matchlet->next)\n> +\t{\n> +\t  int extent;\n> +\n> +\t  extent = matchlet->value_length + matchlet->offset + matchlet->range_length;\n> +\t  if (max_extent < extent)\n> +\t    max_extent = extent;\n> +\t}\n> +    }\n> +\n> +  mime_magic->max_extent = max_extent;\n> +}\n> +\n> +static XdgMimeMagicMatchlet *\n> +_xdg_mime_magic_matchlet_mirror (XdgMimeMagicMatchlet *matchlets)\n> +{\n> +  XdgMimeMagicMatchlet *new_list;\n> +  XdgMimeMagicMatchlet *tmp;\n> +\n> +  if ((matchlets == NULL) || (matchlets->next == NULL))\n> +    return matchlets;\n> +\n> +  new_list = NULL;\n> +  tmp = matchlets;\n> +  while (tmp != NULL)\n> +    {\n> +      XdgMimeMagicMatchlet *matchlet;\n> +\n> +      matchlet = tmp;\n> +      tmp = tmp->next;\n> +      matchlet->next = new_list;\n> +      new_list = matchlet;\n> +    }\n> +\n> +  return new_list;\n> +\n> +}\n> +\n> +static void\n> +_xdg_mime_magic_read_magic_file (XdgMimeMagic *mime_magic,\n> +\t\t\t\t FILE         *magic_file)\n> +{\n> +  XdgMimeMagicState state;\n> +  XdgMimeMagicMatch *match = NULL; /* Quiet compiler */\n> +\n> +  state = XDG_MIME_MAGIC_SECTION;\n> +\n> +  while (state != XDG_MIME_MAGIC_EOF)\n> +    {\n> +      switch (state)\n> +\t{\n> +\tcase XDG_MIME_MAGIC_SECTION:\n> +\t  match = _xdg_mime_magic_match_new ();\n> +\t  state = _xdg_mime_magic_parse_header (magic_file, match);\n> +\t  if (state == XDG_MIME_MAGIC_EOF || state == XDG_MIME_MAGIC_ERROR)\n> +\t    _xdg_mime_magic_match_free (match);\n> +\t  break;\n> +\tcase XDG_MIME_MAGIC_MAGIC:\n> +\t  state = _xdg_mime_magic_parse_magic_line (magic_file, match);\n> +\t  if (state == XDG_MIME_MAGIC_SECTION ||\n> +\t      (state == XDG_MIME_MAGIC_EOF && match->mime_type))\n> +\t    {\n> +\t      match->matchlet = _xdg_mime_magic_matchlet_mirror (match->matchlet);\n> +\t      _xdg_mime_magic_insert_match (mime_magic, match);\n> +\t    }\n> +\t  else if (state == XDG_MIME_MAGIC_EOF || state == XDG_MIME_MAGIC_ERROR)\n> +\t    _xdg_mime_magic_match_free (match);\n> +\t  break;\n> +\tcase XDG_MIME_MAGIC_ERROR:\n> +\t  state = _xdg_mime_magic_parse_error (magic_file);\n> +\t  break;\n> +\tcase XDG_MIME_MAGIC_EOF:\n> +\tdefault:\n> +\t  /* Make the compiler happy */\n> +\t  assert (0);\n> +\t}\n> +    }\n> +  _xdg_mime_update_mime_magic_extents (mime_magic);\n> +}\n> +\n> +void\n> +_xdg_mime_magic_read_from_file (XdgMimeMagic *mime_magic,\n> +\t\t\t\tconst char   *file_name)\n> +{\n> +  FILE *magic_file;\n> +  char header[12];\n> +\n> +  magic_file = fopen (file_name, \"r\");\n> +\n> +  if (magic_file == NULL)\n> +    return;\n> +\n> +  if (fread (header, 1, 12, magic_file) == 12)\n> +    {\n> +      if (memcmp (\"MIME-Magic\\0\\n\", header, 12) == 0)\n> +        _xdg_mime_magic_read_magic_file (mime_magic, magic_file);\n> +    }\n> +\n> +  fclose (magic_file);\n> +}\n> \n> Added: liblicense/trunk/xdgmime/xdgmimemagic.h\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimemagic.h\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimemagic.h\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,56 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimemagic.h: Private file.  Datastructure for storing the magic files.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2003  Red Hat, Inc.\n> + * Copyright (C) 2003  Jonathan Blandford \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> + *\n> + * This library is distributed in the hope that it will be useful,\n> + * but WITHOUT ANY WARRANTY; without even the implied warranty of\n> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n> + * Lesser General Public License for more details.\n> + *\n> + * You should have received a copy of the GNU Lesser General Public\n> + * License along with this library; if not, write to the\n> + * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n> + * Boston, MA 02111-1307, USA.\n> + */\n> +\n> +#ifndef __XDG_MIME_MAGIC_H__\n> +#define __XDG_MIME_MAGIC_H__\n> +\n> +#include \n> +#include \"xdgmime.h\"\n> +typedef struct XdgMimeMagic XdgMimeMagic;\n> +\n> +#ifdef XDG_PREFIX\n> +#define _xdg_mime_glob_read_from_file             XDG_ENTRY(glob_read_from_file)\n> +#define _xdg_mime_magic_new                       XDG_ENTRY(magic_new)\n> +#define _xdg_mime_magic_read_from_file            XDG_ENTRY(magic_read_from_file)\n> +#define _xdg_mime_magic_free                      XDG_ENTRY(magic_free)\n> +#define _xdg_mime_magic_get_buffer_extents        XDG_ENTRY(magic_get_buffer_extents)\n> +#define _xdg_mime_magic_lookup_data               XDG_ENTRY(magic_lookup_data)\n> +#endif\n> +\n> +\n> +XdgMimeMagic *_xdg_mime_magic_new                (void);\n> +void          _xdg_mime_magic_read_from_file     (XdgMimeMagic *mime_magic,\n> +\t\t\t\t\t\t  const char   *file_name);\n> +void          _xdg_mime_magic_free               (XdgMimeMagic *mime_magic);\n> +int           _xdg_mime_magic_get_buffer_extents (XdgMimeMagic *mime_magic);\n> +const char   *_xdg_mime_magic_lookup_data        (XdgMimeMagic *mime_magic,\n> +\t\t\t\t\t\t  const void   *data,\n> +\t\t\t\t\t\t  size_t        len,\n> +\t\t\t\t\t\t  const char   *mime_types[],\n> +\t\t\t\t\t\t  int           n_mime_types);\n> +\n> +#endif /* __XDG_MIME_MAGIC_H__ */\n> \n> Added: liblicense/trunk/xdgmime/xdgmimeparent.c\n> ===================================================================\n> --- liblicense/trunk/xdgmime/xdgmimeparent.c\t                        (rev 0)\n> +++ liblicense/trunk/xdgmime/xdgmimeparent.c\t2007-06-29 19:16:02 UTC (rev 6089)\n> @@ -0,0 +1,219 @@\n> +/* -*- mode: C; c-file-style: \"gnu\" -*- */\n> +/* xdgmimealias.c: Private file.  Datastructure for storing the hierarchy.\n> + *\n> + * More info can be found at http://www.freedesktop.org/standards/\n> + *\n> + * Copyright (C) 2004  Red Hat, Inc.\n> + * Copyright (C) 2004  Matthias Clasen \n> + *\n> + * Licensed under the Academic Free License version 2.0\n> + * Or under the following terms:\n> + *\n> + * This library is free software; you can redistribute it and/or\n> + * modify it under the terms of the GNU Lesser General Public\n> + * License as published by the Free Software Foundation; either\n> + * version 2 of the License, or (at your option) any later version.\n> \n> @@ Diff output truncated at 100000 characters. @@\n> \n> This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.\n> \n> -------------------------------------------------------------------------\n> This SF.net email is sponsored by DB2 Express\n> Download DB2 Express C - the FREE version of DB2 express and take\n> control of your XML. No limits. Just data. Click to get it now.\n> http://sourceforge.net/powerbar/db2/\n> _______________________________________________\n> Cctools-cvs mailing list\n> Cctools-cvs@lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/cctools-cvs\n-- \nJon Phillips\n\nSan Francisco, CA\nUSA PH 510.499.0894\njon@rejon.org\nhttp://www.rejon.org\n\nMSN, AIM, Yahoo Chat: kidproto\nJabber Chat: rejon@gristle.org\nIRC: rejon@irc.freenode.net\n\n_______________________________________________\ncc-devel mailing list\ncc-devel@lists.ibiblio.org\nhttp://lists.ibiblio.org/mailman/listinfo/cc-devel\n\n"}
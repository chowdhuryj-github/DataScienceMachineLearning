{"category": "ham", "to_address": "perl6-internals@perl.org", "from_address": "Jonathan Worthington <jonathan@jnthn.net>", "subject": "My brain dump for the PMCs PDD", "body": "Hi all,\n\nHere's my semi-coherent collection of random thoughts about PMCs, typed \nup while sitting in a nice sunny park in London last week. A lot of \ndetails will need hashing out with these ideas. I am primarily trying to \naddress:\n\n* Interaction between PMCs and classes built with Class (but it's \nactually a more geneal problem of interaction between classes from \ndifferent and imcompatible class system implementations; I think we need \nsomething that deals with the general problem and is not specific to PMCs).\n\n* PMC state\n\n* PMCs and roles\n\n== PMC Attributes\nPresent situation: PMCs have up to three slots for data if they use_ext. \nAny slots that their parents use are unusable in a non-compatible way, \nso any complex inheritance hierarchy is near impossible to achieve.\n\nProposal: PMCs can have attributes just as classes in HLLs have \nattributes. This is somewhat related to variable sized PMCs; note you \ncan leave PMC headers fixed size and just have a pmc_ext like structure \nthat is the variable sized bit. The implementation of attributes and \nattribute inheritance would be pretty standard.\n\n== Introspection\nWhile every instance of an object instantiated from a Parrot Class has \nthe Class available for introspection purposes, PMCs do not. This needs \nto change, and here's something I think will work.\n\nEvery PMC gets an automatically generated instance of MetaPMC. This \nimplements the inspect and inspect_str vtable methods, which again will \nbe generated automatically. This will allow full outside introspection \nof the methods, attributes, inheritance and roles done by a PMC. The \nMetaPMC will be attached to a namespace just as a class or role is \nattached to a namespace today. Using the get_class op will return the \nMetaPMC, just as you'd get a Class if you called get_class on an Object. \nYou can go ahead and introspect the thing like a class, and it'll Just Work.\n\n== Interaction Between HLL Clases and PMCs\nIn the inheritance heirarchy, MetaPMCs show up just as a Class would. \nHowever, in your MRO, you treat anything from a different \"universe\" \n(that is, PMCs are in a different universe to classes built using the \ndefault Parrot Class) as a black box - that is, you don't list all of \nits parents in the MRO. (Whether inspecting the MRO lies and does \ninclude them is another matter, I'm talking internals here).\n\nMethod lookup should always be done by obtaining the method done by a \nclass using the inspection interface unless it is of the same type of \nclass as the one who's find_method vtable method is doing the lookup \n(you understand your own internals, so you can cheat). This means that \nPMCs just expose their methods as a class would expose its methods - \nthrough the MetaPMC.\n\nState is a bit harder when it comes to inheritance, since different \nclass systems will chose to store it in different ways. For example, the \ndefault Parrot Class implementation uses a ResizablePMCArray in the \nObject to store attributes. PMCs will do it differently, being based \nupon a C structure.\n\nWe can partly resolve the problem by introducing the same kind of rule \nwe have been doing so far: you only include attributes from classes in \nthe same \"universe\" as yourself - that is, implemented using the same or \na compatible underlying implementation. When Class builds its attribute \nlookup table, it does not include attributes from PMCs.\n\nAt the point of attribute lookup, when an imcompatible type of class is \nreached, lookup is then delegated to the get_attribute vtable method of \nthe instance from the different universe.\n\nFor this to work, any class implementaiton will need to instantiate \nobjects of any class that it directly inherits from that belongs to a \ndifferent universe. That is, if you inherit from two PMCs when creating \na Class, then each of those PMCs will need to be instantiated. (This is \nsort of what we do today, but we can only support one PMC parent, not \nmultiple ones; also I'm extending this to deal not just with the \nClass/PMC mismatch, but also the mismatch that will occur when you have \nother class system implementations that are totally different internally).\n\n== PMRs (Parrot Magic Roles)\nIf a PMC does a role, you can do that composition statically in the PMC \ncompiler. That kinda means that roles at a C level need not exist at \nruntime. Unfortunately, that'd mean that we couldn't inspect the role at \nruntime or compose it into a non-PMC class, which would rather suck. \nConclusion: roles somehow need to exist at runtime.\n\nRoles have methods and state. As before, methods are quite easy to deal \nwith, but state is a pain. The main issue is that the state exists at a \nC level. To deal with this for classes, we had to instantiate each of \nthe PMCs we inherited from, so we had state available in the right form. \nWe have the same situation with roles, which seems to suggest that you \nneed to keep around a collection of \"instantiated\" roles (yes, I know, \nyou can't really instantiate a role) that are from a different universe.\n\nThis is all starting to make PMCs and PMRs sound very similar, to the \nextent that you probably want to re-use a lot of the functionaltiy \nbetween the two of them.\n\nUnfortunately, we have no such general concpet of instantiating a role \nfor the sake of having its state available. Trouble is that the roles \npaper gets some good properties from roles by them *not* having state, \nand having roles with state loses you them. Of course, there's \nadvantages too, but you lose a lot of the implementation simplicity. In \nfact, this whole thing is still the biggest unsolved problem in my mind. \nA general mechanism to bridge the gap between classes in different \nuinverses wasn't so bad, because you had instantiation so you can \nactually delegate rather than inherit. With roles, we don't have that, \nso you can't use the same cheat unless you make roles somehow \ninstantiable, or at least provide a way of saying \"here's the state of \nthe role from a different universe\".\n\n== Calling methods in a subclass from a different universe\nState for once doesn't hurt us here, since you can't see the state of a \nsubclass (since you don't know it exists). The same ins't true of method \noverriding. If you call a method from different universe, delegation \nbreaks down and you can't call accross the boundary - the find_method \nvtable ends up invoking on the wrong object.\n\nThe only way I see to resolve this is to try and pull apart \"who am I\" \nfrom \"what state do I have\". The two are tied together under the current \nPMC design. It's incompatible ways of doing state that leads us to \nwanting delegation, so maybe what we really want is to actually pass a \ncopy of the PMC data structure with the vtable of the class deepest in \nthe inheritance hierarchy, but with the state stored in whatever way the \nobject in the different universe uses. If you stick with fixed sized PMC \nheaders pointing to a vtable and the state, with variable sized state, \nthat becomes reasonably easy to implement. It's a tad evil, and we'd \nwant a way to say to implementers of other class systems \"just call this \nmagic bit of code that crosses you into the other universe\".\n\nNote that with this, you'd need to be quite careful about calling the \ncorrect get_attribute and set_attribute methods when you delegate up the \ntree, as I suggested for crossing universe boundaries during attribute \nlookup.\n\nOK, that's all I've got for now. Sorry for the rambling towards the end \nas I explored the bits I'm not clear on yet, and hope it's helpful.\n\nJonathan\n\n\n"}
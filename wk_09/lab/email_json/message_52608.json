{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jerry@samba.org", "subject": "svn commit: samba r23580 - in branches/SAMBA_3_0_RELEASE: .\n\tsource/client source/nsswitch", "body": "Author: jerry\nDate: 2007-06-22 04:09:38 +0000 (Fri, 22 Jun 2007)\nNew Revision: 23580\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23580\n\nLog:\nMerge bug fix for 4720 and Jeremy's winbindd_dual.c changes (still testing these)\nModified:\n   branches/SAMBA_3_0_RELEASE/WHATSNEW.txt\n   branches/SAMBA_3_0_RELEASE/source/client/client.c\n   branches/SAMBA_3_0_RELEASE/source/nsswitch/winbindd_dual.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_RELEASE/WHATSNEW.txt\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/WHATSNEW.txt\t2007-06-21 23:11:21 UTC (rev 23579)\n+++ branches/SAMBA_3_0_RELEASE/WHATSNEW.txt\t2007-06-22 04:09:38 UTC (rev 23580)\n@@ -55,6 +55,11 @@\n     * Add more netlogon GetDcName() client calls.\n \n \n+o   SATOH Fumiyasu \n+    * BUG 4720: Fix smbclient connections to share names containing \n+      multibyte characters.\n+\n+\n o   Steve Langasek \n     * Allow SIGTERM to cause nmbd to exit on awaiting an interface \n       to come up.\n\nModified: branches/SAMBA_3_0_RELEASE/source/client/client.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/client/client.c\t2007-06-21 23:11:21 UTC (rev 23579)\n+++ branches/SAMBA_3_0_RELEASE/source/client/client.c\t2007-06-22 04:09:38 UTC (rev 23580)\n@@ -3915,14 +3915,6 @@\n \t\t/* if the service has not yet been specified lets see if it is available in the popt stack */\n \t\tif (!service_opt && poptPeekArg(pc)) {\n \t\t\tpstrcpy(service, poptGetArg(pc));\n-\t\t\t/* Convert any '/' characters in the service name to '\\' characters */\n-\t\t\tstring_replace(service, '/','\\\\');\n-\n-\t\t\tif (count_chars(service,'\\\\') < 3) {\n-\t\t\t\td_printf(\"\\n%s: Not enough '\\\\' characters in service\\n\",service);\n-\t\t\t\tpoptPrintUsage(pc, stderr, 0);\n-\t\t\t\texit(1);\n-\t\t\t}\n \t\t\tservice_opt = True;\n \t\t}\n \n@@ -4010,14 +4002,6 @@\n \t/* if the service has not yet been specified lets see if it is available in the popt stack */\n \tif (!service_opt && poptPeekArg(pc)) {\n \t\tpstrcpy(service, poptGetArg(pc));\n-\t\t/* Convert any '/' characters in the service name to '\\' characters */\n-\t\tstring_replace(service, '/','\\\\');\n-\n-\t\tif (count_chars(service,'\\\\') < 3) {\n-\t\t\td_printf(\"\\n%s: Not enough '\\\\' characters in service\\n\",service);\n-\t\t\tpoptPrintUsage(pc, stderr, 0);\n-\t\t\texit(1);\n-\t\t}\n \t\tservice_opt = True;\n \t}\n \n@@ -4056,6 +4040,16 @@\n \t}\n \t\n \tload_interfaces();\n+\n+\tif (service_opt) {\n+\t\t/* Convert any '/' characters in the service name to '\\' characters */\n+\t\tstring_replace(service, '/','\\\\');\n+\t\tif (count_chars(service,'\\\\') < 3) {\n+\t\t\td_printf(\"\\n%s: Not enough '\\\\' characters in service\\n\",service);\n+\t\t\tpoptPrintUsage(pc, stderr, 0);\n+\t\t\texit(1);\n+\t\t}\n+\t}\n \t\n \tif ( strlen(new_workgroup) != 0 )\n \t\tset_global_myworkgroup( new_workgroup );\n\nModified: branches/SAMBA_3_0_RELEASE/source/nsswitch/winbindd_dual.c\n===================================================================\n--- branches/SAMBA_3_0_RELEASE/source/nsswitch/winbindd_dual.c\t2007-06-21 23:11:21 UTC (rev 23579)\n+++ branches/SAMBA_3_0_RELEASE/source/nsswitch/winbindd_dual.c\t2007-06-22 04:09:38 UTC (rev 23580)\n@@ -97,6 +97,8 @@\n \tstruct winbindd_response *response;\n \tvoid (*continuation)(void *private_data, BOOL success);\n \tstruct timed_event *reply_timeout_event;\n+\tpid_t child_pid; /* pid of the child we're waiting on. Used to detect\n+\t\t\t    a restart of the child (child->pid != child_pid). */\n \tvoid *private_data;\n };\n \n@@ -174,36 +176,51 @@\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n \n+\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n+\t\t\"Closing connection to it.\\n\",\n+\t\tstate->child_pid ));\n+\n \t/* Deal with the reply - set to error. */\n-\n \tasync_reply_recv(private_data, False);\n+}\n \n-\tDEBUG(0,(\"async_request_timeout_handler: child pid %u is not responding. \"\n-\t\t\"Closing connection to it.\\n\",\n-\t\tstate->child->pid ));\n+/**************************************************************\n+ Common function called on both async send and recv fail.\n+ Cleans up the child and schedules the next request.\n+**************************************************************/\n \n-\t/* Send kill signal to child. */\n-\tkill(state->child->pid, SIGTERM);\n+static void async_request_fail(struct winbindd_async_request *state)\n+{\n+\tDLIST_REMOVE(state->child->requests, state);\n \n-\t/* \n-\t * Close the socket to the child.\n-\t */\n+\tTALLOC_FREE(state->reply_timeout_event);\n \n-\twinbind_child_died(state->child->pid);\n+\tSMB_ASSERT(state->child_pid != (pid_t)0);\n+\n+\t/* If not already reaped, send kill signal to child. */\n+\tif (state->child->pid == state->child_pid) {\n+\t\tkill(state->child_pid, SIGTERM);\n+\n+\t\t/* \n+\t\t * Close the socket to the child.\n+\t\t */\n+\t\twinbind_child_died(state->child_pid);\n+\t}\n+\n+\tstate->response->length = sizeof(struct winbindd_response);\n+\tstate->response->result = WINBINDD_ERROR;\n+\tstate->continuation(state->private_data, False);\n }\n \n static void async_request_sent(void *private_data_data, BOOL success)\n {\n-\tuint32_t timeout = 30;\n \tstruct winbindd_async_request *state =\n \t\ttalloc_get_type_abort(private_data_data, struct winbindd_async_request);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not send async request\\n\"));\n-\n-\t\tstate->response->length = sizeof(struct winbindd_response);\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tDEBUG(5, (\"Could not send async request to child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n@@ -215,25 +232,14 @@\n \t\t\t async_reply_recv, state);\n \n \t/* \n-\t * Normal timeouts are 30s, but auth requests may take a long\n-\t * time to timeout.\n-\t */\n-\n-\tif (state->request->cmd == WINBINDD_PAM_AUTH ||\n-\t\t\tstate->request->cmd == WINBINDD_PAM_AUTH_CRAP ) {\n-\n-\t\ttimeout = 300;\n-\t}\n-\n-\t/* \n-\t * Set up a timeout of 30 seconds for the response.\n+\t * Set up a timeout of 300 seconds for the response.\n \t * If we don't get it close the child socket and\n \t * report failure.\n \t */\n \n \tstate->reply_timeout_event = event_add_timed(winbind_event_context(),\n \t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\ttimeval_current_ofs(timeout,0),\n+\t\t\t\t\t\t\ttimeval_current_ofs(300,0),\n \t\t\t\t\t\t\t\"async_request_timeout\",\n \t\t\t\t\t\t\tasync_request_timeout_handler,\n \t\t\t\t\t\t\tstate);\n@@ -248,27 +254,23 @@\n \t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n \tstruct winbindd_child *child = state->child;\n \n-\tif (state->reply_timeout_event) {\n-\t\tTALLOC_FREE(state->reply_timeout_event);\n-\t}\n+\tTALLOC_FREE(state->reply_timeout_event);\n \n \tstate->response->length = sizeof(struct winbindd_response);\n \n \tif (!success) {\n-\t\tDEBUG(5, (\"Could not receive async reply\\n\"));\n+\t\tDEBUG(5, (\"Could not receive async reply from child pid %u\\n\",\n+\t\t\t(unsigned int)state->child_pid ));\n \n-\t\tcache_cleanup_response(child->pid);\n-\t\tDLIST_REMOVE(child->requests, state);\n-\n-\t\tstate->response->result = WINBINDD_ERROR;\n-\t\tstate->continuation(state->private_data, False);\n+\t\tcache_cleanup_response(state->child_pid);\n+\t\tasync_request_fail(state);\n \t\treturn;\n \t}\n \n-\tSMB_ASSERT(cache_retrieve_response(child->pid,\n+\tSMB_ASSERT(cache_retrieve_response(state->child_pid,\n \t\t\t\t\t   state->response));\n \n-\tcache_cleanup_response(child->pid);\n+\tcache_cleanup_response(state->child_pid);\n \t\n \tDLIST_REMOVE(child->requests, state);\n \n@@ -303,6 +305,9 @@\n \t\treturn;\n \t}\n \n+\t/* Now we know who we're sending to - remember the pid. */\n+\trequest->child_pid = child->pid;\n+\n \tsetup_async_write(&child->event, request->request,\n \t\t\t  sizeof(*request->request),\n \t\t\t  async_main_request_sent, request);\n@@ -517,7 +522,7 @@\n \t}\n \n \tif (child == NULL) {\n-\t\tDEBUG(0, (\"Unknown child %d died!\\n\", pid));\n+\t\tDEBUG(5, (\"Already reaped child %u died\\n\", (unsigned int)pid));\n \t\treturn;\n \t}\n \n@@ -713,9 +718,7 @@\n \n \tDEBUG(10,(\"account_lockout_policy_handler called\\n\"));\n \n-\tif (child->lockout_policy_event) {\n-\t\tTALLOC_FREE(child->lockout_policy_event);\n-\t}\n+\tTALLOC_FREE(child->lockout_policy_event);\n \n \tmethods = child->domain->methods;\n \n@@ -962,9 +965,7 @@\n \n \tfor (domain = domain_list(); domain; domain = domain->next) {\n \t\tif (domain != child->domain) {\n-\t\t\tif (domain->check_online_event) {\n-\t\t\t\tTALLOC_FREE(domain->check_online_event);\n-\t\t\t}\n+\t\t\tTALLOC_FREE(domain->check_online_event);\n \t\t}\n \t}\n \n\n"}
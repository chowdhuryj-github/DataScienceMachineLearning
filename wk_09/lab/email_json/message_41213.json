{"category": "ham", "to_address": "perl6-language@perl.org", "from_address": "larry@cvs.develooper.com", "subject": "[svn:perl6-synopsis] r14413 - doc/trunk/design/syn", "body": "Author: larry\nDate: Sat Jun  2 12:42:11 2007\nNew Revision: 14413\n\nModified:\n   doc/trunk/design/syn/S02.pod\n   doc/trunk/design/syn/S03.pod\n   doc/trunk/design/syn/S04.pod\n   doc/trunk/design/syn/S06.pod\n   doc/trunk/design/syn/S09.pod\n   doc/trunk/design/syn/S13.pod\n\nLog:\nDropped : from all listop contextualizers, whether sigil and typename.\nThe @@ contextualizer is now also named \"slice\".\nConsistent with that, we have regularized slice nomenclature:\n* A \"slice\" now always refers to the whole multidimensional subscript,\n    or the list of lists corresponding to that.\n* We now try to avoid calling the individual sublists \"slices\".\n* The parameter to a subscript is *@@slice, not *@@slices.\n* The term \"multislice\" is now deemed redundant.\n\n\nModified: doc/trunk/design/syn/S02.pod\n==============================================================================\n--- doc/trunk/design/syn/S02.pod\t(original)\n+++ doc/trunk/design/syn/S02.pod\tSat Jun  2 12:42:11 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 10 Aug 2004\n-  Last Modified: 29 May 2007\n+  Last Modified: 2 Jun 2007\n   Number: 2\n-  Version: 108\n+  Version: 109\n \n This document summarizes Apocalypse 2, which covers small-scale\n lexical items and typological issues.  (These Synopses also contain\n@@ -446,8 +446,11 @@\n     $spot.defined;          # False\n     say $spot;              # \"Dog\"\n \n-Any class name used as a value by itself is an undefined instance of that\n-class's prototype.  See S12 for more on that.\n+Any class name used as a value by itself is an undefined instance of\n+that class's prototype, or I.  See S12 for more on that.\n+(Any type name in rvalue context is parsed as a list operator\n+indicating a typecast, but an argumentless one of these degenerates\n+to a typecast of undef, producing the protoobject.)\n \n To get a real C object, call a constructor method such as C:\n \n@@ -1059,7 +1062,7 @@\n     %   unordered hash (associative array)\n     &   code/rule/token/regex\n     ::  package/module/class/role/subset/enum/type/grammar\n-    @@  multislice view of @\n+    @@  slice view of @\n \n Within a declaration, the C<&> sigil also declares the visibility of the\n subroutine name without the sigil within the scope of the declaration:\n@@ -1324,9 +1327,9 @@\n \n =item *\n \n-Slicing syntax is covered in S09.  Multidimensional\n-slices will be done with semicolons between individual slice subscripts.\n-Each such slice is evaluated lazily.\n+Slicing syntax is covered in S09.  A multidimensional\n+slice will be done with semicolons between individual slice sublists.\n+Each such slice sublist is evaluated lazily.\n \n =item *\n \n@@ -1422,9 +1425,17 @@\n than a punctuational variable.  This allows you to use sigils as coercion\n operators:\n \n-    print $( foo() )\n+    print $( foo() )    # foo called in item context\n+    print @@( foo() )   # foo called in slice context\n \n-It also allows the use of bare sigils as placeholders for anonymous variables:\n+The bare sigil is parsed as a list operator in rvalue context, so\n+these mean the same thing:\n+\n+    print $ foo()       # foo called in item context\n+    print @@ foo()      # foo called in slice context\n+\n+In declarative contexts bare sigils may be used as placeholders for\n+anonymous variables:\n \n     my ($a, $, $c) = 1..3;\n     print unless (state $)++;\n\nModified: doc/trunk/design/syn/S03.pod\n==============================================================================\n--- doc/trunk/design/syn/S03.pod\t(original)\n+++ doc/trunk/design/syn/S03.pod\tSat Jun  2 12:42:11 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 8 Mar 2004\n-  Last Modified: 29 May 2007\n+  Last Modified: 2 Jun 2007\n   Number: 3\n-  Version: 115\n+  Version: 116\n \n =head1 Overview\n \n@@ -729,16 +729,6 @@\n Note that, unlike in Perl 5, you must use the C<.meth> forms to default\n to C<$_> in Perl 6.\n \n-=item *\n-\n-The C contextualizer\n-\n-    item\n-\n-The new name for Perl 5's C contextualizer.  Equivalent to C<$()>.\n-We still call the values scalars, and talk about \"scalar operators\", but\n-scalar operators are those that put their arguments into item context.\n-\n =back\n \n =head2 Nonchaining binary precedence\n@@ -1297,40 +1287,80 @@\n \n Sigils as contextualizer listops\n \n-    $:\n-    @:\n-    %:\n-    &:\n-    @@:\n+    Sigil       Alpha variant\n+    -----       -------------\n+    $           item\n+    @           list\n+    @@          slice\n+    %           hash\n \n As listops, these look like terms from the left, but raise their\n precedence on the right sufficiently to govern list infix\n operators:\n \n-     $: 1,2 Z 3,4       # [[1,3],[2,4]]\n-     @: 1,2 Z 3,4       # 1,3,2,4\n-    @@: 1,2 Z 3,4       # [1,3],[2,4]\n-     %: 1,2 Z 3,4       # { 1 => 3, 2 => 4 }\n-\n-     $: 1,2 X 3,4      # [[1,3],[1,4],[2,3],[2,4]]\n-     @: 1,2 X 3,4      # 1,3,1,4,2,3,2,4\n-    @@: 1,2 X 3,4      # [1,3],[1,4],[2,3],[2,4]\n+     $ 1,2 Z 3,4       # [\\(1,3),\\(2,4)]\n+     @ 1,2 Z 3,4       # 1,3,2,4\n+    @@ 1,2 Z 3,4       # [1,3],[2,4]\n+     % 1,2 Z 3,4       # { 1 => 3, 2 => 4 }\n+\n+     $ 1,2 X 3,4      # [\\(1,3),\\(1,4),\\(2,3),\\(2,4)]\n+     @ 1,2 X 3,4      # 1,3,1,4,2,3,2,4\n+    @@ 1,2 X 3,4      # [1,3],[1,4],[2,3],[2,4]\n \n These can also influence the result of functions that returns lists of captures:\n \n-     $: map { $_, $_*2 }, ^4   # [[0,0],[1,2],[2,4],[3,6]]\n-     @: map { $_, $_*2 }, ^4   # 0,0,1,2,2,4,3,6\n-    @@: map { $_, $_*2 }, ^4   # [0,0],[1,2],[2,4],[3,6]\n-     %: map { $_, $_*2 }, ^4   # { 0 => 0, 1 => 2, 2 => 4, 3 => 6 }\n+     $ map { $_, $_*2 }, ^4   # [\\(0,0),\\(1,2),\\(2,4),\\(3,6)]\n+     @ map { $_, $_*2 }, ^4   # 0,0,1,2,2,4,3,6\n+    @@ map { $_, $_*2 }, ^4   # [0,0],[1,2],[2,4],[3,6]\n+     % map { $_, $_*2 }, ^4   # { 0 => 0, 1 => 2, 2 => 4, 3 => 6 }\n+\n+=item *\n+\n+The C contextualizer\n+\n+    item foo()\n+\n+The new name for Perl 5's C contextualizer.  Equivalent to C<$()>.\n+We still call the values scalars, and talk about \"scalar operators\", but\n+scalar operators are those that put their arguments into item context.\n+\n+If given a list, this function makes an C from it.  The function\n+is agnostic about any C in such a list.  (Use C<@> or C<@@>\n+below to force that one way or the other).\n \n =item *\n \n The C contextualizer\n \n-    list\n+    list foo()\n \n Forces the subsequent expression to be evaluated in list context.\n-Equivalent to C<@:>.\n+A list of Cs will be transformed into a flat list.\n+Equivalent to C<@()>.\n+\n+=item *\n+\n+The C contextualizer\n+\n+    slice foo()\n+\n+Forces the subsequent expression to be evaluated in slice context.\n+(Slices are considered to be potentially multidimensional in Perl 6.)\n+A list of Cs will be transformed into a list of lists.\n+Equivalent to C<@@()>.\n+\n+=item *\n+\n+The C contextualizer\n+\n+    hash foo()\n+\n+Forces the subsequent expression to be evaluated in hash context.\n+The expression is evaluated in list context (flattening any Cs),\n+then a hash will be created from the list, taken as a list of Cs.\n+(Any element in the list that is not a C will pretend to be a key\n+and grab the next value in the last as its value.)  Equivalent to\n+C<%()>.\n \n =back\n \n@@ -1408,10 +1438,11 @@\n     $x = 1; $y = 2;\n \n The context determines how the expressions terminated by semicolon\n-are interpreted.  At statement level they are statements.  Within\n-a bracketing construct they are interpreted as multidimension slices.\n-(Other contexts may have other interpretations or disallow semicolons\n-entirely.)\n+are interpreted.  At statement level they are statements.  Within a\n+bracketing construct they are interpreted as lists of Cs,\n+which in slice context will be treated as the multiple dimensions of a\n+multidimensional slice.  (Other contexts may have other interpretations\n+or disallow semicolons entirely.)\n \n =item *\n \n@@ -1482,7 +1513,7 @@\n \n Perl\u00a05's C<${...}>, C<@{...}>, C<%{...}>, etc. dereferencing\n forms are now C<$(...)>, C<@(...)>, C<%(...)>, etc. instead.\n-Listop-like forms are C<$:>, C<@:>, C<%:>, etc.\n+Listop-like forms use the bare sigil following by whitespace.\n \n =item *\n \n@@ -1759,7 +1790,7 @@\n right side is too short.  To force list assignment when a subscript\n would return a non-list, either put parens around the entire lvalue,\n or use a comma within the subscript.  (A semicolon in the subscript\n-also works to indicate multidimensional slices.)\n+also works to indicate a multidimensional slice.)\n \n Assuming\n \n@@ -3392,9 +3423,9 @@\n \n and remember the C<@> at the front until you get to the C<=>.\n \n-The empty C<[]> and C<.[]> postfix operators are interpreted as\n-zero-dimensional slices returning the entire array, not null slices\n-returning no elements.  Likewise for C<{}> and C<.{}> on hashes,\n+The empty C<[]> and C<.[]> postfix operators are interpreted as a\n+zero-dimensional slice returning the entire array, not as a one-dimensional\n+null slice returning no elements.  Likewise for C<{}> and C<.{}> on hashes,\n as well as the C<< <> >>, C<< .<> >>, C<\u00ab\u00bb>, and C<.\u00ab\u00bb> constant and\n interpolating slice subscripting forms.\n \n\nModified: doc/trunk/design/syn/S04.pod\n==============================================================================\n--- doc/trunk/design/syn/S04.pod\t(original)\n+++ doc/trunk/design/syn/S04.pod\tSat Jun  2 12:42:11 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 19 Aug 2004\n-  Last Modified: 28 May 2007\n+  Last Modified: 2 Jun 2007\n   Number: 4\n-  Version: 58\n+  Version: 59\n \n This document summarizes Apocalypse 4, which covers the block and\n statement syntax of Perl.\n@@ -255,9 +255,10 @@\n \n The value of a loop statement is the list of values from each\n iteration that successfully completed without a C or C.\n-(This list is actually a multidimensional list (a \"multislice\")\n-with dimensional boundaries at each iteration.  Most list contexts\n-ignore these boundaries and flatten the list.)  If you do not wish\n+(This list is actually a two-dimensional list of Captures (a \"slice\")\n+with dimensional boundaries at each iteration.  List context\n+ignores these boundaries and flattens the list.  Slice context turns\n+the captures into subarrays)  If you do not wish\n to accidentally return a list from the final loop statement in a\n subroutine, place an explicit return statement after it, or declare\n a return type of C.\n@@ -537,8 +538,8 @@\n is ignored when the C is in void context).  Regardless of the\n C's context, the C object is also added to the list of\n values being gathered, which is returned by the C in the form\n-of a lazy multislice, with each slice corresponding to one C\n-capture.  (A multislice is lazily flattened in normal list context,\n+of a lazy slice, with each slice element corresponding to one C\n+capture.  (A list of Cs is lazily flattened in normal list context,\n but you may \"unflatten\" it again with a C<@@()> contextualizer.)\n \n Because C evaluates its block or statement in void context,\n\nModified: doc/trunk/design/syn/S06.pod\n==============================================================================\n--- doc/trunk/design/syn/S06.pod\t(original)\n+++ doc/trunk/design/syn/S06.pod\tSat Jun  2 12:42:11 2007\n@@ -13,9 +13,9 @@\n \n   Maintainer: Larry Wall \n   Date: 21 Mar 2003\n-  Last Modified: 1 Jun 2007\n+  Last Modified: 2 Jun 2007\n   Number: 6\n-  Version: 87\n+  Version: 88\n \n \n This document summarizes Apocalypse 6, which covers subroutines and the\n@@ -294,7 +294,7 @@\n     sub circumfix:{'LEFTDELIM','RIGHTDELIM'} ($contents) {...}\n \n Contrary to Apocalypse 6, there is no longer any rule about splitting an even\n-number of characters.  You must use a two element slice.  Such names\n+number of characters.  You must use a two-element slice.  Such names\n are canonicalized to a single form within the symbol table, so you\n must use the canonical name if you wish to subscript the symbol table\n directly (as in C<< PKG::{'infix:<+>'} >>).  Otherwise any form will\n@@ -323,7 +323,7 @@\n     \n \n Whitespace may never be part of the name (except as separator\n-within a C<< <...> >> or C<\u00ab...\u00bb> slice, as in the example above).\n+within a C<< <...> >> or C<\u00ab...\u00bb> slice subscript, as in the example above).\n \n A null operator name does not define a null or whitespace operator, but\n a default matching subrule for that syntactic category, which is useful when\n@@ -807,18 +807,18 @@\n Some functions take more than one list of positional and/or named arguments,\n that they wish not to be flattened into one list.  For instance, C wants\n to iterate several lists in parallel, while array and hash subscripts want to\n-process multidimensional slices.  The set of underlying argument lists may be\n+process a multidimensional slice.  The set of underlying argument lists may be\n bound to a single array parameter declared with a double C<@@> sigil:\n \n-    sub foo (*@@slices) { ... }\n+    sub foo (*@@slice) { ... }\n \n Note that this is different from\n \n-    sub foo (\\$slices) { ... }\n+    sub foo (\\$slice) { ... }\n \n-insofar as C<\\$slices> is bound to a single argument-list object that\n+insofar as C<\\$slice> is bound to a single argument-list object that\n makes no commitment to processing its structure (and maybe doesn't\n-even know its own structure yet), while C<*@@slices> has to create\n+even know its own structure yet), while C<*@@slice> has to create\n an array that binds the incoming dimensional lists to the array's\n dimensions, and make that commitment visible to the rest of the scope\n via the sigil so that constructs expecting multidimensional lists\n@@ -826,15 +826,15 @@\n \n It is allowed to specify a return type:\n \n-    sub foo (*@@slices --> Num) { ... }\n+    sub foo (*@@slice --> Num) { ... }\n \n The invocant does not participate in multi-dimensional argument lists,\n-so C is not present in the C<@@slices> below:\n+so C is not present in the C<@@slice> below:\n \n-    method foo (*@@slices) { ... }\n+    method foo (*@@slice) { ... }\n \n-The C<@@> sigil is just a variant of the C<@> sigil, so C<@@slices>\n-and C<@slices> are really the same array.  In particular, C<@@_> is\n+The C<@@> sigil is just a variant of the C<@> sigil, so C<@@slice>\n+and C<@slice> are really the same array.  In particular, C<@@_> is\n really the good old C<@_> array viewed as multidimensional.\n \n =head2 Zero-dimensional argument list\n@@ -843,9 +843,9 @@\n argument list becomes a zero-dimensional slice.  It differs from\n C<\\()> in several ways:\n \n-    sub foo (*@@slices) {...}\n-    foo;        # +@@slices == 0\n-    foo();      # +@@slices == 1\n+    sub foo (*@@slice) {...}\n+    foo;        # +@@slice == 0\n+    foo();      # +@@slice == 1\n \n     sub bar (\\$args = \\(1,2,3)) {...}\n     bar;        # $args === \\(1,2,3)\n@@ -1016,8 +1016,8 @@\n sometimes you want to capture the outputs as a list of two iterators,\n namely the two iterators that represent the two input feeds.  You can\n get at those two iterators by using the name C<@@foo> instead, where\n-the \"multislice\" twigil marks a multidimensional array, that is, an\n-array of slices.\n+the \"slice\" sigil marks a multidimensional array, that is, an\n+array of lists, each of which may be treated independently.\n \n     0..*       ==>  @@foo;\n     'a'..*     ==>> @@foo;\n@@ -1583,9 +1583,9 @@\n     type_declarator:\n     version:\n \n-The existing operator may be specified either as a function name\n-or as a string slice equivalent to the one that would be used in\n-the complete function name.  In string slice form the syntactic\n+The existing operator may be specified either as a function object\n+or as a string argument equivalent to the one that would be used in\n+the complete function name.  In string form the syntactic\n category will be assumed to be the same as the new declaration.\n Therefore these all have the same effect:\n \n\nModified: doc/trunk/design/syn/S09.pod\n==============================================================================\n--- doc/trunk/design/syn/S09.pod\t(original)\n+++ doc/trunk/design/syn/S09.pod\tSat Jun  2 12:42:11 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 13 Sep 2004\n-  Last Modified: 4 Apr 2007\n+  Last Modified: 2 Jun 2007\n   Number: 9\n-  Version: 20\n+  Version: 21\n \n =head1 Overview\n \n@@ -301,7 +301,7 @@\n \n     my @calendar[12;*;24];     # day-of-month dimension unlimited/ragged\n \n-You can pass a multislice for the shape as well:\n+You can pass a slice (of any dimensionality) for the shape as well:\n \n     @@shape = (4;2);\n     my int @ints[ [;]@shape ];\n@@ -350,12 +350,12 @@\n \n     @array.postcircumfix:<[ ]>( <== @x[0] <== @x[1] <== @x[2]..*);\n \n-Alternately, use a multislice array, indicated by a double C<@@> sigil:\n+Alternately, use a slice array, indicated by a double C<@@> sigil:\n \n     @array[@@x]\n \n Multislice arrays can keep track of their dimensionality as they\n-are being defined.  Use of multislice syntax can then pull out those\n+are being defined.  Use of slice array syntax can then pull out those\n distinct dimensions:\n \n     my @@x;\n@@ -751,9 +751,9 @@\n \n =head1 Subscript and slice notation\n \n-A subscript indicates a \"slice\" of an array.  Each dimension\n-of an array is sliced separately, so we say a subscript is a\n-semicolon-separated list of slice specifiers, also known as a multislice.\n+A subscript indicates a \"slice\" of an array.  Each dimension of an\n+array is sliced separately, so a multidimensional slice subscript\n+may be supplied as a semicolon-separated list of slice sublists.\n A three-dimensional slice might look like this:\n \n     @x[0..10; 1,0; 1..*:by(2)]\n@@ -773,16 +773,18 @@\n =head1 The semicolon operator\n \n At the statement level, a semicolon terminates the current expression.\n-Within any kind of bracketing construct, semicolon notionally\n-separates slices, the interpretation of which depends on\n-the context.  Such a semicolon list always provides list context to\n-each of its sublists.  The storage of these sublists is hidden in\n-the inner workings of the list.  It does not produce a list of lists. \n+Within any kind of bracketing construct, semicolon notionally separates\n+the sublists of a multidimensional slice, the interpretation of\n+which depends on the context.  Such a semicolon list puts each of its\n+sublists into a Capture, deferring the context of the sublist until\n+it is bound somewhere.  The storage of these sublists is hidden in\n+the inner workings of the list.  It does not produce a list of lists\n+unless the list as a whole is bound into a slice context.\n \n Single dimensional arrays expect simple slice subscripts, meaning\n they will treat a list subscript as a slice in the single dimension of\n the array.  Multi-dimensional arrays, on the other hand, know how to\n-handle multiple slices, one for each dimension.  You need not specify\n+handle a multidimensional slice, with one subslice for each dimension.  You need not specify\n all the dimensions; if you don't, the unspecified dimensions are\n \"wildcarded\".  Supposing you have:\n \n\nModified: doc/trunk/design/syn/S13.pod\n==============================================================================\n--- doc/trunk/design/syn/S13.pod\t(original)\n+++ doc/trunk/design/syn/S13.pod\tSat Jun  2 12:42:11 2007\n@@ -12,9 +12,9 @@\n \n   Maintainer: Larry Wall \n   Date: 2 Nov 2004\n-  Last Modified: 24 Apr 2007\n+  Last Modified: 2 Jun 2007\n   Number: 13\n-  Version: 8\n+  Version: 9\n \n =head1 Overview\n \n@@ -147,14 +147,14 @@\n routine, array, or hash.  The long forms are as follows:\n \n     method postcircumfix:<( )> (|$capture) {...}\n-    method postcircumfix:<[ ]> (*@@slices) {...}\n-    method postcircumfix:<{ }> (*@@slices) {...}\n+    method postcircumfix:<[ ]> (*@@slice) {...}\n+    method postcircumfix:<{ }> (*@@slice) {...}\n \n Those are a bit unwieldy, so you may also use these short forms:\n \n     method &.( |$capture ) {...}\n-    method @.[ *@@slices ] {...}\n-    method %.{ *@@slices } {...}\n+    method @.[ *@@slice ] {...}\n+    method %.{ *@@slice } {...}\n \n The sigil-dot sequence in these short forms autogenerates the\n corresponding public operators, in exactly the same way that\n\n"}
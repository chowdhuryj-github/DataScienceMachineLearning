{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "abartlet@samba.org", "subject": "svn commit: samba r22967 - in\n\tbranches/SAMBA_4_0/source/auth/kerberos: .", "body": "Author: abartlet\nDate: 2007-05-17 05:46:45 +0000 (Thu, 17 May 2007)\nNew Revision: 22967\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=22967\n\nLog:\nMove to the TCP packet interface for the krb5_send_to_kdc plugin.\n\nThis replaces a lump of hand-crafted code with the generic packet\nsystem used in the rest of Samba4.\n\n(I started this while chasing down the epoll bug, which turned out to\nbe seperate)\n\n\nModified:\n   branches/SAMBA_4_0/source/auth/kerberos/krb5_init_context.c\n\n\nChangeset:\nModified: branches/SAMBA_4_0/source/auth/kerberos/krb5_init_context.c\n===================================================================\n--- branches/SAMBA_4_0/source/auth/kerberos/krb5_init_context.c\t2007-05-17 05:44:51 UTC (rev 22966)\n+++ branches/SAMBA_4_0/source/auth/kerberos/krb5_init_context.c\t2007-05-17 05:46:45 UTC (rev 22967)\n@@ -26,6 +26,7 @@\n #include \"heimdal/lib/krb5/krb5_locl.h\"\n #include \"auth/kerberos/kerberos.h\"\n #include \"lib/socket/socket.h\"\n+#include \"lib/stream/packet.h\"\n #include \"system/network.h\"\n #include \"lib/events/events.h\"\n #include \"roken.h\"\n@@ -39,9 +40,10 @@\n \t/* the fd event */\n \tstruct fd_event *fde;\n \n-\tBOOL timeout;\n \tNTSTATUS status;\n-\tDATA_BLOB request, reply, partial;\n+\tDATA_BLOB request, reply;\n+\t\n+\tstruct packet_context *packet;\n \n \tsize_t partial_read;\n \n@@ -82,100 +84,50 @@\n \tDATA_BLOB blob;\n \tsize_t nread, dsize;\n \n-\tswitch (smb_krb5->hi->proto) {\n-\tcase KRB5_KRBHST_UDP:\n-\t\tsmb_krb5->status = socket_pending(smb_krb5->sock, &dsize);\n-\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n-\t\t\ttalloc_free(tmp_ctx);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tblob = data_blob_talloc(tmp_ctx, NULL, dsize);\n-\t\tif (blob.data == NULL && dsize != 0) {\n-\t\t\tsmb_krb5->status = NT_STATUS_NO_MEMORY;\n-\t\t\ttalloc_free(tmp_ctx);\n-\t\t\treturn;\n-\t\t}\n-\t\t\n-\t\tsmb_krb5->status = socket_recv(smb_krb5->sock, blob.data, blob.length, &nread);\n-\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n-\t\t\ttalloc_free(tmp_ctx);\n-\t\t\treturn;\n-\t\t}\n-\t\tblob.length = nread;\n-\n-\t\tif (nread == 0) {\n-\t\t\tsmb_krb5->status = NT_STATUS_UNEXPECTED_NETWORK_ERROR;\n-\t\t\ttalloc_free(tmp_ctx);\n-\t\t\treturn;\n-\t\t}\n-\t\t\n-\t\tDEBUG(2,(\"Received smb_krb5 packet of length %d\\n\", \n-\t\t\t (int)blob.length));\n-\t\t\n-\t\ttalloc_steal(smb_krb5, blob.data);\n-\t\tsmb_krb5->reply = blob;\n+\tsmb_krb5->status = socket_pending(smb_krb5->sock, &dsize);\n+\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n \t\ttalloc_free(tmp_ctx);\n-\t\tbreak;\n-\tcase KRB5_KRBHST_TCP:\n-\t\tif (smb_krb5->partial.length == 0) {\n-\t\t\tsmb_krb5->partial = data_blob_talloc(smb_krb5, NULL, 4);\n-\t\t\tif (!smb_krb5->partial.data) {\n-\t\t\t\tsmb_krb5->status = NT_STATUS_NO_MEMORY;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t\n-\t\t\tsmb_krb5->partial_read = 0;\n-\t\t}\n-\t\t\n-\t\t/* read in the packet length */\n-\t\tif (smb_krb5->partial_read < 4) {\n-\t\t\tuint32_t packet_length;\n-\t\t\t\n-\t\t\tsmb_krb5->status = socket_recv(smb_krb5->sock, \n-\t\t\t\t\t     smb_krb5->partial.data + smb_krb5->partial_read,\n-\t\t\t\t\t     4 - smb_krb5->partial_read,\n-\t\t\t\t\t     &nread);\n-\t\t\t/* todo: this should be converted to the packet_*() routines */\n-\t\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t\n-\t\t\tsmb_krb5->partial_read += nread;\n-\t\t\tif (smb_krb5->partial_read != 4) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t\n-\t\t\tpacket_length = RIVAL(smb_krb5->partial.data, 0);\n-\t\t\t\n-\t\t\tsmb_krb5->partial.data = talloc_realloc(smb_krb5, smb_krb5->partial.data, \n-\t\t\t\t\t\t\t\tuint8_t, packet_length + 4);\n-\t\t\tif (!smb_krb5->partial.data)  {\n-\t\t\t\tsmb_krb5->status = NT_STATUS_NO_MEMORY;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t\n-\t\t\tsmb_krb5->partial.length = packet_length + 4;\n-\t\t}\n-\t\t\n-\t\t/* read in the body */\n-\t\tsmb_krb5->status = socket_recv(smb_krb5->sock, \n-\t\t\t\t     smb_krb5->partial.data + smb_krb5->partial_read,\n-\t\t\t\t     smb_krb5->partial.length - smb_krb5->partial_read,\n-\t\t\t\t     &nread);\n-\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) return;\n-\t\t\n-\t\tsmb_krb5->partial_read += nread;\n-\n-\t\tif (smb_krb5->partial_read != smb_krb5->partial.length) return;\n-\n-\t\tsmb_krb5->reply = data_blob_talloc(smb_krb5, smb_krb5->partial.data + 4, smb_krb5->partial.length - 4);\n-\t\tbreak;\n-\tcase KRB5_KRBHST_HTTP:\n \t\treturn;\n \t}\n+\t\n+\tblob = data_blob_talloc(tmp_ctx, NULL, dsize);\n+\tif (blob.data == NULL && dsize != 0) {\n+\t\tsmb_krb5->status = NT_STATUS_NO_MEMORY;\n+\t\ttalloc_free(tmp_ctx);\n+\t\treturn;\n+\t}\n+\t\n+\tsmb_krb5->status = socket_recv(smb_krb5->sock, blob.data, blob.length, &nread);\n+\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n+\t\ttalloc_free(tmp_ctx);\n+\t\treturn;\n+\t}\n+\tblob.length = nread;\n+\t\n+\tif (nread == 0) {\n+\t\tsmb_krb5->status = NT_STATUS_UNEXPECTED_NETWORK_ERROR;\n+\t\ttalloc_free(tmp_ctx);\n+\t\treturn;\n+\t}\n+\t\n+\tDEBUG(2,(\"Received smb_krb5 packet of length %d\\n\", \n+\t\t (int)blob.length));\n+\t\n+\ttalloc_steal(smb_krb5, blob.data);\n+\tsmb_krb5->reply = blob;\n+\ttalloc_free(tmp_ctx);\n }\n \n+static NTSTATUS smb_krb5_full_packet(void *private, DATA_BLOB data) \n+{\n+\tstruct smb_krb5_socket *smb_krb5 = talloc_get_type(private, struct smb_krb5_socket);\n+\ttalloc_steal(smb_krb5, data.data);\n+\tsmb_krb5->reply = data;\n+\tsmb_krb5->reply.length -= 4;\n+\tsmb_krb5->reply.data += 4;\n+\treturn NT_STATUS_OK;\n+}\n+\n /*\n   handle request timeouts\n */\n@@ -185,9 +137,15 @@\n {\n \tstruct smb_krb5_socket *smb_krb5 = talloc_get_type(private, struct smb_krb5_socket);\n \tDEBUG(5,(\"Timed out smb_krb5 packet\\n\"));\n-\tsmb_krb5->timeout = True;\n+\tsmb_krb5->status = NT_STATUS_IO_TIMEOUT;\n }\n \n+static void smb_krb5_error_handler(void *private, NTSTATUS status) \n+{\n+\tstruct smb_krb5_socket *smb_krb5 = talloc_get_type(private, struct smb_krb5_socket);\n+\tsmb_krb5->status = status;\n+}\n+\n /*\n   handle send events on a smb_krb5 socket\n */\n@@ -216,11 +174,26 @@\n \t\t\t\t uint16_t flags, void *private)\n {\n \tstruct smb_krb5_socket *smb_krb5 = talloc_get_type(private, struct smb_krb5_socket);\n-\tif (flags & EVENT_FD_WRITE) {\n-\t\tsmb_krb5_socket_send(smb_krb5);\n-\t} \n-\tif (flags & EVENT_FD_READ) {\n-\t\tsmb_krb5_socket_recv(smb_krb5);\n+\tswitch (smb_krb5->hi->proto) {\n+\tcase KRB5_KRBHST_UDP:\n+\t\tif (flags & EVENT_FD_WRITE) {\n+\t\t\tsmb_krb5_socket_send(smb_krb5);\n+\t\t} \n+\t\tif (flags & EVENT_FD_READ) {\n+\t\t\tsmb_krb5_socket_recv(smb_krb5);\n+\t\t}\n+\t\tbreak;\n+\tcase KRB5_KRBHST_TCP:\n+\t\tif (flags & EVENT_FD_READ) {\n+\t\t\tpacket_recv(smb_krb5->packet);\n+\t\t}\n+\t\tif (flags & EVENT_FD_WRITE) {\n+\t\t\tpacket_queue_run(smb_krb5->packet);\n+\t\t}\n+\t\tbreak;\n+\tcase KRB5_KRBHST_HTTP:\n+\t\t/* can't happen */\n+\t\tbreak;\n \t}\n }\n \n@@ -304,7 +277,7 @@\n \t\t}\n \t\ttalloc_free(remote_addr);\n \n-\t\tsmb_krb5->fde = event_add_fd(ev, smb_krb5, \n+\t\tsmb_krb5->fde = event_add_fd(ev, smb_krb5->sock, \n \t\t\t\t\t     socket_get_fd(smb_krb5->sock), \n \t\t\t\t\t     EVENT_FD_AUTOCLOSE,\n \t\t\t\t\t     smb_krb5_socket_handler, smb_krb5);\n@@ -315,39 +288,53 @@\n \t\t\t\ttimeval_current_ofs(context->kdc_timeout, 0),\n \t\t\t\tsmb_krb5_request_timeout, smb_krb5);\n \n-\t\tEVENT_FD_WRITEABLE(smb_krb5->fde);\n \t\t\n+\t\tsmb_krb5->status = NT_STATUS_OK;\n+\t\tsmb_krb5->reply = data_blob(NULL, 0);\n+\n \t\tswitch (hi->proto) {\n \t\tcase KRB5_KRBHST_UDP:\n+\t\t\tEVENT_FD_WRITEABLE(smb_krb5->fde);\n \t\t\tsmb_krb5->request = send_blob;\n \t\t\tbreak;\n \t\tcase KRB5_KRBHST_TCP:\n+\n+\t\t\tsmb_krb5->packet = packet_init(smb_krb5);\n+\t\t\tif (smb_krb5->packet == NULL) {\n+\t\t\t\ttalloc_free(smb_krb5);\n+\t\t\t\treturn ENOMEM;\n+\t\t\t}\n+\t\t\tpacket_set_private(smb_krb5->packet, smb_krb5);\n+\t\t\tpacket_set_socket(smb_krb5->packet, smb_krb5->sock);\n+\t\t\tpacket_set_callback(smb_krb5->packet, smb_krb5_full_packet);\n+\t\t\tpacket_set_full_request(smb_krb5->packet, packet_full_request_u32);\n+\t\t\tpacket_set_error_handler(smb_krb5->packet, smb_krb5_error_handler);\n+\t\t\tpacket_set_event_context(smb_krb5->packet, ev);\n+\t\t\tpacket_set_fde(smb_krb5->packet, smb_krb5->fde);\n+\n \t\t\tsmb_krb5->request = data_blob_talloc(smb_krb5, NULL, send_blob.length + 4);\n \t\t\tRSIVAL(smb_krb5->request.data, 0, send_blob.length);\n \t\t\tmemcpy(smb_krb5->request.data+4, send_blob.data, send_blob.length);\n+\t\t\tpacket_send(smb_krb5->packet, smb_krb5->request);\n+\t\t\tEVENT_FD_READABLE(smb_krb5->fde);\n \t\t\tbreak;\n \t\tcase KRB5_KRBHST_HTTP:\n \t\t\ttalloc_free(smb_krb5);\n \t\t\treturn EINVAL;\n \t\t}\n-\t\tsmb_krb5->timeout = False;\n-\t\tsmb_krb5->status = NT_STATUS_OK;\n-\t\tsmb_krb5->reply = data_blob(NULL, 0);\n-\t\tsmb_krb5->partial = data_blob(NULL, 0);\n-\n-\t\twhile (!smb_krb5->timeout && (NT_STATUS_IS_OK(smb_krb5->status)) && !smb_krb5->reply.length) {\n+\t\twhile ((NT_STATUS_IS_OK(smb_krb5->status)) && !smb_krb5->reply.length) {\n \t\t\tif (event_loop_once(ev) != 0) {\n \t\t\t\ttalloc_free(smb_krb5);\n \t\t\t\treturn EINVAL;\n \t\t\t}\n \t\t}\n-\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n-\t\t\tDEBUG(2,(\"Error reading smb_krb5 reply packet: %s\\n\", nt_errstr(smb_krb5->status)));\n+\t\tif (NT_STATUS_EQUAL(smb_krb5->status, NT_STATUS_IO_TIMEOUT)) {\n \t\t\ttalloc_free(smb_krb5);\n \t\t\tcontinue;\n \t\t}\n \n-\t\tif (smb_krb5->timeout) {\n+\t\tif (!NT_STATUS_IS_OK(smb_krb5->status)) {\n+\t\t\tDEBUG(2,(\"Error reading smb_krb5 reply packet: %s\\n\", nt_errstr(smb_krb5->status)));\n \t\t\ttalloc_free(smb_krb5);\n \t\t\tcontinue;\n \t\t}\n\n"}
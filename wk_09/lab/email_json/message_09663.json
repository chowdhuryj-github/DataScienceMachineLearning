{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "tridge@samba.org", "subject": "Rev 165: - split out ctdb_ltdb_lock_fetch_requeue() into a simpler\n\tin http://samba.org/~tridge/ctdb", "body": "------------------------------------------------------------\nrevno: 165\nrevision-id: tridge@samba.org-20070419074327-cdc474844a1e1d90\nparent: tridge@samba.org-20070419062756-3173365728e1cd4f\ncommitter: Andrew Tridgell \nbranch nick: tridge\ntimestamp: Thu 2007-04-19 17:43:27 +1000\nmessage:\n  - split out ctdb_ltdb_lock_fetch_requeue() into a simpler\n    ctdb_ltdb_lock_requeue() and a small wrapper\n  \n  - use ctdb_ltdb_lock_requeue() to fix a possible hang in\n    ctdb_reply_dmaster(), where the ctdb_ltdb_store() could hang waiting\n    for a client. We now requeue the reply_dmaster packet until we have\n    the lock\nmodified:\n  common/ctdb_call.c             ctdb_call.c-20061128065342-to93h6eejj5kon81-1\n  common/ctdb_ltdb.c             ctdb_ltdb.c-20061128065342-to93h6eejj5kon81-2\n  include/ctdb_private.h         ctdb_private.h-20061117234101-o3qt14umlg9en8z0-13\n=== modified file 'common/ctdb_call.c'\n--- a/common/ctdb_call.c\t2007-04-19 06:27:56 +0000\n+++ b/common/ctdb_call.c\t2007-04-19 07:43:27 +0000\n@@ -314,7 +314,9 @@\n \tmemcpy(&r->data[0], data.dptr, data.dsize);\n \n \tif (r->hdr.destnode == r->hdr.srcnode) {\n-\t\tctdb_reply_dmaster(ctdb, &r->hdr);\n+\t\t/* inject the packet back into the input queue */\n+\t\ttalloc_steal(ctdb, r);\n+\t\tctdb_recv_pkt(ctdb, (uint8_t *)&r->hdr, r->hdr.length);\n \t} else {\n \t\tctdb_queue_packet(ctdb, &r->hdr);\n \t}\n@@ -456,6 +458,7 @@\n \tstruct ctdb_call_state *state;\n \tstruct ctdb_db_context *ctdb_db;\n \tTDB_DATA data;\n+\tint ret;\n \n \tstate = idr_find_type(ctdb->idr, hdr->reqid, struct ctdb_call_state);\n \tif (state == NULL) {\n@@ -464,6 +467,16 @@\n \n \tctdb_db = state->ctdb_db;\n \n+\tret = ctdb_ltdb_lock_requeue(ctdb_db, state->call.key, hdr,\n+\t\t\t\t     ctdb_recv_raw_pkt, ctdb);\n+\tif (ret == -2) {\n+\t\treturn;\n+\t}\n+\tif (ret != 0) {\n+\t\tDEBUG(0,(__location__ \" Failed to get lock in ctdb_reply_dmaster\\n\"));\n+\t\treturn;\n+\t}\n+\n \tdata.dptr = c->data;\n \tdata.dsize = c->datalen;\n \n@@ -474,12 +487,15 @@\n \tstate->header.dmaster = ctdb->vnn;\n \n \tif (ctdb_ltdb_store(ctdb_db, state->call.key, &state->header, data) != 0) {\n+\t\tctdb_ltdb_unlock(ctdb_db, state->call.key);\n \t\tctdb_fatal(ctdb, \"ctdb_reply_dmaster store failed\\n\");\n \t\treturn;\n \t}\n \n \tctdb_call_local(ctdb_db, &state->call, &state->header, &data, ctdb->vnn);\n \n+\tctdb_ltdb_unlock(ctdb_db, state->call.key);\n+\n \ttalloc_steal(state, state->call.reply_data.dptr);\n \n \tstate->state = CTDB_CALL_DONE;\n\n=== modified file 'common/ctdb_ltdb.c'\n--- a/common/ctdb_ltdb.c\t2007-04-19 06:27:56 +0000\n+++ b/common/ctdb_ltdb.c\t2007-04-19 07:43:27 +0000\n@@ -244,14 +244,14 @@\n \tDEBUG(2,(__location__ \" PACKET REQUEUED\\n\"));\n }\n \n+\n /*\n-  do a non-blocking ltdb_fetch with a locked record, deferring this\n-  ctdb request until we have the chainlock\n+  do a non-blocking ltdb_lock, deferring this ctdb request until we\n+  have the chainlock\n \n   It does the following:\n \n-   1) tries to get the chainlock. If it succeeds, then it fetches the record, and \n-      returns 0\n+   1) tries to get the chainlock. If it succeeds, then it returns 0\n \n    2) if it fails to get a chainlock immediately then it sets up a\n    non-blocking chainlock via ctdb_lockwait, and when it gets the\n@@ -269,11 +269,10 @@\n       -1:    means that it failed to get the lock, and won't retry\n       -2:    means that it failed to get the lock immediately, but will retry\n  */\n-int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n-\t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n-\t\t\t\t struct ctdb_req_header *hdr, TDB_DATA *data,\n-\t\t\t\t void (*recv_pkt)(void *, uint8_t *, uint32_t ),\n-\t\t\t\t void *recv_context)\n+int ctdb_ltdb_lock_requeue(struct ctdb_db_context *ctdb_db, \n+\t\t\t   TDB_DATA key, struct ctdb_req_header *hdr,\n+\t\t\t   void (*recv_pkt)(void *, uint8_t *, uint32_t ),\n+\t\t\t   void *recv_context)\n {\n \tint ret;\n \tstruct tdb_context *tdb = ctdb_db->ltdb->tdb;\n@@ -297,11 +296,7 @@\n \n \t/* first the non-contended path */\n \tif (ret == 0) {\n-\t\tret = ctdb_ltdb_fetch(ctdb_db, key, header, hdr, data);\n-\t\tif (ret != 0) {\n-\t\t\ttdb_chainunlock(tdb, key);\n-\t\t}\t\n-\t\treturn ret;\n+\t\treturn 0;\n \t}\n \n \tstate = talloc(ctdb_db, struct lock_fetch_state);\n@@ -325,3 +320,24 @@\n \t/* now tell the caller than we will retry asynchronously */\n \treturn -2;\n }\n+\n+/*\n+  a varient of ctdb_ltdb_lock_requeue that also fetches the record\n+ */\n+int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n+\t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n+\t\t\t\t struct ctdb_req_header *hdr, TDB_DATA *data,\n+\t\t\t\t void (*recv_pkt)(void *, uint8_t *, uint32_t ),\n+\t\t\t\t void *recv_context)\n+{\n+\tint ret;\n+\n+\tret = ctdb_ltdb_lock_requeue(ctdb_db, key, hdr, recv_pkt, recv_context);\n+\tif (ret == 0) {\n+\t\tret = ctdb_ltdb_fetch(ctdb_db, key, header, hdr, data);\n+\t\tif (ret != 0) {\n+\t\t\tctdb_ltdb_unlock(ctdb_db, key);\n+\t\t}\n+\t}\n+\treturn ret;\n+}\n\n=== modified file 'include/ctdb_private.h'\n--- a/include/ctdb_private.h\t2007-04-19 06:27:56 +0000\n+++ b/include/ctdb_private.h\t2007-04-19 07:43:27 +0000\n@@ -341,6 +341,10 @@\n int ctdb_ltdb_store(struct ctdb_db_context *ctdb_db, TDB_DATA key, \n \t\t    struct ctdb_ltdb_header *header, TDB_DATA data);\n void ctdb_queue_packet(struct ctdb_context *ctdb, struct ctdb_req_header *hdr);\n+int ctdb_ltdb_lock_requeue(struct ctdb_db_context *ctdb_db, \n+\t\t\t   TDB_DATA key, struct ctdb_req_header *hdr,\n+\t\t\t   void (*recv_pkt)(void *, uint8_t *, uint32_t ),\n+\t\t\t   void *recv_context);\n int ctdb_ltdb_lock_fetch_requeue(struct ctdb_db_context *ctdb_db, \n \t\t\t\t TDB_DATA key, struct ctdb_ltdb_header *header, \n \t\t\t\t struct ctdb_req_header *hdr, TDB_DATA *data,\n\n"}
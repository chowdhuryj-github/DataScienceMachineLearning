{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "jpeach@samba.org", "subject": "svn commit: samba r23395 - in branches/SAMBA_3_0_26/source: lib smbd", "body": "Author: jpeach\nDate: 2007-06-08 22:39:04 +0000 (Fri, 08 Jun 2007)\nNew Revision: 23395\n\nWebSVN: http://websvn.samba.org/cgi-bin/viewcvs.cgi?view=rev&root=samba&rev=23395\n\nLog:\nMerge branches/SAMBA_3_0@23393\n\nSupport BSD group semantics by making sure that the effective GID\nis always passed as the first GID when calling setgroups(2).\n\nModified:\n   branches/SAMBA_3_0_26/source/lib/system.c\n   branches/SAMBA_3_0_26/source/lib/system_smbd.c\n   branches/SAMBA_3_0_26/source/smbd/sec_ctx.c\n\n\nChangeset:\nModified: branches/SAMBA_3_0_26/source/lib/system.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/system.c\t2007-06-08 22:36:46 UTC (rev 23394)\n+++ branches/SAMBA_3_0_26/source/lib/system.c\t2007-06-08 22:39:04 UTC (rev 23395)\n@@ -889,15 +889,13 @@\n }\n \n /**************************************************************************\n- Wrapper for getgroups. Deals with broken (int) case.\n+ Wrap setgroups and getgroups for systems that declare getgroups() as\n+ returning an array of gid_t, but actuall return an array of int.\n ****************************************************************************/\n \n-int sys_getgroups(int setlen, gid_t *gidset)\n+#if defined(HAVE_BROKEN_GETGROUPS)\n+static int sys_broken_getgroups(int setlen, gid_t *gidset)\n {\n-#if !defined(HAVE_BROKEN_GETGROUPS)\n-\treturn getgroups(setlen, gidset);\n-#else\n-\n \tGID_T gid;\n \tGID_T *group_list;\n \tint i, ngroups;\n@@ -919,7 +917,7 @@\n \tif (setlen == 0)\n \t\tsetlen = groups_max();\n \n-\tif((group_list = (GID_T *)malloc(setlen * sizeof(GID_T))) == NULL) {\n+\tif((group_list = SMB_MALLOC_ARRAY(GID_T, setlen)) == NULL) {\n \t\tDEBUG(0,(\"sys_getgroups: Malloc fail.\\n\"));\n \t\treturn -1;\n \t}\n@@ -936,26 +934,10 @@\n \n \tSAFE_FREE(group_list);\n \treturn ngroups;\n-#endif /* HAVE_BROKEN_GETGROUPS */\n }\n \n-\n-/**************************************************************************\n- Wrapper for setgroups. Deals with broken (int) case. Automatically used\n- if we have broken getgroups.\n-****************************************************************************/\n-\n-int sys_setgroups(int setlen, gid_t *gidset)\n+static int sys_broken_setgroups(gid_t primary_gid, int setlen, gid_t *gidset)\n {\n-#if !defined(HAVE_SETGROUPS)\n-\terrno = ENOSYS;\n-\treturn -1;\n-#endif /* HAVE_SETGROUPS */\n-\n-#if !defined(HAVE_BROKEN_GETGROUPS)\n-\treturn setgroups(setlen, gidset);\n-#else\n-\n \tGID_T *group_list;\n \tint i ; \n \n@@ -972,7 +954,7 @@\n \t * GID_T array of size setlen.\n \t */\n \n-\tif((group_list = (GID_T *)malloc(setlen * sizeof(GID_T))) == NULL) {\n+\tif((group_list = SMB_MALLOC_ARRAY(GID_T, setlen)) == NULL) {\n \t\tDEBUG(0,(\"sys_setgroups: Malloc fail.\\n\"));\n \t\treturn -1;    \n \t}\n@@ -989,10 +971,104 @@\n  \n \tSAFE_FREE(group_list);\n \treturn 0 ;\n+}\n+\n #endif /* HAVE_BROKEN_GETGROUPS */\n+\n+/* This is a list of systems that require the first GID passed to setgroups(2)\n+ * to be the effective GID. If your system is one of these, add it here.\n+ */\n+#if defined (FREEBSD) || defined (DARWINOS)\n+#define USE_BSD_SETGROUPS\n+#endif\n+\n+#if defined(USE_BSD_SETGROUPS)\n+/* Depending on the particular BSD implementation, the first GID that is\n+ * passed to setgroups(2) will either be ignored or will set the credential's\n+ * effective GID. In either case, the right thing to do is to guarantee that\n+ * gidset[0] is the effective GID.\n+ */\n+static int sys_bsd_setgroups(gid_t primary_gid, int setlen, const gid_t *gidset)\n+{\n+\tgid_t *new_gidset = NULL;\n+\tint max;\n+\tint ret;\n+\n+\t/* setgroups(2) will fail with EINVAL if we pass too many groups. */\n+\tmax = groups_max();\n+\n+\t/* No group list, just make sure we are setting the efective GID. */\n+\tif (setlen == 0) {\n+\t\treturn setgroups(1, &primary_gid);\n+\t}\n+\n+\t/* If the primary gid is not the first array element, grow the array\n+\t * and insert it at the front.\n+\t */\n+\tif (gidset[0] != primary_gid) {\n+\t        gid_t *new_gidset;\n+\n+\t        new_gidset = SMB_MALLOC_ARRAY(gid_t, setlen + 1);\n+\t        if (new_gidset == NULL) {\n+\t\t\treturn -1;\n+\t        }\n+\n+\t\tmemcpy(new_gidset + 1, gidset, ((setlen + 1) * sizeof(gid_t)));\n+\t\tnew_gidset[0] = primary_gid;\n+\t\tsetlen++;\n+\t}\n+\n+#if defined(BROKEN_GETGROUPS)\n+\tret = sys_broken_setgroups(max, new_gidset ? new_gidset : gidset);\n+#else\n+\tret = setgroups(max, new_gidset ? new_gidset : gidset);\n+#endif\n+\n+\tif (new_gidset) {\n+\t\tint errsav = errno;\n+\t\tSAFE_FREE(new_gidset);\n+\t\terrno = errsav;\n+\t}\n+\n+\treturn ret;\n }\n \n+#endif /* USE_BSD_SETGROUPS */\n+\n /**************************************************************************\n+ Wrapper for getgroups. Deals with broken (int) case.\n+****************************************************************************/\n+\n+int sys_getgroups(int setlen, gid_t *gidset)\n+{\n+#if defined(HAVE_BROKEN_GETGROUPS)\n+\treturn sys_broken_getgroups(setlen, gidset);\n+#else\n+\treturn getgroups(setlen, gidset);\n+#endif\n+}\n+\n+/**************************************************************************\n+ Wrapper for setgroups. Deals with broken (int) case and BSD case.\n+****************************************************************************/\n+\n+int sys_setgroups(gid_t UNUSED(primary_gid), int setlen, gid_t *gidset)\n+{\n+#if !defined(HAVE_SETGROUPS)\n+\terrno = ENOSYS;\n+\treturn -1;\n+#endif /* HAVE_SETGROUPS */\n+\n+#if defined(HAVE_BROKEN_GETGROUPS)\n+\treturn sys_broken_setgroups(setlen, gidset);\n+#elif defined(USE_BSD_SETGROUPS)\n+\treturn sys_bsd_setgroups(primary_gid, setlen, gidset);\n+#else\n+\treturn setgroups(setlen, gidset);\n+#endif\n+}\n+\n+/**************************************************************************\n  Wrappers for setpwent(), getpwent() and endpwent()\n ****************************************************************************/\n \n\nModified: branches/SAMBA_3_0_26/source/lib/system_smbd.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/lib/system_smbd.c\t2007-06-08 22:36:46 UTC (rev 23394)\n+++ branches/SAMBA_3_0_26/source/lib/system_smbd.c\t2007-06-08 22:39:04 UTC (rev 23395)\n@@ -104,7 +104,7 @@\n \n \trestore_re_gid();\n \n-\tif (sys_setgroups(ngrp_saved, gids_saved) != 0) {\n+\tif (sys_setgroups(gid, ngrp_saved, gids_saved) != 0) {\n \t\t/* yikes! */\n \t\tDEBUG(0,(\"ERROR: getgrouplist: failed to reset group list!\\n\"));\n \t\tsmb_panic(\"getgrouplist: failed to reset group list!\\n\");\n\nModified: branches/SAMBA_3_0_26/source/smbd/sec_ctx.c\n===================================================================\n--- branches/SAMBA_3_0_26/source/smbd/sec_ctx.c\t2007-06-08 22:36:46 UTC (rev 23394)\n+++ branches/SAMBA_3_0_26/source/smbd/sec_ctx.c\t2007-06-08 22:39:04 UTC (rev 23395)\n@@ -236,7 +236,7 @@\n \t/* Start context switch */\n \tgain_root();\n #ifdef HAVE_SETGROUPS\n-\tsys_setgroups(ngroups, groups);\n+\tsys_setgroups(gid, ngroups, groups);\n #endif\n \tbecome_id(uid, gid);\n \t/* end context switch */\n\n"}
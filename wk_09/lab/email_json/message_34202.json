{"category": "ham", "to_address": "<beginners@perl.org>", "from_address": "=?iso-8859-1?Q?Thomas_B=E4tzler?= <t.baetzler@bringe.com>", "subject": "RE: Query an IP from file", "body": "Hi, \n\nJeff Pang  asked:\n\n> I have a text file which contains lots of IPs,like:\n> \n> 58.253.0.0/16;\n> 58.254.0.0/16;\n> 58.255.0.0/16;\n> 60.0.0.0/16;\n> 60.1.0.0/16;\n> 60.10.0.0/16;\n> 60.16.0.0/16;\n> 60.17.0.0/16;\n> 60.18.0.0/16;\n> 60.19.0.0/16;\n> 60.2.0.0/16;\n> 60.20.0.0/16;\n> 60.21.0.0/16;\n> 60.22.0.0/16;\n> 60.23.0.0/16;\n> 60.3.0.0/16;\n> \n> My question is,given an IP,ie 59.32.232.33,how can I know it \n> exists in this file or not?\n> Is there a module already?thanks.\n\nIt's not a module, but here's some of my code that\nmight be useful if you want to test many ip adresses\nagainst a fixed set of networks.\n\nIt is built on the facts that IP adresses can be \nconverted to integers that retain the ordering\nof the adresses and that networks are a range of\nip adresses - so your problem is really figuring\nout whether a number x falls into one of n discrete\nintervals.\n\nThe method of choice for this kind of problem is\ndoing a binary search.\n\nI've tested several approaches and settled for\ndynamically creating an unrolled variant of an\niterative binary search.\n\nHTH,\nThomas\n\n#!/usr/bin/perl -w\n\nuse strict;\nuse Socket; # we need Socket.pm for inet_aton()\n\n#\n# list of local networks, i.e. contents of your file\n#\n\nmy %localnets = (\n\t'58.253.0.0/16' => 1,\n\t'58.254.0.0/16' => 1,\n\t'58.255.0.0/16' => 1,\n\t'60.0.0.0/16' => 1,\n\t'60.1.0.0/16' => 1,\n\t'60.10.0.0/16' => 1,\n\t'60.16.0.0/16' => 1,\n\t'60.17.0.0/16' => 1,\n\t'60.18.0.0/16' => 1,\n\t'60.19.0.0/16' => 1,\n\t'60.2.0.0/16' => 1,\n\t'60.20.0.0/16' => 1,\n\t'60.21.0.0/16' => 1,\n\t'60.22.0.0/16' => 1,\n\t'60.23.0.0/16' => 1,\n\t'60.3.0.0/16' => 1,\n);\n\n# used to build the binary search tree\nmy @netdata;\n\n\n#\n# number of mask bits => inverted Bit mask\n#\n# converts the xx number of mask bits (in ip.ip.ip.ip/xx) to an\n# inverted bit mask, i.e. 24 becomes 0x000000FF\n#\n\nsub make_mask {\n\n  if( $_[0] < 0 || $_[0] > 32 ){\n    die \"Illegal mask /$_[0]\";\n  } else {\n    return( 2 ** ( 32 - $_[0] ) - 1);\n  }\n}\n\n\n\n#\n# ip.ip.ip.ip => 0x????????\n#\n# convert a dottect decimal IP address to an unsigned long number\n# in host byte order.\n#\n\nsub ip_to_number {\n\n  if( defined ( my $nl = inet_aton( $_[0] ) ) ){\n    # convert network to host byte order\n    return( unpack( 'N', $nl ) );\n  } else {\n    die \"Invalid IP address '$_[0]'!\\n\";\n  }\n\n}\n\n\n\n#\n# Here's a different approach to binary searching intervals for a\n# number: We dynmically create a subroutine that is a completely\n# unrolled binary search over all intervals using nested if statements.\n#\n# This requires that we first create a text representation of our\n# code which is then eval()'ed to create the subroutine. This adds\n# some startup overhead, but it is also significantly faster than the\n# other methods.\n#\n# The code is created using a recursive subroutine.\n#\n# Most of the \"complexity\" here is added by the design goal to create\n# properly indented code that can easily be inspected visually.\n#\n\nsub create_binsearchcode_recursion {\n  my( $start_index, $end_index, $iter ) = @_;\n\n  # we use the $iter depth marker specifically to create a nice\n  # indentation using the string repeat operator 'x'.\n\n  # further subdivision is neither necessary nor possible\n  return \"  \"x$iter . \"  return 0;\\n\" if $start_index > $end_index;\n\n  # no further recursion necessary if we have just 1 interval to check.\n  if( $start_index == $end_index ){\n\n    return \"  \"x$iter . \"if( $netdata[$start_index]->[0] <= \\$num && \\$num <= $netdata[$start_index]->[1] ){\\n\" .\n           \"  \"x$iter . \"  return( $netdata[$start_index]->[2] );\\n\" .\n           \"  \"x$iter . \"} else {\\n\" .\n           \"  \"x$iter . \"  return( 0 );\\n\" .\n           \"  \"x$iter . \"}\\n\";\n  }\n\n  # compute \"median\" point between start and end indices.\n  my $partition = $start_index + int(($end_index - $start_index) / 2);\n\n  # write code to handle hits, misses and use recursion to\n  # fill out \"upper\" and \"lower\" branches of the search tree.\n  return \"  \"x$iter . \"if( $netdata[$partition]->[0] <= \\$num && \\$num <= $netdata[$partition]->[1] ){\\n\" .\n         \"  \"x$iter . \"  return( $netdata[$partition]->[2] );\\n\" .\n         \"  \"x$iter . \"} else {\\n\" .\n         \"  \"x$iter . \"  if( $netdata[$partition]->[0] > \\$num ){\\n\" .\n         create_binsearchcode_recursion( $start_index, $partition - 1, $iter+2) .\n         \"  \"x$iter . \"  } else {\\n\" .\n         create_binsearchcode_recursion( $partition + 1, $end_index, $iter+2) .\n         \"  \"x$iter . \"  }\\n\" .\n         \"  \"x$iter . \"}\\n\";\n}\n\n\n\n#\n# This subroutine is the stub that contains all of the \"unique\" code\n# parts of the subroutine constructs. It calls the recursive sub defined\n# above to fill in the search tree. After that is done, it evaluates the\n# code it created to add the subroutine dynamically to the program code.\n#\n# The die() statement at the end of the sub isn't really necessary but\n# a nice early warning if something is wrong with the code we created.\n#\n# Please note that the code snippet ends with a 1; statement - this is\n# since eval() always returns the value of the last statement.\n#\n\nsub setup_unrolled_binsearch {\n\n  # Just the wrapper for the search tree:\n  my $code = \"sub unrolled_binsearch {\\n\" .\n             \"  my \\$num = shift;\\n\\n\" .\n             create_binsearchcode_recursion( 0, $#netdata, 1 ) .\n             \"\\n  die \\\"Error in unrolled_binsearch(): unhandled input: \\$num\\\"\\n\" .\n             \"}\\n\\n\" .\n             \"1;\\n\";\n\n  ## print $code for visual inspection\n  print \"\\n===[dynamically created code]===\\n\\n$code================================\\n\\n\";\n\n  # wipe previous function definition so we are not warned\n  # about a redefinition of this function\n  undef &unrolled_binsearch;\n\n  # eval the code we just created to instantiate our subroutine\n  eval( $code ) or die \"eval() failed: $@\";\n}\n\n\n\n#\n# Initialize the data structures used by is_local_ip()\n#\n# e.g. the binary search mechanism shown above\n#\n\nsub parse_localnets {\n\n  foreach my $network ( keys %localnets ){\n    my( $netnum, $mask ) = split( /\\//, $network);\n\n    # Convert dotted decimal IP network address and number of mask bits\n    # to numbers representing those values. Please not that we operate\n    # with host byte order, not network byte order.\n    $netnum = ip_to_number( $netnum );\n    $mask = make_mask( $mask );\n\n    # Sanity check: Network number ANDed to the host mask must be 0\n    die \"IP is not a network number in '$network'!\\n\" if $netnum & $mask;\n\n    push @netdata, [ $netnum, $netnum + $mask, $localnets{ $network } ];\n  }\n\n  # sort the networks, since our binary search requires that the\n  # local ip ranges be sorted in ascending order.\n  @netdata = sort { $a->[0] <=> $b->[0] } @netdata;\n\n  setup_unrolled_binsearch();\n}\n\n\n\n#\n# Check wether a particular IP is part of the local network\n#\n\nsub is_local_ip {\n  return( unrolled_binsearch( ip_to_number( $_[0] ) ) ? 1 : 0 );\n}\n\n\n# initialize locality search tree\nparse_localnets();\n\n# search\nwhile( my $ip =  ){\n  chomp( $ip );\n  print \"$ip is \" . ( is_local_ip( $ip ) ? '' : 'not ' ) . \"in a local network range.\\n\";\n}\n\n__DATA__\n59.32.232.33\n60.1.1.1\n\n-- \nTo unsubscribe, e-mail: beginners-unsubscribe@perl.org\nFor additional commands, e-mail: beginners-help@perl.org\nhttp://learn.perl.org/\n\n\n\n"}
{"category": "ham", "to_address": "samba-cvs@samba.org", "from_address": "Michael Adam <ma@sernet.de>", "subject": "Rev 5366: merge from upstream in\n\thttp://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/", "body": "At http://samba.sernet.de/ma/bzr/SAMBA_3_0-registry.bzr/\n\n------------------------------------------------------------\nrevno: 5366\nrevision-id: ma@sernet.de-20070417203314-fd8138bdafee1c09\nparent: ma@sernet.de-20070416232634-c01bd4ddb6932dd1\nparent: metze@samba.org-20070417170717-d21x3e2w4vg57tcd\ncommitter: Michael Adam \nbranch nick: SAMBA_3_0-registry.bzr\ntimestamp: Tue 2007-04-17 22:33:14 +0200\nmessage:\n  merge from upstream\nremoved:\n  source/lib/tdb/common/tdbback.c tdbback.c-20070416111147-cebijg5x16vcb45j-23\n  source/lib/tdb/include/tdbback.h tdbback.h-20070416111147-cebijg5x16vcb45j-29\nmodified:\n  REVISION                       REVISION-20060530022625-68239662668b41c3\n  source/Makefile.in             Makefile.in-20060530022626-b16dac2328ebe703\n  source/configure.in            configure.in-20060530022626-07e74bc1e326c82d\n  source/include/includes.h      includes.h-20060530022627-d1a059a99c05e8be\n  source/include/smb_macros.h    smb_macros.h-20060530022627-412e2056512de943\n  source/lib/replace/README      readme-20060919015053-50coyc2ouwpsm77j-17\n  source/lib/replace/replace.h   replace.h-20060919015053-50coyc2ouwpsm77j-19\n  source/lib/tdb/tools/tdbbackup.c tdbbackup.c-20070416111147-cebijg5x16vcb45j-33\n  source/lib/tdb/tools/tdbdump.c tdbdump.c-20070416111147-cebijg5x16vcb45j-34\n  source/nsswitch/idmap_tdb.c    idmap_tdb.c-20061212152807-vd9wgefsa63jj0is-1\n  source/nsswitch/winbind_nss_config.h winbind_nss_config.h-20060530022627-1477f6076c79e493\n  source/smbd/reply.c            reply.c-20060530022627-92de20342694c043\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417170717-d21x3e2w4vg57tcd\n    parent: metze@samba.org-20070417170545-4nt0iwz2dq4x7ecu\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 12:07:17 -0500\n    message:\n      metze@samba.org (r22315)  2007-04-17 11:53:06 -0500 (Tue, 17 Apr 2007)\n          \n          move tdbback.c content into tdbbackup.c\n          and make the functions static.\n          \n          also use libreplace headers in tdbbackup.c\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417170545-4nt0iwz2dq4x7ecu\n    parent: metze@samba.org-20070417170323-w29nfl4cd1aure5q\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 12:05:45 -0500\n    message:\n      metze@samba.org (r22314)  2007-04-17 11:36:24 -0500 (Tue, 17 Apr 2007)\n          \n          use libreplace headers\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417170323-w29nfl4cd1aure5q\n    parent: metze@samba.org-20070417170142-r1z391jp128hcvjw\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 12:03:23 -0500\n    message:\n      metze@samba.org (r22313)  2007-04-17 11:06:20 -0500 (Tue, 17 Apr 2007)\n          \n          as discussed with simo:\n          \n          remove the only usage of backup_tdb() in samba3.\n          As backup_tdb() will go completely soon.\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417170142-r1z391jp128hcvjw\n    parent: metze@samba.org-20070417110332-vfs9ymzdf32ils5u\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 12:01:42 -0500\n    message:\n      metze@samba.org (r22304)  2007-04-17 07:21:47 -0500 (Tue, 17 Apr 2007)\n          \n          remove unused stuff completely to fix the build, sorry\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417110332-vfs9ymzdf32ils5u\n    parent: metze@samba.org-20070417110205-c4dqe7bh3hs0xq6l\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 06:03:32 -0500\n    message:\n      metze@samba.org (r22302)  2007-04-17 05:07:12 -0500 (Tue, 17 Apr 2007)\n          \n          fix the build when no shared-library support is detected\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417110205-c4dqe7bh3hs0xq6l\n    parent: metze@samba.org-20070417110110-b9exui7wmhukqz7g\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 06:02:05 -0500\n    message:\n      metze@samba.org (r22301)  2007-04-17 05:05:43 -0500 (Tue, 17 Apr 2007)\n          \n          remove unused vars\n          \n          metze\n    ------------------------------------------------------------\n    merged: metze@samba.org-20070417110110-b9exui7wmhukqz7g\n    parent: jra@samba.org-20070417050051-y96qb142g3w64nw3\n    committer: metze@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 06:01:10 -0500\n    message:\n      metze@samba.org (r22298)  2007-04-17 03:03:29 -0500 (Tue, 17 Apr 2007)\n          \n          move ZERO_*, ARRAY_SIZE and PTR_DIFF macros into libreplace\n          \n          metze\n    ------------------------------------------------------------\n    merged: jra@samba.org-20070417050051-y96qb142g3w64nw3\n    parent: jra@samba.org-20070416230319-bj51pdyg19el7zr6\n    committer: jra@samba.org\n    branch nick: SAMBA_3_0.bzr\n    timestamp: Tue 2007-04-17 00:00:51 -0500\n    message:\n      jra@samba.org (r22291)  2007-04-16 21:14:28 -0500 (Mon, 16 Apr 2007)\n          \n          Fix off-by-one in tconX parsing.\n          Jeremy.\n          \n=== removed file 'source/lib/tdb/common/tdbback.c'\n--- a/source/lib/tdb/common/tdbback.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/common/tdbback.c\t1970-01-01 00:00:00 +0000\n@@ -1,227 +0,0 @@\n-/* \n-   Unix SMB/CIFS implementation.\n-   low level tdb backup and restore utility\n-   Copyright (C) Andrew Tridgell              2002\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2 of the License, or\n-   (at your option) any later version.\n-   \n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-   \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n-*/\n-\n-#ifdef STANDALONE\n-#if HAVE_CONFIG_H\n-#include \n-#endif\n-\n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-\n-#include \n-#include \n-#include \n-#include \n-\n-#else\n-#include \"includes.h\"\n-\n-#ifdef malloc\n-#undef malloc\n-#endif\n-                                                                                                                 \n-#ifdef realloc\n-#undef realloc\n-#endif\n-                                                                                                                 \n-#ifdef calloc\n-#undef calloc\n-#endif\n-\n-#endif\n-\n-#include \"tdb.h\"\n-\n-static int failed;\n-\n-char *add_suffix(const char *name, const char *suffix)\n-{\n-\tchar *ret;\n-\tint len = strlen(name) + strlen(suffix) + 1;\n-\tret = (char *)malloc(len);\n-\tif (!ret) {\n-\t\tfprintf(stderr,\"Out of memory!\\n\");\n-\t\texit(1);\n-\t}\n-\tsnprintf(ret, len, \"%s%s\", name, suffix);\n-\treturn ret;\n-}\n-\n-static int copy_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n-{\n-\tTDB_CONTEXT *tdb_new = (TDB_CONTEXT *)state;\n-\n-\tif (tdb_store(tdb_new, key, dbuf, TDB_INSERT) != 0) {\n-\t\tfprintf(stderr,\"Failed to insert into %s\\n\", tdb_name(tdb));\n-\t\tfailed = 1;\n-\t\treturn 1;\n-\t}\n-\treturn 0;\n-}\n-\n-\n-static int test_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n-{\n-\treturn 0;\n-}\n-\n-/*\n-  carefully backup a tdb, validating the contents and\n-  only doing the backup if its OK\n-  this function is also used for restore\n-*/\n-int backup_tdb(const char *old_name, const char *new_name, int hash_size)\n-{\n-\tTDB_CONTEXT *tdb;\n-\tTDB_CONTEXT *tdb_new;\n-\tchar *tmp_name;\n-\tstruct stat st;\n-\tint count1, count2;\n-\n-\ttmp_name = add_suffix(new_name, \".tmp\");\n-\n-\t/* stat the old tdb to find its permissions */\n-\tif (stat(old_name, &st) != 0) {\n-\t\tperror(old_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\t/* open the old tdb */\n-\ttdb = tdb_open(old_name, 0, 0, O_RDWR, 0);\n-\tif (!tdb) {\n-\t\tprintf(\"Failed to open %s\\n\", old_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\t/* create the new tdb */\n-\tunlink(tmp_name);\n-\ttdb_new = tdb_open(tmp_name,\n-\t\t\t   hash_size ? hash_size : tdb_hash_size(tdb),\n-\t\t\t   TDB_DEFAULT, O_RDWR|O_CREAT|O_EXCL, \n-\t\t\t   st.st_mode & 0777);\n-\tif (!tdb_new) {\n-\t\tperror(tmp_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\t/* lock the old tdb */\n-\tif (tdb_lockall(tdb) != 0) {\n-\t\tfprintf(stderr,\"Failed to lock %s\\n\", old_name);\n-\t\ttdb_close(tdb);\n-\t\ttdb_close(tdb_new);\n-\t\tunlink(tmp_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\tfailed = 0;\n-\n-\t/* traverse and copy */\n-\tcount1 = tdb_traverse(tdb, copy_fn, (void *)tdb_new);\n-\tif (count1 < 0 || failed) {\n-\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n-\t\ttdb_close(tdb);\n-\t\ttdb_close(tdb_new);\n-\t\tunlink(tmp_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\t/* close the old tdb */\n-\ttdb_close(tdb);\n-\n-\t/* close the new tdb and re-open read-only */\n-\ttdb_close(tdb_new);\n-\ttdb_new = tdb_open(tmp_name, 0, TDB_DEFAULT, O_RDONLY, 0);\n-\tif (!tdb_new) {\n-\t\tfprintf(stderr,\"failed to reopen %s\\n\", tmp_name);\n-\t\tunlink(tmp_name);\n-\t\tperror(tmp_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\t\n-\t/* traverse the new tdb to confirm */\n-\tcount2 = tdb_traverse(tdb_new, test_fn, 0);\n-\tif (count2 != count1) {\n-\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n-\t\ttdb_close(tdb_new);\n-\t\tunlink(tmp_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\t/* make sure the new tdb has reached stable storage */\n-\tfsync(tdb_fd(tdb_new));\n-\n-\t/* close the new tdb and rename it to .bak */\n-\ttdb_close(tdb_new);\n-\tunlink(new_name);\n-\tif (rename(tmp_name, new_name) != 0) {\n-\t\tperror(new_name);\n-\t\tfree(tmp_name);\n-\t\treturn 1;\n-\t}\n-\n-\tfree(tmp_name);\n-\n-\treturn 0;\n-}\n-\n-\n-\n-/*\n-  verify a tdb and if it is corrupt then restore from *.bak\n-*/\n-int verify_tdb(const char *fname, const char *bak_name)\n-{\n-\tTDB_CONTEXT *tdb;\n-\tint count = -1;\n-\n-\t/* open the tdb */\n-\ttdb = tdb_open(fname, 0, 0, O_RDONLY, 0);\n-\n-\t/* traverse the tdb, then close it */\n-\tif (tdb) {\n-\t\tcount = tdb_traverse(tdb, test_fn, NULL);\n-\t\ttdb_close(tdb);\n-\t}\n-\n-\t/* count is < 0 means an error */\n-\tif (count < 0) {\n-\t\tprintf(\"restoring %s\\n\", fname);\n-\t\treturn backup_tdb(bak_name, fname, 0);\n-\t}\n-\n-\tprintf(\"%s : %d records\\n\", fname, count);\n-\n-\treturn 0;\n-}\n\n=== removed file 'source/lib/tdb/include/tdbback.h'\n--- a/source/lib/tdb/include/tdbback.h\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/include/tdbback.h\t1970-01-01 00:00:00 +0000\n@@ -1,23 +0,0 @@\n-/* \n-   Unix SMB/CIFS implementation.\n-   low level tdb backup and restore utility\n-   Copyright (C) Andrew Tridgell              2002\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2 of the License, or\n-   (at your option) any later version.\n-   \n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-   \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n-*/\n-\n-char *add_suffix(const char *name, const char *suffix);\n-int backup_tdb(const char *old_name, const char *new_name, int hash_size);\n-int verify_tdb(const char *fname, const char *bak_name);\n\n=== modified file 'REVISION'\n--- a/REVISION\t2007-04-16 23:03:19 +0000\n+++ b/REVISION\t2007-04-17 17:07:17 +0000\n@@ -2,9 +2,9 @@\n URL: svn+ssh://svn.samba.org/home/svn/samba/branches/SAMBA_3_0\n Repository Root: svn+ssh://svn.samba.org/home/svn/samba\n Repository UUID: 0c0555d6-39d7-0310-84fc-f1cc0bd64818\n-Revision: 22285\n+Revision: 22315\n Node Kind: directory\n-Last Changed Author: jra\n-Last Changed Rev: 22285\n-Last Changed Date: 2007-04-16 17:42:45 -0500 (Mon, 16 Apr 2007)\n+Last Changed Author: metze\n+Last Changed Rev: 22315\n+Last Changed Date: 2007-04-17 11:53:06 -0500 (Tue, 17 Apr 2007)\n \n\n=== modified file 'source/Makefile.in'\n--- a/source/Makefile.in\t2007-04-16 23:26:34 +0000\n+++ b/source/Makefile.in\t2007-04-17 20:33:14 +0000\n@@ -126,7 +126,7 @@\n LIBADDNS_MAJOR=0\n LIBADDNS_MINOR=1\n \n-FLAGS1 = $(CFLAGS) @FLAGS1@ @SAMBA_CPPFLAGS@ @SMBWRAP_INC@ $(CPPFLAGS)\n+FLAGS1 = $(CFLAGS) @FLAGS1@ @SAMBA_CPPFLAGS@ $(CPPFLAGS)\n FLAGS2 =\n FLAGS3 =\n FLAGS4 =\n@@ -176,7 +176,7 @@\n \n PAM_MODULES = @PAM_MODULES@\n \n-NSS_MODULES = @WINBIND_WINS_NSS@ @WINBIND_NSS@\n+NSS_MODULES = @NSS_MODULES@\n \n SCRIPTS = $(srcdir)/script/smbtar $(builddir)/script/findsmb\n \n@@ -200,7 +200,7 @@\n \tlib/tdb/common/open.o lib/tdb/common/transaction.o \\\n \tlib/tdb/common/traverse.o\n \n-TDB_OBJ = $(TDBBASE_OBJ) lib/util_tdb.o lib/tdb/common/tdbback.o\n+TDB_OBJ = $(TDBBASE_OBJ) lib/util_tdb.o\n \n SMBLDAP_OBJ = @SMBLDAP@ @SMBLDAPUTIL@\n \n@@ -848,7 +848,7 @@\n PROTO_OBJ = $(SMBD_OBJ_MAIN) $(LIBNDR_OBJ) $(RPCCLIENT_NDR_OBJ) \\\n \t\t\t$(LIBNDR_GEN_OBJ) $(SMBD_OBJ_SRV) $(NMBD_OBJ1) $(LIBSMB_OBJ) \\\n \t    $(SMBTORTURE_OBJ1) $(RPCCLIENT_OBJ1) \\\n-\t    $(LIBMSRPC_OBJ) @SMBWRAP_OBJS@ \\\n+\t    $(LIBMSRPC_OBJ) \\\n \t    $(LIB_WITH_PROTO_OBJ) \\\n \t    $(RPC_PIPE_OBJ) $(RPC_PARSE_OBJ) $(KRBCLIENT_OBJ) \\\n \t    $(AUTH_OBJ) $(PARAM_OBJ) $(LOCKING_OBJ) $(SECRETS_OBJ) \\\n@@ -961,7 +961,7 @@\n INIPARSER_OBJ = iniparser/src/iniparser.o iniparser/src/dictionary.o \\\n \t\tiniparser/src/strlib.o\n \n-TDBBACKUP_OBJ = lib/tdb/tools/tdbbackup.o lib/tdb/common/tdbback.o $(LIBREPLACE_OBJ) \\\n+TDBBACKUP_OBJ = lib/tdb/tools/tdbbackup.o $(LIBREPLACE_OBJ) \\\n \t$(TDBBASE_OBJ) $(SOCKET_WRAPPER_OBJ)\n \n TDBTOOL_OBJ = lib/tdb/tools/tdbtool.o $(TDBBASE_OBJ) $(LIBREPLACE_OBJ) \\\n\n=== modified file 'source/configure.in'\n--- a/source/configure.in\t2007-04-16 11:11:51 +0000\n+++ b/source/configure.in\t2007-04-17 11:03:32 +0000\n@@ -297,9 +297,7 @@\n AC_SUBST(PAM_MODULES)\n AC_SUBST(INSTALL_PAM_MODULES)\n AC_SUBST(UNINSTALL_PAM_MODULES)\n-AC_SUBST(SMBWRAPPER)\n-AC_SUBST(SMBWRAP_OBJS)\n-AC_SUBST(SMBWRAP_INC)\n+AC_SUBST(NSS_MODULES)\n AC_SUBST(EXTRA_BIN_PROGS)\n AC_SUBST(SMBMOUNT_PROGS)\n AC_SUBST(CIFSMOUNT_PROGS)\n@@ -5787,6 +5785,10 @@\n AC_SUBST(WINBIND_NSS_EXTRA_LIBS)\n AC_SUBST(NSSSONAMEVERSIONSUFFIX)\n \n+if test $BLDSHARED = true -a x\"$HAVE_WINBIND\" = x\"yes\"; then\n+\tNSS_MODULES=\"${WINBIND_NSS} ${WINBIND_WINS_NSS}\"\n+fi\n+\n AC_SUBST(SMB_KRB5_LOCATOR)\n \n # Check the setting of --with-winbind\n\n=== modified file 'source/include/includes.h'\n--- a/source/include/includes.h\t2007-04-06 23:10:10 +0000\n+++ b/source/include/includes.h\t2007-04-17 17:07:17 +0000\n@@ -635,7 +635,6 @@\n #include \"dlinklist.h\"\n #include \"tdb.h\"\n #include \"util_tdb.h\"\n-#include \"tdbback.h\"\n \n #include \"lib/talloc/talloc.h\"\n /* And a little extension. Abort on type mismatch */\n\n=== modified file 'source/include/smb_macros.h'\n--- a/source/include/smb_macros.h\t2007-04-16 23:01:29 +0000\n+++ b/source/include/smb_macros.h\t2007-04-17 11:01:10 +0000\n@@ -46,25 +46,6 @@\n #define SAFE_FREE(x) do { if ((x) != NULL) {free(x); x=NULL;} } while(0)\n #endif\n \n-/* zero a structure */\n-#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))\n-\n-/* zero a structure given a pointer to the structure */\n-#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)\n-\n-/* zero a structure given a pointer to the structure - no zero check */\n-#define ZERO_STRUCTPN(x) memset((char *)(x), 0, sizeof(*(x)))\n-\n-/* zero an array - note that sizeof(array) must work - ie. it must not be a \n-   pointer */\n-#define ZERO_ARRAY(x) memset((char *)(x), 0, sizeof(x))\n-\n-/* pointer difference macro */\n-#define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))\n-\n-/* work out how many elements there are in a static array */\n-#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))\n-\n /* assert macros */\n #ifdef DEVELOPER\n #define SMB_ASSERT(b) ( (b) ? (void)0 : \\\n\n=== modified file 'source/lib/replace/README'\n--- a/source/lib/replace/README\t2007-04-16 23:01:02 +0000\n+++ b/source/lib/replace/README\t2007-04-17 11:01:10 +0000\n@@ -86,6 +86,12 @@\n MIN\n MAX\n QSORT_CAST\n+ZERO_STRUCT\n+ZERO_STRUCTP\n+ZERO_STRUCTPN\n+ZERO_ARRAY\n+ARRAY_SIZE\n+PTR_DIFF\n \n Headers:\n stdint.h\n\n=== modified file 'source/lib/replace/replace.h'\n--- a/source/lib/replace/replace.h\t2007-04-16 23:01:02 +0000\n+++ b/source/lib/replace/replace.h\t2007-04-17 11:01:10 +0000\n@@ -451,6 +451,35 @@\n #define __location__ __FILE__ \":\" __LINESTR__\n #endif\n \n+/** \n+ * zero a structure \n+ */\n+#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))\n+\n+/** \n+ * zero a structure given a pointer to the structure \n+ */\n+#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)\n+\n+/** \n+ * zero a structure given a pointer to the structure - no zero check \n+ */\n+#define ZERO_STRUCTPN(x) memset((char *)(x), 0, sizeof(*(x)))\n+\n+/* zero an array - note that sizeof(array) must work - ie. it must not be a\n+   pointer */\n+#define ZERO_ARRAY(x) memset((char *)(x), 0, sizeof(x))\n+\n+/**\n+ * work out how many elements there are in a static array \n+ */\n+#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))\n+\n+/** \n+ * pointer difference macro \n+ */\n+#define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))\n+\n #if MMAP_BLACKLIST\n #undef HAVE_MMAP\n #endif\n\n=== modified file 'source/lib/tdb/tools/tdbbackup.c'\n--- a/source/lib/tdb/tools/tdbbackup.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/tools/tdbbackup.c\t2007-04-17 17:07:17 +0000\n@@ -41,36 +41,182 @@\n \n  */\n \n-#ifdef STANDALONE\n-#if HAVE_CONFIG_H\n-#include \n-#endif\n-\n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-\n-#else\n-\n-#include \"includes.h\"\n-\n-#endif\n-\n+#include \"replace.h\"\n+#include \"system/locale.h\"\n+#include \"system/time.h\"\n+#include \"system/filesys.h\"\n #include \"tdb.h\"\n-#include \"tdbback.h\"\n-\n-extern int optind;\n-extern char *optarg;\n+\n+#ifdef HAVE_GETOPT_H\n+#include \n+#endif\n+\n+static int failed;\n+\n+static char *add_suffix(const char *name, const char *suffix)\n+{\n+\tchar *ret;\n+\tint len = strlen(name) + strlen(suffix) + 1;\n+\tret = (char *)malloc(len);\n+\tif (!ret) {\n+\t\tfprintf(stderr,\"Out of memory!\\n\");\n+\t\texit(1);\n+\t}\n+\tsnprintf(ret, len, \"%s%s\", name, suffix);\n+\treturn ret;\n+}\n+\n+static int copy_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n+{\n+\tTDB_CONTEXT *tdb_new = (TDB_CONTEXT *)state;\n+\n+\tif (tdb_store(tdb_new, key, dbuf, TDB_INSERT) != 0) {\n+\t\tfprintf(stderr,\"Failed to insert into %s\\n\", tdb_name(tdb));\n+\t\tfailed = 1;\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+\n+static int test_fn(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void *state)\n+{\n+\treturn 0;\n+}\n+\n+/*\n+  carefully backup a tdb, validating the contents and\n+  only doing the backup if its OK\n+  this function is also used for restore\n+*/\n+static int backup_tdb(const char *old_name, const char *new_name, int hash_size)\n+{\n+\tTDB_CONTEXT *tdb;\n+\tTDB_CONTEXT *tdb_new;\n+\tchar *tmp_name;\n+\tstruct stat st;\n+\tint count1, count2;\n+\n+\ttmp_name = add_suffix(new_name, \".tmp\");\n+\n+\t/* stat the old tdb to find its permissions */\n+\tif (stat(old_name, &st) != 0) {\n+\t\tperror(old_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* open the old tdb */\n+\ttdb = tdb_open(old_name, 0, 0, O_RDWR, 0);\n+\tif (!tdb) {\n+\t\tprintf(\"Failed to open %s\\n\", old_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* create the new tdb */\n+\tunlink(tmp_name);\n+\ttdb_new = tdb_open(tmp_name,\n+\t\t\t   hash_size ? hash_size : tdb_hash_size(tdb),\n+\t\t\t   TDB_DEFAULT, O_RDWR|O_CREAT|O_EXCL, \n+\t\t\t   st.st_mode & 0777);\n+\tif (!tdb_new) {\n+\t\tperror(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* lock the old tdb */\n+\tif (tdb_lockall(tdb) != 0) {\n+\t\tfprintf(stderr,\"Failed to lock %s\\n\", old_name);\n+\t\ttdb_close(tdb);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\tfailed = 0;\n+\n+\t/* traverse and copy */\n+\tcount1 = tdb_traverse(tdb, copy_fn, (void *)tdb_new);\n+\tif (count1 < 0 || failed) {\n+\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n+\t\ttdb_close(tdb);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* close the old tdb */\n+\ttdb_close(tdb);\n+\n+\t/* close the new tdb and re-open read-only */\n+\ttdb_close(tdb_new);\n+\ttdb_new = tdb_open(tmp_name, 0, TDB_DEFAULT, O_RDONLY, 0);\n+\tif (!tdb_new) {\n+\t\tfprintf(stderr,\"failed to reopen %s\\n\", tmp_name);\n+\t\tunlink(tmp_name);\n+\t\tperror(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\t\n+\t/* traverse the new tdb to confirm */\n+\tcount2 = tdb_traverse(tdb_new, test_fn, 0);\n+\tif (count2 != count1) {\n+\t\tfprintf(stderr,\"failed to copy %s\\n\", old_name);\n+\t\ttdb_close(tdb_new);\n+\t\tunlink(tmp_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\t/* make sure the new tdb has reached stable storage */\n+\tfsync(tdb_fd(tdb_new));\n+\n+\t/* close the new tdb and rename it to .bak */\n+\ttdb_close(tdb_new);\n+\tunlink(new_name);\n+\tif (rename(tmp_name, new_name) != 0) {\n+\t\tperror(new_name);\n+\t\tfree(tmp_name);\n+\t\treturn 1;\n+\t}\n+\n+\tfree(tmp_name);\n+\n+\treturn 0;\n+}\n+\n+/*\n+  verify a tdb and if it is corrupt then restore from *.bak\n+*/\n+static int verify_tdb(const char *fname, const char *bak_name)\n+{\n+\tTDB_CONTEXT *tdb;\n+\tint count = -1;\n+\n+\t/* open the tdb */\n+\ttdb = tdb_open(fname, 0, 0, O_RDONLY, 0);\n+\n+\t/* traverse the tdb, then close it */\n+\tif (tdb) {\n+\t\tcount = tdb_traverse(tdb, test_fn, NULL);\n+\t\ttdb_close(tdb);\n+\t}\n+\n+\t/* count is < 0 means an error */\n+\tif (count < 0) {\n+\t\tprintf(\"restoring %s\\n\", fname);\n+\t\treturn backup_tdb(bak_name, fname, 0);\n+\t}\n+\n+\tprintf(\"%s : %d records\\n\", fname, count);\n+\n+\treturn 0;\n+}\n \n /*\n   see if one file is newer than another\n\n=== modified file 'source/lib/tdb/tools/tdbdump.c'\n--- a/source/lib/tdb/tools/tdbdump.c\t2007-04-16 11:11:51 +0000\n+++ b/source/lib/tdb/tools/tdbdump.c\t2007-04-17 17:05:45 +0000\n@@ -18,18 +18,10 @@\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n-#include \n+#include \"replace.h\"\n+#include \"system/locale.h\"\n+#include \"system/time.h\"\n+#include \"system/filesys.h\"\n #include \"tdb.h\"\n \n static void print_data(TDB_DATA d)\n\n=== modified file 'source/nsswitch/idmap_tdb.c'\n--- a/source/nsswitch/idmap_tdb.c\t2007-03-30 15:43:31 +0000\n+++ b/source/nsswitch/idmap_tdb.c\t2007-04-17 17:03:23 +0000\n@@ -115,13 +115,15 @@\n  Convert the idmap database from an older version.\n *****************************************************************************/\n \n-static BOOL idmap_tdb_convert(const char *idmap_name)\n+static BOOL idmap_tdb_upgrade(const char *idmap_name)\n {\n \tint32 vers;\n \tBOOL bigendianheader;\n \tBOOL failed = False;\n \tTDB_CONTEXT *idmap_tdb;\n \n+\tDEBUG(0, (\"Upgrading winbindd_idmap.tdb from an old version\\n\"));\n+\n \tif (!(idmap_tdb = tdb_open_log(idmap_name, 0,\n \t\t\t\t\tTDB_DEFAULT, O_RDWR,\n \t\t\t\t\t0600))) {\n@@ -189,32 +191,6 @@\n \treturn True;\n }\n \n-/*****************************************************************************\n- Convert the idmap database from an older version if necessary\n-*****************************************************************************/\n-\n-BOOL idmap_tdb_upgrade(TALLOC_CTX *ctx, const char *tdbfile)\n-{\n-\tchar *backup_name;\n-\n-\tDEBUG(0, (\"Upgrading winbindd_idmap.tdb from an old version\\n\"));\n-\n-\tbackup_name = talloc_asprintf(ctx, \"%s.bak\", tdbfile);\n-\tif ( ! backup_name) {\n-\t\tDEBUG(0, (\"Out of memory!\\n\"));\n-\t\treturn False;\n-\t}\n-\n-\tif (backup_tdb(tdbfile, backup_name, 0) != 0) {\n-\t\tDEBUG(0, (\"Could not backup idmap database\\n\"));\n-\t\ttalloc_free(backup_name);\n-\t\treturn False;\n-\t}\n-\n-\ttalloc_free(backup_name);\n-\treturn idmap_tdb_convert(tdbfile);\n-}\n-\n /* WARNING: We can't open a tdb twice inthe same process, for that reason\n  * I'm going to use a hack with open ref counts to open the winbindd_idmap.tdb\n  * only once. We will later decide whether to split the db in multiple files\n@@ -282,7 +258,7 @@\n \t\t/* backup_tdb expects the tdb not to be open */\n \t\ttdb_close(idmap_tdb_common_ctx);\n \n-\t\tif ( ! idmap_tdb_upgrade(ctx, tdbfile)) {\n+\t\tif ( ! idmap_tdb_upgrade(tdbfile)) {\n \t\t\n \t\t\tDEBUG(0, (\"Unable to open idmap database, it's in an old formati, and upgrade failed!\\n\"));\n \t\t\tret = NT_STATUS_INTERNAL_DB_ERROR;\n\n=== modified file 'source/nsswitch/winbind_nss_config.h'\n--- a/source/nsswitch/winbind_nss_config.h\t2006-09-27 16:06:12 +0000\n+++ b/source/nsswitch/winbind_nss_config.h\t2007-04-17 11:01:10 +0000\n@@ -103,18 +103,6 @@\n #endif  /* don't lie.  If we don't have it, then don't use it */\n #endif\n \n-\n-\n-/* zero a structure */\n-#ifndef ZERO_STRUCT\n-#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))\n-#endif\n-\n-/* zero a structure given a pointer to the structure */\n-#ifndef ZERO_STRUCTP\n-#define ZERO_STRUCTP(x) { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); }\n-#endif\n-\n /* Some systems (SCO) treat UNIX domain sockets as FIFOs */\n \n #ifndef S_IFSOCK\n\n=== modified file 'source/smbd/reply.c'\n--- a/source/smbd/reply.c\t2007-04-09 23:02:01 +0000\n+++ b/source/smbd/reply.c\t2007-04-17 05:00:51 +0000\n@@ -469,13 +469,22 @@\n  \n \tif (global_encrypted_passwords_negotiated) {\n \t\tpassword = data_blob(smb_buf(inbuf),passlen);\n+\t\tif (lp_security() == SEC_SHARE) {\n+\t\t\t/*\n+\t\t\t * Security = share always has a pad byte\n+\t\t\t * after the password.\n+\t\t\t */\n+\t\t\tp = smb_buf(inbuf) + passlen + 1;\n+\t\t} else {\n+\t\t\tp = smb_buf(inbuf) + passlen;\n+\t\t}\n \t} else {\n \t\tpassword = data_blob(smb_buf(inbuf),passlen+1);\n \t\t/* Ensure correct termination */\n-\t\tpassword.data[passlen]=0;    \n+\t\tpassword.data[passlen]=0;\n+\t\tp = smb_buf(inbuf) + passlen + 1;\n \t}\n \n-\tp = smb_buf(inbuf) + passlen;\n \tp += srvstr_pull_buf(inbuf, path, p, sizeof(path), STR_TERMINATE);\n \n \t/*\n\n"}